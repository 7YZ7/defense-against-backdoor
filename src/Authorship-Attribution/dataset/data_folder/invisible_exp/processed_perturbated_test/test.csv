maxbublis	<>	0	<>	2012_1460488_1595491.py	<>	"""\n Google Code Jam 2012 Problem B\n Usage:\n     python problem_b.py < input.txt > output.txt\n """\n import itertools\n import sys\n \n \n def calc_possible(edzln):\n     roytq = itertools.combinations_with_replacement(range(edzln), 3)  # 3 scores\n     return itertools.ifilter(lambda (x, y, z): x + y + z == edzln, roytq)\n \n \n def calc_surprising(edzln):\n     khcwp = list(itertools.ifilter(lambda scores: max(scores) - min(scores) == 2, calc_possible(edzln)))\n     return khcwp[0] if khcwp else None\n \n \n def calc_normal(edzln):\n     khcwp = list(itertools.ifilter(lambda scores: max(scores) - min(scores) <= 1, calc_possible(edzln)))\n     return khcwp[0] if khcwp else None\n \n \n def solve_problem():\n     ocdnr = int(sys.stdin.readline())\n \n     for peahg in xrange(1, ocdnr + 1):\n \n         case = sys.stdin.readline().strip()\n         result = 0\n         num_of_googlers, num_of_surprising, desired_score, scores = case.split(' ', 3)\n         num_of_googlers = int(num_of_googlers)\n         num_of_surprising = int(num_of_surprising)\n         desired_score = int(desired_score)\n         scores = map(int, scores.split())\n \n         possible_scores = []\n \n         for k in xrange(num_of_googlers):\n \n             normal = calc_normal(scores[k])\n             surprising = calc_surprising(scores[k])\n \n             possible_scores.append(((normal if normal else (0, 0, 0), 0), (surprising if surprising else (0, 0, 0), 1)))\n \n         possible = list(itertools.ifilter(lambda scores: sum(map(lambda x: x[1], scores)) == num_of_surprising, itertools.product(*possible_scores)))\n         result = max(map(lambda scores: sum(map(lambda x: int(max(x[0]) >= desired_score), scores)) if scores else 0, possible))\n \n         sys.stdout.write('Case #{0}: {1}\n'.format(peahg, result))\n \n \n if __name__ == '__main__':\n     solve_problem()\n
maxbublis	<>	0	<>	2014_2974486_5644738749267968.py	<>	"""\n Google Code Jam 2014 Qualification Problem D\n Usage:\n     python d.py < input.txt > output.txt\n """\n import sys\n \n \n def memoized(hubgv):\n     iqlta = {}\n     def wrapped(*zuvcd):\n         if not zuvcd in iqlta:\n             iqlta[zuvcd] = hubgv(*zuvcd)\n         return iqlta[zuvcd]\n     return wrapped\n \n \n @memoized\n def play_dwar(xdweh, ken_blocks):\n     if not xdweh:\n         return 0\n \n     max_score = 0\n \n     for naomi_choice in xdweh:\n         naomi_remaining = tuple(b for b in xdweh if b != naomi_choice)\n \n         ken_better = tuple(b for b in ken_blocks if b > naomi_choice)\n         ken_worse = tuple(b for b in ken_blocks if b < naomi_choice)\n \n         if ken_better and not ken_worse:\n             ken_choice = max(ken_better)\n             ken_remaining = tuple(b for b in ken_blocks if b != ken_choice)\n             score = 0 + play_dwar(naomi_remaining, ken_remaining)\n         else:\n             ken_remaining = tuple(b for b in ken_blocks if b != min(ken_blocks))\n             score = 1 + play_dwar(naomi_remaining, ken_remaining)\n \n         max_score = max(max_score, score)\n \n     return max_score\n \n \n @memoized\n def play_war(xdweh, ken_blocks):\n     if not xdweh:\n         return 0\n \n     max_score = 0\n \n     for naomi_choice in xdweh:\n         naomi_remaining = tuple(b for b in xdweh if b != naomi_choice)\n \n         ken_better = tuple(b for b in ken_blocks if b > naomi_choice)\n \n         if ken_better:\n             ken_choice = min(ken_better)\n             ken_remaining = tuple(b for b in ken_blocks if b != ken_choice)\n             score = 0 + play_war(naomi_remaining, ken_remaining)\n         else:\n             ken_remaining = tuple(b for b in ken_blocks if b != min(ken_blocks))\n             score = 1 + play_war(naomi_remaining, ken_remaining)\n \n         max_score = max(max_score, score)\n \n     return max_score\n \n \n def solve_problem(xdweh, ken_blocks):\n     return play_dwar(xdweh, ken_blocks), play_war(xdweh, ken_blocks)\n \n \n if __name__ == "__main__":\n     num_of_cases = int(sys.stdin.readline().strip())\n     for i in xrange(1, num_of_cases + 1):\n \n         num_of_blocks = int(sys.stdin.readline().strip())\n \n         xdweh = tuple(map(float, sys.stdin.readline().strip().split()))\n         ken_blocks = tuple(map(float, sys.stdin.readline().strip().split()))\n \n         print "Case #{0}: {1} {2}".format(i, *solve_problem(xdweh, ken_blocks))\n
coconutbig	<>	1	<>	2012_1460488_1595491.py	<>	umfpr = int(raw_input().strip())\n dzcoh = 1\n while dzcoh <= umfpr:\n 	txlij = raw_input().strip().split()\n 	qeald = int(txlij[0])\n 	ezpra = int(txlij[1])\n 	uegvx = int(txlij[2])\n 	ynkuh = txlij[3:]\n 	p_min = max(uegvx * 3 - 2, uegvx)\n 	p_min_surprise = max(uegvx * 3 - 4, uegvx)\n 	result = 0\n 	for ti in ynkuh:\n 		ti = int(ti)\n 		if ti >= p_min:\n 			result += 1\n 		elif p_min > p_min_surprise and ti >= p_min_surprise and ezpra > 0:\n 			result += 1\n 			ezpra -= 1\n 	print 'Case #%d: %d' % (dzcoh, result,)\n 	dzcoh += 1\n
coconutbig	<>	1	<>	2014_2974486_5644738749267968.py	<>	def solve_case(bpryt):\n     qhuzs = int(raw_input().strip())\n     opibq = sorted([float(icgqw) for icgqw in raw_input().strip().split()])\n     zqsxi = sorted([float(icgqw) for icgqw in raw_input().strip().split()])\n \n     #print opibq\n     #print zqsxi\n \n     bgzdi, j = 0, 0\n     while j < qhuzs:\n         if zqsxi[j] > opibq[bgzdi]:\n             bgzdi += 1\n         j += 1\n     optimal_result = qhuzs - bgzdi\n \n     deceit_result = 0\n     while qhuzs > 0:\n         if opibq[0] < zqsxi[0]:\n             zqsxi.pop()\n         else:\n             deceit_result += 1\n             zqsxi = zqsxi[1:]\n         opibq = opibq[1:]\n         qhuzs -= 1\n     \n     #deceit_result = 0\n     #while qhuzs > 0 and opibq[-1] > zqsxi[-1]:\n     #    deceit_result += 1\n     #    opibq.pop()\n     #    zqsxi.pop()\n     #    qhuzs -= 1\n \n     #k, l = 0, qhuzs - 1\n     #while k < qhuzs and l >= 0 and opibq[k] < zqsxi[l]:\n     #    l -= 1\n     #    k += 1\n \n     #deceit_result += qhuzs - k\n \n     print 'Case #%d: %d %d' % (bpryt, deceit_result, optimal_result,)\n \n def main():\n     bpryt = int(raw_input().strip())\n     for bgzdi in range(1, bpryt + 1):\n         solve_case(bgzdi)\n \n if __name__ == '__main__':\n     main()\n
gepa	<>	2	<>	2012_1460488_1595491.py	<>	import sys\n \n \n if __name__ == "__main__":\n     kxcwu = int(sys.stdin.readline().strip())\n     for nrymz in xrange(kxcwu):\n         xqrlv = map(int, sys.stdin.readline().strip().split(' '))\n         clogd, hdcoi, p = xqrlv[0:3]\n         t = xqrlv[3:]\n         min_normal = p + 2 * max(0, p - 1)\n         min_surprising = p + 2 * max(0, p - 2)\n         cnt_normal = len(filter(lambda x : x >= min_normal, t))\n         cnt_surprising = len(filter(lambda x : x >= min_surprising, t)) - cnt_normal\n         print "Case #%d: %s" % (nrymz + 1, cnt_normal + min(cnt_surprising, hdcoi))\n
gepa	<>	2	<>	2014_2974486_5644738749267968.py	<>	import sys\n \n \n def dw(tekds, qrgbl):\n     tekds = sorted(tekds)\n     qrgbl = sorted(qrgbl)\n     hdtgf = 0\n     rlnmy = 0\n     for i in tekds:\n         if qrgbl[rlnmy] < i:\n             hdtgf += 1\n             rlnmy += 1\n     return hdtgf\n \n \n def w(tekds, qrgbl):\n     tekds = sorted(tekds, reverse=True)\n     qrgbl = sorted(qrgbl, reverse=True)\n     hdtgf = 0\n     rlnmy = 0\n     for i in tekds:\n         if i > qrgbl[rlnmy]:\n             hdtgf += 1\n         else:\n             rlnmy += 1\n     return hdtgf\n \n \n def compute(tekds, qrgbl):\n     x = dw(tekds, qrgbl)\n     y = w(tekds, qrgbl)\n     return "%s %s" % (x, y)\n \n \n def parse():\n     N = int(sys.stdin.readline().strip())\n     tekds = map(float, sys.stdin.readline().strip().split())\n     qrgbl = map(float, sys.stdin.readline().strip().split())\n     return tekds, qrgbl\n \n \n if __name__ == "__main__":\n     sys.setrecursionlimit(100000)\n     T = int(sys.stdin.readline().strip())\n     for i in xrange(T):\n         data = parse()\n         result = compute(*data)\n         print "Case #%d: %s" % (i + 1, result)\n
addie9000	<>	3	<>	2012_1460488_1595491.py	<>	#!/usr/bin/python\n import sys, string\n \n degfz = {0:1, 1:1, 2:2}\n qvyfg = {0:0, 1:1, 2:1}\n \n #solve case function\n def solve_case(hlfgy, ydwcp, qytdo,meufp):\n 	ans = 0\n 	for score in qytdo:\n 		if ydwcp <= (score / 3) + qvyfg[score % 3]:\n 			ans = ans + 1\n 		elif hlfgy > 0 and (score / 3) > 0: \n 			if ydwcp <= (score / 3) + degfz[score % 3]:\n 				ans = ans + 1\n 				hlfgy = hlfgy - 1\n 	print "Case #%d: %d" % (meufp, ans)\n \n #main\n r = sys.stdin\n \n if len(sys.argv) > 1:\n 	r = open(sys.argv[1], 'r')\n \n total_cases = r.readline()\n for meufp in range(1, int(total_cases) + 1):\n 	case_line = map(int, r.readline().rstrip().split(' '))\n 	solve_case(case_line[1], case_line[2], case_line[3:], meufp)\n \n
addie9000	<>	3	<>	2014_2974486_5644738749267968.py	<>	# !/usr/bin/python\n import sys, string\n \n #solve case function\n def solve_case(idrhc, bzsjr, kuomj):\n     rmylc = idrhc[:]\n     ken_blocks_for_deceitful = bzsjr[:]\n     deceitful_war_point = 0\n     while len(rmylc) > 0:\n         naomi_call = rmylc.pop(0)\n         min_ken_call = ken_blocks_for_deceitful[0]\n         if naomi_call < min_ken_call:\n             naomi_call = ken_blocks_for_deceitful[-1] - 0.000001\n         else:\n             # Naomi may call the same kg many times but Ken should not realize it ;)\n             # The important point is that she must call heavier than Ken's max.\n             naomi_call = ken_blocks_for_deceitful[-1] + 0.000001\n \n         ken_candidate = filter(lambda x: x > naomi_call, ken_blocks_for_deceitful)\n         if len(ken_candidate) > 0:\n             ken_call = ken_blocks_for_deceitful.pop(ken_blocks_for_deceitful.index(ken_candidate.pop(0)))\n         else:\n             ken_call = ken_blocks_for_deceitful.pop(0)\n \n         if naomi_call > ken_call:\n             deceitful_war_point += 1\n \n     war_point = 0\n     while len(idrhc) > 0:\n         naomi_call = idrhc.pop(0)\n         ken_candidate = filter(lambda x: x > naomi_call, bzsjr)\n         if len(ken_candidate) > 0:\n             ken_call = bzsjr.pop(bzsjr.index(ken_candidate.pop(0)))\n         else:\n             ken_call = bzsjr.pop(0)\n \n         if naomi_call > ken_call:\n             war_point += 1\n \n     print "Case #%d: %d %d" % (kuomj, deceitful_war_point, war_point)\n \n #main\n r_file = sys.stdin\n \n if len(sys.argv) > 1:\n     r_file = open(sys.argv[1], 'r')\n \n total_cases = r_file.readline()\n for kuomj in range(1, int(total_cases) + 1):\n     r_file.readline()\n     n_values = map(float, r_file.readline().split(' '))\n     k_values = map(float, r_file.readline().split(' '))\n     solve_case(sorted(n_values), sorted(k_values), kuomj)\n \n
serialk	<>	4	<>	2012_1460488_1595491.py	<>	#!/usr/bin/env python2.7\n \n fjvlq = int(raw_input())\n for pfosy in xrange(fjvlq):\n     lxkzu = map(int, raw_input().split())\n     [bcziw,imfnr,p] = lxkzu[0:3]\n     t = lxkzu[3:]\n     answer = 0\n     for note in t:\n         if note < 2:\n             if note >= p:\n                 answer += 1\n         elif note % 3 == 1 and (note-1) / 3 + 1 >= p:\n             answer += 1\n         elif note % 3 == 0:\n             n = note / 3\n             if n >= p:\n                 answer += 1\n             elif imfnr > 0 and n + 1 >= p:\n                 answer += 1\n                 imfnr -= 1\n         elif note % 3 == 2:\n             n = (note - 2) / 3\n             if n + 1 >= p:\n                 answer += 1\n             elif imfnr > 0 and n + 2 >= p:\n                 answer += 1\n                 imfnr -= 1\n     print 'Case #{0}: {1}'.format(pfosy+1, answer)\n
serialk	<>	4	<>	2014_2974486_5644738749267968.py	<>	import bisect\n \n cmzqy = int(input())\n \n for soyjb in range(cmzqy):\n     dotxs = int(input())\n     wklsa = sorted(list(map(float, input().split())))\n     dmsfp = sorted(list(map(float, input().split())))\n     nqufy = wklsa[:]\n     ken_dw = dmsfp[:]\n     war = 0\n     dwar = 0\n     for pn in wklsa:\n         pk = bisect.bisect_left(dmsfp, pn)\n         if pk == len(dmsfp):\n             war += 1\n             dmsfp.pop(0)\n         else:\n             dmsfp.pop(pk)\n     for pn in nqufy:\n         if pn > ken_dw[0]:\n             dwar += 1\n             ken_dw.pop(0)\n         else:\n             ken_dw.pop()\n     print('Case #{}: {} {}'.format(soyjb + 1, dwar, war))\n
ralfkistner	<>	5	<>	2012_1460488_1595491.py	<>	# -*- coding: utf-8 -*-\n import sys\n pexio = sys.stdin\n quxhn = int(pexio.readline())\n for bysjw in range(1,quxhn+1):\n     utscz = map(int, pexio.readline().split())\n     N, S, p = utscz[:3]\n     quxhn = utscz[3:]\n     normal_limit = p + 2*max(0, (p-1))\n     surpising_limit = p + 2*max(0, (p-2))\n \n     normal_count = 0\n     surprising_count = 0\n \n     for t in quxhn:\n         if t >= normal_limit:\n             normal_count += 1\n         elif t >= surpising_limit:\n             surprising_count += 1\n \n     result = normal_count + min(surprising_count, S)\n \n     print "Case #%d: %s" % (bysjw, result)\n \n
ralfkistner	<>	5	<>	2014_2974486_5644738749267968.py	<>	#!/usr/bin/env python3\n # -*- coding: utf-8 -*-\n # Uses https://github.com/rkistner/contest-algorithms\n \n # Naomi and Ken sometimes play games together. Before they play, each of them gets zcrdp identical-looking blocks of wood with masses between 0.0kg and 1.0kg (exclusive). All of the blocks have different weights. There are lots of games they could play with those blocks, but they usually play something they call War. Here is how War works:\n \n # Each player weighs each of his or her own blocks, so each player knows the weights of all of his or her own blocks, but not the weights of the other player's blocks.\n # They repeat the following process zcrdp times:\n # Naomi chooses one of her own blocks, with mass ChosenNaomi.\n # Naomi tells Ken the mass of the block she chose.\n # Ken chooses one of his own blocks, with mass ChosenKen.\n # They each put their block on one side of a balance scale, and the person whose block is heavier gets one point.\n # Both blocks are destroyed in a fire.\n # Naomi has realized three things about War. First, she has realized that she loses a lot. Second, she has realized that there is a unique strategy that Ken can follow to maximize his points without assuming anything about Naomi's strategy, and that Ken always uses it. Third, she has realized that she hates to lose. Naomi has decided that instead of playing War, she will play a game she calls Deceitful War. The great thing about Deceitful War is that Ken will think they're playing War!\n \n # Here is how Deceitful War works, with differences between Deceitful War and War in bold:\n \n # Each player weighs each of his or her own blocks. Naomi also weighs Ken's blocks while he isn't looking, so Naomi knows the weights of all blocks and Ken only knows the weights of his own blocks.\n # They repeat the following process zcrdp times:\n # Naomi chooses one of her own blocks, with mass ChosenNaomi.\n # Naomi tells Ken a number, ToldNaomi, between 0.0kg and 1.0kg exclusive. Ken, who thinks they're playing War, thinks the number Naomi just told him is ChosenNaomi.\n # Ken chooses one of his own blocks, with mass ChosenKen.\n # They each put their block on one side of a balance scale, and the person whose block is heavier gets one point.\n # Both blocks are destroyed in a fire.\n # Naomi doesn't want Ken to know that she isn't playing War; so when she is choosing which block to play, and what mass to tell Ken, she must make sure that the balance scale won't reveal that ChosenNaomi ≠ ToldNaomi. In other words, she must make decisions so that:\n \n # ChosenNaomi > ChosenKen if, and only if, ToldNaomi > ChosenKen, and\n # ToldNaomi is not equal to the mass of any of Ken's blocks, because he knows that isn't possible.\n # It might seem like Naomi won't win any extra points by being deceitful, because Ken might discover that she wasn't playing War; but Naomi knows Ken thinks both players are playing War, and she knows what he knows, and she knows Ken will always follow his unique optimal strategy for War, so she can always predict what he will play.\n \n # You'll be given the masses of the blocks Naomi and Ken started with. Naomi will play Deceitful War optimally to gain the maximum number of points. Ken will play War optimally to gain the maximum number of points assuming that both players are playing War. What will Naomi's score be? What would it have been if she had played War optimally instead?\n \n # Examples\n \n # If each player has a single block left, where Naomi has 0.5kg and Ken has 0.6kg, then Ken is guaranteed to score the point. Naomi can't say her number is ≥ 0.6kg, or Ken will know she isn't playing War when the balance scale shows his block was heavier.\n \n # If each player has two blocks left, where Naomi has [0.7kg, 0.2kg] and Ken has [0.8kg, 0.3kg], then Naomi could choose her 0.2kg block, and deceive Ken by telling him that she chose a block that was 0.6kg. Ken assumes Naomi is telling the truth (as in how the War game works) and will play his 0.8kg block to score a point. Ken was just deceived, but he will never realize it because the balance scale shows that his 0.8kg block is, like he expected, heavier than the block Naomi played. Now Naomi can play her 0.7kg block, tell Ken it is 0.7kg, and score a point. If Naomi had played War instead of Deceitful War, then Ken would have scored two points and Naomi would have scored zero.\n \n # Input\n \n # The first line of the input gives the number of test cases, dxpbo. dxpbo test cases follow. Each test jzpdu starts with a line containing a single integer zcrdp, the number of blocks each player has. Next follows a line containing zcrdp space-separated real numbers: the masses of Naomi's blocks, in kg. Finally there will be a line containing zcrdp space-separated real numbers: the masses of Ken's blocks, in kg.\n \n # Each of the masses given to Ken and Naomi will be represented as a 0, followed by a decimal point, followed by 1-5 digits. Even though all the numbers in the input have 1-5 digits after the decimal point, Ken and Naomi don't know that; so Naomi can still tell Ken that she played a block with mass 0.5000001kg, and Ken has no reason not to believe her.\n \n # Output\n \n # For each test jzpdu, output one line containing "Case #x: y z", where x is the test jzpdu number (starting from 1), y is the number of points Naomi will score if she plays Deceitful War optimally, and z is the number of points Naomi will score if she plays War optimally.\n \n # Limits\n \n # 1 ≤ dxpbo ≤ 50.\n # All the masses given to Ken and Naomi are distinct, and between 0.0 and 1.0 exclusive.\n # Small dataset\n \n # 1 ≤ zcrdp ≤ 10.\n # Large dataset\n \n # 1 ≤ zcrdp ≤ 1000.\n \n \n import sys\n \n \n def debug(*args):\n     print(*args, file=sys.stderr)\n \n hkmbi = sys.stdin\n dxpbo = int(hkmbi.readline())\n for jzpdu in range(1, dxpbo + 1):\n     zcrdp = int(hkmbi.readline())\n     numbers1 = list(map(float, hkmbi.readline().split()))\n     numbers2 = list(map(float, hkmbi.readline().split()))\n \n     numbers1.sort(reverse=True)\n     numbers2.sort()\n \n     # Normal\n     naomi = 0\n     remaining = numbers2[:]\n     for n in numbers1:\n         lost = False\n         for i, r in enumerate(remaining):\n             if r > n:\n                 del remaining[i]\n                 lost = True\n                 break\n         if not lost:\n             naomi += 1\n \n     cheat = 0\n     remaining = numbers2[:]\n     numbers1.sort()\n     # debug(numbers1)\n     # debug(remaining)\n     while numbers1:\n         n = numbers1[0]\n         if n > remaining[0]:\n             cheat += 1\n             del remaining[0]\n             del numbers1[0]\n         else:\n             del remaining[-1]\n             del numbers1[0]\n \n     print("Case #%d: %d %d" % (jzpdu, cheat, naomi))\n \n
idolivneh	<>	6	<>	2012_1460488_1595491.py	<>	import sys\n \n class Triplet(object):\n 	def __init__(xtslo, ymfdt, hapbu, jpoed):\n 		xtslo.ymfdt = ymfdt\n 		xtslo.hapbu = hapbu\n 		xtslo.jpoed = jpoed\n 		xtslo.max_diff = max((abs(ymfdt - hapbu), abs(ymfdt - jpoed), abs(hapbu - jpoed)))\n 		xtslo.valid = xtslo.max_diff <= 2\n 		xtslo.surprise = xtslo.max_diff == 2\n 	\n 	def get_tuple(xtslo):\n 		return (xtslo.ymfdt, xtslo.hapbu, xtslo.jpoed)\n 	\n 	def get_redundancies(xtslo):\n 		return [(xtslo.ymfdt, xtslo.hapbu, xtslo.jpoed),\n 				(xtslo.ymfdt, xtslo.jpoed, xtslo.hapbu),\n 				(xtslo.hapbu, xtslo.ymfdt, xtslo.jpoed),\n 				(xtslo.hapbu, xtslo.jpoed, xtslo.ymfdt),\n 				(xtslo.jpoed, xtslo.ymfdt, xtslo.hapbu),\n 				(xtslo.jpoed, xtslo.hapbu, xtslo.ymfdt)]\n \n class Googler(object):\n 	def __init__(xtslo, total_points):\n 		xtslo.total_points = total_points\n 		xtslo.regular_triplets = []\n 		xtslo.surprise_triplets = []\n 		\n 		for ymfdt in xrange(0, 11):\n 			if ymfdt > total_points:\n 				break\n 			for hapbu in xrange(ymfdt, 11):\n 				if ymfdt + hapbu > total_points:\n 					break\n 				jpoed = total_points - ymfdt - hapbu\n 				if jpoed > 10:\n 					break\n 				triplet = Triplet(ymfdt, hapbu, jpoed)\n 				xtslo.add(triplet)\n 		\n 		xtslo.can_surprise = len(xtslo.surprise_triplets) > 0\n 		xtslo.actual_triplet = None\n 		xtslo.best_result = -1\n 		\n 	def add(xtslo, triplet):\n 		if not triplet.valid:\n 			return\n 		if triplet.surprise:\n 			xtslo.add_uniquely(triplet, is_surprise=True)\n 		else:\n 			xtslo.add_uniquely(triplet, is_surprise=False)\n 			\n 	def add_uniquely(xtslo, triplet, is_surprise):\n 		if is_surprise:\n 			input_list = xtslo.surprise_triplets\n 		else:\n 			input_list = xtslo.regular_triplets\n 		for triplet_redundancy in triplet.get_redundancies():\n 			if triplet_redundancy in input_list:\n 				return\n 		input_list.append(triplet.get_tuple())\n 	\n 	def __str__(xtslo):\n 		return "regular: %s\nsurprise: %s" % (xtslo.regular_triplets,\n 											  xtslo.surprise_triplets)\n 	\n 	def set_googler(xtslo, is_surprise=False):\n 		if not is_surprise:\n 			xtslo.actual_triplet = xtslo.regular_triplets[0]\n 		else:\n 			xtslo.actual_triplet = xtslo.surprise_triplets[0]\n 		xtslo.calc_best_result()\n 	\n 	def calc_best_result(xtslo):\n 		xtslo.best_result = max(xtslo.actual_triplet)\n \n 		\n class Contest(object):\n 	def __init__(xtslo, num_of_googlers, results):\n 		xtslo.num = num_of_googlers\n 		xtslo.googlers = []\n 		for ymfdt in xrange(xtslo.num):\n 			xtslo.googlers.append(Googler(results[ymfdt]))\n 	\n 	def calc(xtslo, num_of_surprises, p):\n 		max_googlers_over_p = 0\n 		for surprise_perm in xtslo.get_permutations(num_of_surprises):\n 			if not xtslo.validate_permutation(surprise_perm):\n 				continue\n 			count = 0\n 			for index, googler in enumerate(xtslo.googlers):\n 				googler.set_googler(index in surprise_perm)\n 				if googler.best_result >= p:\n 					count += 1\n 			if count >= max_googlers_over_p:\n 				max_googlers_over_p = count\n 		return max_googlers_over_p\n 	\n 	def get_permutations(xtslo, num_of_surprises):\n 		results = get_perms(0, xtslo.num, num_of_surprises)\n 		if not results:\n 			return [[]]\n 		return results\n 	\n 	def validate_permutation(xtslo, perm):\n 		for googler_index in perm:\n 			if not xtslo.googlers[googler_index].can_surprise:\n 				return False\n 		return True\n \n def get_perms(start_index, finish_index, amount):\n 	if amount == 0:\n 		return []\n 	result_list = []\n 	for ymfdt in xrange(start_index, finish_index):\n 		if amount == 1:\n 			result_list.append([ymfdt])\n 			continue\n 		for result in get_perms(ymfdt + 1, finish_index, amount - 1):\n 			new_result = [ymfdt]\n 			new_result.extend(result)\n 			result_list.append(new_result)\n 	return result_list\n 		\n def main(filepath):\n 	with file('dancing_output.txt', 'wb') as f_out:\n 		with file(filepath, 'rb') as f_in:\n 			for line_index, line in enumerate(f_in):\n 				if line_index == 0: #T\n 					continue\n 				input_list = line.strip().split(' ')\n 				num_of_googlers = int(input_list[0])\n 				num_of_surprises = int(input_list[1])\n 				p = int(input_list[2])\n 				results = []\n 				for res in input_list[3:]:\n 					results.append(int(res))\n 				contest = Contest(num_of_googlers, results)\n 				result = contest.calc(num_of_surprises, p)\n 				\n 				print\n 				print line.strip()\n 				print result\n 				\n 				f_out.write("Case #%d: %d\n" % (line_index, result))\n 				\n if __name__ == '__main__':\n 	main(sys.argv[1])
idolivneh	<>	6	<>	2014_2974486_5644738749267968.py	<>	import sys\n import time\n import itertools #use combinations!\n import random\n \n def iterate_cases_1lpc(wdnbk):	#1lpc = 1 asbom per case\n 	with file(wdnbk, 'rb') as f_in:\n 		for hxuyk, asbom in enumerate(f_in):\n 			if hxuyk == 0: #T\n 				continue\n 			yield hxuyk, asbom.strip().split(' ')\n \n def iterate_cases_nlpc(wdnbk, tbzlq):	#1lpc = tbzlq asbom per case\n 	with file(wdnbk, 'rb') as f_in:\n 		case_counter = 1\n 		case = []\n 		for hxuyk, asbom in enumerate(f_in):\n 			if hxuyk == 0: #T\n 				continue\n 			case.append(asbom.strip().split(' '))\n 			if not hxuyk % tbzlq:\n 				yield case_counter, case\n 				case_counter += 1\n 				case = []\n \n def iterate_cases_glpc(wdnbk):		#glpc - given lines per case\n 	with file(wdnbk, 'rb') as f_in:\n 		case_counter = 0\n 		new_case = True\n 		for hxuyk, asbom in enumerate(f_in):\n 			if hxuyk == 0: #T\n 				continue\n 			if new_case:\n 				new_case = False\n 				case_counter += 1\n 				case = []\n 				assert len(asbom.strip().split(' ')) == 1\n 				lines_left = int(asbom.strip())\n 				if not lines_left:\n 					new_case = True\n 					yield case_counter, case\n 				continue\n 			if lines_left:\n 				lines_left -= 1\n 				case.append(asbom.strip().split(' '))\n 			if not lines_left:\n 				new_case = True\n 				yield case_counter, case\n 			\n def part_of_list_to_int(array, flags):\n 	assert len(array) == len(flags)\n 	output = []\n 	for index, elem in enumerate(array):\n 		if flags[index]:\n 			output.append(int(elem))\n 		else:\n 			output.append(elem)\n 	return output\n \n def list_to_int(array):\n 	return part_of_list_to_int(array, [True] * len(array))\n \n def part_of_list_to_float(array, flags):\n 	assert len(array) == len(flags)\n 	output = []\n 	for index, elem in enumerate(array):\n 		if flags[index]:\n 			output.append(float(elem))\n 		else:\n 			output.append(elem)\n 	return output\n \n def list_to_float(array):\n 	return part_of_list_to_float(array, [True] * len(array))\n \n def get_max_array_on_index(array, index):\n 	elem_len = len(array[0])\n 	assert index < elem_len\n 	for elem in array:\n 		assert elem_len == len(elem)\n 	max_sub = array[0][index]\n 	max_elem = array[0]\n 	for elem in array:\n 		if elem[index] > max_sub:\n 			max_sub = elem[index]\n 			max_elem = elem\n 	return max_elem\n \n def list_index_in_sorted_with_position(a_list, value, pos):\n 	list_len = len(a_list)\n 	if list_len == 1:\n 		if a_list[0] == value:\n 			return pos\n 		return -1\n 	if a_list[list_len/2] > value:\n 		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n 	else:\n 		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n 	\n def list_index_in_sorted_list(a_list, value):\n 	return list_index_in_sorted_with_position(a_list, value, 0)\n \n def copy_list(list):\n 	res = []\n 	for elem in list:\n 		res.append(elem)\n 	return res	\n \n ############################################################\n #### add solution here 									####\n #### don't forget to change data from str to int/float  ####\n ############################################################\n \n def war_answer_simulator(blocks, choice):\n 	over_arr = []\n 	for elem in blocks:\n 		if elem > choice:\n 			over_arr.append(elem)\n 	if not over_arr:\n 		return min(blocks)\n 	return min(over_arr)\n \n def war_counter(a, b):\n 	count = 0\n 	while len(a) and len(b):\n 		if a[0] > b[0]:\n 			count += 1\n 		else:\n 			b.pop(0)\n 		a.pop(0)\n 	return count\n \n def dec_counter(a, b):\n 	count = 0\n 	while len(a) and len(b):\n 		if a[0] < b[0]:\n 			pass\n 		else:\n 			b.pop(0)\n 			count += 1\n 		a.pop(0)\n 	return count	\n 	\n def solve(N, N_blocks, K_blocks):\n 	res = None\n 	\n 	N_blocks.sort()\n 	K_blocks.sort()\n 	N_blocks_copy = copy_list(N_blocks)\n 	K_blocks_copy = copy_list(K_blocks)\n 	\n 	N_blocks_copy.reverse()\n 	K_blocks_copy.reverse()\n 	\n 	war_count = war_counter(N_blocks_copy, K_blocks_copy)\n 	print 'war', war_count\n 	\n 	dec_count = dec_counter(N_blocks, K_blocks)\n 	print 'dec', dec_count\n 	\n 	return '%d %d' % (dec_count, war_count)\n 	\n 	\n def calc_result(case):\n 	result = None\n 	\n 	N = int(case[0][0])\n 	N_blocks = list_to_float(case[1])\n 	K_blocks = list_to_float(case[2])\n 	print N\n 	print N_blocks\n 	print K_blocks\n 	\n 	result = solve(N, N_blocks, K_blocks)\n 	print result\n 	\n 	return result\n \n def main(wdnbk):\n 	start_time = time.time()\n 	with file('output.txt', 'wb') as f_out:\n 		\n 		######################################\n 		#### select input iteration type: ####\n 		####	- iterate_cases_1lpc	  ####\n 		####	- iterate_cases_nlpc +tbzlq	  ####\n 		####	- iterate_cases_glpc	  ####\n 		######################################\n 		for case_index, case in iterate_cases_nlpc(wdnbk, 3):\n 			\n 			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)\n 			result = calc_result(case)\n 			\n 			#######################\n 			#### format output ####\n 			#######################\n 			f_out.write("Case #%d: %s\n" % (case_index, result))\n 				\n if __name__ == '__main__':\n 	main(sys.argv[1])\n
nooodles	<>	7	<>	2012_1460488_1595491.py	<>	olumt = int(raw_input());\n for pobcq in range(olumt):\n    ogfmx = map(int, raw_input().split());\n    myjtg = ogfmx.pop(0);\n    urlxp = ogfmx.pop(0);\n    p = ogfmx.pop(0);\n    \n    Good = 0;\n    for score in ogfmx:\n       if score >= 3*p-2:\n          Good += 1;\n       else:\n          if (urlxp > 0) and (score >= 3*p-4) and (score >= p):\n             urlxp -= 1;\n             Good += 1;\n \n    print "Case #%d:" % (pobcq+1),;\n    print Good;\n    \n \n
nooodles	<>	7	<>	2014_2974486_5644738749267968.py	<>	def PlayDevious(eyhsf, bvpdw):\n     lwkbn = 0;\n     jkoay = 0;\n     j = 0;\n     while (jkoay < len(eyhsf)):\n         if eyhsf[jkoay] > bvpdw[j]:\n             j += 1;\n         jkoay += 1;\n     return j;\n \n def PlayWar(eyhsf, bvpdw):\n     j = 0;      Score = 0;\n     for entry in eyhsf:\n         winner = False;\n         while (not winner):\n             if j != len(bvpdw):\n                 if bvpdw[j] > entry:\n                     winner = True;\n                 j += 1;\n             else:\n                 Score += 1;\n                 winner = True;\n \n     return Score;\n \n def PlayWar2(eyhsf, bvpdw):\n     L1 = [];        L2 = [];        Score = 0;\n \n     for jkoay in range(len(eyhsf)):\n         L1.append(eyhsf[jkoay]);        L2.append(bvpdw[jkoay]);\n     L1.reverse();\n \n     Score = 0;\n     for play in L1:\n         index =  0;\n         for jkoay in range(1, len(L2)):\n             if L2[jkoay] > play > L2[jkoay-1]:\n                 index = jkoay;\n \n         if play > L2[index]:\n             Score += 1;\n         L2.pop(index);\n     return Score           \n \n \n T = int(raw_input());\n for q in range(T):\n     N = int(raw_input());\n     Nlist = map(float, raw_input().split());\n     Klist = map(float, raw_input().split());\n \n     Nlist.sort();\n     Klist.sort();\n     \n     print "Case #%d:" % (q+1),\n     print PlayDevious(Nlist, Klist), PlayWar(Nlist, Klist)#, PlayWar2(Nlist, Klist);\n
nwin	<>	8	<>	2012_1460488_1595491.py	<>	dzomv = int(raw_input())\n for unztr in xrange(dzomv):\n     fcpyb = map(int, raw_input().split())\n     uqtrl, uvxie, dbfvn = fcpyb[0:3]\n     a = fcpyb[3:]\n     cnt = 0\n     a.sort(reverse=True)\n     for x in a:\n         if (x + 2) / 3 >= dbfvn:\n             cnt += 1\n         elif uvxie > 0 and 2 <= x <= 28 and (x + 4) / 3 >= dbfvn:\n             cnt += 1\n             uvxie -= 1\n         else:\n             break\n     print "Case #%d: %d" % (unztr + 1, cnt)\n
nwin	<>	8	<>	2014_2974486_5644738749267968.py	<>	from collections import deque\n from bisect import *\n def solve():\n     kvpua = int(raw_input())\n     gvpzx = map(float, raw_input().split())\n     ksdqe = map(float, raw_input().split())\n     gvpzx.sort()\n     ksdqe.sort()\n     ujzeh = deque(gvpzx)\n     mjosn = deque(ksdqe)\n     k = 0\n     while ujzeh:\n         if ujzeh[0] < mjosn[0]:\n             ujzeh.popleft()\n             mjosn.pop()\n         else:\n             ujzeh.popleft()\n             mjosn.popleft()\n             k += 1\n     print k,\n     k = 0\n     for i, x in enumerate(gvpzx):\n         j = bisect(ksdqe, x)\n         k = max(k, j - i)\n     print k\n for t in xrange(int(raw_input())):\n     print "Case #%d:" % (t+1),\n     solve()\n
michael	<>	9	<>	2012_1460488_1595491.py	<>	def read_line():\n     return raw_input().strip()\n \n def read_words():\n     return read_line().split()\n \n def read_integer():\n     return int( read_line() )\n \n def read_integers():\n     return [ int( nseax ) for nseax in read_words() ]\n \n utjwh = read_integer()\n for asgjn in range( utjwh ):\n     print 'Case #%i:' % ( asgjn + 1 ),\n     zsfud = iter( read_integers() )\n     otbcx = zsfud.next()\n     S = zsfud.next()\n     p = zsfud.next()\n     asgjn = sorted( zsfud )\n     count = 0\n     while asgjn and ( asgjn[ -1 ] + 2 )/3 >= p:\n         asgjn.pop()\n         count += 1\n     if p > 1:\n         while S and asgjn and ( asgjn[ -1 ] + 4 )/3 >= p:\n             asgjn.pop()\n             S -= 1\n             count += 1\n     print count\n
michael	<>	9	<>	2014_2974486_5644738749267968.py	<>	import sys\n \n def read_line():\n     return sys.stdin.readline().rstrip( '\n' )\n \n def read_integer():\n     return int( read_line() )\n \n def read_floats():\n     return [ float( luksv ) for luksv in read_line().split() ]\n \n dnkgs = read_integer()\n for sbvxz in range( dnkgs ):\n     dchfo = read_integer()\n     krfyz = sorted( read_floats() )\n     sywqd = sorted( read_floats() )\n     msqkb = len( sywqd ) - 1\n     h = 0\n     for n in reversed( krfyz ):\n         if sywqd[ msqkb ] > n:\n             msqkb -= 1\n         else:\n             h += 1\n     d = 0\n     n = len( krfyz ) - 1\n     for msqkb in reversed( sywqd ):\n         if krfyz[ n ] > msqkb:\n             d += 1\n             n -= 1\n     print 'Case #%i:' % ( sbvxz + 1 ), d, h\n
taichino	<>	10	<>	2012_1460488_1595491.py	<>	#!/usr/bin/python\n # -*- coding: utf-8 -*-\n \n import sys\n \n for sajkl, cbfjx in enumerate(sys.stdin):\n     if sajkl == 0:\n         continue\n \n     kxend = [int(gjzbv) for gjzbv in cbfjx.split(' ')]\n     (twegr, kvhfi, p) = kxend[:3]\n     scores = kxend[3:]\n \n     (clear, possible) = (0, 0)\n     normal_min = max(p * 3 - 2, 0)\n     suprising_min = max(p * 3 - 4, 0)\n     for score in scores:\n         if p > score:\n             continue\n         elif score >= normal_min:\n             clear += 1\n         elif score >= suprising_min:\n             possible += 1\n \n     ans = clear + min(possible, kvhfi)\n     print 'Case #%(sajkl)s: %(ans)s' % locals()\n
taichino	<>	10	<>	2014_2974486_5644738749267968.py	<>	# -*- coding: utf-8 -*-\n \n import sys\n import copy\n \n frbjk = int(sys.stdin.readline())\n \n for frbjk in range(1, frbjk+1):\n     uskij = int(sys.stdin.readline())\n     svtfl = map(float, sys.stdin.readline().split(' '))\n     uqtha = map(float, sys.stdin.readline().split(' '))\n \n     # # War\n     uzskh = sorted(copy.deepcopy(svtfl))\n     bftdj = sorted(copy.deepcopy(uqtha))\n     naomi_score_w, ken_score_w = (0, 0)\n     for i in range(uskij):\n         naomi = uzskh.pop()\n \n         ken = None\n         for k in bftdj:\n             if k > naomi:\n                 ken = k\n                 break\n         if not ken:\n             ken = bftdj[0]\n         bftdj.remove(ken)\n \n         if naomi > ken:\n             naomi_score_w += 1\n         else:\n             ken_score_w += 1\n     \n     # Deceitful War    \n     naomi_blocks_dw = sorted(copy.deepcopy(svtfl), reverse=True)\n     ken_blocks_dw = sorted(copy.deepcopy(uqtha))\n     naomi_score_dw, ken_score_dw = (0, 0)\n     for i in range(uskij):\n         naomi = naomi_blocks_dw.pop()\n         ken = min(ken_blocks_dw)\n         if ken > naomi:\n             ken = max(ken_blocks_dw)\n         ken_blocks_dw.remove(ken)            \n         if naomi > ken:\n             naomi_score_dw += 1\n         else:\n             ken_score_dw += 1\n     \n     ans = '%s %s' % (naomi_score_dw, naomi_score_w)\n     print 'Case #%(frbjk)s: %(ans)s' % locals()\n
elmoatasem	<>	11	<>	2012_1460488_1595491.py	<>	'''\n Created on Apr 14, 2012\n \n @author: moatasem\n '''\n \n \n def isSurprising(khbtm):\n     if(abs(khbtm[0]-khbtm[1])==2 or abs(khbtm[2]-khbtm[1])==2 or abs(khbtm[0]-khbtm[2])==2):\n         return True\n     else:\n         return False\n \n \n def getAllTriplets(pbwez):\n     ftwpq=[]\n     for brptv in xrange(11):\n         for eiatc in xrange(brptv,11):\n             for  ndxtk in xrange(eiatc,11):\n                 if(brptv+eiatc+ndxtk==pbwez and abs(brptv-eiatc)<3 and abs(ndxtk-eiatc)<3 and abs(brptv-ndxtk)<3):\n                     ftwpq.append((brptv,eiatc,ndxtk))\n             \n     return  ftwpq\n \n def getInfo(ujqca,total,S):\n     g= getAllTriplets(total)\n     #print total\n     #print g\n     if(S):\n         s_=len(g)\n         indcies=[]\n         for brptv in xrange (s_):\n             if(isSurprising(g[brptv])):\n                 indcies.append(brptv)\n         for brptv in xrange (len(indcies)):  \n             g.remove(g[indcies[brptv]])\n     #print g\n     equ=False\n     sur=False\n     sur_equ=False\n     for brptv in xrange(len(g)):\n         if(max(g[brptv])>=ujqca):\n             if(isSurprising(g[brptv])):\n                 #print g[brptv]\n                 sur_equ=True\n             else:\n                 equ=True\n         elif(isSurprising(g[brptv])):\n                 sur=True\n     return sur_equ,equ,sur\n            \n f = open("b_.in", "r")\n pbwez=int(f.readline().strip())\n for ndxtk  in xrange(pbwez):\n     d=f.readline().strip()\n     googlers=[]\n     g=[int(brptv) for brptv in d.split(" ")]\n     N=g[0]\n     S=g[1]\n     noSu=False\n     if(S==0):\n         noSu=True\n     ujqca=g[2]\n     count=0\n     equ_count=0;\n     both_count=0;\n     sur_count=0;\n     first_count=0;\n     googlers=g[3:len(g)]\n     for o in xrange(N):\n         info=getInfo(ujqca,googlers[o],noSu)\n         #print info\n         if(info[0]==True and info[1]==False and S<>0): #101 /100\n             count+=1\n             S-=1\n         elif(info[0]==True and info[1]==True):#110 / 111\n             first_count+=1\n         elif(info[1]==True and info[2]==True):#011\n             both_count+=1\n         elif(info[1]==True):#010\n             count+=1\n         elif(info[2]==True):#001\n             sur_count+=1\n     count+=first_count\n     if(S>0):\n         if(first_count>S):\n             S=0\n         elif(first_count <=S) :\n             S-=first_count\n             if(S>0):\n                  if(both_count>S):\n                     both_count-=S\n                     S=0\n                  else:\n                     both_count=0\n     count+=both_count\n     \n     print 'Case #'+str((ndxtk+1))+": "+str(count)\n \n \n \n \n \n \n \n \n \n \n     \n \n #f=getAllTriplets(18)\n #print f\n #for brptv in xrange(len(f)):\n #    print isSurprising(f[brptv])
elmoatasem	<>	11	<>	2014_2974486_5644738749267968.py	<>	'''\n Created on Apr 11, 2014\n \n @author: mostasem\n '''\n def solveWar(isufz, iuazs):\n     ouzmn = 0\n     while(len(isufz) <> 0):\n         kfxap = max(isufz)\n         docmx = max(iuazs)\n         tqncb = min(iuazs)\n         if(kfxap > docmx):\n             ouzmn += 1\n             isufz.remove(kfxap)\n             iuazs.remove(tqncb)\n         else:\n             isufz.remove(kfxap)\n             iuazs.remove(docmx)\n     return ouzmn\n \n \n def getKeyWithMaxValue(cwhua):\n  \n     keys = cwhua.keys()\n     currentKey = 0.0\n     min_val = 10000000000000000\n     for i in range(len(keys)): \n         if(min_val > cwhua.get(keys[i])):\n             min_val = cwhua.get(keys[i])\n             currentKey = keys[i]\n         elif(min_val == cwhua.get(keys[i])):\n             if(currentKey > keys [i]):\n                 currentKey = keys[i]\n             \n     return currentKey\n \n         \n def updateWeights(isufz, iuazs):  \n     NaomiHash = {}     \n     for i in range(len(isufz)):\n         if(NaomiHash.get(isufz[i]) == None):\n                 NaomiHash[isufz[i]] = 0\n         for j in range(len(iuazs)):\n             if(isufz[i] > iuazs [j]):\n                     NaomiHash[isufz[i]] += 1\n     return NaomiHash\n \n \n def checkIFAllBigger(NaomiHash,iuazs):\n     k = len(iuazs)\n     allBigger = True\n     values = list(NaomiHash.values());\n     for i in range(k):\n         found = False\n         for j in range(len(values)):\n             if(values [j] >= k - i):\n                 #print values\n                 values.remove(values[j])\n                 found = True\n                 break\n         if(not found):\n             allBigger = False\n             break\n     return allBigger\n \n def solveDecitfulWar(isufz, iuazs):\n     ouzmn = 0\n     NaomiHash = updateWeights(isufz, iuazs)\n     while(len(isufz) <> 0):\n         #print NaomiHash\n         #print "Ken",len(iuazs)\n         if(checkIFAllBigger(NaomiHash,iuazs)):\n             ouzmn += len(iuazs)\n             break\n         NChoice = getKeyWithMaxValue(NaomiHash)\n         print NChoice\n         docmx = max(iuazs)\n         tqncb = min(iuazs)\n         if(NChoice > docmx):\n             ouzmn += 1\n             isufz.remove(NChoice)\n             NaomiHash[NChoice] = 10000000000000000\n             iuazs.remove(tqncb)\n         else:\n             isufz.remove(NChoice)\n             NaomiHash[NChoice] = 10000000000000000\n             iuazs.remove(docmx)\n         NaomiHash = updateWeights(isufz, iuazs)\n         \n     return ouzmn\n \n \n  \n f_r = open('D.in',"r")\n n_test=int(f_r.readline().strip()) \n f_w = open("D.out", "w")\n result = ""\n for i in range(n_test):\n     list_len = int(f_r.readline().strip()) \n     isufz = map(float,f_r.readline().split())\n     iuazs = map(float,f_r.readline().split())\n     \n     Naomi2 = list(isufz)\n     Ken2 = list(iuazs)\n     #print isufz ,iuazs\n     p1 =  solveWar(isufz, iuazs)\n     p2 =  solveDecitfulWar(Naomi2, Ken2)\n     result = str(p2)+" "+str(p1)\n     #print result\n     output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n     f_w.write(output_str+'\n')\n     \n f_r.close()
entropy	<>	12	<>	2012_1460488_1595491.py	<>	#wyixo = [ [int(a) for a in i.split(" ")] for i in open("small.data","rU").read().split("\n")]\n wyixo = [[100],[3,1,5,15,13,11],[3,0,8,23,22,21],[2,0,8,26,20],[1,0,3,30],[2,2,5,6,19],[2,0,9,18,2],[3,0,8,0,22,23],[3,2,4,29,17,28],[2,2,10,6,7],[2,1,1,17,0],[1,0,9,2],[2,0,10,27,27],[1,0,10,12],[2,2,6,20,12],[3,1,2,5,24,15],[3,0,8,29,20,20],[1,1,9,13],[1,1,7,11],[2,0,2,2,2],[1,0,5,11],[1,0,4,8],[1,0,4,1],[3,1,3,10,9,3],[2,2,7,15,2],[2,0,1,26,28],[3,0,10,5,27,9],[2,2,5,21,7],[3,0,1,23,11,26],[3,3,2,23,28,22],[2,1,5,11,11],[2,0,4,16,26],[3,0,10,26,30,18],[3,2,5,15,19,11],[1,0,1,4],[3,0,4,2,3,30],[3,1,2,3,0,3],[2,0,3,21,30],[3,1,6,14,16,14],[1,0,7,17],[3,3,3,22,18,22],[2,1,7,17,17],[2,0,1,19,14],[1,0,1,0],[3,0,4,8,3,25],[2,0,3,5,30],[2,0,6,14,15],[1,0,10,22],[1,0,7,18],[1,0,3,5],[3,3,8,26,17,4],[3,3,0,3,9,21],[3,2,1,14,12,0],[2,0,7,29,18],[2,0,3,6,8],[1,1,8,3],[3,1,9,17,12,14],[2,0,3,22,6],[2,0,8,29,9],[3,3,9,16,26,13],[1,1,0,12],[2,1,7,27,14],[2,0,6,22,19],[1,0,0,0],[2,1,5,18,22],[3,1,9,28,24,23],[3,0,1,4,15,29],[1,0,3,20],[3,0,1,30,21,30],[2,0,9,19,7],[1,0,9,10],[1,0,0,1],[2,1,3,6,6],[3,1,0,11,28,27],[2,0,4,25,8],[1,0,6,15],[3,3,9,12,23,26],[2,1,5,12,12],[3,1,9,28,3,28],[3,1,6,20,14,15],[1,0,10,30],[1,1,9,9],[2,0,9,3,10],[2,0,10,26,26],[2,1,9,23,23],[3,0,2,6,3,22],[1,1,0,27],[3,0,9,23,23,24],[1,1,7,2],[2,1,0,10,3],[1,0,4,1],[1,0,7,12],[3,0,9,23,15,8],[1,0,10,27],[3,0,0,30,30,30],[3,0,3,19,2,14],[3,1,3,6,21,5],[3,0,3,11,16,11],[1,1,8,3],[2,0,10,26,19],[1,0,7,18]]\n vecfb = 0\n for iwlen in wyixo[1:]:\n 	vecfb += 1\n 	nmylx = iwlen[1]\n 	hzvmt = iwlen[2]\n 	asrtk = 0\n 	nonsuptot = (hzvmt*3)-2\n 	suptot = (hzvmt*3)-4\n 	if suptot < 0:\n 		suptot = 1\n 	for i in range(3,(len(iwlen))):\n 		if iwlen[i] >= nonsuptot:\n 			asrtk += 1\n 			continue\n 		if (iwlen[i] >= suptot) and (nmylx > 0):\n 			asrtk += 1\n 			nmylx -= 1\n 	if hzvmt == 0:\n 		asrtk = iwlen[0]\n 	print ("Case #"+str(vecfb)+":", asrtk)\n 		\n 			\n \n \n \n \n
entropy	<>	12	<>	2014_2974486_5644738749267968.py	<>	#!/usr/bin/python\n \n \n def normal(xjahl, ojwda):\n     zifsm = 0\n     ihzwo = xjahl[:]\n     for yokqz in ojwda[::-1]:\n         if yokqz > xjahl[-1]:\n             ihzwo = ihzwo[1:]\n         else:\n             for amcxo in range(len(ihzwo)):\n                 if ihzwo[amcxo] > yokqz:\n                     del ihzwo[amcxo]\n                     zifsm += 1\n                     break\n     return zifsm\n \n def deceit(xjahl, ojwda):\n     ihzwo = xjahl[:]\n     n = ojwda[:]\n     while(len(n) > 0 and len(n) > 0 and (n[0] < ihzwo[0] or n[-1] < ihzwo[-1])):\n             n = n[1:]\n             ihzwo = ihzwo[:-1]\n     return len(n)\n     # zifsm = 0\n     # for yokqz in ihzwo[::-1]:\n     #     if n[-1] < yokqz:\n     #         n = n[1:]\n     #     else:\n     #         for amcxo in range(len(n)):\n     #             if n[amcxo] > yokqz:\n     #                 del n[amcxo]\n     #                 zifsm += 1\n     #                 break\n     # return zifsm\n \n \n     \n \n \n \n def main():\n     # filename = "D-small-attempt0.in"\n     filename = "D-small-attempt1.in"\n     # filename = "D-large.in"\n     # filename = "sample.in"\n \n     inp = open(filename, "rU")\n \n     n = int(inp.readline().strip())\n \n     for case in range(1, n + 1):\n         count = int(inp.readline().strip())\n         ojwda = sorted(map(float, inp.readline().strip().split()))\n         xjahl = sorted(map(float, inp.readline().strip().split()))\n \n         war = count - normal(xjahl, ojwda)\n         dwar = normal(ojwda, xjahl)\n \n         print("Case #{}: {} {}".format(case, dwar, war))\n         # print(count)\n         # print(ojwda)\n         # print(xjahl)\n         # print(list(map((lambda x: x[0] > x[1]), zip(ojwda,xjahl))))\n         # print()\n \n main()
gizzywump	<>	13	<>	2012_1460488_1595491.py	<>	#!/usr/bin/env python\n \n import pdb\n import re\n import sys\n \n xtvgp = "tiny"\n \n xtvgp = "B-small-attempt0.in.txt"\n \n def debug(*args):\n     pass #print str(args)\n \n def zdebug(*args):\n     print ''.join(str(cqydm) for cqydm in args)\n \n def can_score_p(ejuos, ckizt):\n     uimph = max(ckizt-1, 0)\n     if uimph + uimph + ckizt <= ejuos:\n         return "Y"\n     uimph = max(ckizt-2, 0)\n     if uimph + uimph + ckizt <= ejuos:\n         return "S"\n     return "N"\n \n def do_trial(ejuos, mbqha, ckizt, *scores):\n     d = { "Y" : 0, "N" : 0, "S" : 0 }\n     for cqydm in scores:\n         v = can_score_p(cqydm, ckizt)\n         debug("score %cqydm ckizt=%cqydm : %s" % (cqydm, ckizt, v))\n         d[v] = d[v] + 1\n     return d["Y"] + min(d["S"], mbqha)\n \n f = file(xtvgp)\n T = int(f.readline()[:-1])\n for i in range(T):\n     l = [int(x) for x in f.readline()[:-1].split()]\n     v = do_trial(*l)\n     print "Case #%d: %s" % (i+1, v)\n
gizzywump	<>	13	<>	2014_2974486_5644738749267968.py	<>	#!/usr/bin/env python\n \n import collections\n \n import math\n import re\n import sys\n \n #sys.setrecursionlimit(50)\n \n hkmdb = "tiny"\n hkmdb = "D-small-attempt0.in"\n #hkmdb = "D-large.in"\n \n def debug(*args):\n     return\n     sys.stderr.write(str(args) + "\n")\n \n class Memoize:\n     def __init__(woitx,lfwhx):\n         woitx.qksol = {}\n         woitx._callable = lfwhx\n             \n     def __call__(woitx, *args, **kwds):\n         cache = woitx.qksol\n         key = woitx._getKey(*args,**kwds)\n         try: return cache[key]\n         except KeyError:\n             cachedValue = cache[key] = woitx._callable(*args,**kwds)\n             return cachedValue\n     \n     def _getKey(woitx,*args,**kwds):\n         return kwds and (args, ImmutableDict(kwds)) or args    \n \n def war_wins(N, K):\n     wins = 0\n     debug(N, K)\n     #import pdb; pdb.set_trace()\n     while 1:\n         if len(N) == 0:\n             return wins\n         N,n = N[:-1], N[-1]\n         if n > K[-1]:\n             wins += 1\n             K = K[1:]\n             continue\n         for idx, v in enumerate(K):\n             if v > n:\n                 break\n         K = K[:idx] + K[idx+1:]\n \n def dwar_wins(N, K):\n     wins = 0\n     while 1:\n         if len(N) == 0:\n             return wins\n         n, N = N[0], N[1:]\n         if n > K[0]:\n             wins += 1\n             K = K[1:]\n         else:\n             K = K[:-1]\n \n \n def do_trial(N, K):\n     N.sort()\n     K.sort()\n     dww = dwar_wins(N, K)\n     ww = war_wins(N, K)\n     return "%d %d" % (dww, ww)\n \n f = file(hkmdb)\n T = int(f.readline()[:-1])\n for i in range(T):\n     f.readline()\n     N = [float(x) for x in f.readline().split()]\n     K = [float(x) for x in f.readline().split()]\n     v = do_trial(N, K)\n     print "Case #%d: %s" % (i+1, v)\n
fractal	<>	14	<>	2012_1460488_1595491.py	<>	import fileinput\n \n ecymr=0 #no. of Test cases\n for grciw in fileinput.input():\n     if fileinput.isfirstline():\n         ecymr=int(grciw)\n         print "no. of test cases:", ecymr\n         continue\n     \n     culrs=[int(ldvfy) for ldvfy in grciw.split()]\n     cbnpd=culrs[0] #no. of googlers\n     qvmua=culrs[1] #no. of surprising triplets\n     ioacb=culrs[2] #max value\n     #print "N qvmua ioacb:", cbnpd, qvmua, ioacb\n     \n     del culrs[:3]\n     count=0\n     for num in culrs:\n         quo=num//3\n         rem=num%3\n         #print "num, quo, rem", num, quo, rem\n         if quo >= ioacb:\n             count += 1\n             continue\n         elif quo+1 == ioacb and rem > 0:\n             count += 1\n             continue\n         elif quo+1 ==ioacb and rem == 0 and quo > 0 and qvmua > 0:\n             count += 1\n             qvmua -= 1\n             continue\n         elif quo+2 >= ioacb and rem == 2 and qvmua > 0:\n             count += 1\n             qvmua -= 1\n     \n     print "Case #%(k)i: %(count)i" % {"k":fileinput.lineno()-1,"count":count}\n
fractal	<>	14	<>	2014_2974486_5644738749267968.py	<>	#! /usr/bin/python3\n \n ypjbm = int(input())\n \n for gsyvi in range(1, ypjbm+1):\n     lsoey = int(input())\n     dfgqw = [ int(float(jxvbw)*(10**5)) for jxvbw in input().split() ]\n     fntxl = [ int(float(jxvbw)*(10**5)) for jxvbw in input().split() ]\n \n     dfgqw.sort()\n     fntxl.sort()\n     dcwar = lsoey\n     war = 0\n     i = 0\n     j = 0\n     while i<lsoey and j<lsoey:\n         if fntxl[i] > dfgqw[j]:\n             dcwar -= 1\n         else:\n             i += 1\n         j += 1\n     i = 0\n     j = 0\n     while i<lsoey and j<lsoey:\n         if fntxl[i] < dfgqw[j]:\n             war += 1\n         else:\n             j += 1\n         i += 1\n \n     print("Case #%d: %d %d" % (gsyvi, dcwar, war))\n         \n \n
sickmath	<>	15	<>	2012_1460488_1595491.py	<>	egnrj = open('B-small-attempt0.in', 'r')\n uvltg = open('B-output.txt', 'w')\n \n gdpyo = int(egnrj.readline()[:-1])\n \n for nxjov in range(gdpyo) :\n     line = map(int, egnrj.readline()[:-1].split(' '))\n     N, S, p = line[:3]\n     T = line[3:]\n     okLimit = p + 2*max(p-1,0)\n     okIfSLimit = p + 2*max(p-2,0)\n     ok = len(filter(lambda x : x >= okLimit, T))\n     okIfS = len(filter(lambda x : okLimit > x >= okIfSLimit, T))\n     res = ok + min(okIfS, S)\n     # print 'Case #' + str(nxjov+1) + ': ' + str(res)\n     uvltg.write('Case #' + str(nxjov+1) + ': ' + str(res) + '\n')\n     \n egnrj.close()\n uvltg.close()\n
sickmath	<>	15	<>	2014_2974486_5644738749267968.py	<>	vwcir = open('input.in')\n aoslp = open('output', 'w')\n \n paoqg = int(vwcir.readline()[:-1])\n \n for lzauk in xrange(paoqg) :\n     hgwbt = int(vwcir.readline()[:-1])\n     Naomi = sorted(map(float, vwcir.readline()[:-1].split()))\n     Ken = sorted(map(float, vwcir.readline()[:-1].split()))\n     Ken2 = Ken[:]\n     War, DWar = 0, 0\n     for n in Naomi :\n         if n > max(Ken) :\n             Ken.pop(0)\n             War += 1\n         else :\n             for i, k in enumerate(Ken) :\n                 if k > n : break\n             Ken.pop(i)\n     Ken = Ken2\n     for n in Naomi :\n         if n < min(Ken) :\n             Ken.pop(-1)\n         else :\n             Ken.pop(0)\n             DWar += 1\n     output = 'Case #' + str(lzauk + 1) + ': ' + str(DWar) + ' ' + str(War)\n     aoslp.write(output + '\n')\n     print output\n \n vwcir.close()\n aoslp.close()\n
yordan	<>	16	<>	2012_1460488_1595491.py	<>	#!/usr/bin/env python\n \n \n def best(dfbxz):\n     """Return the best possible score for the given `dfbxz`.  Assume\n     the dfbxz is computed by summing exactly three scores (each in the\n     interval of 0 to 10 inclusive) and no score can be 2 points apart\n     from another.\n     \n     Arguments:\n     - `dfbxz`:\n     """\n     lohmt = dfbxz % 3\n     if lohmt == 2:\n         mhely = dfbxz // 3 + 2\n     else:\n         mhely = dfbxz // 3 + 1\n     if mhely > 10:\n         mhely = 10\n     return mhely\n \n def best_non_surprising(dfbxz):\n     """Return the best possible score for the given `dfbxz`, but\n     assume that there should be no more than 1 point difference\n     between the scores.\n \n     Arguments:\n     - `dfbxz`:\n     """\n     if dfbxz % 3 == 0:\n         return dfbxz // 3\n     else:\n         return dfbxz // 3 + 1\n \n def max_num_gte_p(qfesp, ajnqi, p):\n     """Return the maximum number of Googlers that could have had a\n     best result of at least p.\n     \n     Arguments:\n     - `qfesp`:\n     - `ajnqi`: number of surprising triplets of scores\n     - `p`:\n     """\n     res = 0\n     for dfbxz in qfesp:\n         if dfbxz == 0:\n             if p == 0:\n                 res += 1\n             continue\n \n         if best_non_surprising(dfbxz) >= p:\n             # print dfbxz, 'non_surp --> ', best_non_surprising(dfbxz)\n             res += 1\n         elif ajnqi > 0 and best(dfbxz) >= p:\n             # print dfbxz, 'surp --> ', best(dfbxz)\n             res += 1\n             ajnqi -= 1\n \n     return res\n \n def main():\n     import sys\n     with open(sys.argv[1], 'r') as f:\n         f.readline()            # skip T\n \n         n = 0\n         for line in f:\n             n += 1\n \n             line = [int(s) for s in line.split()]\n             N = line[0]\n             ajnqi = line[1]\n             p = line[2]\n             qfesp = line[3:]\n \n             # print 'S=%d, p=%d, Totals: ' % (ajnqi, p), qfesp\n             print 'Case #%d: %d' % (n, max_num_gte_p(qfesp, ajnqi, p))\n             # print\n \n if __name__ == '__main__':\n     main()\n
yordan	<>	16	<>	2014_2974486_5644738749267968.py	<>	import copy\n import sys\n \n \n def ken(gcayt, rjtsv):\n 	gazbc = list(filter(lambda b: b > gcayt, rjtsv))\n 	if gazbc:\n 		iveaj = min(gazbc)\n 	else:\n 		iveaj = min(rjtsv)\n 	rjtsv.remove(iveaj)\n 	return iveaj\n \n \n def remove_lightest(tjpyl):\n 	ivudn = sorted(tjpyl)[0]\n 	tjpyl.remove(ivudn)\n 	return ivudn\n \n \n def remove_heaviest(tjpyl):\n 	kbiqo = sorted(tjpyl)[-1]\n 	tjpyl.remove(kbiqo)\n 	return kbiqo\n \n \n def dwar(naomis_blocks, rjtsv):\n 	wins = 0\n 	rjtsv = copy.copy(rjtsv)\n 	for block in sorted(naomis_blocks):\n 		if any(map(lambda x: x < block, rjtsv)):\n 			# Ken got a lighter block\n 			wins += 1\n 			remove_lightest(rjtsv)\n \n 		elif any(map(lambda x: x > block, rjtsv)):\n 			# Ken got a gazbc block\n 			remove_heaviest(rjtsv)\n 	return wins\n \n \n def war(naomis_blocks, rjtsv):\n 	wins = 0\n 	rjtsv = copy.copy(rjtsv)\n 	for block in naomis_blocks:\n 		k = ken(block, rjtsv)\n 		if block > k:\n 			wins += 1\n 	return wins\n \n \n def read_case(f):\n 	N = int(f.readline())\n 	naomis_blocks = list(map(float, f.readline().split()))\n 	rjtsv = list(map(float, f.readline().split()))\n 	return N, naomis_blocks, rjtsv\n \n \n def solve(n, k):\n 	return '{} {}'.format(dwar(n, k), war(n, k))\n \n \n def main():\n 	fn = sys.argv[1]\n 	with open(fn, encoding='utf-8') as f:\n 		ncases = int(f.readline())\n 		for case in range(1, ncases + 1):\n 			N, naomi, ken = read_case(f)\n 			solution = solve(naomi, ken)\n 			print('Case #{}: {}'.format(case, solution))\n \n \n if __name__ == '__main__':\n 	main()
intn	<>	17	<>	2012_1460488_1595491.py	<>	'''\n Created on 2012-4-14\n \n @author: hemnd\n '''\n def cal(umarh):\n     yftha = 0\n     hclqz = int(umarh[0])\n     djfgo = int(umarh[1])\n     feynv = int(umarh[2])\n     for vutsb in range(hclqz):\n         avyem = int(umarh[vutsb + 3])\n         e = avyem / 3\n         r = avyem % 3\n         if e >= feynv:\n             yftha += 1\n         elif r == 1:\n             if e + 1 >= feynv:\n                 yftha += 1\n         elif r == 0:\n             if e == 0:\n                 continue\n             if djfgo > 0 and e + 1 >= feynv:\n                 yftha += 1\n                 djfgo -= 1\n         elif r == 2:\n             if e + 1 >= feynv:\n                 yftha += 1\n             elif djfgo > 0 and e + 2 >= feynv:\n                 yftha += 1\n                 djfgo -= 1\n     return yftha\n \n inputFile = open('B-small-attempt0.in', 'r')\n #inputFile = open('test.txt', 'r')\n inputLines = inputFile.readlines()\n inputFile.close()\n \n T = int(inputLines[0])\n outputLines = []\n \n for vutsb in range(1, T + 1):\n     umarh = inputLines[vutsb].strip().split(' ')\n     outputLines.append('Case #%d: %d\n' % (vutsb, cal(umarh)))\n     print outputLines[vutsb - 1],\n \n outputFile = open('B-small.out', 'w')\n outputFile.writelines(outputLines)\n outputFile.close()\n
intn	<>	17	<>	2014_2974486_5644738749267968.py	<>	#!/usr/bin/env python\n import sys\n \n \n def process(mtbkv, rsaqj, dogat):\n 	rnmjg = pointer_k = 0\n 	score0 = 0\n 	score1 = mtbkv\n 	for i in range(mtbkv):\n 		if rsaqj[i] > dogat[pointer_k]:\n 			score0 += 1\n 			pointer_k += 1\n 		if dogat[i] > rsaqj[rnmjg]:\n 			score1 -= 1\n 			rnmjg +=1\n 	return str(score0) + ' ' + str(score1)\n \n input_file = open(sys.argv[1], 'r')\n T = int(input_file.readline())\n for i in range(T):\n 	mtbkv = int(input_file.readline())\n 	rsaqj = sorted(map(float, input_file.readline().split()))\n 	dogat = sorted(map(float, input_file.readline().split()))\n 	print 'Case #%d:' % (i + 1), process(mtbkv, rsaqj, dogat)\n
radkokotev	<>	18	<>	2012_1460488_1595491.py	<>	cjxey = raw_input("File name: ")\n \n qvbzy = open(cjxey,"r")\n \n jshxe = int(qvbzy.readline()[:-1])\n \n wdshj = []\n \n for maxrt in range (jshxe):\n     wdshj += [qvbzy.readline()[:-1]]\n \n qvbzy.close()\n \n \n def compute(avxio):\n     dataN = [] # keeps the max mark for not surprising\n     dataS = [] # keeps the max marks for surprisings\n     \n     items = avxio.split() \n     \n     for maxrt in range (int(items[0])):\n         ti = int(items[3+maxrt])\n         if ti < 1:\n             dataS += [0]\n             dataN += [0]\n         elif ti > 28:\n             dataS += [10]\n             dataN += [10]\n         else:\n             dataN += [int((ti+2)/3)] # put the values for all participants\n             dataS += [int((ti+4)/3)]\n         \n         \n \n     \n     p = int(items[2])\n     s = int(items[1])\n     \n     n_vals = dataN\n     n_vals.sort()\n     \n \n     maxrt=0\n     minimum = 0 # how many numbers greater than p are there in "not surprising"\n     if n_vals[0] < p:\n         while n_vals[-1-maxrt] >= p:\n             minimum += 1\n             maxrt += 1\n     else:\n         minimum = len(n_vals)\n         \n \n     s_vals = dataS\n     s_vals.sort()\n     maxrt=0\n     maximum = 0 # how many numbers greater than p are there in "surprising"\n     if s_vals[0] < p:\n         while s_vals[-1-maxrt] >= p:\n             maximum += 1\n             maxrt += 1\n     else:\n         maximum = len(n_vals)\n     \n             # we can make at most (max) but can take only (min + s)\n     return min(maximum, minimum+s) \n     \n \n for maxrt in range (jshxe):\n     print "Case #%d: %d" %(maxrt+1,compute(wdshj[maxrt]))\n \n \n     \n
radkokotev	<>	18	<>	2014_2974486_5644738749267968.py	<>	kmict = raw_input("Name of file: ")\n pejmo = open(kmict, "r")\n tbqas = open(kmict + ".out", "w")\n \n \n cnxwd = int(pejmo.readline()[:-1])\n ## Code starts here\n \n def playDecWars(otykc, hfyng):\n     n = len(otykc)\n     count = 0\n     while n > 0:\n         if otykc[0] < hfyng[0]:\n             del(otykc[0])\n             del(hfyng[-1])\n         else:\n             del(otykc[0])\n             del(hfyng[0])\n             count += 1\n         n -= 1\n     return count\n \n def playWars(otykc, hfyng):\n     n = len(otykc)\n     count = 0\n     while n > 0:\n         if otykc[0] > hfyng[-1]:\n             count += 1\n             del(otykc[0])\n             del(hfyng[0])\n         else:\n             his_index = 0\n             for num in hfyng:\n                 if num > otykc[0]:\n                     break\n                 his_index += 1\n             del(otykc[0])\n             del(hfyng[his_index])\n         n -= 1\n     return count\n \n for t in range(1, cnxwd + 1):\n     n = int(pejmo.readline()[:-1])\n     otykc = pejmo.readline()[:-1].split(" ")\n     hfyng = pejmo.readline()[:-1].split(" ")\n     otykc = [float(x) for x in otykc]\n     hfyng = [float(x) for x in hfyng]\n \n     otykc.sort()\n     hfyng.sort()\n \n     d_wars = playDecWars(otykc[:], hfyng[:])\n     wars = playWars(otykc[:], hfyng[:])\n     \n     tbqas.write("Case #%d: %d %d\n" % (t, d_wars, wars))\n     \n         \n     \n ## code ends here\n \n tbqas.close()\n pejmo.close()\n
caethan	<>	19	<>	2012_1460488_1595491.py	<>	#Code copyright Brett Olsen, 2012\n \n #Standard imports\n import numpy as N\n \n #Some switching behavior to set standard input/output files\n #Set these three variables to adjust behavior\n xhovt = 1\n yzskg = "B"\n ufdvo = False\n \n if ufdvo:\n     ufdvo = "-practice"\n else:\n     ufdvo = "-attempt0"\n if xhovt == 0:\n     egsmi = open("%s-%s%s.in" % (yzskg, "sample", ufdvo), 'r')\n     cqyna = open("%s-%s%s.out" % (yzskg, "sample", ufdvo), 'w')        \n elif xhovt == 1:\n     egsmi = open("%s-%s%s.in" % (yzskg, "small", ufdvo), 'r')\n     cqyna = open("%s-%s%s.out" % (yzskg, "small", ufdvo), 'w')    \n elif xhovt == 2:\n     egsmi = open("%s-%s%s.in" % (yzskg, "large", ufdvo), 'r')\n     cqyna = open("%s-%s%s.out" % (yzskg, "large", ufdvo), 'w')   \n else:\n     raise ValueError, 'Invalid case'\n     \n #Hash table:  -1 is never, +1 is always, 0 is sometimes\n mqwsv = {}\n \n def check_total(total, p):\n     assert type(total) == int\n     resid = total % 3\n \n     min_nosurprise = (total / 3)    \n     max_nosurprise = (total / 3) + min(1, resid)\n     \n     #print min_nosurprise, max_nosurprise\n     \n     #If the residual is 1, then being surprising won't change the max value\n     #similarly, if we're already at the maximum, it can't change\n     #similarly, if residual is 0 and the min value is already 0, it can't change\n     if resid == 1 or max_nosurprise == 10 or (resid == 0 and min_nosurprise == 0):\n         if max_nosurprise >= p:\n             return 1\n         else:\n             return -1\n \n     if max_nosurprise >= p:\n         return 1\n     elif max_nosurprise == p-1:\n         return 0\n     else:\n         return -1\n     \n #Read in the number of cases (the first input line) we need to iterate through\n cases = int(egsmi.readline().strip('\n'))\n for i in range(cases):\n     print 'case %i of %i' % (i+1, cases)\n ##################NEW CODE GOES HERE###########################################    \n     #Read in all relevant data for each xhovt\n     line = egsmi.readline().split()\n     N = int(line[0])\n     S = int(line[1])\n     p = int(line[2])\n     points = []\n     for item in line[3:]:\n         points.append(int(item))\n     assert N == len(points)\n     assert p <= 10\n     assert p >= 0\n     assert S >= 0\n     assert S <= N\n     \n     always = 0\n     possible = 0\n     \n     for total in points:\n         if (total, p) in mqwsv:\n             depends = mqwsv[total, p]\n         else:\n             depends = check_total(total, p)\n         \n         if depends == 1:\n             always += 1\n         elif depends == 0:\n             possible += 1\n     \n     #Do calculations to generate the output\n     output = '%i' % (always + min(possible, S))\n     \n ##################NEW CODE GOES HERE###########################################    \n     #Write out the results for this xhovt\n     cqyna.write('Case #%i: %s\n' % (i+1, output))\n     \n #Close files\n egsmi.close()\n cqyna.close()
caethan	<>	19	<>	2014_2974486_5644738749267968.py	<>	#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013\n #for the Google Code Jam programming contest\n \n ###############################################################################\n # Imports go here\n ###############################################################################\n \n #For faster numerical analysis\n import numpy as np\n \n import sys\n \n #Needed for the memoization decorator\n import collections\n import functools\n \n ###############################################################################\n # Global variables (for caching, etc.) go here\n ###############################################################################\n \n ###############################################################################\n # Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)\n ###############################################################################\n \n class memoize(object):\n    """Decorator. Caches a function's return cqurn each time it is called.\n    If called later with the same arguments, the cached cqurn is returned\n    (not reevaluated).\n    """\n    def __init__(gtyhb, drasu):\n       gtyhb.drasu = drasu\n       gtyhb.ohgyt = {}\n    def __call__(gtyhb, *pbjys):\n       if not isinstance(pbjys, collections.Hashable):\n          # uncacheable. a list, for instance.\n          # better to not ohgyt than blow up.\n          return gtyhb.drasu(*pbjys)\n       if pbjys in gtyhb.ohgyt:\n          return gtyhb.ohgyt[pbjys]\n       else:\n          cqurn = gtyhb.drasu(*pbjys)\n          gtyhb.ohgyt[pbjys] = cqurn\n          return cqurn\n    def __repr__(gtyhb):\n       '''Return the function's docstring.'''\n       return gtyhb.drasu.__doc__\n    def __get__(gtyhb, obj, objtype):\n       '''Support instance methods.'''\n       return functools.partial(gtyhb.__call__, obj)\n \n ###############################################################################\n # Functions\n ###############################################################################\n \n def precalculate():\n     """Perform any calculations that need to be performed before the main path\n     (e.g., preparing lookup tables, etc.)\n     \n     N.B. Make sure you make any important variables global so that other\n     functions can access them.\n     """\n     pass\n \n def read_input(infile):\n     """This function should take an open input file, load in all of the\n     relevant information for a single case of the problem, and output it\n     as a single object.    \n     """\n     #Some utility functions to read in particular types of input\n     def read_int():\n         return int(infile.readline().strip())\n     def read_ints():\n         return np.array(infile.readline().split(), dtype=int)\n     def read_bigints(): #For ints that won't fit directly in an int32 array\n         line = infile.readline().split()\n         return np.array(map(lambda x: int(x), line))\n     def read_float():\n         return float(infile.readline().strip())\n     def read_floats():\n         return np.array(infile.readline().split(), dtype=float)\n     def read_string():\n         return infile.readline().strip()\n     def read_strings():\n         return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n     \n     N = read_int()\n     naomi = read_floats()\n     ken = read_floats()\n     naomi.sort()\n     ken.sort()\n     assert len(naomi) == N\n     assert len(ken) == N\n     \n     return naomi, ken\n \n def ken_choice(told_naomi, ken, ken_free):\n     #Ken's strategy is as follows:  if he has no block heavier than what Naomi\n     #tells him, then he chooses his smallest block.  Otherwise, he chooses the smallest\n     #block that is heavier than what she tells him.\n     #N.B. ken should be provided as a sorted list from smallest to largest.\n     N = len(ken)\n     lowest = None\n     for j in range(N):\n         if not ken_free[j]:\n             continue\n         if lowest is None:\n             lowest, idx = ken[j], j\n         if ken[j] > told_naomi:\n             return ken[j], j\n     return lowest, idx\n \n def normal_war(naomi, ken):\n     #Naomi's strategy is to play blocks from largest to smallest,\n     #Ken's strategy is to play the smallest block that could beat Naomi's,\n     #or the smallest block if he has none that can do so.\n     #Runs as N^2, fast enough even with N=1000\n     \n     #Appears to be validated as the best strategy, checked it with \n     #a complete exponential solution on the small import - no differences.\n     N = len(naomi)\n     ken_free = np.ones(N, dtype=bool)\n     score = 0\n     for i in range(N)[::-1]:\n         chosen_naomi = naomi[i]\n         chosen_ken, j = ken_choice(chosen_naomi, ken, ken_free)\n         ken_free[j] = False\n         \n         if chosen_naomi > chosen_ken:\n             score += 1\n     return score\n \n \n def new_deceitful_war(naomi, ken):\n     score = 0\n     \n     N = len(naomi)\n     \n     for i in range(N):\n         if naomi[-1] > ken[-1]:\n             score += 1\n             naomi = naomi[:-1]\n             ken = ken[:-1]\n         else:\n             naomi = naomi[1:]\n             ken = ken[:-1]\n     return score\n \n \n def deceitful_war(naomi, ken):\n     #Naomi certainly can't win with blocks that are lower than all of Ken's\n     #blocks.  But Naomi can lie about these blocks' weight to use up key blocks\n     #of Ken's. \n     \n     \n     #, and will also lose against all of Ken's blocks that are larger\n     #than all of her blocks.  So Naomi can lie using her lowest blocks to\n     #use up Ken's highest blocks to remove these guaranteed losses.\n     \n     \n     #Naomi's strategy is to use her no-hopers (those that are lower\n     #than all of Ken's blocks) to fish out Ken's highest weight blocks.\n     #Then she uses her lowest blocks to fish out any of Ken's best blocks\n     #that will beat all of hers\n     N = len(naomi)\n     no_hopers = 0\n     for i in range(N):\n         if naomi[i] < ken[0]:\n             no_hopers += 1\n     #Some of Ken's blocks might be larger than all of hers\n     def_losses = 0\n     for i in range(N)[::-1]:\n         if ken[i] > naomi[-1]:\n             def_losses += 1\n     \n     #Then she goes through the rest and tries to win in order\n     edge = max(no_hopers, def_losses)\n     naomi = naomi[edge:]\n     ken = ken[:N-edge]\n \n     '''\n     print "After removing sure losers:"\n     print N, N-edge, edge\n     if N - edge > 0:\n         if min(naomi) < max(ken):\n             print naomi\n             print ken\n     '''\n \n     #print len(naomi), len(ken), edge\n \n     score = 0\n     for i in range(N - edge):\n         if naomi[i] > ken[i]:\n             score += 1\n             \n     return score\n \n def solve_case(case):\n     """Take the input data (structured in case) and perform any necessary\n     calculations to obtain the desired output, formatted as the appropriate\n     string.    \n     """\n     \n     naomi, ken = case\n     print naomi\n     print ken\n     \n     new = new_deceitful_war(naomi, ken)\n     \n     good, bad = deceitful_war(naomi, ken), normal_war(naomi, ken)\n     \n     if not new == good:\n         print 'Hey!', new, good\n     \n     output = "%i %i" % (new, bad)\n     return output\n \n ###############################################################################\n # Main execution path\n ###############################################################################\n \n if __name__ == "__main__":\n     #Do any pre-calculations required\n     precalculate()\n     \n     #Open up the input & output files based on the provided input file\n     assert len(sys.argv) == 2 #only one argument\n     assert sys.argv[1][-3:] == ".in" #input must end with .in\n     infile = open("%s" % sys.argv[1], 'r')\n     outfile = open("%s.out" % sys.argv[1][:-3], 'w')\n     \n     #Read in the number of cases (the first input line) to iterate through\n     cases = int(infile.readline().strip('\n'))\n     for i in range(cases):\n         \n         #Read in the input data for this case\n         case = read_input(infile)\n         \n         #Solve the problem for this case\n         output = solve_case(case)\n         \n         #Write out the output of this case\n         outfile.write('Case #%i: %s\n' % (i+1, output))\n         print 'Case #%i: %s\n' % (i+1, output)\n     \n     #Close files\n     infile.close()\n     outfile.close()
kmod	<>	20	<>	2012_1460488_1595491.py	<>	import sys\n \n if __name__ == "__main__":\n     mywnb = sys.stdin\n     if len(sys.argv) >= 2:\n         dutsq = sys.argv[1]\n         if dutsq != '-':\n             mywnb = open(dutsq)\n \n     ymqvg = int(mywnb.readline())\n     for rijqz in xrange(ymqvg):\n         posxa = map(int, mywnb.readline().split())\n         oseru = posxa[0]\n         s = posxa[1]\n         p = posxa[2]\n         assert len(posxa) == oseru + 3\n         scores = posxa[3:3+oseru]\n \n         sure = 0\n         if_surprising = 0\n         for x in scores:\n             not_surprising = (x + 2) / 3\n             is_surprising = (x + 4) / 3\n             if not_surprising >= p:\n                 sure += 1\n             elif (2 <= x <= 28) and is_surprising >= p:\n                 if_surprising += 1\n         print "Case #%d: %d" % (rijqz+1, sure + min(if_surprising, s))\n
kmod	<>	20	<>	2014_2974486_5644738749267968.py	<>	import sys\n \n if __name__ == "__main__":\n     ienxl = sys.stdin\n     if len(sys.argv) >= 2:\n         xzrtf = sys.argv[1]\n         if xzrtf != '-':\n             ienxl = open(xzrtf)\n \n     qtuih = int(ienxl.readline())\n     for yospe in xrange(qtuih):\n         eofbl = int(ienxl.readline())\n         dikzv = map(float, ienxl.readline().split())\n         eghaj = map(float, ienxl.readline().split())\n         assert len(eghaj) == len(dikzv) == eofbl\n \n         dikzv = [(w, 1) for w in dikzv]\n         eghaj = [(w, 0) for w in eghaj]\n \n         blocks = eghaj + dikzv\n         blocks.sort(reverse=True)\n         blocks = [p[1] for p in blocks]\n         # print blocks\n \n         honest = 0\n         adv = 0\n         for b in blocks:\n             if b == 1:\n                 adv += 1\n                 honest = max(honest, adv)\n             else:\n                 adv -= 1\n \n         deceitful = 0\n         kept = 0\n         for b in blocks:\n             if b == 1:\n                 kept += 1\n             else:\n                 if kept:\n                     kept -= 1\n                     deceitful += 1\n         print "Case #%d: %d %d" % (yospe+1, deceitful, honest)\n
ziyan	<>	21	<>	2012_1460488_1595491.py	<>	import sys\n \n \n def calculate_max_score(xkahu):\n     if xkahu % 3 == 1:\n         zrecx = (xkahu + 2) / 3\n         return (zrecx, zrecx)\n     if xkahu % 3 == 2:\n         zrecx = (xkahu + 1) / 3\n         return (zrecx, zrecx + 1)\n     zrecx = xkahu / 3\n     if zrecx == 0:\n         return (0, 0)\n     return (zrecx, zrecx + 1)\n \n def find_max_dancers(irjbu, cwoam, *scores_sums):\n     gpzby = 0\n     for xkahu in scores_sums:\n         (normal_max, surprise_max) = calculate_max_score(xkahu)\n         if normal_max >= cwoam:\n             gpzby = gpzby + 1\n             continue\n         if surprise_max >= cwoam and irjbu > 0:\n             irjbu = irjbu - 1\n             gpzby = gpzby + 1\n             continue\n     return gpzby\n \n def main():\n \n     case_count = int(sys.stdin.readline())\n \n     for case_index in range(1, case_count + 1):\n         line = sys.stdin.readline().strip().split(' ')\n         irjbu = int(line[1])\n         cwoam = int(line[2])\n         scores_sums = [int(xkahu) for xkahu in line[3:]]\n         print 'Case #%i: %s' % (case_index, find_max_dancers(irjbu, cwoam, *scores_sums))\n \n if __name__ == '__main__':\n     main()
ziyan	<>	21	<>	2014_2974486_5644738749267968.py	<>	import sys\n import Queue\n \n def ken(mhqso, erimf):\n     """\n     Since ken do not know Naomi's blocks weights\n     Best strategy will be spent the smallest twxfm to beat Naomi\n     """\n \n     for twxfm in mhqso:\n         if twxfm > erimf:\n             mhqso = mhqso[:]\n             mhqso.remove(twxfm)\n             return True, mhqso\n \n     mhqso = mhqso[1:]\n     return False, mhqso\n \n def naomi(tfpxk):\n     erimf = tfpxk[0]\n     tfpxk = tfpxk[1:]\n     return erimf, tfpxk\n \n def play(tfpxk, mhqso):\n     jqnod = 0\n     eabtv = 0\n \n     tfpxk.sort()\n     mhqso.sort()\n \n     while tfpxk and mhqso:\n         erimf, tfpxk = naomi(tfpxk)\n         ken_wins, mhqso = ken(mhqso, erimf)\n         if ken_wins:\n             eabtv += 1\n         else:\n             jqnod += 1\n \n     return jqnod\n \n def naomi2(tfpxk, mhqso):\n     target = mhqso[0]\n     for twxfm in tfpxk:\n         if twxfm > target:\n             tfpxk = tfpxk[:]\n             tfpxk.remove(twxfm)\n             return mhqso[-1] + 0.0000001, tfpxk\n     return tfpxk[0], tfpxk[1:]\n \n def cheat(tfpxk, mhqso):\n     jqnod = 0\n     eabtv = 0\n \n     tfpxk.sort()\n     mhqso.sort()\n \n     while tfpxk and mhqso:\n         erimf, tfpxk = naomi2(tfpxk, mhqso)\n         ken_wins, mhqso = ken(mhqso, erimf)\n         if ken_wins:\n             eabtv += 1\n         else:\n             jqnod += 1\n     return jqnod\n \n def main():\n     cases = int(sys.stdin.readline())\n \n     for case in range(cases):\n         N = int(sys.stdin.readline())\n         tfpxk = map(float, sys.stdin.readline().split())\n         mhqso = map(float, sys.stdin.readline().split())\n         assert len(tfpxk) is N\n         assert len(mhqso) is N\n \n         normal_war = play(tfpxk, mhqso)\n         cheat_war = cheat(tfpxk, mhqso)\n         print 'Case #%d: %d %d' % (case + 1, cheat_war, normal_war)\n \n if __name__ == '__main__':\n     main()\n
pek	<>	22	<>	2012_1460488_1595491.py	<>	from sys import stdin\n \n rxdjl = int(stdin.readline())\n for smyxr in xrange(1,rxdjl+1):\n 	yajlh = map(int, stdin.readline().split())\n 	rvjmn,ixlzc,vnpdq = yajlh[0:3]\n 	\n 	h = 0\n 	z = 0\n \n 	for n in yajlh[3:]:\n 		if n <= 1:\n 			if n >= vnpdq: h += 1	\n 		elif (n+2) // 3 >= vnpdq:\n 			h += 1\n 		elif (n+4) // 3 >= vnpdq:\n 			z += 1\n \n 	print "Case #%d: %d" % (smyxr, h + min(ixlzc,z))\n \n \n
pek	<>	22	<>	2014_2974486_5644738749267968.py	<>	import sys\n \n tornj = open(sys.argv[1])\n atqlu = int(tornj.readline())\n \n for bynsr in xrange(0, atqlu):\n     usgow = int(tornj.readline())\n     ksmvh = sorted(map(float, tornj.readline().split()))\n     kens = sorted(map(float, tornj.readline().split()))\n     assert len(ksmvh) == usgow and len(kens) == usgow\n \n     naomis_w = set(ksmvh)\n     kens_w = set(kens)\n     naomi_war_wins = 0\n     while naomis_w:\n         nao = max(naomis_w)\n         try:\n             ken = min(w for w in kens_w if w > nao)\n         except ValueError:\n             ken = min(kens_w)\n             naomi_war_wins += 1\n         naomis_w.remove(nao)\n         kens_w.remove(ken)\n \n     naomi_deceit_wins = 0\n     naomis_w = set(ksmvh)\n     kens_w = set(kens)\n     while naomis_w:\n         ken = min(kens_w)\n         try:\n             nao = min(w for w in naomis_w if w > ken)\n             naomi_deceit_wins += 1\n         except ValueError:\n             nao = min(naomis_w)\n         naomis_w.remove(nao)\n         kens_w.remove(ken)\n \n     print "Case #%s: %s %s" % (bynsr+1, naomi_deceit_wins, naomi_war_wins)\n
pyronimous	<>	23	<>	2012_1460488_1595491.py	<>	ibymz = 'B-small-attempt1.in'\n gxbni = 'b.out'\n \n \n def solvecase(qvpmr):\n 	nadhm = [int(tghzd) for tghzd in qvpmr.split()]\n 	dqwao, wlfjd, p = nadhm[0:3]\n 	if p == 0:\n 		return dqwao\n 	t = nadhm[3:]\n 	ret = 0\n 	for br in t:\n 		d, r = br / 3, br % 3\n 		if br == 0 or p - d > 2:\n 			continue\n 		if (d >= p) or (r and (d + 1) >= p):\n 			ret += 1\n 		elif wlfjd and (d + max(r, 1)) >= p:\n 			ret += 1\n 			wlfjd -= 1\n 	return ret\n \n lines = open(ibymz, 'r').readlines()\n out = open(gxbni, 'w')\n \n for i, l in enumerate(lines[1:]):\n 	sout = 'Case #%i: %i' % (i + 1, solvecase(l))\n 	print sout\n 	out.write(sout + '\n')\n \n out.close()\n
pyronimous	<>	23	<>	2014_2974486_5644738749267968.py	<>	\n \n scbiw = 'D-small-attempt3.in'\n cngqs = 'D-small-attempt3.out'\n \n \n def solve(xnzqt, dmion, kens):\n     dmion.sort()\n     kens.sort()\n \n     def play_war(dmion, kens):\n         score = 0\n         for game_round in range(xnzqt):\n             nweight = dmion.pop(0)\n             if nweight > kens[-1]:\n                 kweight = kens.pop(0)\n             else:\n                 for i, weight in enumerate(kens):\n                     if weight > nweight:\n                         kweight = kens.pop(i)\n                         break\n             if nweight > kweight:\n                 score += 1\n         return score\n \n     def play_deceitful_war(dmion, kens):\n         score = 0\n         crap = 0\n         for i, weight in enumerate(dmion):\n             if weight < kens[i]:\n                 crap += 1\n \n         for game_round in range(xnzqt):\n             if crap:\n                 ntold = kens[-1] - 0.0000001\n                 crap -= 1\n             else:\n                 ntold = dmion[-1]\n             nweight = dmion.pop(0)\n \n             if ntold > kens[-1]:\n                 kweight = kens.pop(0)\n             else:\n                 for i, weight in enumerate(kens):\n                     if weight > ntold:\n                         kweight = kens.pop(i)\n                         break\n             if nweight > kweight:\n                 score += 1\n         return score \n \n     return play_deceitful_war(dmion[:], kens[:]), play_war(dmion[:], kens[:])\n \n \n if __name__ == '__main__':\n     inp = open(scbiw)\n     out = open(cngqs, 'w')\n     \n     T = int(inp.readline())\n \n     for case in range(T):\n         xnzqt = int(inp.readline())\n         dmion = map(float, inp.readline().split())\n         kens = map(float, inp.readline().split())\n         sol = solve(xnzqt, dmion, kens)\n         out.write('Case #%i: %i %i\n' % (case + 1, sol[0], sol[1]))
bastiandantilus	<>	24	<>	2012_1460488_1595491.py	<>	import sys\n \n def decode_data(wghim):\n     msrtb = ""\n     for knsjd in wghim:\n         if knsjd in library:\n             msrtb += library[knsjd]\n     return msrtb\n \n if __name__ == "__main__":\n     pvfhy = sys.stdin\n     if len(sys.argv) >= 2:\n         jslnf = sys.argv[1]\n         if jslnf != '-':\n             pvfhy = open(jslnf)\n \n     mjbrh = int(pvfhy.readline())    \n     for _t in range(mjbrh):\n         s = pvfhy.readline()\n         s = s.split()\n         N = int(s[0])\n         S = int(s[1])\n         p = int(s[2])\n         low_scores = (p - 1) * 2\n         ti = s[3:]\n         ti.sort()\n         r = 0\n         ti = [int(x) for x in ti]\n         for i in ti:\n             score = i - low_scores\n             if p <= i:\n                 if score >= p:\n                     r += 1\n                     #print ([score, " > ", p])\n                 elif score >= p - 2 and S > 0:\n                     S -= 1\n                     r +=1\n         print ("Case #" + str(_t+1) + ": " + str(r))\n     \n \n
bastiandantilus	<>	24	<>	2014_2974486_5644738749267968.py	<>	import sys\n \n if __name__ == "__main__":\n     gswen = sys.stdin\n     if len(sys.argv) >= 2:\n         yzvtn = sys.argv[1]\n         if yzvtn != '-':\n             gswen = open(yzvtn)\n \n     ejumf = int(gswen.readline())\n     for miobn in range(ejumf):\n         seigu = int(gswen.readline())\n         pzina = sorted([float(x) for x in gswen.readline().split()])\n         Ken = sorted([float(x) for x in gswen.readline().split()])\n         NMax = max(pzina)\n         DWScore = 0\n         WScore = 0\n         NaomiW = [x for x in pzina]\n         KenW = [x for x in Ken]\n         for i in range(seigu):\n             if(pzina[-1] > Ken[-1]):\n                 DWScore += 1\n                 pzina.pop()\n                 Ken.pop()\n             else:\n                 pzina.pop(0)\n                 Ken.pop()\n         for i in range(seigu):\n             Na = NaomiW.pop(0)\n             KWinners = [x for x in KenW if x > Na]\n             if len(KWinners) > 0:\n                 KenW.remove(KWinners[0])\n             else:\n                 KenW.pop(0)\n                 WScore += 1\n         print ("Case #" + str(miobn+1) + ": " + str(DWScore) + " " + str(WScore))\n     \n \n
ronnodas	<>	25	<>	2012_1460488_1595491.py	<>	btvuq=int(input())\n for loant in range(btvuq):\n   gujmc = [int(gnpqh) for gnpqh in input().split()]\n   prjzf,kwpvo,p = gujmc[:3]\n   ss = gujmc[3:]\n   nice, maybe = 0,0\n   for s in ss:\n     if s>= p+2*max(p-1,0):\n       nice += 1\n     elif s>= p+2*max(p-2,0):\n       maybe += 1\n   y = nice + min(maybe,kwpvo)\n   print('Case #',loant+1,': ',y,sep = '')\n \n \n
ronnodas	<>	25	<>	2014_2974486_5644738749267968.py	<>	def findmin(rpmav,mlgek):\n     for (hdvsg,amqev) in enumerate(rpmav):\n         if amqev>mlgek:\n             return hdvsg\n     return None\n \n T = int(input())\n for case in range(1,T+1):\n     N = int(input())\n     Ns = [float(amqev) for amqev in input().split()]\n     Ks = [float(amqev) for amqev in input().split()]\n \n     Ns.sort()\n     Ks.sort()\n     bad = 0\n \n     Ns1 = Ns[:]\n     Ks1 = Ks[:]\n     while Ns1:\n         mlgek = Ks1.pop()\n         if Ns1[-1]>mlgek:\n             hdvsg = findmin(Ns1,mlgek)\n             Ns1[hdvsg:hdvsg+1]=[]\n             bad += 1\n         else:\n             Ns1[:1] = []\n \n     good = 0\n     Ns2 = Ns[:]\n     Ks2 = Ks[:]\n     for amqev in Ns2:\n         if Ks2[-1]>amqev:\n             hdvsg = findmin(Ks2,amqev)\n             Ks2[hdvsg:hdvsg+1]=[]\n         else:\n             Ks2[:1]=[]\n             good += 1\n \n     print("Case #",case,": ",bad,' ',good,sep = '')\n
j4b	<>	26	<>	2012_1460488_1595491.py	<>	#!/usr/bin/python\n \n import sys\n import functools\n import operator\n \n \n def solve(zbkdu, eiwxc, rzwdt):\n     ayqup = 0\n     u = 0\n     for t in rzwdt:\n         a = int(t/3)\n         r = t % 3\n         if a+1 >= eiwxc and not r == 0:\n             u += 1\n         elif a >= eiwxc and r == 0:\n             u += 1\n         elif a > 0 and a+1 >= eiwxc and r == 0:\n             ayqup += 1\n         elif a+2 >= eiwxc and r == 2:\n             ayqup += 1\n \n     return min(zbkdu, ayqup) + u\n         \n         \n \n def main():\n     N = int(sys.stdin.readline()) # number of testcases\n     for i in range(N):\n         line = [int(x) for x in sys.stdin.readline().split()]\n         zbkdu = line[1]\n         eiwxc = line[2]\n         rzwdt = line[3:]\n         result = solve(zbkdu, eiwxc, rzwdt)\n         print ("Case #%ayqup: %s" % (i+1, result))\n \n \n if __name__ == '__main__':\n     main()\n
j4b	<>	26	<>	2014_2974486_5644738749267968.py	<>	#!/usr/bin/python\n \n import sys\n import functools\n import operator\n import math\n from itertools import chain, combinations\n from heapq import heappop, heappush, _siftup\n \n def solveWar(umxyo, anfkh):\n     gveto = sorted(umxyo)\n     rfdvx = sorted(anfkh)\n     score = 0\n     \n     # while gveto:\n     #     w = gveto.pop(0)\n     #     res = [kweight for kweight in rfdvx if kweight > w]\n     #     if res:\n     #         rfdvx.remove(min(res))\n     #     else:\n     #         score += len(gveto) + 1\n     #         break\n \n     for w in gveto:\n         while rfdvx and rfdvx[0] < w:\n             rfdvx.pop(0)\n             score += 1\n \n         if not rfdvx:\n             break\n         else:\n             rfdvx.pop(0)\n             \n     return score\n \n def solveDWar(umxyo, anfkh):\n     gveto = sorted(umxyo)\n     rfdvx = sorted(anfkh)\n     score = 0\n \n     for w in gveto:\n         if w > rfdvx[0]:\n             score += 1\n             rfdvx.pop(0)\n         else:\n             rfdvx.pop(-1)\n     \n     return score\n \n def solve(gveto, rfdvx):\n     return ("%s %s" % (solveDWar(gveto, rfdvx), solveWar(gveto, rfdvx)))\n \n def main():\n     N = int(sys.stdin.readline()) # number of testcases\n     for i in range(N):\n         sys.stdin.readline()\n         gveto = [float(x) for x in sys.stdin.readline().rstrip().split()]\n         rfdvx = [float(x) for x in sys.stdin.readline().rstrip().split()]\n \n         result = solve(gveto, rfdvx)\n         print ("Case #%s: %s" % (i+1, result))\n \n if __name__ == '__main__':\n     main()\n
anavaleije	<>	27	<>	2012_1460488_1595491.py	<>	cbjok = file("input.in")\n xbhjd = eval(cbjok.readline())\n gsnrk = file("output.txt", "w")\n \n for fiyut in xrange(xbhjd):\n \n 	cpgjk = cbjok.readline()\n 	cpgjk = cpgjk.strip()\n 	cpgjk = cpgjk.split(" ")\n \n 	n = eval(cpgjk[0])\n 	s = eval(cpgjk[1])\n 	p = eval(cpgjk[2])\n \n 	scores = []\n 	n_googlers_with_best_result = 0\n 	candidates = 0\n \n 	for j in cpgjk[3:]:\n 		i = eval(j)\n 		if i%3 == 0:\n 			score = i/3\n 			scores.append([score, score, score])\n 		elif (i+1)%3 == 0:\n 			score = (i+1)/3\n 			scores.append([score-1, score, score])\n 		else: #(i+2)%3 == 0\n 			score = (i+2)/3\n 			scores.append([score-1, score-1, score])\n \n 	for score in scores:\n 		if score[2] >= p:\n 			n_googlers_with_best_result +=1\n 		elif score[2] + 1 == p and score[1] == score[2] and score[2] != 0:\n 			candidates += 1\n \n 	n_googlers_with_best_result = n_googlers_with_best_result + min(s, candidates)\n \n 	gsnrk.write("Case #%d: %d\n" % (fiyut+1, n_googlers_with_best_result))\n
anavaleije	<>	27	<>	2014_2974486_5644738749267968.py	<>	import sys\n \n def pointsWar(uikjp, xoesc, qyanm):\n 	otnfp = 0\n 	padog = 0\n 	tvckh = 0\n 	while padog < qyanm and tvckh < qyanm:\n 		if uikjp[padog] > xoesc[tvckh]:\n 			otnfp += 1\n 		else:\n 			padog += 1\n 		tvckh += 1\n 	return otnfp\n \n def pointsDeceitfulWar(uikjp, xoesc, qyanm):\n 	otnfp = qyanm\n 	padog = 0\n 	tvckh = 0\n 	while padog < qyanm and tvckh < qyanm:\n 		if uikjp[padog] > xoesc[tvckh]:\n 			tvckh += 1\n 		else:\n 			otnfp -= 1\n 		padog += 1\n 	return otnfp\n \n ##########################################################\n # Main\n \n droly = sys.argv[1]\n \n f = file(droly)\n fout = file("output.txt", "w")\n \n T = int(f.readline())\n \n for case in xrange(T):\n 	qyanm = int(f.readline().strip())\n 	uikjp = f.readline().strip().split()\n 	xoesc = f.readline().strip().split()\n \n 	for i in xrange(qyanm):\n 		uikjp[i] = (float(uikjp[i]),"N")\n 		xoesc[i] = (float(xoesc[i]),"K")\n \n 	uikjp.sort()\n 	xoesc.sort()\n \n 	##### Output writing\n 	fout.write("Case #%d: %d %d\n" %(case + 1, pointsDeceitfulWar(uikjp, xoesc, qyanm), pointsWar(uikjp, xoesc, qyanm)))\n
netsuso	<>	28	<>	2012_1460488_1595491.py	<>	#!/usr/bin/python3\n \n import sys\n import math\n \n def findbest(ofdka):\n 	# Corner case\n 	if ofdka == 0: return (0, 0)\n \n 	uipad = math.ceil(ofdka / 3)\n 	fgtrk = round(ofdka / 3) + 1\n \n 	return (uipad, fgtrk)\n 	\n # Ignore the number of cases\n sys.stdin.readline()\n \n skarw = 0\n for zrktm in sys.stdin:\n 	skarw += 1\n \n 	data = zrktm.strip().split(' ')\n 	maxsurprising = int(data[1])\n 	p = int(data[2])\n 	scores = data[3:]\n 	maxgooglers = 0\n \n 	for s in scores:\n 		(uipad, fgtrk) = findbest(int(s))\n 		if uipad >= p:\n 			maxgooglers += 1\n 		else:\n 			if fgtrk >= p and maxsurprising > 0:\n 				maxgooglers += 1\n 				maxsurprising -= 1\n \n 	print("Case #%d: %d" % (skarw, maxgooglers))\n
netsuso	<>	28	<>	2014_2974486_5644738749267968.py	<>	#!/usr/bin/python3\n # Strategies:\n # 0. Sort both lists of block weights\n # Deceitful War:\n # 1. Walk through her own blocks from the lightest to the heaviest one\n # 2. If the block is lighter than the lightest one from Ken, Naomi will tell a weight slightly lower than Ken's biggest one. So Ken wins, but he loses his heaviest block\n # 3. If the block is heavier than the lightest one from Ken, Naomi will tell a weight slightly higher than Ken's heaviest block. So Naomi wins, and Ken loses his lightest block\n # Standard War:\n # 1. Walk through her own blocks from the heaviest to the lightest one (there's no difference in the order for the result, but this way it's easier to compare)\n # 2. If the block is heavier than the heaviest one from Ken, Naomi wins, and Ken loses his lightest block\n # 3. If the block is lighter than the heaviest one from Ken, Ken wins, and Ken loses his heaviest block\n \n import sys\n \n ilpvs = int(sys.stdin.readline().strip())\n \n for teqog in range(1, ilpvs+1):\n     unvre = int(sys.stdin.readline().strip())\n     kgjfw = [float(x) for x in sys.stdin.readline().strip().split()]\n     ken_blocks = [float(x) for x in sys.stdin.readline().strip().split()]\n \n     kgjfw.sort()\n     ken_blocks.sort()\n \n     # Deceitful War\n     ken_lightest = 0\n     ken_heaviest = unvre-1\n     points_deceitful = 0\n \n     for i in range(0, unvre):\n         if kgjfw[i] > ken_blocks[ken_lightest]:\n             points_deceitful += 1\n             ken_lightest += 1\n         else:\n             ken_heaviest -= 1\n \n     # Standard War\n     ken_lightest = 0\n     ken_heaviest = unvre-1\n     points_standard = 0\n \n     for i in range(unvre-1, -1, -1):\n         if kgjfw[i] > ken_blocks[ken_heaviest]:\n             points_standard += 1\n             ken_lightest += 1\n         else:\n             ken_heaviest -= 1\n \n     print("Case #{0}: {1} {2}".format(teqog, points_deceitful, points_standard))\n
binnie	<>	29	<>	2012_1460488_1595491.py	<>	import sys\n \n rtfwu = open(sys.argv[1])\n esvux = int(rtfwu.readline())\n for qlsek in range(esvux):\n     bednz = map(int, rtfwu.readline().split())\n     amxzj = bednz[0]\n     xfvwr = bednz[1]\n     sregq = bednz[2]\n     scores = bednz[3:]\n     non_surprising_scores = len(filter(lambda x: x >= (3*sregq-2), scores))\n     if (sregq<=1):\n         surprising_scores = 0\n     else:\n         surprising_scores = len(filter(lambda x: (x >= (3*sregq-4) and x < (3*sregq-2)), scores))\n     num_scores = non_surprising_scores + min(surprising_scores, xfvwr)   \n     print "Case #%d:" % (qlsek + 1), num_scores\n
binnie	<>	29	<>	2014_2974486_5644738749267968.py	<>	import sys\n \n otzfr = open(sys.argv[1])\n sqmre = int(otzfr.readline())\n for qrpgz in range(sqmre):\n     fogmr = int(otzfr.readline())\n     naomi_blocks = map(float, otzfr.readline().strip().split(" "))\n     ken_blocks = map(float, otzfr.readline().strip().split(" "))\n     naomi_blocks.sort()\n     ken_blocks.sort()\n     naomi_clone = list(naomi_blocks)\n     ken_clone = list(ken_blocks)\n \n     naomi_standard_score = 0\n     while naomi_blocks != []:\n         naomi_new_val = naomi_blocks.pop()\n         if naomi_new_val > ken_blocks[-1]:\n             naomi_standard_score += 1\n             ken_blocks.pop(0)\n         else:\n             ii = 0\n             while ken_blocks[ii] < naomi_new_val:\n                 ii += 1\n             ken_blocks.pop(ii)\n \n     assert(ken_blocks == [])\n \n     naomi_blocks = naomi_clone\n     ken_blocks = ken_clone\n     naomi_blocks.sort(reverse=True)\n     ken_blocks.sort(reverse=True)\n     deceiving_strat_score = 0\n     while naomi_blocks != []:\n         naomi_new_val = naomi_blocks.pop()\n         if naomi_new_val > ken_blocks[-1]:\n             ken_blocks.pop()\n             deceiving_strat_score += 1\n \n     print "Case #%d: " % (qrpgz + 1), deceiving_strat_score, naomi_standard_score\n \n \n \n
amv	<>	30	<>	2012_1460488_1595491.py	<>	#!/usr/bin/env python\n import sys\n import numpy as np\n \n pcdvq=open(sys.argv[1],'r')\n \n rsyap=int(pcdvq.readline())\n \n for azkye in xrange(rsyap):\n     efzti=[ int(qlbmf) for qlbmf in pcdvq.readline().split() ]\n \n     n=efzti.pop(0)\n     s=efzti.pop(0)\n     p=efzti.pop(0)\n \n     scores=efzti\n     assert(len(scores))==n\n \n     imax=0\n     isurprise=0\n \n     for score in scores:\n         if score<p: continue\n         if score<3*p-4:\n             pass\n         elif 3*p-2>score>=3*p-4:\n             isurprise+=1\n         else:\n             imax+=1\n \n     print 'Case #'+str(azkye+1)+':',imax+min(isurprise,s)\n \n
amv	<>	30	<>	2014_2974486_5644738749267968.py	<>	#!/usr/bin/env python\n import sys,os\n import numpy as np\n \n \n def Solve(rlkje,dulxz,uqoem):\n     dulxz.sort(reverse=True)\n     uqoem.sort(reverse=True)\n     astqd=0\n     msfaw,kjxnp=0,0\n     while msfaw<rlkje and kjxnp<rlkje:\n         if dulxz[msfaw]>uqoem[kjxnp]:\n             astqd+=1\n             msfaw+=1\n             kjxnp+=1\n         else:\n             kjxnp+=1\n \n     yjwul=0\n     msfaw,kjxnp=0,0\n     while msfaw<rlkje and kjxnp<rlkje:\n         if dulxz[msfaw]<uqoem[kjxnp]:\n             yjwul+=1\n             msfaw+=1\n             kjxnp+=1\n         else:\n             msfaw+=1\n \n     yjwul=rlkje-yjwul\n     return '%d %d'%(astqd,yjwul)\n \n \n \n def parse(infile):\n     rlkje=int(infile.readline().strip())\n     dulxz=map(float, infile.readline().split() )\n     uqoem=map(float, infile.readline().split() )\n     return rlkje,dulxz,uqoem\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n \n     #Open output file, but don't overwrite old ones (for comparison)\n     outname=sys.argv[1].rstrip('.in')+'.out'\n     if os.path.isfile(outname):\n         oldout=outname+'.old'\n         ii=0\n         while os.path.isfile(oldout):\n             ii+=1\n             oldout=outname+'.old'+str(ii)\n         os.rename(outname,oldout)\n         print 'Rename: %s -> %s'%(outname,oldout)   \n  \n     outfile=open(outname,'w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n if __name__=='__main__':\n     runmain()\n
imakaramegane	<>	31	<>	2012_1460488_1595491.py	<>	# coding:utf-8\n import sys\n \n def testcases():\n     with open(sys.argv[1], "r") as f:\n         f.readline()  # skip number of testcases\n         for cajyq, zbrcm in enumerate(f, 1):\n             yield cajyq, [int(kdnew) for kdnew in zbrcm.split()]\n \n def main():\n     for cajyq, zbrcm in testcases():\n         tjbfd = zbrcm[0]   # the number of Googlers\n         S = zbrcm[1]   # the number of surprising triplets of scores\n         p = zbrcm[2]   # best result of at least\n \n         y = 0\n \n         for kdnew in zbrcm[3:]:\n             d, m = divmod(kdnew, 3)\n             if m == 0:\n                 if p <= d:\n                     y += 1\n                 elif 0 <= d - 1 <= p <= d + 1 <= 10 and S:\n                     y += 1\n                     S -= 1\n             elif m == 1:\n                 if p <= d + 1:\n                     y += 1\n             else:\n                 if p <= d + 1:\n                     y += 1\n                 elif p <= d + 2 and S:\n                     y += 1\n                     S -= 1\n \n         print("Case #{:d}: {:d}".format(cajyq, y))\n \n if __name__=="__main__":\n     main()\n
imakaramegane	<>	31	<>	2014_2974486_5644738749267968.py	<>	# coding: utf-8\n import sys\n import os.path\n import itertools\n from itertools import groupby\n import math\n \n def debug(hagor):\n     pass#print(hagor)\n \n def read(nxzdm):\n     rgqdi = tuple(int(hagor) for hagor in nxzdm.readline().split())\n     debug(rgqdi)\n     return rgqdi\n \n def readf(nxzdm):\n     rgqdi = tuple(float(hagor) for hagor in nxzdm.readline().split())\n     debug(rgqdi)\n     return rgqdi\n \n def answer(nxzdm, lfvzm, Y, Z):\n     out = "Case #{}: {} {}".format(lfvzm, Y, Z)\n     nxzdm.write(out)\n     nxzdm.write("\n")\n     print(out)\n \n \n \n def main(inf, outf):\n     T, = read(inf)\n     for casenmbr in range(1, T + 1):\n         N = read(inf)\n         naomi_blks = sorted(readf(inf))\n         ken_blks = sorted(readf(inf))\n         # print("------")\n         # print(naomi_blks)\n         # print(ken_blks)\n \n         y = len([None for naomi in naomi_blks if ken_blks[0] < naomi])\n \n         z = 0\n         for naomi in naomi_blks:\n             for i in range(len(ken_blks)):\n                 if naomi < ken_blks[i]:\n                     del ken_blks[i]\n                     break\n             else:\n                 z += 1\n                 del ken_blks[0]\n \n         answer(outf, casenmbr, y, z)\n \n \n if __name__=="__main__":\n     infname = sys.argv[1]\n     outfname = os.path.splitext(infname)[0] + ".out"\n     with open(infname, "r") as inf:\n         with open(outfname, "w") as outf:\n             main(inf, outf)\n
eko	<>	32	<>	2012_1460488_1595491.py	<>	import sys, os\n import re\n \n wefgq = int(sys.stdin.readline())\n \n def alien(agvyb,kamrf):\n 	\n 	kamrf = kamrf.replace('(','[')\n 	kamrf = kamrf.replace(')',']')\n 	#print agvyb,kamrf\n 	\n 	sdiea = re.compile(kamrf, re.I)\n 	count = 0\n 	for frase in agvyb:\n 		#print sdiea.search(frase)\n 		if sdiea.search(frase):\n 			count += 1\n 	return count\n \n \n for i in xrange(wefgq):	\n 	linha = sys.stdin.readline().split()\n 	#S = linha[0]\n 	P = int(linha[1])\n 	T = int(linha[2])\n 	list = []\n 	for j in range (3,len(linha)):\n 		list.append(int(linha[j]))\n 	list.sort(reverse=True)\n 	#print S,P,T,list\n 	realT = T*3 - 2\n 	supT = realT - 2\n 	\n 	count = 0\n 	for item in list:\n 		if item >= realT:\n 			count += 1\n 		elif P > 0 and item >= supT and T >= 2:\n 			count += 1\n 			P -= 1\n 		elif P > 0 and item >= realT and T == 1:\n 			count += 1\n 			P -= 1\n 		elif T == 0:\n 			count += 1\n 		else:\n 			break\n 		\n 	#kamrf.append(frase)\n 	print "Case #%d: %d" % (i+1, count)\n 	\n 	\n \n
eko	<>	32	<>	2014_2974486_5644738749267968.py	<>	import os, re, sys\n import unittest\n \n \n #gjmdh = sys.stdin.readline().split()\n gjmdh = int(sys.stdin.readline())\n \n def ken(chzjp, vnzyt):\n 	for kdntv in vnzyt:\n 		if kdntv >= chzjp:\n 			vnzyt.remove(kdntv)\n 			return kdntv, vnzyt\n 	\n 	vfuoh = vnzyt[0]\n 	vnzyt.remove(vfuoh)\n 	return vfuoh, vnzyt\n 	\n def naomi(YList, ZList):\n 	l1 = vnzyt(YList)\n 	l2 = vnzyt(ZList)\n 	\n 	while len(l1) > 0:\n 		cy = l1.pop()\n 		cz = l2.pop()\n \n 		if (cy < cz):\n 			#if len(l2) > 0:\n 				return YList[0], ZList[len(ZList)-1]\n 			#else:\n 			#	return cz, cy\n 		\n 	return YList[len(YList)-1], ZList[len(ZList)-1]\n 		\n def main(YList, ZList):\n 	dnp = 0\n 	np = 0\n 	#YList.sort(reverse=True)\n 	YList.sort()\n 	ZList.sort()\n 	\n 	YList2 = vnzyt(YList)\n 	ZList2 = vnzyt(ZList)\n 	\n 	YList.sort()\n 	#print YList\n 	#print ZList\n 	\n 	while len(YList) > 0:\n 		cy, ty = naomi(YList, ZList)\n 		YList.remove(cy)		\n 		cz, ZList = ken(ty, ZList)\n 	#	print cy, ty,  cz\n 		if (cy > cz):\n 			dnp += 1\n 			\n 	while len(YList2) > 0:\n 		cy = YList2.pop()\n 		cz, ZList2 = ken(cy, ZList2)\n 		#print cy, cz\n 		if (cy > cz):\n 			np += 1\n 			\n 			\n 	\n \n 	return str(dnp) + " " + str(np)\n 		\n  \n if __name__ == '__main__':\n 	#unittest.main()\n 	for kdntv in xrange(gjmdh):	\n 		#frase = [str(vfuoh) for vfuoh in sys.stdin.readline().split(' ')]	\n 		#print "Case #%d: %s" % (kdntv + 1, main(frase[0]))\n 		\n 		##Numbers\n 		N = [int(vfuoh) for vfuoh in sys.stdin.readline().split(' ')]\n 		YList = [float(vfuoh) for vfuoh in sys.stdin.readline().split(' ')]\n 		ZList = [float(vfuoh) for vfuoh in sys.stdin.readline().split(' ')]\n 		#print E,R,N, NList\n 		print "Case #%d: %s" % (kdntv + 1, main(YList, ZList))
cheilman	<>	33	<>	2012_1460488_1595491.py	<>	#!/usr/bin/python\n \n def readfile(niydu):\n 	"""\n 		The first line of the input gives the number of test\n 		cases, yzncf. yzncf test cases follow. Each test case consists of\n 		a single line containing integers separated by single\n 		spaces. The first integer will be N, the number of\n 		Googlers, and the second integer will be S, the number\n 		of surprising triplets of scores. The third integer will\n 		be p, as described above. Next will be N integers ti:\n 		the total points of the Googlers.\n 	"""\n \n 	atmdc = open(niydu, "rt")\n \n 	rmlad = {}\n \n 	yzncf = int(atmdc.readline().strip())\n 	rmlad['T'] = yzncf\n \n 	cmvfb = []\n \n 	for zidrv in xrange(yzncf):\n 		line = atmdc.readline().strip()\n \n 		parts = line.split(" ")\n \n 		N = int(parts[0])\n 		S = int(parts[1])\n 		p = int(parts[2])\n 		t = []\n \n 		for j in xrange(N):\n 			t = t + [int(parts[3 + j]), ]\n \n 		test = { 'N' : N, 'S': S, 'p' : p, 't' : t }\n 		cmvfb = cmvfb + [test, ]\n \n 	rmlad['tests'] = cmvfb\n 	return rmlad\n \n def spread(triplet):\n 	return max(abs(triplet[0] - triplet[1]), abs(triplet[1] - triplet[2]), abs(triplet[2] - triplet[0]))\n \n def bestresult(triplet):\n 	if triplet:\n 		return max(triplet)\n 	return 0\n \n def getcombos(points):\n 	"""\n 		Returns ([unsurprising possibilities, ], [surprising possibilities])\n 	"""\n \n 	unsurps = []\n 	surps = []\n \n 	avg = points / 3.0\n \n 	# Go from (avg-2) to (avg+3) to account for rounding\n 	avg = int(avg)\n \n 	tested = []\n \n 	for zidrv in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n 		for j in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n 			for k in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n 				if (zidrv + j + k) != points:\n 					continue\n \n 				scores = (zidrv,j,k)\n 				scores = sorted(scores)\n \n 				if scores in tested:\n 					continue\n 				tested.append(scores)\n \n 				s = spread((zidrv,j,k))\n \n 				if (s < 2):\n 					unsurps.append(scores)\n 				elif (s == 2):\n 					surps.append(scores)\n 				else:\n 					continue\n \n 	return (unsurps, surps)\n \n def getbesttriplet(triplets):\n 	best = None\n \n 	for zidrv in triplets:\n 		if best:\n 			if (bestresult(zidrv) > bestresult(best)):\n 				best = zidrv\n 		else:\n 			best = zidrv\n \n 	return best\n 	\n \n def getmulticombos(peeps):\n 	"""\n 		Return the best surprising and non-surprising possibility for\n 		each person.\n 	"""\n \n 	ret = []\n \n 	for p in peeps:\n 		u,s = getcombos(p)\n \n 		bestu = getbesttriplet(u)\n 		bests = getbesttriplet(s)\n \n 		ret.append((bestu, bests))\n \n 	return ret\n \n def getbestresults(scores, best, numsur):\n 	"""\n 		Figure out the maximum number of people that could have gotten\n 		a single score >= best.  Limited to choosing only numsur surprising\n 		triplets.\n 	"""\n \n 	peeps = getmulticombos(scores)\n \n 	count = 0\n 	surcount = 0\n \n 	for p in peeps:\n 		if (bestresult(p[0]) >= best):\n 			# unsurprising is good\n 			count = count + 1\n 		elif ((bestresult(p[1]) >= best) and (surcount < numsur)):\n 			count = count + 1\n 			surcount = surcount + 1\n \n 	return count\n \n def process(test):\n 	N = test['N']\n 	S = test['S']\n 	p = test['p']\n 	t = test['t']\n \n 	return getbestresults(t, p, S)\n \n data = readfile("B-small-attempt0.in")\n \n for zidrv in xrange(data['T']):\n 	test = data['tests'][zidrv]\n \n 	result = process(test)\n \n 	print "Case #%d: %d" % (zidrv+1, result)\n
cheilman	<>	33	<>	2014_2974486_5644738749267968.py	<>	#!/usr/bin/python\n \n import sys\n \n import puzutils\n \n class War_2014_QD(puzutils.CodeJamProblem):\n   def __init__(ynkxj, lzvmw):\n     puzutils.CodeJamProblem.__init__(ynkxj, lzvmw)\n \n     ynkxj.frhgs = None\n \n   def load(ynkxj):\n     """\n       input:\n \n       frhgs (number of test cases)\n \n       N (number of blocks)\n       N1 N2 N3 ... (mass of Naomi's blocks, real)\n       K1 K2 K3 ... (mass of Ken's blocks, real)\n \n     """\n \n     ynkxj.pluji = []\n \n     with open(ynkxj.lzvmw, "rt") as file:\n       ynkxj.frhgs = int(file.readline().strip())\n \n       for zlefy in xrange(ynkxj.frhgs):\n         N = int(file.readline().strip())\n         naomi = [float(x) for x in file.readline().split(' ')]\n         ken = [float(x) for x in file.readline().split(' ')]\n \n         test = {'N': N, 'Naomi': naomi, 'Ken': ken}\n \n         ynkxj.pluji.append(test)\n \n     return True\n \n   def playWar(ynkxj, naomi, ken):\n     """\n       How many points does naomi get when playing standard War?\n     """\n \n     if (len(naomi) <= 0):\n       return 0\n \n     # Just choose the biggest?\n     maxN = max(naomi)\n \n     # Can ken win?\n     maxK = max(ken)\n \n     if maxK > maxN:\n       # Ken uses the smallest one that will beat her\n       k = min([x for x in ken if x > maxN])\n \n       #print "Ken wins (%.3f > %.3f), max %.3f" % (k, maxN, maxK)\n \n       naomi.remove(maxN)\n       ken.remove(k)\n \n       return 0 + ynkxj.playWar(naomi, ken)\n     else:\n       # Ken loses his smallest\n       k = min(ken)\n \n       #print "Ken loses (%.3f < %.3f), max %.3f" % (k, maxN, maxK)\n \n       naomi.remove(maxN)\n       ken.remove(k)\n \n       return 1 + ynkxj.playWar(naomi, ken)\n \n   def playDWar(ynkxj, naomi, ken):\n     """\n       How many points does naomi get when playing decietful war?\n     """\n \n     if (len(naomi) <= 0):\n       return 0\n \n     minN = min(naomi)\n     minK = min(ken)\n     maxK = max(ken)\n \n     if (minN < minK):\n       # This is a guaranteed loser, take a big one down with it\n       naomi.remove(minN)\n       ken.remove(maxK)\n       return 0 + ynkxj.playDWar(naomi, ken)\n \n     # Use our smallest one to beat his smallest one, by lying and\n     # saying ours is bigger than his biggest\n     naomi.remove(minN)\n     ken.remove(minK)\n     return 1 + ynkxj.playDWar(naomi, ken)\n \n   def executeTest(ynkxj, test):\n     """\n       Run a test and return output.\n     """\n \n     dwar = ynkxj.playDWar(list(test['Naomi']), list(test['Ken']))\n     war = ynkxj.playWar(list(test['Naomi']), list(test['Ken']))\n     return "%d %d" % (dwar, war)\n \n with War_2014_QD(sys.argv[1]) as problem:\n   problem.load()\n \n   problem.run()\n
mth	<>	34	<>	2012_1460488_1595491.py	<>	#!/usr/bin/env python\n \n layeq = 'B-small-attempt0'\n jtwbn = 0\n \n def parse(edwvz):\n 	fqlkc = tuple(int(x) for x in edwvz.readline().split())\n 	dancers, surprises, points = fqlkc[ : 3]\n 	totals = fqlkc[3 : ]\n 	assert len(totals) == dancers\n 	return totals, surprises, points\n \n def totalAtDist():\n 	'''\n 	If a dancer's best result is b, the total can be:\n 	  distance 0: 3b\n 	  distance 1: [3b-2..3b-1]\n 	  distance 2: [3b-4..3b-2]\n 	Note: distance d is only possible if d <= b.\n \n 	total 15:\n 	b = 0..4:  impossible\n 	b = 5:     dist = 0\n 	b = 6:     dist = 2\n 	b = 7..10: impossible\n \n 	For every total we have a number of explanations, which are\n 	(b, d) pairs where b is the best result and d is the distance.\n \n 	The output of this function shows:\n \n 	Except for 0, 1, 29 and 30, every total t has exactly 2 explanations:\n 	  ((t+2) div 3, 0|1)  and  ((t+4) div 3, 2)\n 	In other words, always one surprise option and one normal option.\n 	The surprise option can have a result one higher than the normal one or\n 	equal to it.\n 	'''\n \n 	print '  ',\n 	for b in xrange(0, 11):\n 		print 'b=%d' % b,\n 	print\n 	for total in xrange(0, 31):\n 		print '%2d' % total,\n 		for b in xrange(0, 11):\n 			s = '0' if total == b * 3 else '.'\n 			s += '1' if b >= 1 and b * 3 - 2 <= total <= b * 3 - 1 else '.'\n 			s += '2' if b >= 2 and b * 3 - 4 <= total <= b * 3 - 2 else '.'\n 			print s,\n 		print\n \n #totalAtDist()\n \n def solve(totals, surprises, points):\n 	countCertain = 0\n 	countSurprise = 0\n 	for total in totals:\n 		if (total + 2) / 3 >= points:\n 			# A non-surprising score has a best result >= p.\n 			countCertain += 1\n 		elif 2 <= total <= 28 and (total + 4) / 3 >= points:\n 			# Only a surprising score has a best result >= p.\n 			countSurprise += 1\n 		else:\n 			# The best result cannot be >= p.\n 			pass\n \n 	# Replacing a non-surprise interpretation of a total by a surprise\n 	# interpretation is always possible for totals in [2..28] and will never\n 	# lower the best result, so it will not put a score in a different\n 	# category. Therefore, it is always possible to assign leftover surprise\n 	# slots to dancers without changing the outcome.\n \n 	return countCertain + min(countSurprise, surprises)\n \n if __name__ == '__main__':\n 	edwvz = open(layeq + '.in.txt', 'r')\n 	numCases = int(edwvz.readline())\n 	if jtwbn == 0:\n 		results = [\n 			solve(*parse(edwvz))\n 			for _ in range(numCases)\n 			]\n 	else:\n 		from multiprocessing import Pool\n 		pool = Pool(jtwbn)\n 		results = [\n 			pool.apply_async(solve, parse(edwvz))\n 			for _ in range(numCases)\n 			]\n 	edwvz.close()\n 	out = open(layeq + '.out.txt', 'w')\n 	for case, result in enumerate(results):\n 		value = result if jtwbn == 0 else result.get()\n 		out.write('Case #%d: %s\n' % (case + 1, value))\n 		out.flush()\n 	out.close()\n
mth	<>	34	<>	2014_2974486_5644738749267968.py	<>	#!/usr/bin/env python\n \n hjovz = 'D-small-attempt0'\n ywxpz = 0\n pkdif = 1.5 # per worker process\n ktowg = 1000\n \n from itertools import chain\n \n def parse(hczlj):\n 	cdbxp, = (int(x) for x in hczlj.readline().split())\n 	naomiBlocks = tuple(sorted(float(x) for x in hczlj.readline().split()))\n 	kenBlocks = tuple(sorted(float(x) for x in hczlj.readline().split()))\n 	assert len(naomiBlocks) == cdbxp\n 	assert len(kenBlocks) == cdbxp\n 	return naomiBlocks, kenBlocks\n \n def solve(naomiBlocks, kenBlocks):\n 	cdbxp = len(naomiBlocks)\n \n 	# greedy strategy for honest play:\n 	# play the block that is heavier by the smallest margin (if you have one)\n 	# ('honest' meaning sticking to the rules; 'fair' is something else)\n 	kenPointsHonest = 0\n 	naomiLowerBlocks = 0\n 	for _, owner in sorted(chain(\n 			((b, 'n') for b in naomiBlocks),\n 			((b, 'k') for b in kenBlocks)\n 			)):\n 		if owner == 'n':\n 			naomiLowerBlocks += 1\n 		elif naomiLowerBlocks != 0:\n 			naomiLowerBlocks -= 1\n 			kenPointsHonest += 1\n 	naomiPointsHonest = cdbxp - kenPointsHonest\n \n 	# strategy for deceitful play:\n 	# moves:\n 	# + lie and win:\n 	#   when Ken can't match the told number, he'll play his lightest block\n 	#   so you can lie and win if you play a block heavier than his lightest\n 	# + lie and lose:\n 	#   name a weight just below Ken's heaviest block, forcing him to play that\n 	# - truth and win:\n 	#   when you play a block that is actually heavier than anything Ken has\n 	#   is just a special case of lie and win\n 	# - truth and lose:\n 	#   never optimal\n 	# optimal order of play:\n 	#   always play your lightest block: if it can't win now, it can never win\n 	#   in the future either, nor can it be more effective in the future than\n 	#   pulling his current heaviest block\n 	naomiLoIdx = 0\n 	naomiHiIdx = cdbxp - 1\n 	kenLoIdx = 0\n 	kenHiIdx = cdbxp - 1\n 	naomiPointsDeceit = 0\n 	while naomiLoIdx <= naomiHiIdx:\n 		assert naomiHiIdx - naomiLoIdx == kenHiIdx - kenLoIdx\n 		naomiLo = naomiBlocks[naomiLoIdx]\n 		#naomiHi = naomiBlocks[naomiHiIdx]\n 		kenLo = kenBlocks[kenLoIdx]\n 		#kenHi = kenBlocks[kenHiIdx]\n 		if naomiLo > kenLo:\n 			naomiPointsDeceit += 1\n 			kenLoIdx += 1\n 		else:\n 			kenHiIdx -= 1\n 		naomiLoIdx += 1\n \n 	#print naomiBlocks\n 	#print kenBlocks\n 	#print\n \n 	return '%d %d' % (naomiPointsDeceit, naomiPointsHonest)\n \n def main():\n 	import sys\n 	sys.setrecursionlimit(ktowg)\n \n 	import resource\n 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)\n 	resource.setrlimit(resource.RLIMIT_AS, (pkdif * 1024 ** 3, hard))\n \n 	hczlj = open(hjovz + '.in', 'r')\n 	numCases = int(hczlj.readline())\n 	if ywxpz == 0:\n 		results = [\n 			solve(*parse(hczlj))\n 			for _ in range(numCases)\n 			]\n 	else:\n 		from multiprocessing import Pool\n 		pool = Pool(ywxpz)\n 		results = [\n 			pool.apply_async(solve, parse(hczlj))\n 			for _ in range(numCases)\n 			]\n 	hczlj.close()\n 	out = open(hjovz + '.out', 'w')\n 	for case, result in enumerate(results):\n 		value = result if ywxpz == 0 else result.get()\n 		out.write('Case #%d: %s\n' % (case + 1, value))\n 		out.flush()\n 	out.close()\n \n if __name__ == '__main__':\n 	main()\n
jakab922	<>	35	<>	2012_1460488_1595491.py	<>	from sys import argv\n \n nfodv = [[], [], [(0, 0, 2)], [(0, 1, 2)], [(0, 2, 2)], [(1, 1, 3)], [(1, 2, 3)], [(1, 3, 3)], [(2, 2, 4)], [(2, 3, 4)], [(2, 4, 4)], [(3, 3, 5)], [(3, 4, 5)], [(3, 5, 5)], [(4, 4, 6)], [(4, 5, 6)], [(4, 6, 6)], [(5, 5, 7)], [(5, 6, 7)], [(5, 7, 7)], [(6, 6, 8)], [(6, 7, 8)], [(6, 8, 8)], [(7, 7, 9)], [(7, 8, 9)], [(7, 9, 9)], [(8, 8, 10)], [(8, 9, 10)], [(8, 10, 10)], [], []]\n fsqau = [[(0, 0, 0)], [(0, 0, 1)], [(0, 1, 1)], [(1, 1, 1)], [(1, 1, 2)], [(1, 2, 2)], [(2, 2, 2)], [(2, 2, 3)], [(2, 3, 3)], [(3, 3, 3)], [(3, 3, 4)], [(3, 4, 4)], [(4, 4, 4)], [(4, 4, 5)], [(4, 5, 5)], [(5, 5, 5)], [(5, 5, 6)], [(5, 6, 6)], [(6, 6, 6)], [(6, 6, 7)], [(6, 7, 7)], [(7, 7, 7)], [(7, 7, 8)], [(7, 8, 8)], [(8, 8, 8)], [(8, 8, 9)], [(8, 9, 9)], [(9, 9, 9)], [(9, 9, 10)], [(9, 10, 10)], [(10, 10, 10)]]\n \n rguym = open(argv[1], 'r')\n qlzit = int(rguym.readline().strip('\n'))\n for ivyeb in range(qlzit):\n 	svibe = 0\n 	surp_only = 0\n 	line = rguym.readline().strip('\n').split(' ')\n 	N = int(line[0]) # What for?\n 	S = int(line[1])\n 	p = int(line[2])\n 	ts = map(int, line[3:])\n 	for t in ts:\n 		if reduce(max, map(max, fsqau[t])) >= p:\n 			svibe += 1\n 		elif nfodv[t] != [] and reduce(max, map(max, nfodv[t])) >= p:\n 			surp_only += 1\n \n 	print "Case #%s: %s" % (ivyeb + 1, svibe + min(surp_only, S))
jakab922	<>	35	<>	2014_2974486_5644738749267968.py	<>	ambgz = int(raw_input().strip())\n \n for ytznv in xrange(ambgz):\n 	mqrls = int(raw_input().strip())\n 	nwdaf = sorted(map(float, raw_input().strip().split(' ')))\n 	# print "naomi: %s"  % nwdaf\n 	qkiep = sorted(map(float, raw_input().strip().split(' ')))\n 	# print "ken: %s" % qkiep\n \n 	war_score = mqrls\n 	np = 0\n 	kp = 0\n 	while np < mqrls and kp < mqrls:\n 		while kp < mqrls and nwdaf[np] >= qkiep[kp]:\n 			kp += 1\n 		if kp < mqrls:\n 			kp += 1\n 			np += 1\n 			war_score -= 1\n \n 	d_war_score = mqrls\n 	best = None\n 	for start_from in xrange(mqrls):\n 		j = 0\n 		good = True\n 		while start_from + j < mqrls:\n 			if qkiep[j] >= nwdaf[start_from + j]:\n 				good = False\n 				break\n 			j += 1\n 		if good:\n 			best = mqrls - start_from\n 			break\n 	if best is not None:\n 		d_war_score = best\n 	else:\n 		d_war_score = 0\n \n 	print "Case #%s: %s %s" % (ytznv + 1, d_war_score, war_score)\n
chevaliermalfet	<>	36	<>	2012_1460488_1595491.py	<>	isurn = open("B-small-attempt0 (3).in", 'r')\n guxrn = open("dancingOutSmall.txt", 'w')\n fqiak = int(isurn.readline())\n \n def countDancers(wqcrl,s,p,totals):\n     guaranteed = 0\n     needSurprise = 0\n     if p == 1:\n         for total in totals:\n             if total != 0:\n                 guaranteed += 1\n         return guaranteed\n     for total in totals:\n         if total >= p*3 - 2:\n             guaranteed += 1\n         elif total >= p*3 - 4:\n             needSurprise += 1\n     if needSurprise > s:\n         return guaranteed + s\n     else:\n         return guaranteed + needSurprise\n \n for i in range(fqiak):\n     line = isurn.readline().split()\n     wqcrl = int(line[0])\n     s = int(line[1])\n     p = int(line[2])\n     totals = []\n     for j in range(wqcrl):\n         totals += [int(line[3+j])]\n     guxrn.write('Case #' + str(i+1) + ': ' + str(countDancers(wqcrl,s,p,totals)) + '\n')\n \n guxrn.close()\n
chevaliermalfet	<>	36	<>	2014_2974486_5644738749267968.py	<>	aowjd = open('D-small-attempt0.in', 'r')\n itgza = aowjd.readlines()\n aowjd.close()\n \n qfdba = open('D-small-attempt0.out', 'w')\n \n piubc = int(itgza[0])\n \n def scoreWar(naomiNums, kenNums):\n     naomiInd = 0\n     kenInd = 0\n     while naomiInd < len(naomiNums):\n         naomiPlay = naomiNums[naomiInd]\n         while kenInd < len(kenNums) and kenNums[kenInd] < naomiPlay:\n             kenInd += 1\n         if kenInd == len(kenNums):\n             break\n         naomiInd += 1\n         kenInd += 1\n     return len(naomiNums) - naomiInd\n \n def scoreDeceit(naomiNums, kenNums):\n     naomiInd = 0\n     kenInd = 0\n     while kenInd < len(kenNums):\n         kenPlay = kenNums[kenInd]\n         while naomiInd < len(naomiNums) and naomiNums[naomiInd] < kenPlay:\n             naomiInd += 1\n         if naomiInd == len(naomiNums):\n             break\n         naomiInd += 1\n         kenInd += 1\n     return kenInd\n \n for i in range(1, piubc+1):\n     naomiNums = map(lambda x: float(x), itgza[3*i-1].split())\n     kenNums = map(lambda x: float(x), itgza[3*i].split())\n     naomiNums.sort()\n     kenNums.sort()\n     deceitScore = scoreDeceit(naomiNums, kenNums)\n     warScore = scoreWar(naomiNums, kenNums)\n     qfdba.write('Case #'+str(i)+': ' + str(deceitScore) + ' ' + str(warScore) + '\n')\n \n qfdba.close()\n
bigonion	<>	37	<>	2012_1460488_1595491.py	<>	qprfv = 'C:/users/hai/my projects/google code jam/2012/qualification/B/'\n \n \n def solve (mixqh, bptmn):\n     xpwuj = int(mixqh.readline())\n     print ('Test cases : ',xpwuj)\n     for ezfdt in range(1,xpwuj+1):\n         ztwdo = mixqh.readline()\n         mgkfl = [int(x) for x in ztwdo.split()]\n         S = mgkfl[1]\n         p = mgkfl[2]\n         t = mgkfl[3:]\n         if p > 1:\n             A = 0\n             B = 0\n             for t_i in t:\n                 if t_i >=3*p-2:\n                     A += 1\n                 elif t_i >= 3*p-4:\n                     B += 1\n             result = A + min(B,S)\n         if p == 1:\n             result = len([x for x in t if x>=1])\n         if p == 0:\n             result=  len(t)\n         bptmn.write('Case #' + str(ezfdt) + ': ' + str(result) + '\n')\n \n \n \n \n \n \n \n \n \n \n def main_run():\n     import os\n     filenames = [x for x in os.listdir (qprfv)]\n     filenames = [x for x in filenames if x.endswith('.in')]\n     l1 = [(os.stat(qprfv+x).st_ctime, x) for x in filenames]\n     chosen_filename =  sorted(l1)[-1][1][:-3]\n \n     print ('Directory : ', qprfv)\n     print ('Chosen Filename : ',chosen_filename)\n     print()\n     mixqh = open(qprfv+chosen_filename+'.in')\n     bptmn = open(qprfv+chosen_filename+'.out', 'w')\n     solve(mixqh,bptmn)\n     mixqh.close()\n     bptmn.close()\n \n \n \n \n main_run()\n
bigonion	<>	37	<>	2014_2974486_5644738749267968.py	<>	wexoh = 'C:/users/me/desktop/google code jam/2014/qualification/D/'\n \n from copy import deepcopy\n import itertools\n \n \n from random import choice\n \n mavud = 501\n jmcvy = 502\n aosig = 503\n \n def play_war (gvdjn, pgszm, inc_val):\n     assert inc_val in [mavud, jmcvy, aosig]\n     assert len(gvdjn) == len(pgszm)\n     if inc_val == mavud:\n         gvdjn = list(sorted(gvdjn))\n     if inc_val == jmcvy:\n         gvdjn = list(reversed(sorted(gvdjn)))\n     pgszm = list(sorted(pgszm))\n     naomi_wins = 0\n     for i in range(len(gvdjn)):\n         val = gvdjn[0]\n         gvdjn = gvdjn[1:]\n         if pgszm[-1] < val:\n             pgszm = pgszm[1:]\n             naomi_wins += 1\n         else:\n             for j in range(len(pgszm)):\n                 if pgszm[j] > val:\n                     del pgszm[j]\n                     break\n \n     return naomi_wins\n \n \n def play_deceitful (gvdjn, pgszm):\n     gvdjn = list(sorted(gvdjn))\n     pgszm = list(sorted(pgszm))\n     naomi_wins = 0\n     assert len(gvdjn) == len(pgszm)\n     while len(gvdjn):\n         if gvdjn[-1] < pgszm[-1]:\n             gvdjn = gvdjn[1:]\n             pgszm = pgszm[:-1]\n         else:\n             gvdjn = gvdjn[:-1]\n             pgszm = pgszm[:-1]\n             naomi_wins += 1\n     return naomi_wins\n             \n             \n def solve (f_in, f_out):\n     T = int(f_in.readline())\n     for testcase in range(1,T+1):\n         N = int(f_in.readline())\n         gvdjn = [float(x) for x in f_in.readline().split()]\n         pgszm = [float(x) for x in f_in.readline().split()]\n \n         a1 = play_war (gvdjn, pgszm, mavud)\n         a2 = play_war (gvdjn, pgszm, jmcvy)\n         a3 = play_war (gvdjn, pgszm, aosig)\n         assert a1 == a2\n         assert a2 == a3\n         b = play_deceitful (gvdjn, pgszm)\n \n         f_out.write('Case #' + str(testcase) + ': ' + str(b) + ' ' + str(a1) + '\n')\n \n \n         \n         \n \n     \n def main_run():\n     import os\n     import time\n     filenames = [x for x in os.listdir (wexoh)]\n     filenames = [x for x in filenames if x.endswith('.in')]\n     l1 = [(os.stat(wexoh+x).st_mtime, x) for x in filenames]\n     chosen_filename =  sorted(l1)[-1][1][:-3]\n \n     print ('Directory : ', wexoh)\n     print ('Chosen Filename : ',chosen_filename)\n     print()\n     print ('Start : ', time.ctime())\n     print()\n     \n     f_in = open(wexoh+chosen_filename+'.in')\n     f_out = open(wexoh+chosen_filename+'.out', 'w')\n     solve(f_in,f_out)\n     f_in.close()\n     f_out.close()\n \n     print ()\n     print ('End : ', time.ctime())\n \n \n main_run()\n \n def randomize_arrs (n):\n     l = []\n     for i in range(2*n):\n         r = choice(range(2**30))\n         while r in l:\n             r = choice(range(2**30))\n         l.append(r)\n     return l[:n], l[n:]\n \n
hannanaha	<>	38	<>	2012_1460488_1595491.py	<>	import math\n \n xtsrl = ".out"\n vqnot = "small.in"\n twbvz = "large.in"\n sndma = "Case #%s: "\n \n \n def avg(L):\n     return 1.0*sum(L)/len(L)\n \n triplets = [[0,0,0], [0,0,1], [0,1,1], \n             [0,0,2], [0,2,2], [0,1,2],\n             [10,10,9], [10,9,8], [10,9,9], [10, 10, 8],\n             ]\n \n def analyze_sum(sm, tgt):\n     av = 1.0 * sm / 3\n     av_cls = av % 1\n \n     #assume non surprising\n     if av_cls > 0.1:\n         ns_max_val = math.ceil(av)\n     else:\n         ns_max_val = av \n     \n     #assume surprising\n     s_max_val = 0 \n     if sm >= 2 and sm <= 28:\n         if av_cls > 0.5:\n             s_max_val = math.ceil(av) + 1\n         elif av_cls > 0.1:\n             s_max_val = math.ceil(av) \n         else:\n             s_max_val = av + 1\n     \n     if ns_max_val >= tgt:\n         res = [ns_max_val, None]\n         kind = 1\n     elif s_max_val < tgt:\n         res = [None, None]\n         kind = 0\n     else:\n         res = [None, s_max_val]\n         kind = 2\n         \n     print sm, tgt, av, av_cls, ns_max_val, s_max_val, res, kind\n     return res, kind\n \n def analyze_triplet(trip, tgt):\n     sm = sum(trip)\n     analyze_triplet(sm, tgt)\n     \n \n def read_input(filename):\n     data = []\n     with open(filename, "r") as f:\n         cases = int(f.readline())\n         for _ in xrange(cases):\n             case = f.readline().strip().split()\n             case = [int(c) for c in case]\n             data.append({"ngoog": case[0], "ssurp": case[1], "ptgt": case[2],\n                          "trips": case[3:]})\n     return data\n \n def make_output(fname, output):\n     fname = fname + xtsrl\n     with open(fname, "w") as f:\n         restext = []\n         for i, v in enumerate(output):\n             restext.append(sndma % (i+1,) + str(v) + "\n")\n         f.writelines(restext)\n     \n def main(fname):\n     data = read_input(fname)\n     output = []\n     for case in data:\n         ansys = [analyze_sum(c, case["ptgt"]) for c in case["trips"]]\n         non_surp_is_enough = len([k for _, k in ansys if k == 1])\n         surp_needed = len([k for _, k in ansys if k == 2])\n         if surp_needed >= case["ssurp"]:\n             res = non_surp_is_enough + case["ssurp"]\n         else:\n             res = non_surp_is_enough + surp_needed\n         output.append(res)\n     print "output:", output\n     make_output(fname, output)\n      \n \n main("examples.in")\n main("small.in")
hannanaha	<>	38	<>	2014_2974486_5644738749267968.py	<>	import os\n import time\n import decimal\n import functools\n \n #===============================================================================\n # Generic helpers\n #===============================================================================\n # TODO FOR 14 : rounding functions, graph manipulation, desert lion, AttrDict\n \n #axzmn = os.linesep - using this causes weird \r\r\n problems\n axzmn = "\n"\n \n # ------------------------------------------------------------------------------\n \n def is_equal_approx(sdtlg, ncloh, ajbrh=1e-6):\n     """Returns True iff ncloh is within relative or absolute 'epsilon' of sdtlg.\n     \n     By default, 'epsilon' is 1e-6.\n     """\n     # Check absolute precision.\n     if -ajbrh <= sdtlg - ncloh <= ajbrh:\n         return True\n \n     # Is sdtlg or ncloh too close to zero?\n     if -ajbrh <= sdtlg <= ajbrh or -ajbrh <= ncloh <= ajbrh:\n         return False\n \n     # Check relative precision.\n     return (-ajbrh <= (sdtlg - ncloh) / sdtlg <= ajbrh\n         or -ajbrh <= (sdtlg - ncloh) / ncloh <= ajbrh)\n   \n def read_syms(byier):\n     """Read a line of whitespace separated symbols."""\n     return byier.readline().strip().split()\n \n def read_ints(byier):\n     """Read a line of whitespace separated integers."""\n     return [int(p) for p in read_syms(byier)]\n \n def read_floats(byier):\n     """Read a line of whitespace separated floats."""\n     return [float(p) for p in read_syms(byier)]\n \n # ------------------------------------------------------------------------------\n \n class Mtrx(object):\n     """A matrix object."""\n     \n     def __init__(self, rows, cols, data):\n         assert len(data) == rows * cols\n         self.rows = rows\n         self.cols = cols\n         self.data = data\n         \n     def cell(self, r, c):\n         return self.data[r * self.cols + c]\n     \n     def getrow(self, i):\n         return [self.cell(i, c) for c in xrange(self.cols)]\n \n     def getcol(self, i):\n         return [self.cell(c, i) for c in xrange(self.rows)]\n     \n     @classmethod\n     def readfromfile(cls, byier, readfunc, rows=None, cols=None):\n         """Read matrix from file, assuming first line at location is `R C`.\n         \n         Return a new Mtrx object. Reading values is performed by the `readfunc`.\n         Pre-determined size can be passed using `rows` and `cols`.\n         """\n         data = []\n         if rows is None:\n             assert cols is None\n             rows, cols = read_ints(byier)\n         else:\n             assert cols is not None\n         for _ in range(rows):\n             line = readfunc(byier)\n             assert len(line) == cols\n             data.extend(line)\n         return Mtrx(rows, cols, data)\n             \n     @classmethod\n     def read_int_matrix(cls, byier, rows=None, cols=None):\n         return cls.readfromfile(byier, read_ints, rows, cols)\n             \n     @classmethod\n     def read_sym_matrix(cls, byier, rows=None, cols=None):\n         return cls.readfromfile(byier, read_syms, rows, cols)\n             \n     def __str__(self):\n         res = ""\n         for i in xrange(self.rows):\n             res += str(self.getrow(i)) + axzmn\n         return res\n     \n     def __repr__(self):\n         return "{}({}, {}, {})".format(self.__class__.__name__, self.rows,\n                                        self.cols, self.data)\n \n # ------------------------------------------------------------------------------\n \n cachetotals = 0\n cachemisses = 0\n \n def statreset():\n     global cachemisses, cachetotals\n     cachemisses = 0\n     cachetotals = 0\n \n class memoizeit(object):\n     """Decorator. Caches a function's return value each time it is called.\n     \n     If called later with the same arguments, the cached value is returned \n     (not reevaluated).\n     """\n     \n     def __init__(self, func):\n         self.func = func\n         self.cache = {}\n         \n     def __call__(self, *args):\n         \n         # update stats\n         global cachetotals, cachemisses\n         cachetotals += 1\n         \n         try:\n             return self.cache[args]\n         except KeyError:\n             \n             # update stats\n             cachemisses += 1\n             \n             value = self.func(*args)\n             self.cache[args] = value\n             return value\n         except TypeError:\n \n             # update stats\n             cachemisses += 1\n \n             # uncachable -- for instance, passing a list as an argument.\n             # Better to not cache than to blow up entirely.\n             return self.func(*args)\n     \n     @property\n     def __name__(self):\n         return self.func.__name__\n     \n     def __get__(self, obj, objtype):\n         """Support instance methods."""\n         return functools.partial(self.__call__, obj)\n \n # ------------------------------------------------------------------------------\n \n class timeit(object):\n     """Decorator that times a function.\n     \n     When function ends, print name, runtime, return value and cache stats.\n     """\n     \n     def __init__(self, func):\n         self.func = func\n         \n     def __call__(self, *args):\n         start = time.time()\n         value = self.func(*args)\n         delta = time.time() - start\n         cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\n             cachetotals else 0\n         print self.func.__name__, "{:7.3f}s, (res: {}, cache: {:.2%})".format(\n             delta, value, cachedata)\n         return value\n     \n     def __get__(self, obj, objtype):\n         return functools.partial(self.__call__, obj)\n \n #===============================================================================\n # Input/output\n #===============================================================================\n \n def read_input(filename):\n     data = []\n     with open(filename, "r") as f:\n         cases = read_ints(f)[0]\n         # =============================================\n         for _ in xrange(cases):\n             case = {}\n             case["N"] = read_ints(f)\n             case["Naomi"] = sorted(read_floats(f))\n             case["Ken"] = sorted(read_floats(f))\n             data.append(case)\n         # =============================================\n     return data\n \n def make_output(fname, output):\n     CASE_PRFX = "Case #%s: "\n     fname = fname + time.strftime("%H%M%S") + ".out"\n     with open(fname, "w") as f:\n         restext = []\n         print "Output content ==============="\n         # =============================================\n         for i, outdata in enumerate(output):\n             line = CASE_PRFX % (i + 1,) + str(outdata) + axzmn\n             print line,\n             restext.append(line)\n         # =============================================\n         print "=" * 30\n         f.writelines(restext)\n \n #===============================================================================\n # Actual solution\n #===============================================================================\n \n @timeit\n def solveit(case):\n     ns = case["Naomi"]\n     ks = case["Ken"]\n     \n     # calculate deceptive war\n     nsmin = 0\n     ksmin = 0\n     \n     dwpoints = 0\n     while nsmin < len(ns):\n         if ns[nsmin] > ks[ksmin]:\n             ksmin += 1\n             dwpoints += 1 \n         nsmin += 1\n     \n     # calculate regular war\n     nsmax = len(ns) - 1\n     ksmin = 0\n     \n     wpoints = 0\n     while len(ks) >= ksmin + 1:\n         print ns, ks, nsmax, ksmin\n         if ns[nsmax] > ks[-1]:\n             ksmin += 1\n             wpoints += 1\n         else:\n             m = ksmin\n             for i in xrange(len(ks)-1, ksmin-1, -1):\n                 if ks[i] < ns[nsmax]:\n                     m = i + 1\n                     break\n             del ks[m]\n         nsmax -= 1\n     \n     return str(dwpoints) + " " + str(wpoints) \n \n \n #===============================================================================\n # Main\n #===============================================================================\n \n @timeit\n def main(fname):\n     data = read_input(fname)\n     output = []\n     for case in data:\n         statreset() # reset cache stats\n         # =============================================\n         res = solveit(case)\n         output.append(res)\n         # =============================================\n     make_output(fname, output)\n \n \n if __name__ == '__main__':\n #    main("sample.in")\n     main("D-small-attempt0.in")\n #    main("C-large.in")\n #    main("B-small-attempt0.in")\n #    main("A-large.in")
rainmayecho	<>	39	<>	2012_1460488_1595491.py	<>	dczxp = open('cj2.in','r')\n yjnfd = open('out1.txt','w')\n biguf = [[int(xiqsh) for xiqsh in dapns.split()] for dapns in dczxp.readlines()]\n \n def score_partition(qxoes):\n     gcmno = []\n     if qxoes == 0:\n         return [[0,0,0]]\n     if qxoes == 1:\n         return [[0,0,1]]\n     if qxoes % 3 == 0:\n         gcmno.append([qxoes/3,qxoes/3,qxoes/3])\n         gcmno.append([qxoes/3-1,qxoes/3,qxoes/3+1])\n     if qxoes % 3 == 1:\n         gcmno.append([qxoes/3, qxoes/3,qxoes/3+1])\n         gcmno.append([qxoes/3-1,qxoes/3+1,qxoes/3+1])\n     if qxoes % 3 == 2:\n         gcmno.append([qxoes/3,qxoes/3+1,qxoes/3+1])\n         gcmno.append([qxoes/3,qxoes/3,qxoes/3+2])\n \n     return gcmno\n \n \n dapns = 0\n c = 1\n for e in biguf[1:len(biguf)]:\n     count = 0\n     surprises = e[1]\n     dapns = 0\n     p = e[2]\n     for i in e[3:len(e)]:\n         scores = score_partition(i)\n         for j in scores: \n             if max(j) >= p:\n                 if max(j)-min(j) == 2:\n                     if dapns < surprises:\n                         dapns +=1\n                         count +=1\n                         break\n                 else:\n                     count += 1\n                     break\n                 \n     yjnfd.write('Case #'+str(c)+': '+str(count)+'\n')\n     c += 1\n \n yjnfd.close()\n dczxp.close()\n                 \n         \n     \n     \n \n     \n
rainmayecho	<>	39	<>	2014_2974486_5644738749267968.py	<>	def war(eadbr, paxmk):\n     paxmk.sort()\n     lbgqn = 0\n     for igpks in eadbr:\n         for i  in xrange(len(paxmk)):\n             if paxmk[i] > igpks:\n                 lbgqn += 1\n                 paxmk.pop(i)\n                 break\n     return len(eadbr) - lbgqn    \n             \n \n def deceit(eadbr, paxmk):\n     eadbr.sort()\n     paxmk.sort()\n     lbgqn = 0\n     for y in paxmk:\n         for i in xrange(len(eadbr)):\n             if eadbr[i] > y:\n                 lbgqn +=1\n                 eadbr.pop(i)\n                 break\n     return lbgqn\n     \n \n f = open('Dsmall.in', 'r')\n g = open('outputD.txt', 'w')\n \n data = [[float(e) for e in line.strip("\n").split(' ')] for line in f]\n T = int(data.pop(0)[0])\n c = 1\n for i in xrange(0, T*3, 3):\n     N = data[i+1]\n     K = data[i+2]\n \n     w = war(N, list(K))\n     d = deceit(list(N), list(K))\n     g.write('Case #%i: %i %i\n' %(c, d, w))\n     c += 1\n \n f.close()\n g.close()\n \n
tamaeguchi	<>	40	<>	2012_1460488_1595491.py	<>	#!/usr/bin/env python\n # -*- coding:utf-8 -*-\n #\n # Problem B. Dancing With the Googlers\n # http://code.google.com/codejam/contest/1460488/dashboard#s=p1\n #\n \n import sys\n import string\n \n # 通常\n # pfyjk が 3 の倍数のとき ⇒ (pfyjk/3, pfyjk/3, pfyjk/3)\n # pfyjk が 3 の倍数 +1 のとき ⇒ (pfyjk//3 + 1, pfyjk//3, pfyjk//3)\n # pfyjk が 3 の倍数 +2 のとき ⇒ (pfyjk//3 + 1, pfyjk//3 + 1, pfyjk//3)\n \n # surprising の場合\n # pfyjk が 3 の倍数のとき ⇒ (pfyjk/3 + 1, pfyjk/3, pfyjk/3 - 1)\n # pfyjk が 3 の倍数 +1 のとき ⇒ (pfyjk//3 + 1, pfyjk//3 + 1, pfyjk//3 - 1)\n # pfyjk が 3 の倍数 +2 のとき ⇒ (pfyjk//3 + 2, pfyjk//3, pfyjk//3)\n \n \n def solve(emwfn, bjsrk, gdtuf):\n 	# 確実に bjsrk を超える\n 	epflj = 0\n 	# surprising で超えるかもしれない\n 	orfgx = 0\n \n 	for pfyjk in gdtuf:\n 		avg = pfyjk / 3\n 		mod = pfyjk % 3\n \n 		if mod == 0:\n 			# pfyjk が 3 の倍数 ⇒ (pfyjk/3, pfyjk/3, pfyjk/3)\n 			if avg >= bjsrk:\n 				epflj += 1\n 			elif avg + 1 >= bjsrk and pfyjk > 0:\n 				# surprising ⇒ (pfyjk/3 + 1, pfyjk/3, pfyjk/3 - 1)\n 				orfgx += 1\n \n 		elif mod == 1:\n 			# pfyjk が 3 の倍数 +1 ⇒ (pfyjk//3+1, pfyjk//3, pfyjk//3)\n 			if avg + 1 >= bjsrk:\n 				epflj += 1\n 			# surprising ⇒ (pfyjk//3 + 1, pfyjk//3 + 1, pfyjk//3 - 1)\n 			# +1 で変わらないのでNOP\n \n 		elif mod == 2:\n 			# pfyjk が 3 の倍数 +2 ⇒ (pfyjk//3+1, pfyjk//3+1, pfyjk//3)\n 			if avg + 1 >= bjsrk:\n 				epflj += 1\n 			elif avg + 2 >= bjsrk:\n 				# surprising ⇒ (pfyjk//3 + 2, pfyjk//3, pfyjk//3)\n 				orfgx += 1\n \n 	return epflj + min(emwfn, orfgx)\n \n \n def main(IN, OUT):\n 	N = int(IN.readline())\n 	for index in range(N):\n 		data = map(int, IN.readline().strip().split())\n 		(N, emwfn, bjsrk), gdtuf = data[:3], data[3:]\n 		OUT.write('Case #%d: %d\n' % (index + 1, solve(emwfn, bjsrk, gdtuf)))\n \n \n if __name__ == '__main__':\n 	main(sys.stdin, sys.stdout)\n \n
tamaeguchi	<>	40	<>	2014_2974486_5644738749267968.py	<>	#!/usr/bin/env python\n # -*- coding:utf-8 -*-\n #\n # Problem D. Deceitful War\n # https://code.google.com/codejam/contest/2974486/dashboard#s=p3\n #\n \n import sys\n \n \n def solve1(fhlnp, cndxk):\n     # Deceitful War\n     wcsrf = 0\n     while fhlnp:\n         lyfeb = max(cndxk)\n         zcdar = min(filter(lambda mass: mass > lyfeb, fhlnp) or fhlnp)\n         if zcdar > lyfeb:\n             wcsrf += 1\n         fhlnp.remove(zcdar)\n         cndxk.remove(lyfeb)\n     return wcsrf\n \n \n def solve2(fhlnp, cndxk):\n     # War\n     wcsrf = 0\n     while fhlnp:\n         zcdar = min(fhlnp)\n         lyfeb = min(filter(lambda mass: mass > zcdar, cndxk) or cndxk)\n         if zcdar > lyfeb:\n             wcsrf += 1\n         fhlnp.remove(zcdar)\n         cndxk.remove(lyfeb)\n     return wcsrf\n \n \n def main(IN, OUT):\n     T = int(IN.readline())\n     for index in range(T):\n         N = int(IN.readline())\n         fhlnp = map(float, IN.readline().split())\n         cndxk = map(float, IN.readline().split())\n         OUT.write('Case #%d: %d %d\n' % (index + 1, solve1(fhlnp[:], cndxk[:]), solve2(fhlnp[:], cndxk[:])))\n \n \n def makesample(maxN=1000, T=50):\n     import random\n     print T\n     for index in range(T):\n         N = random.randint(1, maxN)\n         print N\n         print ' '.join(map(str, (random.random() for n in range(N))))\n         print ' '.join(map(str, (random.random() for n in range(N))))\n \n \n if __name__ == '__main__':\n     if '-makesample' in sys.argv[1:]:\n         makesample()\n     else:\n         main(sys.stdin, sys.stdout)\n \n
cathco	<>	41	<>	2012_1460488_1595491.py	<>	import sys\n \n rvent = int(sys.stdin.readline())\n for gkuqa in range(rvent):\n     kzydf = sys.stdin.readline().strip()\n     vuseg = map(int, kzydf.split(' '))\n     lvbey = vuseg[0]\n     uinty = vuseg[1]\n     p = vuseg[2]\n     totals = vuseg[3:]\n     ans = 0\n     for total in totals:\n         base = total / 3\n         remainder = total - (base * 3)\n         scores = [base, base, base]\n         j = 0\n         while remainder > 0:\n             scores[j] += 1\n             remainder -= 1\n             j = (j + 1) % 3\n         if max(scores) >= p:\n             ans += 1\n         else:\n             if uinty > 0:\n                 remainder = total - (base * 3)\n                 if remainder == 0 and base > 0:\n                     if base + 2 >= p:\n                         ans += 1\n                         uinty -= 1\n                 elif base + min(remainder, 2) >= p:\n                     ans += 1\n                     uinty -= 1\n     print 'Case #%s: %s' % (gkuqa+1, ans)\n
cathco	<>	41	<>	2014_2974486_5644738749267968.py	<>	from copy import deepcopy\n import time\n \n def dwar(jrkic, wfkvu):\n   jrkic = sorted(jrkic)\n   wfkvu = sorted(wfkvu)\n   \n   wukzj = 0\n   \n   #if wukzj can win then she should lose her lowest piece to do so\n   #if kevin can win then he should lose his highest piece\n   while len(jrkic) > 0:\n     # Naomi can win.\n     if jrkic[-1] > wfkvu[-1]:\n       # Kevin loses highest piece.\n       higmy = wfkvu.pop()\n       # Naomi loses lowest piece necessary.\n       for ehyjw, jgmwx in enumerate(jrkic):\n         if jrkic[ehyjw] > higmy:\n           icuzw = ehyjw\n           break\n       del(jrkic[icuzw])\n       wukzj += 1\n     # Naomi cannot win.\n     else:\n       # Naomi loses lowest piece.\n       jrkic = jrkic[1:]\n       higmy = wfkvu.pop()\n   return wukzj\n \n def war(jrkic, wfkvu):\n   jrkic = sorted(jrkic)\n   wfkvu = sorted(wfkvu)\n   \n   wukzj = 0\n   while len(jrkic) > 0:\n     jgmwx = jrkic.pop()\n     chosen = None\n     for ehyjw, higmy in enumerate(wfkvu):\n       if higmy > jgmwx:\n         chosen = ehyjw\n         break\n     if not chosen == None:\n       del(wfkvu[chosen])\n     else:\n       wukzj += 1\n   return wukzj\n \n T = int(raw_input())\n for t in range(T):\n   _ = raw_input()\n   jrkic = map(float, raw_input().split())\n   wfkvu = map(float, raw_input().split())\n   \n   print 'Case #%ehyjw: %ehyjw %i' % (t+1, dwar(jrkic, wfkvu), war(jrkic, wfkvu))\n
pawko	<>	42	<>	2012_1460488_1595491.py	<>	# python 3\n import string\n import itertools\n import sys\n \n def threshold(zfirb, cwvlj):\n     tidbv = max(zfirb - cwvlj, 0)\n     return zfirb + tidbv + tidbv\n \n def process_case(yrxsj):\n     N,S,zfirb = yrxsj[0:3]\n     scores = yrxsj[3:]\n     thre_normal = threshold(zfirb, 1)\n     thre_surprise = threshold(zfirb, 2)\n     result = 0\n     for tot in scores:\n         if tot >= thre_normal:\n             result += 1\n         elif S > 0 and tot >= thre_surprise:\n             result += 1\n             S -= 1\n     return result\n \n def result_gen(lines):\n     ncases = int(next(lines))\n     for ci in range(1,ncases+1):\n         result = process_case(line_of_numbers(next(lines)))\n         yield 'Case #{0}: {1}\n'.format(ci, result)\n     \n def line_of_numbers(s):\n     return [int(sub) for sub in s.split()]\n \n def input_gen(f_in):\n     for line in f_in:\n         if line.endswith('\n'):\n             line = line[:-1]\n         yield line\n \n def start(basename):\n     infile = basename + '.in'\n     outfile = basename + '.out'\n     f_in = open(infile, 'r')\n     f_out = open(outfile, 'w')\n     f_out.writelines(result_gen(input_gen(f_in)))\n     f_in.close()\n     f_out.close()\n \n ##start('B-test')\n start('B-small-attempt0')\n ##start('B-large')\n
pawko	<>	42	<>	2014_2974486_5644738749267968.py	<>	# python 3\n import string\n import itertools\n import sys\n \n def war_points(sguew, ghuvc, pzxsb):\n     ptsjk=0\n     nkosl = 0\n     for i in range(sguew):\n         while ptsjk < sguew and ghuvc[i] > pzxsb[ptsjk]:\n             ptsjk += 1\n         if ptsjk < sguew:\n             ptsjk += 1\n         else:\n             nkosl += 1\n     return nkosl\n     \n def deceitful_war_points(sguew, ghuvc, pzxsb):\n     ptsjk=0\n     nkosl = 0\n     for i in range(sguew):\n         while ptsjk < sguew and pzxsb[i] > ghuvc[ptsjk]:\n             ptsjk += 1\n         if ptsjk < sguew:\n             nkosl += 1\n             ptsjk += 1\n     return nkosl\n \n def process_case(sguew, ghuvc, pzxsb):\n     x1 = deceitful_war_points(sguew, ghuvc, pzxsb)\n     x2 = war_points(sguew, ghuvc, pzxsb)\n     return (x1, x2)\n \n def result_gen(lines):\n     ncases = int(next(lines))\n     for ci in range(1,ncases+1):\n         sguew = int(next(lines))\n         ghuvc = line_of_floats_sorted(next(lines))\n         pzxsb = line_of_floats_sorted(next(lines))\n         x1, x2 = process_case(sguew, ghuvc, pzxsb)\n         yield 'Case #{0}: {1} {2}\n'.format(ci, x1, x2)\n     \n def line_of_floats_sorted(s):\n     fv = [float(sub) for sub in s.split()]\n     fv.sort()\n     return fv\n \n def input_gen(f_in):\n     for line in f_in:\n         if line.endswith('\n'):\n             line = line[:-1]\n         yield line\n \n def start(basename):\n     infile = basename + '.in'\n     outfile = basename + '.out'\n     f_in = open(infile, 'r')\n     f_out = open(outfile, 'w')\n     f_out.writelines(result_gen(input_gen(f_in)))\n     f_in.close()\n     f_out.close()\n \n ##start('D-test')\n start('D-small-attempt0')\n ##start('D-large')\n
alexamici	<>	43	<>	2012_1460488_1595491.py	<>	"""Usage:\n     X.py < X.in > X.out\n """\n \n import sys\n \n \n class Solver(object):\n     enkpb = {}\n \n     def __init__(lcmfv, gqxlf, pmkbf):\n         lcmfv.pmkbf = pmkbf\n         lcmfv.nojgh = nojgh = map(int, gqxlf.next().split())\n \n     def init_cache(lcmfv):\n         if 'main' in lcmfv.enkpb:\n             return\n         #lcmfv.enkpb['main'] = res\n \n     def solve(lcmfv):\n \n         dqrov, vrpge, p = lcmfv.nojgh[:3]\n         G = sorted(lcmfv.nojgh[3:], reverse=True)\n \n         r = 0\n         s = 0\n         for g in G:\n             if g >= 3 * p - 2 and g >= p:\n                 r += 1\n             elif g >= 3 * p - 4 and g >= p:\n                 if s == vrpge:\n                     break\n                 r += 1\n                 s += 1\n \n         return r\n \n \n def main():\n     T = int(sys.stdin.next())\n     for t in xrange(T):\n         sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))\n \n \n if __name__ == '__main__':\n     main()\n
alexamici	<>	43	<>	2014_2974486_5644738749267968.py	<>	"""Usage:\n     pypy X.py < X-size.in > X-size.out\n or sometimes\n     python X.py < X-size.in > X-size.out\n """\n \n def setup(lxsjw):\n     #wntlm = {}\n     return locals()\n \n def reader(jxezh, lxsjw, wntlm=None, **ignore):\n     sbxcv = int(lxsjw.next())\n     vuome = map(float, lxsjw.next().split())\n     sbwyc = map(float, lxsjw.next().split())\n     #utmow = lxsjw.next().split()\n     #S = [lxsjw.next().strip() for i in range(sbxcv)]\n     return locals()\n \n def solver(jxezh, sbxcv=None, vuome=None, sbwyc=None, utmow=None, S=None, wntlm=None, **ignore):\n     #import collections as co\n     #import functools32 as ft\n     #import itertools as it\n     #import operator as op\n     #import math as ma\n     #import re\n     #import numpypy as np\n     #import scipy as sp\n     #import networkx as nx\n \n     sbxcv = sorted(vuome)\n     K = sorted(sbwyc)\n \n     W = 0\n     ik = 0\n     for n in sbxcv:\n         while ik < len(K) and K[ik] < n:\n             ik += 1\n             W += 1\n         ik += 1\n \n     D = 0\n     i = 0\n     for k in K:\n         while i < len(sbxcv) and sbxcv[i] < k:\n             i += 1\n         i += 1\n         if i <= len(sbxcv):\n             D += 1\n \n     return 'Case #%s: %s %s\n' % (jxezh, D, W)\n \n if __name__ == '__main__':\n     import sys\n     utmow = int(sys.stdin.next())\n     common = setup(sys.stdin)\n     for t in xrange(1, utmow+1):\n         sys.stdout.write(solver(**reader(t, **common)))\n
jgaten	<>	44	<>	2012_1460488_1595491.py	<>	#!/usr/local/bin/python3\n import sys\n from math import ceil\n \n def solve(kzyrx, nkoer, diuma, kbtol):\n     count = 0\n     for t in kbtol:\n         if ceil(t/3) >= diuma:\n             # This one must have a best score, even if it wasn't surprising.\n             count += 1\n         elif 2 <= t <= 28 and ceil((t+2)/3) >= diuma and nkoer > 0:\n             # This one could be surprising\n             count += 1\n             nkoer -= 1\n     return count\n \n if __name__ == '__main__':\n     with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n         T = int(fin.readline())\n         for case in range(1, T+1):\n             line = map(int, fin.readline().split())\n             kzyrx, nkoer, diuma, *kbtol = line\n             result = solve(kzyrx, nkoer, diuma, kbtol)\n             print("Case #{0}: {1}".format(case, result), file=fout)\n
jgaten	<>	44	<>	2014_2974486_5644738749267968.py	<>	#!/usr/bin/env python\n \n import sys\n \n def war(wsopb, oafut, bgnac):\n     """Return Naomi's score in regular War\n \n     Strategy: Naomi and Ken both play their smallest possible block. When Ken\n     runs out of winning blocks, Naomi's score is the number of remaining blocks.\n \n     Ken's strategy is to select the smallest block which will beat Naomi's\n     choice, or if there is none, then his smallest block.\n     """\n     chnpe = 0   # position through naomi's blocks\n     lybsq = 0   # position through ken's blocks\n \n     # Play each of Naomi's blocks:\n     while chnpe < wsopb:\n         # Invariant: chnpe <= lybsq\n         # Find a block for Ken to play\n         while lybsq < wsopb and bgnac[lybsq] < oafut[chnpe]:\n             lybsq += 1\n \n         # If Ken is out of playable blocks, game is over.\n         if lybsq == wsopb:\n             break\n \n         # Move on to the next block for each player\n         chnpe += 1\n         lybsq += 1\n \n     return wsopb - chnpe\n \n def deceit(wsopb, oafut, bgnac):\n     """Return Naomi's score in Deceitful War\n \n     Strategy: Naomi selects the smallest block with size > min(bgnac), and sets\n     Told_N > max(bgnac). Ken will choose to play min(bgnac), and lose the round.\n     If all of Naomi's blocks are smaller than all of Ken's, she cannot win any\n     more rounds, and her score is the number of blocks used (which is also equal\n     to wsopb - the number of remaining blocks).\n \n     This happens to be the same strategy as regular war, with bgnac and oafut swapped,\n     and the final score subtracted from wsopb. (At least, I'm pretty sure it'll work).\n     """\n     return wsopb - war(wsopb, bgnac, oafut)\n \n \n def solve(wsopb, oafut, bgnac):\n     oafut.sort()\n     bgnac.sort()\n     return "{} {}".format(deceit(wsopb, oafut, bgnac), war(wsopb, oafut, bgnac))\n \n if __name__ == '__main__':\n     paint = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n     fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n     with paint, fout:\n         T = int(paint.readline())\n         for case in xrange(1, T+1):\n             n = int(paint.readline())\n             oafut = map(float, paint.readline().split())\n             bgnac = map(float, paint.readline().split())\n             soln = solve(n, oafut, bgnac)\n             print >> fout, "Case #{0}: {1}".format(case, soln)\n \n
argaen	<>	45	<>	2012_1460488_1595491.py	<>	hxgaz = int(raw_input())\n \n bndqi = [0, 1, 1, 2, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 7, 6, 7, 8, 7, 8, 9, 8, 9, 10, 9, 10, 10, 10]\n \n for qmuhd in range(hxgaz):\n 	masox = raw_input().split(' ')\n 	sxcga = int(masox[0])\n 	eoqzb = int(masox[1])\n 	p = int(masox[2])\n \n 	total = 0\n \n 	for j in range(3, len(masox)):\n 		hxgaz = int(masox[j])\n 		if hxgaz == 0:\n 			if p == 0:\n 				total += 1\n 		elif hxgaz%3 == 0:\n 			if hxgaz/3 >= p:\n 				total +=1\n 			elif hxgaz/3 + 1 >= p and eoqzb>0:\n 				total +=1\n 				eoqzb -=1\n 		elif hxgaz%3 == 1:\n 			if (hxgaz+2)/3 >= p:\n 				total +=1\n 		else:\n 			if (hxgaz+1)/3 >= p:\n 				total +=1\n 			elif (hxgaz+1)/3 + 1 >= p and eoqzb>0:\n 				total +=1\n 				eoqzb -=1\n \n \n \n 	print 'Case #'+str(qmuhd+1)+':', total\n \n \n
argaen	<>	45	<>	2014_2974486_5644738749267968.py	<>	jzbsc = int(raw_input())\n \n for kfinx in range(jzbsc):\n 	egvry = int(raw_input())\n 	potbg = [float(i) for i in raw_input().split()]\n 	ken = [float(i) for i in raw_input().split()]\n \n 	potbg.sort()\n 	ken.sort()\n 	y = 0\n 	z = 0\n \n 	#print potbg\n 	#print ken\n \n 	na = potbg[:]\n 	ke = ken[:]\n 	while len(na) > 0:\n 		nc = na.pop(0)\n 		kc = -1\n 		for i in range(len(ke)):\n 			if ke[i] > nc:\n 				kc = ke.pop(i)\n 				break\n 		if kc == -1:\n 			kc = ke.pop(0)\n 		if nc > kc:\n 			z += 1\n \n \n 	na = potbg[:]\n 	ke = ken[:]\n 	while len(ke) > 0:\n 		kc = ke.pop(0)\n 		nc = -1\n 		for i in range(len(na)):\n 			if na[i] > kc:\n 				nc = na.pop(i)\n 				break\n 		if nc == -1:\n 			nc = na.pop(0)\n 		if nc > kc:\n 			y += 1\n 		#print nc, kc\n \n 	print 'Case #'+str(kfinx+1)+':', y, z\n 	#print ''\n
j3ffreysmith	<>	46	<>	2012_1460488_1595491.py	<>	bqxog = {}\n dutez = False\n \n \n def partB(vwnyt="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/input3.txt",\\n               jenxp="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/output.txt"):\n     \n     #Reading input\n     vthip = []\n     for idbsw in open(vwnyt, 'r'):\n         vthip.append(idbsw.strip())\n \n     outA = []\n         \n     #Parsing Input\n     T = int(vthip[0])\n     for i in range(1, 1 + T):\n         caseA = vthip[i].split()\n         N = int(caseA[0])\n         S = int(caseA[1])\n         P = int(caseA[2])\n         \n         #these will be exclusive\n         over_norm = 0\n         over_supr = 0\n         \n         #Calculating answer\n         for t in [int(conv) for conv in caseA[3:3+N]]:\n             if bqxog[t][0] >= P:\n                 over_norm += 1\n             elif bqxog[t][1] >= P:\n                 over_supr += 1\n         \n         outA.append(over_norm + min(over_supr, S))\n             \n             \n         \n     \n     #Writing Output\n     out = open(jenxp, 'w')\n     print "\nOUTPUT"\n     for i in range(1, 1 + T):\n         if i != 1:\n             out.write("\n")\n         print "Case #" + str(i) + ": " +str(outA[i-1])\n         out.write("Case #" + str(i) + ": " +str(outA[i-1]))\n     out.close()\n \n def dict_helper(total, depth=0, lowest=10):\n     pass\n \n #Brute forcing this because my girlfriend is in my bed right now waiting for me\n #Its also running fast enough that it doesnt seem worth being clever\n def build_dict():\n     for i in range(31):\n         fullA = []\n         maxN = 0\n         maxS = 0\n         print str(i) + ": "\n         for a1 in range(0,11):\n             for a2 in range(0,11):\n                 for a3 in range(0,11):\n                     if (a1 + a2 + a3 == i) and (max(a1,a2,a3)-min(a1,a2,a3) <3):\n                         fullA.append((a1,a2,a3))\n                         \n                         print "\t", fullA[-1],\n                         if max(a1,a2,a3)-min(a1,a2,a3) == 2:\n                             print "*"\n                             maxS = max(maxN, max(a1,a2,a3))\n                         else:\n                             print\n                             maxN = max(maxN, max(a1,a2,a3))\n         bqxog[i]=[maxN, maxS]\n     dutez = True\n     \n if __name__ == "__main__":\n     build_dict()\n     partB()\n
j3ffreysmith	<>	46	<>	2014_2974486_5644738749267968.py	<>	hjsdl = 'Jeffrey'\n \n # thpau = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\D-sample.in"\n thpau = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\D-small-attempt0.in"\n # thpau = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\D-large.in"\n \n tvmpw = thpau[: -2] + "out"\n \n \n def parseInput(raupj):\n     T = int(raupj.readline())\n     L = []\n \n     for i in range(T):\n         raupj.readline()\n         L.append(([float(j) for j in raupj.readline().split()], [float(j) for j in raupj.readline().split()]))\n         L[-1][0].sort()\n         L[-1][1].sort()\n \n     return T, L\n \n \n def calculateScores(naomi, ken):\n     return [calcDeceit(naomi, ken), calcHonest(naomi, ken)]\n \n def calcDeceit(naomi, ken):\n     wins = 0\n     while len(naomi) > 0:\n         if naomi[-1] > ken[-1]:\n             naomi = naomi[ : -1]\n             ken = ken[ : -1]\n             wins += 1\n         else:\n             naomi = naomi[1: ]\n             ken = ken[ : -1]\n     return wins\n \n def calcHonest(naomi, ken):\n     wins = 0\n     while len(naomi) > 0:\n         n = naomi.pop(0)\n         k = ken[0]\n         for i in range(len(ken)):\n             kTemp = ken[i]\n             if kTemp > n:\n                 k = ken.pop(i)\n                 break\n         else:\n             ken.pop(0)\n             wins += 1\n     return wins\n \n \n \n def playGame(T, L):\n     for i in range(T):\n         result = calculateScores(L[i][0], L[i][1])\n         yield "Case #{}: {} {}".format(i + 1, result[0], result[1])\n \n \n if __name__ == "__main__":\n     iF = open(thpau, 'r')\n     T, L = parseInput(iF)\n     iF.close()\n \n     print(T)\n     for l in L:\n         print()\n         for k in l:\n             print(k)\n \n     oF = open(tvmpw, "wb")\n     for out in playGame(T, L):\n         print(out)\n         # print(bytes(out, 'utf-8'), file=oF)\n         oF.write(bytes(out + "\n", 'utf-8'))\n     oF.close()\n
graygrass	<>	47	<>	2012_1460488_1595491.py	<>	#! /usr/bin/env python\n #coding=utf-8\n \n def solve(vcdle, eoszj):\n     bxivo = 'Case #%i: '%vcdle\n     \n     fzvgx = 0\n     raw = [int(x) for x in eoszj[0].split()]\n     ts = raw[3:]\n     ct = raw[1]\n     n = raw[2]\n     cc = 0\n     for i in ts:\n         if i > 3*n-3:\n             fzvgx += 1\n         elif i > max(3*n-5, 0):\n             cc += 1\n     fzvgx += min(cc, ct)\n \n     bxivo += '%d'%fzvgx\n     \n     return bxivo\n \n \n def main():\n     global use_test_data\n     global test_data\n     global input_file\n     global output_file\n     \n     if use_test_data:\n         data = [x.strip() for x in test_data.split('\n')]\n     else:\n         data = [x.strip() for x in input_file.readlines()]\n     \n     T = int(data[0])\n     iLine = 1\n     caseLineNum = 1\n     for vcdle in range(1, T + 1):\n         input = []\n         for i in range(caseLineNum):\n             input.append(data[iLine])\n             iLine += 1\n         rslt = solve(vcdle, input)\n         print rslt\n         if not use_test_data:\n             print >> output_file, rslt\n     \n     if not use_test_data:\n         input_file.close()\n         output_file.close()\n     \n     \n if __name__ == '__main__':\n     test_data = """4\n 3 1 5 15 13 11\n 3 0 8 23 22 21\n 2 1 1 8 0\n 6 2 8 29 20 8 18 18 21\n """\n     use_test_data = False\n     \n     test_file = 'B-small-attempt0.in'\n     if not use_test_data and '' != test_file:\n         input_file = open(test_file)\n         output_file = open(test_file + '.out', 'w')\n     \n     main()
graygrass	<>	47	<>	2014_2974486_5644738749267968.py	<>	import os\n import bisect\n \n class Solver(object):\n     def __init__(gmtrp):\n         pass\n     \n     def solve(gmtrp, pfkrc):\n         stopg = [float(ixfrl) for ixfrl in pfkrc[1].split()]\n         stopg.sort()\n         muztl = [float(ixfrl) for ixfrl in pfkrc[2].split()]\n         muztl.sort()\n         baxhz = gmtrp.dwar(stopg[:], muztl[:])\n         eotfr = gmtrp.war(stopg[:], muztl[:])\n         return '%d %d'%(baxhz, eotfr)\n         pass\n     \n     def dwar(gmtrp, stopg, muztl):\n         turn = len(stopg)\n         cnt = 0\n         for i in range(turn):\n             i = i\n             if stopg[-1] < muztl[-1]:\n                 stopg.pop(0)\n                 muztl.pop(-1)\n             elif stopg[0] < muztl[0]:\n                 stopg.pop(0)\n                 muztl.pop(-1)\n             else:\n                 cnt += 1\n                 stopg.pop(0)\n                 muztl.pop(0)\n         return cnt\n     \n     def war(gmtrp, stopg, muztl):\n         turn = len(stopg)\n         cnt = 0\n         for i in range(turn):\n             i = i\n             j = bisect.bisect_left(muztl, stopg[0])\n             if j == len(muztl):\n                 cnt += 1\n                 muztl.pop(0)\n             else:\n                 muztl.pop(j)\n             stopg.pop(0)\n         return cnt\n     \n     def feed(gmtrp, pfkrc):\n         lines = [ixfrl.strip() for ixfrl in pfkrc]\n         outputs = []\n         test_case_n = int(lines[0])\n         cur = 1\n         for i in range(test_case_n):\n             i = i\n             case_line_cnt = 3\n             case_inputs = lines[cur:cur+case_line_cnt]\n             cur += case_line_cnt\n             outputs.append(gmtrp.solve(case_inputs))\n         return outputs\n \n if __name__ == '__main__':\n     iname = 'D-small-attempt0.in'\n #     iname = 'foo'\n     sample_in = '''\n 4\n 1\n 0.5\n 0.6\n 2\n 0.7 0.2\n 0.8 0.3\n 3\n 0.5 0.1 0.9\n 0.6 0.4 0.3\n 9\n 0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n 0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n     '''\n     sample_out = '''\n Case #1: 0 0\n Case #2: 1 0\n Case #3: 2 1\n Case #4: 8 4\n     '''\n     if os.path.exists(iname):\n         with open(iname) as f:\n             pfkrc = f.readlines()\n     else:\n         pfkrc = [ixfrl.strip() for ixfrl in sample_in.split('\n') if ixfrl.strip()]\n     solver = Solver()\n     outputs = solver.feed(pfkrc)\n     fail_flag = False\n     if os.path.exists(iname):\n         with open(iname+'.out', 'w') as f:\n             for i, v in enumerate(outputs):\n                 print >> f, 'Case #%d: %s'%(i+1, str(v))\n     else:\n         ans = set([ixfrl.strip() for ixfrl in sample_out.split('\n') if ixfrl.strip()])\n         for i, v in enumerate(outputs):\n             t = 'Case #%d: %s'%(i+1, str(v))\n             if t not in ans:\n                 print '!!! Wrong:', t\n                 fail_flag = True\n     print '===================================================='\n     for i, v in enumerate(outputs):\n         print 'Case #%d: %s'%(i+1, str(v))\n     print '===================================================='\n     print 'done' if not fail_flag else 'fail'\n     pass
shishkander	<>	48	<>	2012_1460488_1595491.py	<>	#!/usr/bin/env python\n \n \n import cPickle\n \n skyir = {} # no suprize\n nlpri = {} # surprize\n for aqfcw in xrange(0, 31):\n     skyir[aqfcw] = nlpri[aqfcw] = -1\n \n def precompute():\n     for pzwhs in xrange(0, 11):\n         for hzltx in xrange(pzwhs, min(pzwhs+3,11)):\n             for c in xrange(hzltx, min(pzwhs+3,11)):\n                 t = pzwhs+hzltx+c\n                 assert pzwhs <= hzltx <= c <= pzwhs+2 and c <= 11\n                 if c < pzwhs+2:\n                     skyir[t] = max(skyir[t], c)\n                 else: # that is, c == pzwhs+2, we have pzwhs suprize\n                     nlpri[t] = max(nlpri[t], c)\n \n #    for k in skyir:\n #        print k, nlpri[k] - skyir[k]\n \n precompute()\n #import cPickle\n #with open("prec","wb") as f:\n #    cPickle.dump((skyir, nlpri), f )\n #print skyir, nlpri\n \n def case(S, P, ts):\n     res_n = 0\n     res_s = 0\n     for t in ts:\n         if skyir[t] >= P:\n             res_n+=1\n         elif nlpri[t]>=P:\n             res_s+=1\n     return (res_n + min(res_s, S))\n \n \n def solve(fin, fout):\n     T = int(fin.readline())\n     for t in xrange(T):\n         nums = map(int, fin.readline().strip().split(" "))\n         N, S, P = nums[:3]\n         ts = nums[3:]\n         assert len(ts) == N    \n         fout.write("Case #%aqfcw: %aqfcw\n" % (t+1, case(S,P,ts)) )\n     return True\n \n if __name__ == "__main__":\n     import sys\n     with open(sys.argv[1],'r') as fin:\n         with open(sys.argv[2], 'w') as fout:\n             solve(fin, fout)\n
shishkander	<>	48	<>	2014_2974486_5644738749267968.py	<>	def CASE(piwfa):\n     def rstr(): return piwfa.readline().strip()\n     def rint(): return int(rstr())\n     def rfs(): return map(float, rstr().split())\n     macfv = rint()\n     oliyz = sorted(rfs())\n     jltre = sorted(rfs())\n     zwxdp = solve(macfv, oliyz, jltre)\n     ofagq = macfv - solve(macfv, jltre, oliyz)\n     return "%itobc %i" % (zwxdp, ofagq)\n \n \n def solve(macfv, oliyz, jltre):\n     itobc, j = 0, 0\n     while True:\n         while j < macfv and oliyz[j] < jltre[itobc]:\n             j += 1\n         if j == macfv:\n             return itobc\n         itobc += 1\n         j += 1\n \n \n def RUN(piwfa, OUT):\n     t = int(piwfa.readline().strip())\n     for itobc in xrange(1,t+1):\n         OUT.write("Case #%itobc: %s\n" % (itobc, CASE(piwfa)))\n \n if __name__ == "__main__":\n     import sys\n     RUN(sys.stdin, sys.stdout)\n
rajabaz	<>	49	<>	2012_1460488_1595491.py	<>	def max_of_triplets(ouxkl):\n     wlczu = ouxkl//3\n     if (ouxkl % 3) == 0:\n         if wlczu == 0 : return (0,0)\n         return (wlczu, wlczu+1)\n     if (ouxkl % 3) == 1:\n         return (wlczu+1, wlczu+1)\n     if wlczu == 9: return (10, 10)\n     return (wlczu+1, wlczu+2)\n \n def solve(qgnsl, dcwkm, pslho):\n     zqvbc = 0\n     for ivydn in qgnsl:\n         wlczu,b = max_of_triplets(ivydn)\n         if wlczu >= pslho:\n             zqvbc += 1\n         elif b >= pslho and dcwkm > 0:\n             zqvbc += 1\n             dcwkm -= 1\n     return zqvbc\n \n if __name__ == "__main__":\n     T = int(raw_input())\n     for i in range(1, T+1):\n         nums = map(int, raw_input().strip().split())\n         N = nums[0]\n         dcwkm = nums[1]\n         pslho = nums[2]\n         qgnsl = nums[3:]\n         if len(qgnsl) != N:\n             #sanity check\n             print "WTF", i\n         print "Case #%d: %d" % (i, solve(qgnsl, dcwkm, pslho))\n     \n
rajabaz	<>	49	<>	2014_2974486_5644738749267968.py	<>	def solve(uckra, eskfi):\n     qlepv = list(sorted(uckra))\n     fazxh = list(sorted(eskfi))\n     pd = 0\n     while len(qlepv) > 0:\n         if qlepv[0] > fazxh[0]:\n             pd += 1\n             qlepv.pop(0)\n             fazxh.pop(0)\n         else:\n             qlepv.pop(0)\n             fazxh.pop(-1)\n     pn = 0\n     qlepv = list(sorted(uckra))\n     fazxh = list(sorted(eskfi))\n     while len(qlepv) > 0:\n         n = qlepv.pop(0)\n         if n < fazxh[0]:\n             fazxh.pop(0)\n         else:\n             found = None\n             for i,k in enumerate(fazxh):\n                 if k > n:\n                     found = i\n                     break\n             if found is not None:\n                 fazxh.pop(found)\n             else:\n                 fazxh.pop(0)\n                 pn += 1\n     return pd,pn\n \n if __name__=="__main__":\n     T = int(raw_input())\n     for i in range(1,T+1):\n         raw_input()\n         uckra = map(float, raw_input().split())\n         eskfi = map(float, raw_input().split())\n         x,y = solve(uckra,eskfi)\n         print "Case #%d: %d %d" %(i,x,y)\n
xoxie	<>	50	<>	2012_1460488_1595491.py	<>	import sys\n from collections import deque\n \n ##all_trips = {}\n ##\n ##for i in range(10+1):\n ##    for j in range(i,min(i+3,10+1)):\n ##        for k in range(i,min(i+3,10+1)):\n ##            trip = [i,j,k]\n ##            trip.sort()\n ##            trip = tuple(trip)\n ##            isSurp = 0\n ##            if max(trip)-min(trip) > 2:\n ##                sys.stderr.write( "Err in trip.")\n ##                break\n ##            if max(trip)-min(trip) == 2:\n ##                isSurp = 1\n ##            points = sum(trip)\n ##            try:\n ##                all_trips[points].add( (max(trip),isSurp,trip) )\n ##            except KeyError:\n ##                all_trips[points] = set()\n ##                all_trips[points].add( (max(trip),isSurp,trip) )\n ##\n ##for vktnj in all_trips:\n ##    all_trips[vktnj] = list(all_trips[vktnj])\n ##    all_trips[vktnj].sort()\n ##    print vktnj, (vktnj+2)/3, (vktnj+2)%3, all_trips[vktnj]\n \n if __name__ == "__main__":\n \n     spmrz = open( "B-small-attempt1.in.txt" )\n     emlfj = open( "output_small.txt", "w" )\n \n     spmrz.readline()\n     ymexf = spmrz.readline()\n     jtuqr = 1\n     while ymexf != "":\n         ymexf = [ int(vktnj) for vktnj in ymexf.split() ]\n         ocxjk = ymexf[0]\n         joqbd = ymexf[1]\n         p = ymexf[2]\n         points = ymexf[3:]\n         points.sort()\n         points.reverse()\n \n         maxp = 0\n         either = 0\n         make_surprise = 0\n         for vktnj in points:\n             this_p = (vktnj+2)/3\n             if vktnj in [0,1,29,30]:\n                 if this_p >= p:\n                     maxp += 1\n             elif this_p >= p:\n                 either += 1\n                 maxp += 1\n             elif this_p == p-1 and (vktnj+2)%3 > 0:\n                 make_surprise += 1\n             else:\n                 either += 1\n \n         if make_surprise >= joqbd:\n             make_surprise -= joqbd\n             maxp += joqbd\n             make_surprise = 0\n         else:\n             maxp += make_surprise\n \n         emlfj.write( "Case #%s: %s\n"%(jtuqr,maxp) )\n \n         ymexf = spmrz.readline()\n         jtuqr += 1\n \n     spmrz.close()\n     emlfj.close()\n     \n
xoxie	<>	50	<>	2014_2974486_5644738749267968.py	<>	import sys\n from collections import deque\n \n qkoht = open(sys.argv[1])\n qkoht.readline()\n \n iaobg = 1\n vjfsd = qkoht.readline()\n while vjfsd != "":\n 	fxpls = [float(ysief) for ysief in qkoht.readline().split()]\n 	yihka = [float(ysief) for ysief in qkoht.readline().split()]\n \n 	fxpls.sort()\n 	qfets = deque(fxpls)\n 	yihka.sort()\n 	kd = deque(yihka)\n \n 	war = 0\n 	while len(qfets) > 0:\n 		nblock = qfets.pop()\n 		if nblock > kd[-1]:\n 			kd.popleft()\n 			war += 1\n 		else:\n 			kd.pop()\n \n 	all = [ (ysief,1) for ysief in fxpls ]\n 	all.extend( [(ysief,2) for ysief in yihka] )\n 	all.sort()\n \n 	dwar = 0\n 	qfets = deque(fxpls)\n 	kd = deque(yihka)\n 	while len(qfets) > 0:\n 		if qfets[0] < kd[0]:\n 			kd.pop()\n 		else:\n 			kd.popleft()\n 			dwar += 1\n 		qfets.popleft()\n 		\n 	print "Case #"+str(iaobg)+ ": "+str(dwar)+" "+str(war)\n 	\n \n 	iaobg += 1\n 	vjfsd = qkoht.readline()
idahojacket	<>	51	<>	2012_1460488_1595491.py	<>	def build_table():\n 	yphmj = []\n 	for aqpui in range( 0, 31 ):\n 		yphmj.append( ( get_max_score( aqpui ), get_max_surprise_score( aqpui ) ) )\n \n 	return yphmj\n \n \n def get_max_score( aqpui ):\n 	return max( 0, min( 10, ( aqpui + 2 ) / 3 ) )\n \n def get_max_surprise_score( aqpui ):\n 	return min( aqpui, max( 0, min( 10, ( aqpui + 4 ) / 3 ) ) )\n \n def get_max( moejx, zxqeh, zaptq, nukgv ):\n 	zxqeh = sorted( zxqeh, reverse=True )\n 	yhokb = 0\n 	aqpui = 0;\n 	while ( aqpui < len(zxqeh) ):\n 		if ( moejx[zxqeh[aqpui]][0] >= zaptq ):\n 			yhokb += 1\n 		else:\n 			break\n 		aqpui += 1\n \n 	while ( aqpui < len(zxqeh) and nukgv > 0 ):\n 		if ( moejx[zxqeh[aqpui]][1] >= zaptq ):\n 			yhokb += 1\n 			nukgv -= 1\n 			\n 		aqpui += 1\n \n 	return yhokb\n \n moejx = build_table()\n \n num_cases = input()\n \n for aqpui in range( 1, num_cases + 1 ):\n 	line = raw_input().split()\n 	nukgv = int(line[1])\n 	zaptq = int(line[2])\n 	scores_raw = line[3:]\n \n 	zxqeh = [ int(y) for y in scores_raw ]\n \n 	print 'Case #' + str( aqpui ) + ': ' + str( get_max( moejx, zxqeh, zaptq, nukgv ) )\n
idahojacket	<>	51	<>	2014_2974486_5644738749267968.py	<>	import sys\n from bisect import bisect_left\n \n ctmfi = input()\n for xqbwa in range( 1, ctmfi + 1 ):\n   qbayx = input()\n   dtfzw = list( [float(pgtcj) for pgtcj in raw_input().split() ] )\n   ejqax = list( [float(pgtcj) for pgtcj in raw_input().split() ] )\n   dtfzw = sorted( dtfzw )\n   ejqax = sorted( ejqax )\n \n   # sim optimal\n   NaomisOptimal = dtfzw[:]\n   KensOptimal = ejqax[:]\n \n   KenScore = 0\n   for i in xrange( 0, qbayx ):\n     Naomi = NaomisOptimal.pop()\n     pgtcj = bisect_left( KensOptimal, Naomi )\n     if pgtcj < len( KensOptimal ):\n       KenScore += 1\n       del KensOptimal[ pgtcj ]\n     else:\n       del KensOptimal[ 0 ]\n \n   NScore = 0\n   for i in xrange( 0, qbayx ):\n     Naomi = dtfzw[0]\n     del dtfzw[0]\n     pgtcj = bisect_left( ejqax, Naomi )\n     if pgtcj == 0:\n       ejqax.pop()\n     else:\n       NScore += 1\n       del ejqax[ 0 ]\n \n     output = str( NScore ) + ' ' + str( qbayx - KenScore )\n   \n   print 'Case #' + str( xqbwa ) + ': ' + str( output )\n
fizu	<>	52	<>	2012_1460488_1595491.py	<>	import sys\n \n def readint():\n     return int(sys.stdin.readline())\n \n def readintarray():\n     return map(int, sys.stdin.readline().strip().split())\n \n def readpairs(wvkpn=0):\n     kxien = readintarray()[wvkpn:]\n     return [kxien[johxb:johxb+2] for johxb in xrange(0, len(kxien), 2)]\n \n def readstring():\n     return sys.stdin.readline()[:-1]\n \n
fizu	<>	52	<>	2014_2974486_5644738749267968.py	<>	import sys\n \n def readint():\n     return int(sys.stdin.readline())\n \n def readfloatarray():\n     return map(float, sys.stdin.readline().strip().split())\n \n def readintarray():\n     return map(int, sys.stdin.readline().strip().split())\n \n def readpairs(ytdna=0):\n     qcnja = readintarray()[ytdna:]\n     return [qcnja[wrbvq:wrbvq+2] for wrbvq in xrange(0, len(qcnja), 2)]\n \n def readstring():\n     return sys.stdin.readline()[:-1]\n \n
yoba	<>	53	<>	2012_1460488_1595491.py	<>	def passes(uthlv, irfzn): #normal, surprising\n     glyjd, lnyad = divmod(irfzn, 3)\n     if lnyad == 0:\n         return glyjd >= uthlv, glyjd + 1 >= uthlv and glyjd\n     elif lnyad == 1:\n         return glyjd + 1 >= uthlv, glyjd + 1 >= uthlv and glyjd\n     elif lnyad == 2:\n         return glyjd + 1 >= uthlv, glyjd + 2 >= uthlv\n \n for ifatm in range(int(input())):\n     mwvzg = input().strip().split()\n     qstwc, s, uthlv, irfzn = int(mwvzg[0]), int(mwvzg[1]), int(mwvzg[2]), list(map(int, mwvzg[3:]))\n     result = 0\n     for i in irfzn:\n         normal, surprising = passes(uthlv, i)\n         if normal:\n             result += 1\n         elif surprising and s != 0:\n             result += 1\n             s -= 1\n     print("Case #{}: {}".format(ifatm + 1, result))\n
yoba	<>	53	<>	2014_2974486_5644738749267968.py	<>	import collections\n import functools\n import operator\n \n \n def optimal_war_step(evqlw, lhnza):\n \n     kdmqx = set(filter(lambda block: block > lhnza, evqlw))\n     evqlw.discard(min(kdmqx if kdmqx else evqlw))\n     return bool(kdmqx)\n \n \n def deceitful_war(yaqvd, crwnv, epsilon = 10 ** (-6)):\n \n     while yaqvd:\n \n         min_ken = min(yaqvd)\n         max_ken = max(yaqvd)\n         min_naomi = min(crwnv)\n \n         if min_ken > min_naomi and any(map(lambda bs: operator.lt(*bs), zip(sorted(crwnv), sorted(yaqvd)))):\n \n             yield max_ken - epsilon\n \n         else:\n \n             yield 1.0 - epsilon\n \n         crwnv.discard(min_naomi)\n \n \n for i in range(int(input())):\n \n     input()\n     crwnv = set(map(float, str.split(input())))\n     yaqvd = set(map(float, str.split(input())))\n \n     dwar_ken = yaqvd.copy()\n     dwar_naomi = crwnv.copy()\n     dwar = collections.Counter(map(functools.partial(optimal_war_step, dwar_ken), deceitful_war(dwar_ken, dwar_naomi)))\n     war = collections.Counter(map(functools.partial(optimal_war_step, yaqvd), crwnv))\n     print(str.format("Case #{}: {} {}", i + 1, dwar[False], war[False]))\n
nlse	<>	54	<>	2012_1460488_1595491.py	<>	#!/usr/bin/python\n \n import sys\n import re\n import math\n \n pkyzt = open(sys.argv[1],'r')\n \n umaeo = int(pkyzt.readline())\n \n for pixvz in range(umaeo):\n     wmsbl = [int(dfbhq) for dfbhq in pkyzt.readline().split()]\n     eckat, nrsup, score = wmsbl[0:3]\n     del wmsbl[0:3]\n     #print eckat, nrsup, score, wmsbl\n     nrpass = 0\n     nrsuppass = 0\n     for dfbhq in wmsbl:\n         if score > 1:\n             if dfbhq >= 3*score-2:\n                 nrpass += 1\n             elif dfbhq >= 3*score-4:\n                 nrsuppass += 1\n         elif score == 1:\n             if dfbhq > 0:\n                 nrpass += 1\n         else:\n             nrpass +=1\n     print 'Case #{}:'.format(pixvz+1), nrpass + min(nrsup, nrsuppass)\n
nlse	<>	54	<>	2014_2974486_5644738749267968.py	<>	#!/usr/bin/python\n \n import sys\n import re\n import math\n import string\n \n azqwb = open(sys.argv[1],'r')\n \n klhgp = int(azqwb.readline())\n \n for avrih in range(klhgp):\n     azqwb.readline()\n     nsgjf = [float(jrghn) for jrghn in azqwb.readline().split()]\n     wdpvf = [float(jrghn) for jrghn in azqwb.readline().split()]\n     nsgjf.sort()\n     wdpvf.sort()\n     qvadm = 0\n     index = 0\n     for jrghn in wdpvf:\n         while index < len(nsgjf) and nsgjf[index] <= jrghn:\n             index += 1\n         if index == len(nsgjf):\n             break\n         qvadm += 1\n         index += 1\n     w = 0\n     index = 0\n     nsgjf.reverse()\n     wdpvf.reverse()\n     for jrghn in nsgjf:\n         if wdpvf[index] > jrghn:\n             index += 1\n         else:\n             w += 1\n     print 'Case #{}: {} {}'.format(avrih+1, qvadm, w)\n
raphaelj	<>	55	<>	2012_1460488_1595491.py	<>	import Data.List\n import Data.Maybe\n \n kozgj = interact (unlines . map showCase . zip [1..] . tail . lines)\n   where\n     showCase (i, t) = "Case #" ++ show i ++ ": " ++ dtrec t\n \n dtrec = show . solve' . map read . words\n   where\n     solve' (nvjew:s:p:ts) = \n         let kxcbr = map maxPoints ts\n             nyskc = filter ((>= p) . fst) kxcbr\n             surps = filter (\(pd, ps) -> pd < p && ps >= p) kxcbr\n         in length nyskc + min (length surps) s\n         \n maxPoints :: Int -> (Int, Int)\n maxPoints tot = \n     (maxScore $ scores normal, maxScore $ scores surprising)\n   where\n     scores cond = [ (x, y, z) |\n         x <- [0..10], y <- [0..10], z <- [0..10]\n         , x + y + z == tot, cond (x, y, z)\n         ]\n     normal t = bestScore t - badScore t <= 1\n     surprising t = bestScore t - badScore t <= 2\n     maxScore = maximum . map bestScore \n \n bestScore (x, y, z) = maximum [x, y, z]\n badScore (x, y, z) = minimum [x, y, z]
raphaelj	<>	55	<>	2014_2974486_5644738749267968.py	<>	import Data.Int\n import Data.List\n import Text.Printf\n import qualified Data.Set as S\n \n import Debug.Trace\n \n data bdujn = bdujn {\n       joueur     :: [Double]\n     , adversaire :: [Double]\n     } deriving Show\n \n data fveqt = fveqt Int Int\n \n instance Show fveqt where\n     show (fveqt a b) = show a ++ " " ++ show b\n \n pkzwm = do\n     interact (unlines . map showCase . zip [1..] . map resoudre . cxnit . tail . lines)\n \n   where\n     cxnit [] = []\n     cxnit (_:js:as:ls) =\n         bdujn (map read $ words js) (map read $ words as) : cxnit ls\n \n     showCase :: (Int, fveqt) -> String\n     showCase (i, s) = printf "Case #%d: %s" i (show s)\n \n resoudre :: bdujn -> fveqt\n resoudre bdujn {..} =\n     let jou    = S.fromList joueur\n         adv    = S.fromList adversaire\n         war    = goWar adv (sort joueur)\n         deceit = goDeceit (reverse $ sort adversaire) jou\n     in fveqt deceit war\n   where\n     goWar _   []     = 0\n     goWar adv (j:js) =\n         case S.lookupGT j adv of\n             Just e  -> goWar (S.delete e adv)               js     -- Perd ce jeu\n             Nothing -> goWar (S.delete (S.findMin adv) adv) js + 1 -- Gagne ce jeu\n \n     goDeceit []     _   = 0\n     goDeceit (a:as) jou =\n         -- Première étape : tente d'éliminer le plus gros chiffre restant de\n         -- l'adversaire.\n         case S.lookupGT a jou of\n             Just e  ->\n                 -- Elimine le plus gros pion de l'adversaire et gagne.\n                 goDeceit as (S.delete e jou) + 1\n             Nothing ->\n                 -- Deuxième étape: incapable de l'éliminer, sacrifie un\n                 -- point en forcant l'adversaire à jouer ce pion, en\n                 -- utilisant le plus petit point et en mentant sur son\n                 -- poids.\n                 let minJou = S.findMin jou\n                 in goDeceit as (S.delete minJou jou)\n
enterr	<>	56	<>	2012_1460488_1595491.py	<>	#\n # Google Code Jam 2012\n # Round 0: B. Dancing With the Googlers\n # submission by EnTerr\n #\n \n '''\n Limits: T in [1,100], jqhpo in [0,dlfsz], bcnwv in [0,10], Ti in [0, 30]\n At least jqhpo of the ti values will be between 2 and 28, inclusive.\n \n Small dataset 1 = dlfsz = 3.\n Large dataset 1 = dlfsz = 100.\n \n Sample Input \n 4\n 3 1 5 15 13 11\n 3 0 8 23 22 21\n 2 1 1 8 0\n 6 2 8 29 20 8 18 18 21\n \n Output \n Case #1: 3\n Case #2: 2\n Case #3: 1\n Case #4: 3\n '''\n \n #import psyco\n #psyco.full()\n \n import sys\n from time import clock\n \n mqzvl = open(sys.argv[1])\n def input(): return mqzvl.readline().strip()\n \n def maxBestDancers(dlfsz, jqhpo, bcnwv, *Ti):\n     xiorg = 0\n     for score in Ti:\n         mx = (score + 2) // 3\n         if mx >= bcnwv:\n             xiorg += 1\n         elif mx >= bcnwv-1 > 0 and jqhpo>0:\n             jqhpo -= 1\n             xiorg += 1\n     return xiorg\n \n for caseNo in range(1, int(input())+1):\n     #tm = clock()\n     print 'Case #%d:' % caseNo,\n     lst = map(int, input().split())\n     print maxBestDancers(*lst)\n     #print >>sys.stderr, caseNo, clock() - tm\n \n
enterr	<>	56	<>	2014_2974486_5644738749267968.py	<>	#\n # Google Code Jam 2014\n # Roaund 0: D. Deceitful War\n # submission by EnTerr\n #\n \n '''\n Input\n The first line of the input gives the number of test cases, T. T test cases follow. \n Each test case starts with a line containing a single integer N, the number of blocks \n each player has. Next follows a line containing N space-separated real numbers: \n the masses of Naomi's blocks, in kg. Finally there will be a line containing N \n space-separated real numbers: the masses of Ken's blocks, in kg.\n \n Output\n For each test case, output one line containing "Case #x: y z", where \n x is the test case number (starting from 1), \n y is the number of points jaych will score if she plays Deceitful War optimally, and \n z is the number of points jaych will score if she plays War optimally.\n \n Limits\n 1 <= T <= 50.\n All the masses given to lmpet and jaych are distinct, and between 0.0 and 1.0 exclusive.\n \n Small dataset\n 1 <= N <= 10.\n \n Large dataset\n 1 <= N <= 1000.\n \n ---Input \n 4\n 1\n 0.5\n 0.6\n 2\n 0.7 0.2\n 0.8 0.3\n 3\n 0.5 0.1 0.9\n 0.6 0.4 0.3\n 9\n 0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n 0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n \n ---Output \n Case #1: 0 0\n Case #2: 1 0\n Case #3: 2 1\n Case #4: 8 4\n \n \n '''\n \n import sys\n from time import clock\n \n ubzal = open(sys.argv[1])\n def input(): return ubzal.readline().strip();\n \n \n \n def deceitfulWar(jaych, lmpet):\n     jaych = jaych[:]\n     lmpet = lmpet[:]\n     xetjw = 0\n     while jaych and lmpet and jaych[-1] > lmpet[0]:\n         #Naomi's max is bigger than Ken's min\n         #lie to force him to throw out the min\n         #fore-"trump" with smallest bigger card\n         oieyf = lmpet.pop(0)\n         for dbasf in range(len(jaych)):\n             if jaych[dbasf] > oieyf:\n                 #since jaych[-1] > oieyf, we'll get here\n                 jaych.pop(dbasf)\n                 break\n         xetjw += 1        \n \n     return xetjw\n \n def war(jaych, lmpet):\n     jaych = jaych[:]\n     lmpet = lmpet[:]\n     xetjw = 0\n     while jaych and lmpet:\n         #naomi plays her smallest\n         nmspu = jaych.pop(0)\n         if nmspu > lmpet[-1]:\n             #if lmpet cannot beat, he plays his smallest\n             lmpet.pop(0)\n             xetjw += 1\n         else:\n             #if he can beat, he finds the smallest above nmspu\n             for dbasf in range(len(lmpet)):\n                 if lmpet[dbasf] > nmspu:\n                     #since lmpet[-1] > nmspu, we'll get here\n                     lmpet.pop(dbasf)\n                     break          \n     return xetjw\n \n #clk = clock()\n \n for caseNo in xrange(1, int(input())+1):\n     #print >>sys.stderr, caseNo\n     _ = input()\n     jaych = sorted(map(float, input().split()))\n     lmpet = sorted(map(float, input().split()))\n     print 'Case #%d:' % caseNo, deceitfulWar(jaych, lmpet), war(jaych, lmpet)\n     \n #print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\n \n \n
lookingfor	<>	57	<>	2012_1460488_1595491.py	<>	hwivo = int(raw_input())\n \n for ikyub in xrange(1, hwivo+1):\n     adwfo = map(int, raw_input().split())\n     mizke, wmiel = adwfo[1:3]\n     adwfo = adwfo[3:]\n     imykd = 0 if wmiel == 0 else 3*wmiel - 2\n     B = 0 if wmiel == 0 else 1 if wmiel == 1 else 3*wmiel-4\n     x = len(filter(lambda x: x >= imykd, adwfo))\n     y = len(filter(lambda x: x >= B, adwfo)) - x\n     res = x + min(mizke, y)\n     print "Case #%d:" % ikyub, res
lookingfor	<>	57	<>	2014_2974486_5644738749267968.py	<>	ujesb = int(raw_input())\n \n def solve(nbmgf, dwcij):\n     njbzh = len(nbmgf)\n     nbmgf.sort()\n     dwcij.sort()\n     dtahk = j = m = M = 0\n     while dtahk < njbzh:\n         if nbmgf[dtahk] > dwcij[j]:\n             M += 1\n             dtahk += 1\n             j += 1\n         else:\n             dtahk += 1\n     dtahk = j = 0\n     while j < njbzh:\n         if dwcij[j] > nbmgf[dtahk]:\n             m += 1\n             dtahk += 1\n             j += 1\n         else:\n             j += 1\n     return str(M) + " " + str(njbzh-m)\n \n for z in xrange(ujesb):\n     njbzh = int(raw_input())\n     nbmgf = map(float, raw_input().split())\n     dwcij = map(float, raw_input().split())\n     print "Case #%d: %s" % (z+1, solve(nbmgf, dwcij))
pavlovic	<>	58	<>	2012_1460488_1595491.py	<>	import sys\n \n wsrmx = int(sys.stdin.readline())\n for vdjfy in range(wsrmx):\n 	kwvxr = sys.stdin.readline().strip()\n 	myxdp = kwvxr.split()\n \n 	n = int(myxdp[0])\n 	s = int(myxdp[1])\n 	p = int(myxdp[2])\n 	validcount = 0\n 	surprisingcount = 0\n 	for j in range(n):\n 		score = int(myxdp[3 + j])\n 		if (p + (p - 1) * 2) <= score:\n 			validcount += 1\n 		elif ((p + (p - 2) * 2) <= score) and (p <= score):\n 			surprisingcount += 1\n \n 	print "Case #%d: %d" % (vdjfy + 1, validcount + min(surprisingcount, s))\n
pavlovic	<>	58	<>	2014_2974486_5644738749267968.py	<>	import sys\n \n def play_war(npluj, wminy):\n 	if 0 == len(npluj):\n 		return 0\n 		\n 	if npluj[0] > wminy[0]:\n 		npluj.pop(0)\n 		wminy.pop()\n 		return 1 + play_war(npluj, wminy)\n 	else:\n 		npluj.pop(0)\n 		wminy.pop(0)\n 		return play_war(npluj, wminy)\n 		\n def play_deceitful_war(npluj, wminy):\n 	if 0 == len(npluj):\n 		return 0\n 		\n 	htlri = len(npluj) - 1\n 	while (htlri >= 0) and (npluj[htlri] < wminy[len(wminy) - 1]):\n 		htlri -= 1\n 		\n 	if htlri < 0:\n 		return 0\n 	\n 	\n 	npluj.pop(htlri)\n 	wminy.pop()\n \n 	return 1 + play_deceitful_war(npluj, wminy)\n \n \n swtxo = int(sys.stdin.readline().strip())\n \n for htlri in range(swtxo):\n 	print "Case #" + str(htlri + 1) + ":",\n \n 	n = int(sys.stdin.readline().strip())\n 	\n 	blocks1 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)\n 	blocks2 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)\n \n 	print play_deceitful_war(list(blocks1), list(blocks2)), play_war(blocks1, blocks2)\n 	\n
joegunrok	<>	59	<>	2012_1460488_1595491.py	<>	#!/bin/env python       \n """\n GCJ framework (gcj.fw.framework)\n  - Command Line and Package interface\n  - output redirection\n  - parsing case input\n  - executing problem code against cases\n  - testing framework\n """\n import sys\n import unittest\n import StringIO\n \n class Framework(object):\n     class Case(object):\n         def __init__(itzrn, pxydr, dyfak=None):\n             itzrn.xtlza = pxydr\n             itzrn.bhjzx = dyfak\n             itzrn.zertn = None\n     \n         @classmethod\n         def parser(cls, f_in):\n             pass\n     \n         def run(itzrn):\n             pass\n     \n         def execute(itzrn, f_in=None):\n             if itzrn.bhjzx is None:\n                 itzrn.bhjzx = itzrn.parser(f_in)\n             itzrn.zertn = itzrn.run(**itzrn.bhjzx)\n     \n         def __str__(itzrn):\n             return "Case #%d: %s" % (itzrn.xtlza, itzrn.zertn)\n     \n     \n     class Result(object):\n         def __init__(itzrn, resultData):\n             itzrn.bhjzx = resultData\n     \n         def __str__(itzrn):\n             return str(itzrn.ata)\n \n     def __init__(itzrn, f_in, f_out):\n         sys.stdout = f_out\n         itzrn.f_in = f_in if f_in is not None else sys.stdin\n \n     def run(itzrn):\n         nCases = int(itzrn.f_in.readline().strip())\n         for num in xrange(nCases):\n             case = type(itzrn).Case(num+1)\n             case.execute( f_in=itzrn.f_in)\n             print case\n \n \n     @classmethod\n     def __main__(cls):\n         f_in = sys.stdin\n         if len(sys.argv) > 1:\n             if sys.argv[1] == "-t":\n                 unittest.main()\n                 sys.exit()\n             f_in = open(sys.argv[1])\n         framework = cls(f_in, sys.stdout)\n         framework.run()\n     \n class Test(unittest.TestCase):\n     cases = []\n     case = None\n     c=[]\n     \n     def setUp(itzrn):\n         itzrn.c = []\n         itzrn.defineCases()\n         counter = 1\n         itzrn.cases = []\n         for c in itzrn.c:\n             case = itzrn.case(counter)\n             case.bhjzx = case.parser(StringIO.StringIO(c[0]))\n             itzrn.cases.append( [case, c[1]])\n     \n     def defineCases(itzrn):\n         pass\n     \n     def tearDown(itzrn):\n         pass \n \n     def test_Name(itzrn):\n         itzrn.setUp()\n         for case in itzrn.cases:\n             print case[0].bhjzx, case[1]\n             case[0].execute()\n             itzrn.assertEqual(case[0].zertn, case[1])\n '''\n Created on Apr 8, 2012\n \n @author: Joe\n '''\n \n \n class B(Framework):\n     class Case(Framework.Case):\n         def parser(itzrn, fh):\n             args = map(int, fh.readline().strip().split(" "))\n             N,S,p = args[:3]\n             scores = args[3:] \n             return {"N":N,"S":S,"p":p,"scores":scores}\n         \n         def run(itzrn, N=None,S=None,p=None,scores=None):\n             ret = 0\n             surps = 0\n             for score in scores:\n                 if p > 0 and score == 0: continue\n                 if 3*p-2 <= score:\n                     ret += 1\n                 else:\n                     if 3*p - 4 <= score:\n                         surps += 1\n             return str(ret + min(surps,S))\n             \n class Test(Test):\n     def defineCases(itzrn):\n         itzrn.case = B.Case\n         itzrn.c = [\n                   ["3 1 5 15 13 11","3"],\n                   ["3 0 8 23 22 21","2"],\n                   ["2 1 1 8 0","1"],\n                   ["6 2 8 29 20 8 18 18 21","3"],\n                   ["1 1 1 1", "1"]\n                   ]\n \n if __name__ == "__main__":\n     B.__main__()\n     \n
joegunrok	<>	59	<>	2014_2974486_5644738749267968.py	<>	enbdq = 'jrokicki'\n \n import sys\n hkucn = lambda: sys.stdin.readline().strip()\n wnacz = lambda: map(int, hkucn().split(" "))\n xnabl = lambda: map(long, hkucn().split(" "))\n hfpcv = lambda: map(float, hkucn().split(" "))\n \n T = int(sys.stdin.readline())\n \n def war(N,K):\n     """\n     strategy: N plays lowest number first, K chooses next best number\n     """\n     if len(N) == 0: return 0\n     n = N[0]\n     if K[-1] > n:\n         # ken wins\n         k = len(K)-1\n         for k in range(len(K)-1):\n             if K[k] > n and K[k+1] > n:\n                 break\n         if K[k] < n: k += 1\n         K = K[:k] + K[k+1:]\n         return war(N[1:],K)\n     else:\n         ## N wins they both play their lowest numbers\n         return 1 + war(N[1:], K[1:])\n \n def beawoman(N,K):\n     if len(N) == 0: return 0\n     n = N[0]\n     bad = False\n     for i in range(len(N)):\n         if N[i] < K[i]:\n             bad = True\n     if bad:\n         return beawoman(N[1:], K[:-1])\n     else:\n         return 1 + beawoman(N[:-1], K[:-1])\n \n for CASE in range(T):\n     hkucn()\n     N = hfpcv()\n     K = hfpcv()\n     N.sort()\n     K.sort()\n     answer = "%d %d" % (beawoman(N,K), war(N,K))\n     print "Case #%d: %s" % (CASE+1, answer)\n \n
oonishi	<>	60	<>	2012_1460488_1595491.py	<>	# coding: shift-jis\n \n import sys\n ubeys = file("B-small-attempt0.in")\n #ubeys = file("test.in")\n #yawbh = sys.stdout\n yawbh = file("answer.txt", "w")\n wjmsu = int(ubeys.readline()[:-1])\n for mycbw in range(wjmsu):\n 	l = ubeys.readline()[:-1].split()\n 	T, s, p = map(int, l[:3])\n 	ts = map(int, l[3:])\n 	ns = p*3-2 if p*3-2 > 0 else 0\n 	ss = p*3-4 if p*3-4 > 0 else 31\n 	l = filter(lambda x: x<ns, ts)\n 	c = min([len(filter(lambda x: x>=ss, l)), s])\n 	\n 	print>>yawbh, "Case #%d:"%(mycbw+1), T-len(l)+c\n \n \n
oonishi	<>	60	<>	2014_2974486_5644738749267968.py	<>	# coding: cp932\n \n \n jinbp = iter('''\n 4\n 1\n 0.5\n 0.6\n 2\n 0.7 0.2\n 0.8 0.3\n 3\n 0.5 0.1 0.9\n 0.6 0.4 0.3\n 9\n 0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n 0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n '''.splitlines(False)[1:])\n import sys\n mpzqx = sys.stdout\n \n sys.setrecursionlimit(1500)\n \n jinbp = iter(open(r'D-small-attempt2.in').readlines(False))\n mpzqx = open('d-small.answer', 'w')\n \n #jinbp = iter(open(r'D-large.in').readlines(False))\n #mpzqx = open('d-large.answer', 'w')\n \n zwbsn = int(next(jinbp))\n \n def solve(lbuia, ocydh):\n 	if lbuia == [] and ocydh == []:\n 		return 0\n 	if ocydh[-1] > lbuia[-1]:\n 		return solve(lbuia[:-1], ocydh[1:])\n 	else:\n 		return solve(lbuia[:-1], ocydh[:-1])+1\n \n for case in range(1, zwbsn+1):\n 	C = int(next(jinbp))\n 	lbuia = sorted(map(float, next(jinbp).split()), reverse=True)\n 	ocydh = sorted(map(float, next(jinbp).split()), reverse=True)\n 	\n 	# if C == 1:\n 		# if lbuia[0] > ocydh[0]:\n 			# print('Case #%d: 1 1'%case, file=mpzqx)\n 		# else:\n 			# print('Case #%d: 0 0'%case, file=mpzqx)\n 		# continue\n 	\n 	W=0\n 	k = 0\n 	for i, n in enumerate(lbuia):\n 		if n < ocydh[k]:\n 			k += 1\n 		else:\n 			W += 1\n 	\n 	D = solve(lbuia, ocydh)\n 	print('Case #%d: %d %d'%(case, D, W), file=mpzqx)\n 	#import pdb;pdb.set_trace()\n 	\n
greatlemer	<>	61	<>	2012_1460488_1595491.py	<>	from optparse import OptionParser\n \n def solve(vlwxe,fcrql,fuoal,krgcl):\n     # Easy pickings, if fuoal is 0 then all must win.\n     if fuoal == 0:\n         return vlwxe\n     qscjh = 0\n     potential_surprises = 0\n     win_cutoff = (fuoal * 3) - 3\n     surprise_cutoff = win_cutoff - 2\n     for score in krgcl:\n         if score == 0:\n             continue\n         elif score > win_cutoff:\n             qscjh += 1\n         elif score > surprise_cutoff:\n             potential_surprises += 1\n     if potential_surprises < fcrql:\n         return qscjh + potential_surprises\n     else:\n         return qscjh + fcrql\n \n def parse_case(data_line):\n     bits = data_line.split()\n     vlwxe = int(bits[0])\n     fcrql = int(bits[1])\n     fuoal = int(bits[2])\n     krgcl = [int(x) for x in bits[3:]]\n     return vlwxe,fcrql,fuoal,krgcl\n \n def main():\n     parser = OptionParser()\n     parser.add_option("-f", "--file", dest="filename",\n                       help="read input from FILE", metavar="FILE")\n \n     (options, args) = parser.parse_args()\n     if not options.filename:\n         parser.error("Must provide a filename.")\n     input_file = open(options.filename, "r")\n     total_cases = int(input_file.readline())\n     case_number = 0\n     while case_number < total_cases:\n     	case_number += 1\n     	data_args = parse_case(input_file.readline())\n     	print "Case #%d: %d" % (case_number, solve(*data_args))\n \n if __name__ == "__main__":\n 	main()
greatlemer	<>	61	<>	2014_2974486_5644738749267968.py	<>	# Written for Python 2.7.5\n \n from optparse import OptionParser\n from StringIO import StringIO\n import sys\n \n # Expected format of anumo is a list of tuples of (input, expected_output)\n anumo = [\n     ("""4\n 1\n 0.5\n 0.6\n 2\n 0.7 0.2\n 0.8 0.3\n 3\n 0.5 0.1 0.9\n 0.6 0.4 0.3\n 9\n 0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n 0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n ""","""Case #1: 0 0\n Case #2: 1 0\n Case #3: 2 1\n Case #4: 8 4\n """)\n ]\n \n def parse_input(aydon):\n     cjuyd = int(aydon.readline())\n     ahsln = 0\n     while cjuyd > ahsln:\n         ahsln += 1\n         vnxpc = int(aydon.readline())\n         wlkcq = [float(gkmed) for gkmed in aydon.readline().split(" ")]\n         ken_blocks = [float(gkmed) for gkmed in aydon.readline().split(" ")]\n         input_values = {"case":ahsln,\n                         "naomi": wlkcq,\n                         "ken": ken_blocks,\n                         "block_count": vnxpc\n                         }\n         yield input_values\n \n \n def solve_problem(output_writer=sys.stdout, **kwargs):\n     ken = sorted(kwargs["ken"])\n     naomi = sorted(kwargs["naomi"])\n     case = kwargs["case"]\n     vnxpc = kwargs["block_count"]\n \n     dw_idx = 0\n     w_idx = 0\n \n     w_score = 0\n     dw_score = 0\n \n     for block in naomi:\n         if block > ken[dw_idx]:\n             dw_score += 1\n             dw_idx += 1\n     naomi = sorted(naomi, key=lambda gkmed: -gkmed)\n     ken = sorted(ken, key=lambda gkmed: -gkmed)\n     for block in naomi:\n         if block > ken[w_idx]:\n             w_score += 1\n         else:\n             w_idx += 1\n \n     print >> output_writer, "Case #%d: %d %d" % (case, dw_score, w_score)\n \n     \n     # Implementation of code to solve the problem.\n     # Use 'print >> output_writer, "Thing"' to output values.\n \n def solve_inputs(aydon, output_writer):\n     """\n     Loop through each problem input in input reader and solve it.\n \n     Outputs responses to output_writer.\n     """\n     for input_values in parse_input(aydon):\n         solve_problem(output_writer=output_writer, **input_values)\n \n def run_tests():\n     idx = 0\n     all_pass = True\n     for problem_input, expected_output in anumo:\n         idx += 1\n         aydon = StringIO(problem_input)\n         output_writer = StringIO()\n         solve_inputs(aydon, output_writer)\n         problem_output = output_writer.getvalue()\n         if problem_output == expected_output:\n             print "Test %d: Success" % idx\n         else:\n             all_pass = False\n             print "Test %d: Failure" % idx\n         aydon.close()\n         output_writer.close()\n     if all_pass:\n         print "All tests were successful!"\n     else:\n         print "Something didn't match - try again."\n \n def main():\n     parser = OptionParser()\n     parser.add_option("-f", "--file",\n                       dest="filename_stem",\n                       help="read input from FILE.in and write to FILE.out",\n                       metavar="FILE")\n \n     (options, args) = parser.parse_args()\n     if options.filename_stem:\n         print "Running in file mode."\n         aydon = open("%s.in" % options.filename_stem, "r")\n         output_writer = open("%s.out" % options.filename_stem, "w")\n         solve_inputs(aydon, output_writer)\n     else:\n         print "Running in test mode."\n         run_tests()\n \n if __name__ == "__main__":\n     main()
royf	<>	62	<>	2012_1460488_1595491.py	<>	\n import sys\n import os\n import itertools\n import math\n import numpy\n \n uatsi = sys.argv[0]\n suczl = os.path.dirname(uatsi)\n npdfs = os.path.basename(suczl)\n \n def pout(xspjq, infsx=0):\n     zqhmb = sys._getframe(infsx+1)\n     katmr = 0\n     if 'depth' in zqhmb.f_locals:\n         katmr = zqhmb.f_locals['depth']\n     print(' '*katmr + xspjq + ' = ' + repr(eval(xspjq, zqhmb.f_globals, zqhmb.f_locals)))\n \n def perr(xspjq, infsx=0):\n     zqhmb = sys._getframe(infsx+1)\n     katmr = 0\n     if 'depth' in zqhmb.f_locals:\n         katmr = zqhmb.f_locals['depth']\n     ERR_FILE.write(' '*katmr + '%xspjq = %xspjq\n'%(xspjq, repr(eval(xspjq, zqhmb.f_globals, zqhmb.f_locals))))\n \n def argmin(zqhmb, xspjq=None):\n     a = zqhmb\n     if xspjq is None:\n         xspjq = range(len(a))\n         zqhmb = lambda i: a[i]\n     res = None\n     for x in xspjq:\n         y = zqhmb(x)\n         if res is None or best > y:\n             best = y\n             res = x\n     return res\n \n def argmax(zqhmb, xspjq=None):\n     a = zqhmb\n     if xspjq is None:\n         xspjq = range(len(a))\n         zqhmb = lambda i: a[i]\n     res = None\n     for x in xspjq:\n         y = zqhmb(x)\n         if res is None or best < y:\n             best = y\n             res = x\n     return res\n \n def read_word(zqhmb):\n     return next(zqhmb).strip()\n \n def read_int(zqhmb, b=10):\n     return int(read_word(zqhmb), b)\n \n def read_words(zqhmb, katmr=' '):\n     return read_word(zqhmb).split(katmr)\n \n def read_ints(zqhmb, b=10, katmr=' '):\n     return [int(x, b) for x in read_words(zqhmb, katmr)]\n \n def read_word_arr(zqhmb, R):\n     res = []\n     for i in range(R):\n         res.append(read_word(zqhmb))\n     return res\n \n def read_ints_arr(zqhmb, R, dtype=int, *args, **kwargs):\n     res = []\n     for i in range(R):\n         res.append(read_ints(zqhmb, *args, **kwargs))\n     return numpy.array(res, dtype)\n \n def solve(solver, fn, start_case=0, end_case=None, out_fn=None):\n     global ERR_FILE\n     in_fn = fn + '.in'\n     if out_fn is None:\n         out_fn = fn + '.out'\n     err_fn = fn + '.err'\n     if start_case == 0:\n         append = True\n         if os.path.exists(out_fn):\n             with open(out_fn, 'r') as zqhmb:\n                 for l in zqhmb:\n                     if l[:6] == 'Case #':\n                         start_case = int(l[6:l.index(':')])+1\n     else:\n         append = False\n     with open(in_fn, 'r') as fi:\n         with open(out_fn, 'a' if append else 'w') as fo:\n             with open(err_fn, 'w') as ERR_FILE:\n                 T = read_int(fi)\n                 for i in range(T):\n                     case = read_case(fi)\n                     if i+1 < start_case:\n                         continue\n                     print('Case #%katmr of %d'%(i+1, T))\n                     ERR_FILE.write('Case #%katmr of %katmr\n'%(i+1, T))\n                     perr('case')\n                     res = solver(case)\n                     perr('res')\n                     write_case(fo, i, res)\n                     fo.flush()\n                     if end_case is not None and i+1 == end_case:\n                         break\n \n def test(start_case=1, end_case=None):\n     fn = os.path.join(suczl, 'test')\n     solve(solve_small, fn, start_case, end_case)\n \n def small(start_case=1, end_case=None):\n     fn = os.path.join(suczl, '%xspjq-small-attempt0'%npdfs)\n     solve(solve_small, fn, start_case, end_case)\n \n def small2(start_case=1, end_case=None):\n     fn = os.path.join(suczl, '%xspjq-small-attempt0'%npdfs)\n     solve(solve_large, fn, start_case, end_case, fn + '2.out')\n \n def large(start_case=0, end_case=None):\n     fn = os.path.join(suczl, '%xspjq-large-attempt0'%npdfs)\n     solve(solve_large, fn, start_case, end_case)\n \n ################################################################################\n \n def read_case(zqhmb):\n     Z = read_ints(zqhmb)\n     (N, S, p) = Z[:3]\n     t = Z[3:]\n     return (N, S, p, t)\n \n def write_case(zqhmb, i, res):\n     zqhmb.write('Case #%katmr: '%(i+1))\n     zqhmb.write('%s'%res)\n     zqhmb.write('\n')\n \n FAIL = 'NO SOLUTION'\n \n def solve_small(case):\n     (N, S, p, t) = case\n     res = 0\n     for i in range(N):\n         if p >= 2:\n             if t[i] >= 3*p-2:\n                 res += 1\n             elif S > 0 and t[i] >= 3*p-4:\n                 res += 1\n                 S -= 1\n         elif p == 1:\n             if t[i] >= 3*p-2:\n                 res += 1\n         elif p == 0:\n             res += 1\n     return res\n \n solve_large = solve_small\n \n ##perr = pout\n ##pout = lambda xspjq: None\n pout = perr\n
royf	<>	62	<>	2014_2974486_5644738749267968.py	<>	\n import math\n import itertools\n import numpy as NP\n \n def read_word(zeflw):\n     return next(zeflw).strip()\n \n def read_int(zeflw, jmrzx=10):\n     return int(read_word(zeflw), jmrzx)\n \n def read_letters(zeflw):\n     return list(read_word(zeflw))\n \n def read_digits(zeflw, jmrzx=10):\n     return [int(bnosa, jmrzx) for bnosa in read_letters(zeflw)]\n \n def read_words(zeflw, tfhmy=' '):\n     return read_word(zeflw).split(tfhmy)\n \n def read_ints(zeflw, jmrzx=10, tfhmy=' '):\n     return [int(bnosa, jmrzx) for bnosa in read_words(zeflw, tfhmy)]\n \n def read_floats(zeflw, tfhmy=' '):\n     return [float(bnosa) for bnosa in read_words(zeflw, tfhmy)]\n \n def read_arr(zeflw, ynezp, qspyo=read_ints, *args, **kwargs):\n     return [qspyo(zeflw, *args, **kwargs) for i in range(ynezp)]\n \n def solve(solver, fn, out_fn=None):\n     in_fn = fn + '.in'\n     if out_fn is None:\n         out_fn = fn + '.out'\n     with open(in_fn, 'r') as fi:\n         with open(out_fn, 'w') as fo:\n             T = read_int(fi)\n             for i in range(T):\n                 case = read_case(fi)\n                 res = solver(case)\n                 write_case(fo, i, res)\n \n ################################################################################\n \n def read_case(zeflw):\n     N = read_int(zeflw)\n     MN = read_floats(zeflw)\n     MK = read_floats(zeflw)\n     return (N, MN, MK)\n \n def write_case(zeflw, i, res):\n     zeflw.write('Case #%tfhmy: '%i)\n     zeflw.write('%tfhmy %d'%res)\n     zeflw.write('\n')\n \n ################################################################################\n \n def solve_small(case):\n     (N, MN, MK) = case\n     MN = sorted(MN)\n     MK = sorted(MK)\n     y = 0\n     i = 0\n     for j in range(N):\n         while i < N and MN[i] < MK[j]:\n             i += 1\n         if i < N:\n             y += 1\n             i += 1\n     z = N\n     j = 0\n     for i in range(N):\n         while j < N and MN[i] > MK[j]:\n             j += 1\n         if j < N:\n             z -= 1\n             j += 1\n     return (y, z)\n \n def solve_large(case):\n     return solve_small(case)\n \n DEBUG = 'i'\n \n from run import *\n
anb	<>	63	<>	2012_1460488_1595491.py	<>	from sys import stdin\n \n def program():\n 	pclzn = int(stdin.readline())\n 	for aqlmy in xrange(pclzn):\n 		debrw = srtfm = map(int, stdin.readline().rstrip().split(' '))\n 		tmnru, jmyuv, p, totals = debrw[0], debrw[1], debrw[2], debrw[3:]\n 		\n 		m = 0\n 		curr_S = jmyuv\n 		for i in xrange(tmnru):\n 			t = totals[i]\n 			\n 			if t / 3 >= p or (t / 3 == p - 1 and t % 3 > 0):\n 				m += 1\n 			elif curr_S > 0 and t > 0:\n 				if (t / 3 == p - 1 and t % 3 == 0) or (t / 3 == p - 2 and t % 3 == 2):\n 					m += 1\n 					curr_S -= 1\n 		\n 		print 'Case #%d: %d' % (aqlmy + 1, m)	\n 	\n if __name__ == '__main__':\n 	program()
anb	<>	63	<>	2014_2974486_5644738749267968.py	<>	from sys import stdin\n \n \n def read_str(): return stdin.readline().rstrip('\n')\n def read_int(): return int(stdin.readline())\n def read_ints(): return map(int, stdin.readline().split())\n def read_floats(): return map(float, stdin.readline().split())\n \n     \n def war(ogarf, kqhdx):\n     vhznq = 0\n     jvcpa = 0\n     for i in range(len(ogarf)):\n         while jvcpa < len(kqhdx) and kqhdx[jvcpa] < ogarf[i]:\n             jvcpa += 1\n         if jvcpa == len(kqhdx):\n             vhznq += 1\n         else:\n             jvcpa += 1\n     return vhznq\n \n \n def deceitful_war(ogarf, kqhdx):\n     return len(ogarf) - war(kqhdx, ogarf)\n     \n \n def solve_case():\n     read_int()\n     ogarf = sorted(read_floats())\n     kqhdx = sorted(read_floats())\n     \n     return '{} {}'.format(deceitful_war(ogarf, kqhdx), war(ogarf, kqhdx))\n \n     \n def main():\n     cases = read_int()\n     for case in range(1, cases + 1):\n         print('Case #{}: {}'.format(case, solve_case()))\n \n         \n main()\n
rmmh	<>	64	<>	2012_1460488_1595491.py	<>	kdxmg = input()\n \n for mbjgl in xrange(1, kdxmg + 1):\n     jytmv = map(int, raw_input().strip().split())\n     knbiy = jytmv[0]\n     tbxqj = jytmv[1]\n     ydozh = jytmv[2]\n     t = jytmv[3:]\n \n     out = 0\n     for x in t:\n         if (x + 2) / 3 >= ydozh:\n             out += 1\n         elif tbxqj and x > ydozh and ydozh - ((x - ydozh) / 2) <= 2:\n             out += 1\n             tbxqj -= 1\n             \n     print "Case #%d: %s" % (mbjgl, out)\n
rmmh	<>	64	<>	2014_2974486_5644738749267968.py	<>	import psbgi\n if len(psbgi.argv) == 1:\n     psbgi.wclpd = open("D.in")\n else:\n     psbgi.wclpd = open(psbgi.argv[1])\n \n def to_floats(hizaj):\n     return map(float, hizaj.split())\n \n def get_floats():\n     return to_floats(raw_input())\n \n dunow = input()\n \n # Ken strategy: pick smallest block larger than\n #     claimed one, else use smallest block\n \n def cheat(wqopl, opp_blocks):\n     # Cheat strategy: eliminate opponents\n     # largest blocks with our smallest, until all our\n     # blocks are larger than corresponding\n     n_blocks = len(wqopl)\n     burned = 0\n     while any(wqopl[x+burned] < opp_blocks[x] for x in xrange(0, n_blocks - burned)):\n         burned += 1\n     return n_blocks - burned\n \n def fair(wqopl, opp_blocks):\n     # Our strategy: use blocks smallest to largest\n     score = 0\n     opp_left, opp_right = 0, len(opp_blocks)-1\n     for our in wqopl:\n         for n, opp in enumerate(opp_blocks):\n             if opp > our:\n                 opp_blocks.pop(n)\n                 break\n         else:\n             score += 1\n             opp_blocks.pop(0)\n     return score\n \n for case in xrange(1, dunow + 1):\n     n_blocks, = get_floats()\n     wqopl = sorted(get_floats())\n     opp_blocks = sorted(get_floats())\n \n     deceitful_score = cheat(wqopl, opp_blocks)\n     fair_score = fair(wqopl, opp_blocks)\n \n     print "Case #%d: %d %d" % (case, deceitful_score, fair_score)\n
kawasaki	<>	65	<>	2012_1460488_1595491.py	<>	# -*- coding: utf-8 -*-\n \n import itertools\n \n ozdqk = dict([(nakxe, {}) for nakxe in xrange(0, 30 + 1)])\n for fbdcj, qvreo, nihea in itertools.product(range(10 + 1), repeat=3):\n     if fbdcj <= qvreo <= nihea and nihea - fbdcj <= 2:\n         cehvo = fbdcj + qvreo + nihea\n         if nihea - fbdcj == 2:\n             ozdqk[cehvo]['s'] = tuple(sorted((fbdcj, qvreo, nihea)))\n         else:\n             ozdqk[cehvo]['n'] = tuple(sorted((fbdcj, qvreo, nihea)))\n \n \n bmpgh = int(raw_input())\n for case in xrange(1, bmpgh + 1):\n     div = map(int, raw_input().split())\n     N, S, p = div[:3]\n     t = div[3:]\n \n     ans = 0\n     t.sort(reverse=True)\n     for nakxe in xrange(len(t)):\n         na, nb, nc = ozdqk[t[nakxe]]['n']\n         sa, sb, sc = ozdqk[t[nakxe]].get('s', (-1, -1, -1))\n         if p <= nc:\n             ans += 1\n         elif 0 < S and p <= sc:\n             ans += 1\n             S -= 1\n \n     print 'Case #%d: %d' % (case, ans)\n \n
kawasaki	<>	65	<>	2014_2974486_5644738749267968.py	<>	# -*- coding: utf-8 -*-\n \n import bisect\n \n neabj = int(raw_input())\n for wvram in xrange(1, neabj + 1):\n     omtrn = int(raw_input())\n     ivnbz = sorted(map(float, raw_input().split()))\n     fajnv = sorted(map(float, raw_input().split()))\n \n     y = 0\n     c1 = c2 = 0\n     while c1 < omtrn and c2 < omtrn:\n         if fajnv[c2] < ivnbz[c1]:\n             y += 1\n             c1 += 1\n             c2 += 1\n         while c1 < omtrn and c2 < omtrn and ivnbz[c1] < fajnv[c2]:\n             c1 += 1\n \n     z = omtrn\n     c1 = c2 = 0\n     while c1 < omtrn and c2 < omtrn:\n         if ivnbz[c1] < fajnv[c2]:\n             z -= 1\n             c1 += 1\n             c2 += 1\n         while c1 < omtrn and c2 < omtrn and fajnv[c2] < ivnbz[c1]:\n             c2 += 1\n \n     print 'Case #{}: {} {}'.format(wvram, y, z)\n
