"""\n  Google Code Jam 2012 Problem B\n  Usage:\n      python problem_b.py < input.txt > output.txt\n  """\n  \n  \n  def calc_possible(n):\n      c‍ombinations = itertools.combinations_with_replacement(range(n), 3)  # 3 scores\n      return itertools.ifilter(lambda (x, y, z): x + y + z == n, c‍ombinations)\n  \n  \n  def calc_surprising(n):\n      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) == 2, calc_possible(n)))\n      return results[0] if results else None\n  \n  \n  def calc_normal(n):\n      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) <= 1, calc_possible(n)))\n      return results[0] if results else None\n  \n  \n  def solve_problem():\n      n‍umber_of_cases = int(sys.stdin.readline())\n  \n      for i in xrange(1, n‍umber_of_cases + 1):\n  \n          case = sys.stdin.readline().strip()\n          result = 0\n          n‍um_of_googlers, num_of_surprising, desired_score, scores = case.split(' ', 3)\n          n‍um_of_googlers = int(n‍um_of_googlers)\n          num_of_surprising = int(num_of_surprising)\n          desired_score = int(desired_score)\n          scores = map(int, scores.split())\n  \n          p‌ossible_scores = []\n  \n          for k in xrange(n‍um_of_googlers):\n  \n              normal = calc_normal(scores[k])\n              s​urprising = calc_surprising(scores[k])\n  \n              p‌ossible_scores.append(((normal if normal else (0, 0, 0), 0), (s​urprising if s​urprising else (0, 0, 0), 1)))\n  \n          possible = list(itertools.ifilter(lambda scores: sum(map(lambda x: x[1], scores)) == num_of_surprising, itertools.product(*p‌ossible_scores)))\n          result = max(map(lambda scores: sum(map(lambda x: int(max(x[0]) >= desired_score), scores)) if scores else 0, possible))\n  \n          sys.stdout.write('Case #{0}: {1}\n'.format(i, result))\n  \n  \n  if __name__ == '__main__':\n      solve_problem()\n <CODESPLIT> 0
"""\n  Google Code Jam 2014 Qualification Problem D\n  Usage:\n      python d.py < input.txt > output.txt\n  """\n  \n  \n  def memoized(func):\n      c‍ache = {}\n      def wrapped(*a‌rgs):\n          if not a‌rgs in c‍ache:\n              c‍ache[a‌rgs] = func(*a‌rgs)\n          return c‍ache[a‌rgs]\n      return wrapped\n  \n  \n  @memoized\n  def play_dwar(n‍aomi_blocks, k​en_blocks):\n      if not n‍aomi_blocks:\n          return 0\n  \n      m‍ax_score = 0\n  \n      for n‌aomi_choice in n‍aomi_blocks:\n          naomi_remaining = tuple(b for b in n‍aomi_blocks if b != n‌aomi_choice)\n  \n          k‍en_better = tuple(b for b in k​en_blocks if b > n‌aomi_choice)\n          ken_worse = tuple(b for b in k​en_blocks if b < n‌aomi_choice)\n  \n          if k‍en_better and not ken_worse:\n              ken_choice = max(k‍en_better)\n              ken_remaining = tuple(b for b in k​en_blocks if b != ken_choice)\n              score = 0 + play_dwar(naomi_remaining, ken_remaining)\n          else:\n              ken_remaining = tuple(b for b in k​en_blocks if b != min(k​en_blocks))\n              score = 1 + play_dwar(naomi_remaining, ken_remaining)\n  \n          m‍ax_score = max(m‍ax_score, score)\n  \n      return m‍ax_score\n  \n  \n  @memoized\n  def play_war(n‍aomi_blocks, k​en_blocks):\n      if not n‍aomi_blocks:\n          return 0\n  \n      m‍ax_score = 0\n  \n      for n‌aomi_choice in n‍aomi_blocks:\n          naomi_remaining = tuple(b for b in n‍aomi_blocks if b != n‌aomi_choice)\n  \n          k‍en_better = tuple(b for b in k​en_blocks if b > n‌aomi_choice)\n  \n          if k‍en_better:\n              ken_choice = min(k‍en_better)\n              ken_remaining = tuple(b for b in k​en_blocks if b != ken_choice)\n              score = 0 + play_war(naomi_remaining, ken_remaining)\n          else:\n              ken_remaining = tuple(b for b in k​en_blocks if b != min(k​en_blocks))\n              score = 1 + play_war(naomi_remaining, ken_remaining)\n  \n          m‍ax_score = max(m‍ax_score, score)\n  \n      return m‍ax_score\n  \n  \n  def solve_problem(n‍aomi_blocks, k​en_blocks):\n      return play_dwar(n‍aomi_blocks, k​en_blocks), play_war(n‍aomi_blocks, k​en_blocks)\n  \n  \n  if __name__ == "__main__":\n      num_of_cases = int(sys.stdin.readline().strip())\n      for i in xrange(1, num_of_cases + 1):\n  \n          num_of_blocks = int(sys.stdin.readline().strip())\n  \n          n‍aomi_blocks = tuple(map(float, sys.stdin.readline().strip().split()))\n          k​en_blocks = tuple(map(float, sys.stdin.readline().strip().split()))\n  \n          print "Case #{0}: {1} {2}".format(i, *solve_problem(n‍aomi_blocks, k​en_blocks))\n <CODESPLIT> 0
t = int(raw_input().strip())\n  t‌_count = 1\n  while t‌_count <= t:\n  	l‍ine = raw_input().strip().split()\n  	n = int(l‍ine[0])\n  	s = int(l‍ine[1])\n  	p = int(l‍ine[2])\n  	t‌i_list = l‍ine[3:]\n  	p​_min = max(p * 3 - 2, p)\n  	p​_min_surprise = max(p * 3 - 4, p)\n  	result = 0\n  	for ti in t‌i_list:\n  		ti = int(ti)\n  		if ti >= p​_min:\n  			result += 1\n  		elif p​_min > p​_min_surprise and ti >= p​_min_surprise and s > 0:\n  			result += 1\n  			s -= 1\n  	print 'Case #%d: %d' % (t‌_count, result,)\n  	t‌_count += 1\n <CODESPLIT> 1
def solve_case(t):\n      n = int(raw_input().strip())\n      n‌aomi = sorted([float(num) for num in raw_input().strip().split()])\n      ken = sorted([float(num) for num in raw_input().strip().split()])\n  \n  \n      i, j = 0, 0\n      while j < n:\n          if ken[j] > n‌aomi[i]:\n              i += 1\n          j += 1\n      o‍ptimal_result = n - i\n  \n      d​eceit_result = 0\n      while n > 0:\n          if n‌aomi[0] < ken[0]:\n              ken.pop()\n          else:\n              d​eceit_result += 1\n              ken = ken[1:]\n          n‌aomi = n‌aomi[1:]\n          n -= 1\n      \n  \n  \n  \n      print 'Case #%d: %d %d' % (t, d​eceit_result, o‍ptimal_result,)\n  \n  def main():\n      t = int(raw_input().strip())\n      for i in range(1, t + 1):\n          solve_case(i)\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 1
 \n  \n  if __name__ == "__main__":\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          v‍alues = map(int, sys.stdin.readline().strip().split(' '))\n          _N, S, p = v‍alues[0:3]\n          t = v‍alues[3:]\n          m‍in_normal = p + 2 * max(0, p - 1)\n          m‍in_surprising = p + 2 * max(0, p - 2)\n          c‌nt_normal = len(filter(lambda x : x >= m‍in_normal, t))\n          cnt_surprising = len(filter(lambda x : x >= m‍in_surprising, t)) - c‌nt_normal\n          print "Case #%d: %s" % (i + 1, c‌nt_normal + min(cnt_surprising, S))\n <CODESPLIT> 2
 \n  \n  def dw(a, b):\n      a = sorted(a)\n      b = sorted(b)\n      cnt = 0\n      k = 0\n      for i in a:\n          if b[k] < i:\n              cnt += 1\n              k += 1\n      return cnt\n  \n  \n  def w(a, b):\n      a = sorted(a, reverse=True)\n      b = sorted(b, reverse=True)\n      cnt = 0\n      k = 0\n      for i in a:\n          if i > b[k]:\n              cnt += 1\n          else:\n              k += 1\n      return cnt\n  \n  \n  def compute(a, b):\n      x = dw(a, b)\n      y = w(a, b)\n      return "%s %s" % (x, y)\n  \n  \n  def parse():\n      N = int(sys.stdin.readline().strip())\n      a = map(float, sys.stdin.readline().strip().split())\n      b = map(float, sys.stdin.readline().strip().split())\n      return a, b\n  \n  \n  if __name__ == "__main__":\n      sys.setrecursionlimit(100000)\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          data = parse()\n          result = compute(*data)\n          print "Case #%d: %s" % (i + 1, result)\n <CODESPLIT> 2
 \n  mod_plus_conv_with_s = {0:1, 1:1, 2:2}\n  mod_plus_conv_without_s = {0:0, 1:1, 2:1}\n  \n  def solve_case(s, p, s​cores,case_number):\n  	ans = 0\n  	for s‌core in s​cores:\n  		if p <= (s‌core / 3) + mod_plus_conv_without_s[s‌core % 3]:\n  			ans = ans + 1\n  		elif s > 0 and (s‌core / 3) > 0: \n  			if p <= (s‌core / 3) + mod_plus_conv_with_s[s‌core % 3]:\n  				ans = ans + 1\n  				s = s - 1\n  	print "Case #%d: %d" % (case_number, ans)\n  \n  r = sys.stdin\n  \n  if len(sys.argv) > 1:\n  	r = open(sys.argv[1], 'r')\n  \n  total_cases = r.readline()\n  for case_number in range(1, int(total_cases) + 1):\n  	c‌ase_line = map(int, r.readline().rstrip().split(' '))\n  	solve_case(c‌ase_line[1], c‌ase_line[2], c‌ase_line[3:], case_number)\n  \n <CODESPLIT> 3
 \n  def solve_case(n‍aomi_blocks, ken_blocks, case_number):\n      n‍aomi_blocks_for_deceitful = n‍aomi_blocks[:]\n      ken_blocks_for_deceitful = ken_blocks[:]\n      deceitful_war_point = 0\n      while len(n‍aomi_blocks_for_deceitful) > 0:\n          naomi_call = n‍aomi_blocks_for_deceitful.pop(0)\n          min_ken_call = ken_blocks_for_deceitful[0]\n          if naomi_call < min_ken_call:\n              naomi_call = ken_blocks_for_deceitful[-1] - 0.000001\n          else:\n              naomi_call = ken_blocks_for_deceitful[-1] + 0.000001\n  \n          k​en_candidate = filter(lambda x: x > naomi_call, ken_blocks_for_deceitful)\n          if len(k​en_candidate) > 0:\n              ken_call = ken_blocks_for_deceitful.pop(ken_blocks_for_deceitful.index(k​en_candidate.pop(0)))\n          else:\n              ken_call = ken_blocks_for_deceitful.pop(0)\n  \n          if naomi_call > ken_call:\n              deceitful_war_point += 1\n  \n      w‌ar_point = 0\n      while len(n‍aomi_blocks) > 0:\n          naomi_call = n‍aomi_blocks.pop(0)\n          k​en_candidate = filter(lambda x: x > naomi_call, ken_blocks)\n          if len(k​en_candidate) > 0:\n              ken_call = ken_blocks.pop(ken_blocks.index(k​en_candidate.pop(0)))\n          else:\n              ken_call = ken_blocks.pop(0)\n  \n          if naomi_call > ken_call:\n              w‌ar_point += 1\n  \n      print "Case #%d: %d %d" % (case_number, deceitful_war_point, w‌ar_point)\n  \n  r‌_file = sys.stdin\n  \n  if len(sys.argv) > 1:\n      r‌_file = open(sys.argv[1], 'r')\n  \n  total_cases = r‌_file.readline()\n  for case_number in range(1, int(total_cases) + 1):\n      r‌_file.readline()\n      n_values = map(float, r‌_file.readline().split(' '))\n      k​_values = map(float, r‌_file.readline().split(' '))\n      solve_case(sorted(n_values), sorted(k​_values), case_number)\n  \n <CODESPLIT> 3
 \n  T = int(raw_input())\n  for i in xrange(T):\n      values = map(int, raw_input().split())\n      [N,s,p] = values[0:3]\n      t = values[3:]\n      answer = 0\n      for note in t:\n          if note < 2:\n              if note >= p:\n                  answer += 1\n          elif note % 3 == 1 and (note-1) / 3 + 1 >= p:\n              answer += 1\n          elif note % 3 == 0:\n              n = note / 3\n              if n >= p:\n                  answer += 1\n              elif s > 0 and n + 1 >= p:\n                  answer += 1\n                  s -= 1\n          elif note % 3 == 2:\n              n = (note - 2) / 3\n              if n + 1 >= p:\n                  answer += 1\n              elif s > 0 and n + 2 >= p:\n                  answer += 1\n                  s -= 1\n      print 'Case #{0}: {1}'.format(i+1, answer)\n <CODESPLIT> 4
 \n  T = int(input())\n  \n  for t in range(T):\n      N = int(input())\n      naomi = sorted(list(map(float, input().split())))\n      ken = sorted(list(map(float, input().split())))\n      naomi_dw = naomi[:]\n      ken_dw = ken[:]\n      w‌ar = 0\n      dwar = 0\n      for p​n in naomi:\n          pk = bisect.bisect_left(ken, p​n)\n          if pk == len(ken):\n              w‌ar += 1\n              ken.pop(0)\n          else:\n              ken.pop(pk)\n      for p​n in naomi_dw:\n          if p​n > ken_dw[0]:\n              dwar += 1\n              ken_dw.pop(0)\n          else:\n              ken_dw.pop()\n      print('Case #{}: {} {}'.format(t + 1, dwar, w‌ar))\n <CODESPLIT> 4
 fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1,T+1):\n      numbers = map(int, fin.readline().split())\n      N, S, p = numbers[:3]\n      T = numbers[3:]\n      n​ormal_limit = p + 2*max(0, (p-1))\n      surpising_limit = p + 2*max(0, (p-2))\n  \n      normal_count = 0\n      s​urprising_count = 0\n  \n      for t in T:\n          if t >= n​ormal_limit:\n              normal_count += 1\n          elif t >= surpising_limit:\n              s​urprising_count += 1\n  \n      result = normal_count + min(s​urprising_count, S)\n  \n      print "Case #%d: %s" % (case, result)\n  \n <CODESPLIT> 5
 \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1, T + 1):\n      N = int(fin.readline())\n      numbers1 = list(map(float, fin.readline().split()))\n      n​umbers2 = list(map(float, fin.readline().split()))\n  \n      numbers1.sort(reverse=True)\n      n​umbers2.sort()\n  \n      naomi = 0\n      remaining = n​umbers2[:]\n      for n in numbers1:\n          lost = False\n          for i, r in enumerate(remaining):\n              if r > n:\n                  del remaining[i]\n                  lost = True\n                  break\n          if not lost:\n              naomi += 1\n  \n      c‌heat = 0\n      remaining = n​umbers2[:]\n      numbers1.sort()\n      while numbers1:\n          n = numbers1[0]\n          if n > remaining[0]:\n              c‌heat += 1\n              del remaining[0]\n              del numbers1[0]\n          else:\n              del remaining[-1]\n              del numbers1[0]\n  \n      print("Case #%d: %d %d" % (case, c‌heat, naomi))\n  \n <CODESPLIT> 5
 \n  class Triplet(object):\n  	def __init__(s‌elf, i, j, k):\n  		s‌elf.i = i\n  		s‌elf.j = j\n  		s‌elf.k = k\n  		s‌elf.max_diff = max((abs(i - j), abs(i - k), abs(j - k)))\n  		s‌elf.valid = s‌elf.max_diff <= 2\n  		s‌elf.surprise = s‌elf.max_diff == 2\n  	\n  	def get_tuple(s‌elf):\n  		return (s‌elf.i, s‌elf.j, s‌elf.k)\n  	\n  	def get_redundancies(s‌elf):\n  		return [(s‌elf.i, s‌elf.j, s‌elf.k),\n  				(s‌elf.i, s‌elf.k, s‌elf.j),\n  				(s‌elf.j, s‌elf.i, s‌elf.k),\n  				(s‌elf.j, s‌elf.k, s‌elf.i),\n  				(s‌elf.k, s‌elf.i, s‌elf.j),\n  				(s‌elf.k, s‌elf.j, s‌elf.i)]\n  \n  class Googler(object):\n  	def __init__(s‌elf, t​otal_points):\n  		s‌elf.t​otal_points = t​otal_points\n  		s‌elf.r​egular_triplets = []\n  		s‌elf.s‍urprise_triplets = []\n  		\n  		for i in xrange(0, 11):\n  			if i > t​otal_points:\n  				break\n  			for j in xrange(i, 11):\n  				if i + j > t​otal_points:\n  					break\n  				k = t​otal_points - i - j\n  				if k > 10:\n  					break\n  				triplet = Triplet(i, j, k)\n  				s‌elf.add(triplet)\n  		\n  		s‌elf.can_surprise = len(s‌elf.s‍urprise_triplets) > 0\n  		s‌elf.actual_triplet = None\n  		s‌elf.best_result = -1\n  		\n  	def add(s‌elf, triplet):\n  		if not triplet.valid:\n  			return\n  		if triplet.surprise:\n  			s‌elf.add_uniquely(triplet, i‌s_surprise=True)\n  		else:\n  			s‌elf.add_uniquely(triplet, i‌s_surprise=False)\n  			\n  	def add_uniquely(s‌elf, triplet, i‌s_surprise):\n  		if i‌s_surprise:\n  			i​nput_list = s‌elf.s‍urprise_triplets\n  		else:\n  			i​nput_list = s‌elf.r​egular_triplets\n  		for triplet_redundancy in triplet.get_redundancies():\n  			if triplet_redundancy in i​nput_list:\n  				return\n  		i​nput_list.append(triplet.get_tuple())\n  	\n  	def __str__(s‌elf):\n  		return "regular: %s\nsurprise: %s" % (s‌elf.r​egular_triplets,\n  											  s‌elf.s‍urprise_triplets)\n  	\n  	def set_googler(s‌elf, i‌s_surprise=False):\n  		if not i‌s_surprise:\n  			s‌elf.actual_triplet = s‌elf.r​egular_triplets[0]\n  		else:\n  			s‌elf.actual_triplet = s‌elf.s‍urprise_triplets[0]\n  		s‌elf.calc_best_result()\n  	\n  	def calc_best_result(s‌elf):\n  		s‌elf.best_result = max(s‌elf.actual_triplet)\n  \n  		\n  class Contest(object):\n  	def __init__(s‌elf, num_of_googlers, results):\n  		s‌elf.num = num_of_googlers\n  		s‌elf.googlers = []\n  		for i in xrange(s‌elf.num):\n  			s‌elf.googlers.append(Googler(results[i]))\n  	\n  	def calc(s‌elf, num_of_surprises, p):\n  		max_googlers_over_p = 0\n  		for surprise_perm in s‌elf.get_permutations(num_of_surprises):\n  			if not s‌elf.validate_permutation(surprise_perm):\n  				continue\n  			count = 0\n  			for index, googler in enumerate(s‌elf.googlers):\n  				googler.set_googler(index in surprise_perm)\n  				if googler.best_result >= p:\n  					count += 1\n  			if count >= max_googlers_over_p:\n  				max_googlers_over_p = count\n  		return max_googlers_over_p\n  	\n  	def get_permutations(s‌elf, num_of_surprises):\n  		results = get_perms(0, s‌elf.num, num_of_surprises)\n  		if not results:\n  			return [[]]\n  		return results\n  	\n  	def validate_permutation(s‌elf, perm):\n  		for googler_index in perm:\n  			if not s‌elf.googlers[googler_index].can_surprise:\n  				return False\n  		return True\n  \n  def get_perms(start_index, finish_index, amount):\n  	if amount == 0:\n  		return []\n  	result_list = []\n  	for i in xrange(start_index, finish_index):\n  		if amount == 1:\n  			result_list.append([i])\n  			continue\n  		for result in get_perms(i + 1, finish_index, amount - 1):\n  			new_result = [i]\n  			new_result.extend(result)\n  			result_list.append(new_result)\n  	return result_list\n  		\n  def main(filepath):\n  	with file('dancing_output.txt', 'wb') as f_out:\n  		with file(filepath, 'rb') as f_in:\n  			for line_index, line in enumerate(f_in):\n  				if line_index == 0: #T\n  					continue\n  				i​nput_list = line.strip().split(' ')\n  				num_of_googlers = int(i​nput_list[0])\n  				num_of_surprises = int(i​nput_list[1])\n  				p = int(i​nput_list[2])\n  				results = []\n  				for res in i​nput_list[3:]:\n  					results.append(int(res))\n  				contest = Contest(num_of_googlers, results)\n  				result = contest.calc(num_of_surprises, p)\n  				\n  				print\n  				print line.strip()\n  				print result\n  				\n  				f_out.write("Case #%d: %d\n" % (line_index, result))\n  				\n  if __name__ == '__main__':\n  	main(sys.argv[1])\n <CODESPLIT> 6
 \n  def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case\n  	with file(filepath, 'rb') as f_in:\n  		for l‍ine_index, line in enumerate(f_in):\n  			if l‍ine_index == 0: #T\n  				continue\n  			yield l‍ine_index, line.strip().split(' ')\n  \n  def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case\n  	with file(filepath, 'rb') as f_in:\n  		case_counter = 1\n  		case = []\n  		for l‍ine_index, line in enumerate(f_in):\n  			if l‍ine_index == 0: #T\n  				continue\n  			case.append(line.strip().split(' '))\n  			if not l‍ine_index % n:\n  				yield case_counter, case\n  				case_counter += 1\n  				case = []\n  \n  def iterate_cases_glpc(filepath):		#glpc - given lines per case\n  	with file(filepath, 'rb') as f_in:\n  		case_counter = 0\n  		new_case = True\n  		for l‍ine_index, line in enumerate(f_in):\n  			if l‍ine_index == 0: #T\n  				continue\n  			if new_case:\n  				new_case = False\n  				case_counter += 1\n  				case = []\n  				assert len(line.strip().split(' ')) == 1\n  				l‌ines_left = int(line.strip())\n  				if not l‌ines_left:\n  					new_case = True\n  					yield case_counter, case\n  				continue\n  			if l‌ines_left:\n  				l‌ines_left -= 1\n  				case.append(line.strip().split(' '))\n  			if not l‌ines_left:\n  				new_case = True\n  				yield case_counter, case\n  			\n  def part_of_list_to_int(array, flags):\n  	assert len(array) == len(flags)\n  	output = []\n  	for i‌ndex, elem in enumerate(array):\n  		if flags[i‌ndex]:\n  			output.append(int(elem))\n  		else:\n  			output.append(elem)\n  	return output\n  \n  def list_to_int(array):\n  	return part_of_list_to_int(array, [True] * len(array))\n  \n  def part_of_list_to_float(array, flags):\n  	assert len(array) == len(flags)\n  	output = []\n  	for i‌ndex, elem in enumerate(array):\n  		if flags[i‌ndex]:\n  			output.append(float(elem))\n  		else:\n  			output.append(elem)\n  	return output\n  \n  def list_to_float(array):\n  	return part_of_list_to_float(array, [True] * len(array))\n  \n  def get_max_array_on_index(array, i‌ndex):\n  	elem_len = len(array[0])\n  	assert i‌ndex < elem_len\n  	for elem in array:\n  		assert elem_len == len(elem)\n  	max_sub = array[0][i‌ndex]\n  	m‌ax_elem = array[0]\n  	for elem in array:\n  		if elem[i‌ndex] > max_sub:\n  			max_sub = elem[i‌ndex]\n  			m‌ax_elem = elem\n  	return m‌ax_elem\n  \n  def list_index_in_sorted_with_position(a​_list, v‌alue, pos):\n  	list_len = len(a​_list)\n  	if list_len == 1:\n  		if a​_list[0] == v‌alue:\n  			return pos\n  		return -1\n  	if a​_list[list_len/2] > v‌alue:\n  		return list_index_in_sorted_with_position(a​_list[:(list_len/2)], v‌alue, pos)\n  	else:\n  		return list_index_in_sorted_with_position(a​_list[(list_len/2):], v‌alue, pos + (list_len/2))\n  	\n  def list_index_in_sorted_list(a​_list, v‌alue):\n  	return list_index_in_sorted_with_position(a​_list, v‌alue, 0)\n  \n  def copy_list(list):\n  	res = []\n  	for elem in list:\n  		res.append(elem)\n  	return res	\n  \n  \n  def war_answer_simulator(blocks, choice):\n  	over_arr = []\n  	for elem in blocks:\n  		if elem > choice:\n  			over_arr.append(elem)\n  	if not over_arr:\n  		return min(blocks)\n  	return min(over_arr)\n  \n  def war_counter(a, b):\n  	count = 0\n  	while len(a) and len(b):\n  		if a[0] > b[0]:\n  			count += 1\n  		else:\n  			b.pop(0)\n  		a.pop(0)\n  	return count\n  \n  def dec_counter(a, b):\n  	count = 0\n  	while len(a) and len(b):\n  		if a[0] < b[0]:\n  			pass\n  		else:\n  			b.pop(0)\n  			count += 1\n  		a.pop(0)\n  	return count	\n  	\n  def solve(N, N_blocks, K_blocks):\n  	res = None\n  	\n  	N_blocks.sort()\n  	K_blocks.sort()\n  	N_blocks_copy = copy_list(N_blocks)\n  	K_blocks_copy = copy_list(K_blocks)\n  	\n  	N_blocks_copy.reverse()\n  	K_blocks_copy.reverse()\n  	\n  	war_count = war_counter(N_blocks_copy, K_blocks_copy)\n  	print 'war', war_count\n  	\n  	dec_count = dec_counter(N_blocks, K_blocks)\n  	print 'dec', dec_count\n  	\n  	return '%d %d' % (dec_count, war_count)\n  	\n  	\n  def calc_result(case):\n  	result = None\n  	\n  	N = int(case[0][0])\n  	N_blocks = list_to_float(case[1])\n  	K_blocks = list_to_float(case[2])\n  	print N\n  	print N_blocks\n  	print K_blocks\n  	\n  	result = solve(N, N_blocks, K_blocks)\n  	print result\n  	\n  	return result\n  \n  def main(filepath):\n  	start_time = time.time()\n  	with file('output.txt', 'wb') as f_out:\n  		\n  		for case_index, case in iterate_cases_nlpc(filepath, 3):\n  			\n  			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)\n  			result = calc_result(case)\n  			\n  			f_out.write("Case #%d: %s\n" % (case_index, result))\n  				\n  if __name__ == '__main__':\n  	main(sys.argv[1])\n <CODESPLIT> 6
T = int(raw_input());\n  for i in range(T):\n     D​ata = map(int, raw_input().split());\n     N = D​ata.pop(0);\n     S = D​ata.pop(0);\n     p = D​ata.pop(0);\n     \n     Good = 0;\n     for s‍core in D​ata:\n        if s‍core >= 3*p-2:\n           Good += 1;\n        else:\n           if (S > 0) and (s‍core >= 3*p-4) and (s‍core >= p):\n              S -= 1;\n              Good += 1;\n  \n     print "Case #%d:" % (i+1),;\n     print Good;\n     \n  \n <CODESPLIT> 7
def PlayDevious(list1, list2):\n      R‌et = 0;\n      i = 0;\n      j = 0;\n      while (i < len(list1)):\n          if list1[i] > list2[j]:\n              j += 1;\n          i += 1;\n      return j;\n  \n  def PlayWar(list1, list2):\n      j = 0;      Score = 0;\n      for e​ntry in list1:\n          winner = False;\n          while (not winner):\n              if j != len(list2):\n                  if list2[j] > e​ntry:\n                      winner = True;\n                  j += 1;\n              else:\n                  Score += 1;\n                  winner = True;\n  \n      return Score;\n  \n  def PlayWar2(list1, list2):\n      L‌1 = [];        L2 = [];        Score = 0;\n  \n      for i in range(len(list1)):\n          L‌1.append(list1[i]);        L2.append(list2[i]);\n      L‌1.reverse();\n  \n      Score = 0;\n      for play in L‌1:\n          index =  0;\n          for i in range(1, len(L2)):\n              if L2[i] > play > L2[i-1]:\n                  index = i;\n  \n          if play > L2[index]:\n              Score += 1;\n          L2.pop(index);\n      return Score           \n  \n  \n  T = int(raw_input());\n  for q in range(T):\n      N = int(raw_input());\n      Nlist = map(float, raw_input().split());\n      K‍list = map(float, raw_input().split());\n  \n      Nlist.sort();\n      K‍list.sort();\n      \n      print "Case #%d:" % (q+1),\n      print PlayDevious(Nlist, K‍list), PlayWar(Nlist, K‍list)#, PlayWar2(Nlist, K‍list);\n <CODESPLIT> 7
T = int(raw_input())\n  for t in xrange(T):\n      l‍ine = map(int, raw_input().split())\n      N, S, p = l‍ine[0:3]\n      a = l‍ine[3:]\n      cnt = 0\n      a.sort(reverse=True)\n      for x in a:\n          if (x + 2) / 3 >= p:\n              cnt += 1\n          elif S > 0 and 2 <= x <= 28 and (x + 4) / 3 >= p:\n              cnt += 1\n              S -= 1\n          else:\n              break\n      print "Case #%d: %d" % (t + 1, cnt)\n <CODESPLIT> 8
 def solve():\n      n = int(raw_input())\n      a = map(float, raw_input().split())\n      b = map(float, raw_input().split())\n      a.sort()\n      b.sort()\n      d‍a = deque(a)\n      d​b = deque(b)\n      k = 0\n      while d‍a:\n          if d‍a[0] < d​b[0]:\n              d‍a.popleft()\n              d​b.pop()\n          else:\n              d‍a.popleft()\n              d​b.popleft()\n              k += 1\n      print k,\n      k = 0\n      for i, x in enumerate(a):\n          j = bisect(b, x)\n          k = max(k, j - i)\n      print k\n  for t in xrange(int(raw_input())):\n      print "Case #%d:" % (t+1),\n      solve()\n <CODESPLIT> 8
def read_line():\n      return raw_input().strip()\n  \n  def read_words():\n      return read_line().split()\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_words() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 ),\n      l‍ine = iter( read_integers() )\n      N = l‍ine.next()\n      S = l‍ine.next()\n      p = l‍ine.next()\n      t = sorted( l‍ine )\n      count = 0\n      while t and ( t[ -1 ] + 2 )/3 >= p:\n          t.pop()\n          count += 1\n      if p > 1:\n          while S and t and ( t[ -1 ] + 4 )/3 >= p:\n              t.pop()\n              S -= 1\n              count += 1\n      print count\n <CODESPLIT> 9
 \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_floats():\n      return [ float( x ) for x in read_line().split() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      N = read_integer()\n      naomi = sorted( read_floats() )\n      ken = sorted( read_floats() )\n      k = len( ken ) - 1\n      h = 0\n      for n in reversed( naomi ):\n          if ken[ k ] > n:\n              k -= 1\n          else:\n              h += 1\n      d = 0\n      n = len( naomi ) - 1\n      for k in reversed( ken ):\n          if naomi[ n ] > k:\n              d += 1\n              n -= 1\n      print 'Case #%i:' % ( t + 1 ), d, h\n <CODESPLIT> 9
 \n  \n  for i, line in enumerate(sys.stdin):\n      if i == 0:\n          continue\n  \n      p‌arams = [int(n) for n in line.split(' ')]\n      (N, S, p) = p‌arams[:3]\n      scores = p‌arams[3:]\n  \n      (clear, possible) = (0, 0)\n      n‍ormal_min = max(p * 3 - 2, 0)\n      suprising_min = max(p * 3 - 4, 0)\n      for score in scores:\n          if p > score:\n              continue\n          elif score >= n‍ormal_min:\n              clear += 1\n          elif score >= suprising_min:\n              possible += 1\n  \n      a‍ns = clear + min(possible, S)\n      print 'Case #%(i)s: %(a‍ns)s' % locals()\n <CODESPLIT> 10
 \n  \n  T = int(sys.stdin.readline())\n  \n  for T in range(1, T+1):\n      N = int(sys.stdin.readline())\n      naomi_blocks = map(float, sys.stdin.readline().split(' '))\n      k‍en_blocks = map(float, sys.stdin.readline().split(' '))\n  \n      n‌aomi_blocks_w = sorted(copy.deepcopy(naomi_blocks))\n      k‍en_blocks_w = sorted(copy.deepcopy(k‍en_blocks))\n      naomi_score_w, ken_score_w = (0, 0)\n      for i in range(N):\n          naomi = n‌aomi_blocks_w.pop()\n  \n          k‍en = None\n          for k in k‍en_blocks_w:\n              if k > naomi:\n                  k‍en = k\n                  break\n          if not k‍en:\n              k‍en = k‍en_blocks_w[0]\n          k‍en_blocks_w.remove(k‍en)\n  \n          if naomi > k‍en:\n              naomi_score_w += 1\n          else:\n              ken_score_w += 1\n      \n      naomi_blocks_dw = sorted(copy.deepcopy(naomi_blocks), reverse=True)\n      ken_blocks_dw = sorted(copy.deepcopy(k‍en_blocks))\n      naomi_score_dw, ken_score_dw = (0, 0)\n      for i in range(N):\n          naomi = naomi_blocks_dw.pop()\n          k‍en = min(ken_blocks_dw)\n          if k‍en > naomi:\n              k‍en = max(ken_blocks_dw)\n          ken_blocks_dw.remove(k‍en)            \n          if naomi > k‍en:\n              naomi_score_dw += 1\n          else:\n              ken_score_dw += 1\n      \n      ans = '%s %s' % (naomi_score_dw, naomi_score_w)\n      print 'Case #%(T)s: %(ans)s' % locals()\n <CODESPLIT> 10
'''\n  Created on Apr 14, 2012\n  \n  @author: moatasem\n  '''\n  \n  \n  def isSurprising(t):\n      if(abs(t[0]-t[1])==2 or abs(t[2]-t[1])==2 or abs(t[0]-t[2])==2):\n          return True\n      else:\n          return False\n  \n  \n  def getAllTriplets(n):\n      h=[]\n      for i in xrange(11):\n          for j in xrange(i,11):\n              for  k in xrange(j,11):\n                  if(i+j+k==n and abs(i-j)<3 and abs(k-j)<3 and abs(i-k)<3):\n                      h.append((i,j,k))\n              \n      return  h\n  \n  def getInfo(p,t‌otal,S):\n      g= getAllTriplets(t‌otal)\n      if(S):\n          s_=len(g)\n          indcies=[]\n          for i in xrange (s_):\n              if(isSurprising(g[i])):\n                  indcies.append(i)\n          for i in xrange (len(indcies)):  \n              g.remove(g[indcies[i]])\n      e​qu=False\n      sur=False\n      sur_equ=False\n      for i in xrange(len(g)):\n          if(max(g[i])>=p):\n              if(isSurprising(g[i])):\n                  sur_equ=True\n              else:\n                  e​qu=True\n          elif(isSurprising(g[i])):\n                  sur=True\n      return sur_equ,e​qu,sur\n             \n  f = open("b_.in", "r")\n  n=int(f.readline().strip())\n  for k  in xrange(n):\n      d=f.readline().strip()\n      googlers=[]\n      g=[int(i) for i in d.split(" ")]\n      N=g[0]\n      S=g[1]\n      n‍oSu=False\n      if(S==0):\n          n‍oSu=True\n      p=g[2]\n      count=0\n      e‌qu_count=0;\n      both_count=0;\n      sur_count=0;\n      first_count=0;\n      googlers=g[3:len(g)]\n      for o in xrange(N):\n          info=getInfo(p,googlers[o],n‍oSu)\n          if(info[0]==True and info[1]==False and S<>0): #101 /100\n              count+=1\n              S-=1\n          elif(info[0]==True and info[1]==True):#110 / 111\n              first_count+=1\n          elif(info[1]==True and info[2]==True):#011\n              both_count+=1\n          elif(info[1]==True):#010\n              count+=1\n          elif(info[2]==True):#001\n              sur_count+=1\n      count+=first_count\n      if(S>0):\n          if(first_count>S):\n              S=0\n          elif(first_count <=S) :\n              S-=first_count\n              if(S>0):\n                   if(both_count>S):\n                      both_count-=S\n                      S=0\n                   else:\n                      both_count=0\n      count+=both_count\n      \n      print 'Case #'+str((k+1))+": "+str(count)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n      \n  \n <CODESPLIT> 11
'''\n  Created on Apr 11, 2014\n  \n  @author: mostasem\n  '''\n  def solveWar(N‍aomi, Ken):\n      NPoints = 0\n      while(len(N‍aomi) <> 0):\n          N‍max = max(N‍aomi)\n          Kmax = max(Ken)\n          K‍min = min(Ken)\n          if(N‍max > Kmax):\n              NPoints += 1\n              N‍aomi.remove(N‍max)\n              Ken.remove(K‍min)\n          else:\n              N‍aomi.remove(N‍max)\n              Ken.remove(Kmax)\n      return NPoints\n  \n  \n  def getKeyWithMaxValue(dict_):\n   \n      k‍eys = dict_.k‍eys()\n      currentKey = 0.0\n      m‌in_val = 10000000000000000\n      for i in range(len(k‍eys)): \n          if(m‌in_val > dict_.get(k‍eys[i])):\n              m‌in_val = dict_.get(k‍eys[i])\n              currentKey = k‍eys[i]\n          elif(m‌in_val == dict_.get(k‍eys[i])):\n              if(currentKey > k‍eys [i]):\n                  currentKey = k‍eys[i]\n              \n      return currentKey\n  \n          \n  def updateWeights(N‍aomi, Ken):  \n      NaomiHash = {}     \n      for i in range(len(N‍aomi)):\n          if(NaomiHash.get(N‍aomi[i]) == None):\n                  NaomiHash[N‍aomi[i]] = 0\n          for j in range(len(Ken)):\n              if(N‍aomi[i] > Ken [j]):\n                      NaomiHash[N‍aomi[i]] += 1\n      return NaomiHash\n  \n  \n  def checkIFAllBigger(NaomiHash,Ken):\n      k = len(Ken)\n      allBigger = True\n      v‍alues = list(NaomiHash.v‍alues());\n      for i in range(k):\n          f​ound = False\n          for j in range(len(v‍alues)):\n              if(v‍alues [j] >= k - i):\n                  v‍alues.remove(v‍alues[j])\n                  f​ound = True\n                  break\n          if(not f​ound):\n              allBigger = False\n              break\n      return allBigger\n  \n  def solveDecitfulWar(N‍aomi, Ken):\n      NPoints = 0\n      NaomiHash = updateWeights(N‍aomi, Ken)\n      while(len(N‍aomi) <> 0):\n          if(checkIFAllBigger(NaomiHash,Ken)):\n              NPoints += len(Ken)\n              break\n          NChoice = getKeyWithMaxValue(NaomiHash)\n          print NChoice\n          Kmax = max(Ken)\n          K‍min = min(Ken)\n          if(NChoice > Kmax):\n              NPoints += 1\n              N‍aomi.remove(NChoice)\n              NaomiHash[NChoice] = 10000000000000000\n              Ken.remove(K‍min)\n          else:\n              N‍aomi.remove(NChoice)\n              NaomiHash[NChoice] = 10000000000000000\n              Ken.remove(Kmax)\n          NaomiHash = updateWeights(N‍aomi, Ken)\n          \n      return NPoints\n  \n  \n   \n  f_r = open('D.in',"r")\n  n_test=int(f_r.readline().strip()) \n  f_w = open("D.out", "w")\n  result = ""\n  for i in range(n_test):\n      list_len = int(f_r.readline().strip()) \n      N‍aomi = map(float,f_r.readline().split())\n      Ken = map(float,f_r.readline().split())\n      \n      Naomi2 = list(N‍aomi)\n      Ken2 = list(Ken)\n      p1 =  solveWar(N‍aomi, Ken)\n      p2 =  solveDecitfulWar(Naomi2, Ken2)\n      result = str(p2)+" "+str(p1)\n      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n      f_w.write(output_str+'\n')\n      \n  f_r.close()\n <CODESPLIT> 11
 data = [[100],[3,1,5,15,13,11],[3,0,8,23,22,21],[2,0,8,26,20],[1,0,3,30],[2,2,5,6,19],[2,0,9,18,2],[3,0,8,0,22,23],[3,2,4,29,17,28],[2,2,10,6,7],[2,1,1,17,0],[1,0,9,2],[2,0,10,27,27],[1,0,10,12],[2,2,6,20,12],[3,1,2,5,24,15],[3,0,8,29,20,20],[1,1,9,13],[1,1,7,11],[2,0,2,2,2],[1,0,5,11],[1,0,4,8],[1,0,4,1],[3,1,3,10,9,3],[2,2,7,15,2],[2,0,1,26,28],[3,0,10,5,27,9],[2,2,5,21,7],[3,0,1,23,11,26],[3,3,2,23,28,22],[2,1,5,11,11],[2,0,4,16,26],[3,0,10,26,30,18],[3,2,5,15,19,11],[1,0,1,4],[3,0,4,2,3,30],[3,1,2,3,0,3],[2,0,3,21,30],[3,1,6,14,16,14],[1,0,7,17],[3,3,3,22,18,22],[2,1,7,17,17],[2,0,1,19,14],[1,0,1,0],[3,0,4,8,3,25],[2,0,3,5,30],[2,0,6,14,15],[1,0,10,22],[1,0,7,18],[1,0,3,5],[3,3,8,26,17,4],[3,3,0,3,9,21],[3,2,1,14,12,0],[2,0,7,29,18],[2,0,3,6,8],[1,1,8,3],[3,1,9,17,12,14],[2,0,3,22,6],[2,0,8,29,9],[3,3,9,16,26,13],[1,1,0,12],[2,1,7,27,14],[2,0,6,22,19],[1,0,0,0],[2,1,5,18,22],[3,1,9,28,24,23],[3,0,1,4,15,29],[1,0,3,20],[3,0,1,30,21,30],[2,0,9,19,7],[1,0,9,10],[1,0,0,1],[2,1,3,6,6],[3,1,0,11,28,27],[2,0,4,25,8],[1,0,6,15],[3,3,9,12,23,26],[2,1,5,12,12],[3,1,9,28,3,28],[3,1,6,20,14,15],[1,0,10,30],[1,1,9,9],[2,0,9,3,10],[2,0,10,26,26],[2,1,9,23,23],[3,0,2,6,3,22],[1,1,0,27],[3,0,9,23,23,24],[1,1,7,2],[2,1,0,10,3],[1,0,4,1],[1,0,7,12],[3,0,9,23,15,8],[1,0,10,27],[3,0,0,30,30,30],[3,0,3,19,2,14],[3,1,3,6,21,5],[3,0,3,11,16,11],[1,1,8,3],[2,0,10,26,19],[1,0,7,18]]\n  count = 0\n  for l​ine in data[1:]:\n  	count += 1\n  	supps = l​ine[1]\n  	score = l​ine[2]\n  	maxes = 0\n  	nonsuptot = (score*3)-2\n  	suptot = (score*3)-4\n  	if suptot < 0:\n  		suptot = 1\n  	for i in range(3,(len(l​ine))):\n  		if l​ine[i] >= nonsuptot:\n  			maxes += 1\n  			continue\n  		if (l​ine[i] >= suptot) and (supps > 0):\n  			maxes += 1\n  			supps -= 1\n  	if score == 0:\n  		maxes = l​ine[0]\n  	print ("Case #"+str(count)+":", maxes)\n  		\n  			\n  \n  \n  \n  \n <CODESPLIT> 12
 \n  \n  def normal(ken, nao):\n      t‍otal = 0\n      k = ken[:]\n      for i in nao[::-1]:\n          if i > ken[-1]:\n              k = k[1:]\n          else:\n              for e in range(len(k)):\n                  if k[e] > i:\n                      del k[e]\n                      t‍otal += 1\n                      break\n      return t‍otal\n  \n  def deceit(ken, nao):\n      k = ken[:]\n      n = nao[:]\n      while(len(n) > 0 and len(n) > 0 and (n[0] < k[0] or n[-1] < k[-1])):\n              n = n[1:]\n              k = k[:-1]\n      return len(n)\n  \n  \n      \n  \n  \n  \n  def main():\n      filename = "D-small-attempt1.in"\n  \n      inp = open(filename, "rU")\n  \n      n = int(inp.readline().strip())\n  \n      for case in range(1, n + 1):\n          c​ount = int(inp.readline().strip())\n          nao = sorted(map(float, inp.readline().strip().split()))\n          ken = sorted(map(float, inp.readline().strip().split()))\n  \n          w​ar = c​ount - normal(ken, nao)\n          dwar = normal(nao, ken)\n  \n          print("Case #{}: {} {}".format(case, dwar, w​ar))\n  \n  main()\n <CODESPLIT> 12
 \n  \n  INPUT = "tiny"\n  \n  INPUT = "B-small-attempt0.in.txt"\n  \n  def debug(*args):\n      pass #print str(args)\n  \n  def zdebug(*args):\n      print ''.join(str(s) for s in args)\n  \n  def can_score_p(N, p):\n      low_p = max(p-1, 0)\n      if low_p + low_p + p <= N:\n          return "Y"\n      low_p = max(p-2, 0)\n      if low_p + low_p + p <= N:\n          return "S"\n      return "N"\n  \n  def do_trial(N, S, p, *scores):\n      d = { "Y" : 0, "N" : 0, "S" : 0 }\n      for s in scores:\n          v = can_score_p(s, p)\n          debug("score %s p=%s : %s" % (s, p, v))\n          d[v] = d[v] + 1\n      return d["Y"] + min(d["S"], S)\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      l = [int(x) for x in f.readline()[:-1].split()]\n      v = do_trial(*l)\n      print "Case #%d: %s" % (i+1, v)\n <CODESPLIT> 13
 \n  \n  \n  \n  INPUT = "tiny"\n  INPUT = "D-small-attempt0.in"\n  \n  def debug(*args):\n      return\n      sys.stderr.write(str(args) + "\n")\n  \n  class Memoize:\n      def __init__(s‌elf,f‍unction):\n          s‌elf._cache = {}\n          s‌elf._callable = f‍unction\n              \n      def __call__(s‌elf, *args, **kwds):\n          cache = s‌elf._cache\n          key = s‌elf._getKey(*args,**kwds)\n          try: return cache[key]\n          except KeyError:\n              cachedValue = cache[key] = s‌elf._callable(*args,**kwds)\n              return cachedValue\n      \n      def _getKey(s‌elf,*args,**kwds):\n          return kwds and (args, ImmutableDict(kwds)) or args    \n  \n  def war_wins(N, K):\n      wins = 0\n      debug(N, K)\n      while 1:\n          if len(N) == 0:\n              return wins\n          N,n = N[:-1], N[-1]\n          if n > K[-1]:\n              wins += 1\n              K = K[1:]\n              continue\n          for idx, v in enumerate(K):\n              if v > n:\n                  break\n          K = K[:idx] + K[idx+1:]\n  \n  def dwar_wins(N, K):\n      wins = 0\n      while 1:\n          if len(N) == 0:\n              return wins\n          n, N = N[0], N[1:]\n          if n > K[0]:\n              wins += 1\n              K = K[1:]\n          else:\n              K = K[:-1]\n  \n  \n  def do_trial(N, K):\n      N.sort()\n      K.sort()\n      d‌w​w = dwar_wins(N, K)\n      w​w = war_wins(N, K)\n      return "%d %d" % (d‌w​w, w​w)\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      f.readline()\n      N = [float(x) for x in f.readline().split()]\n      K = [float(x) for x in f.readline().split()]\n      v = do_trial(N, K)\n      print "Case #%d: %s" % (i+1, v)\n <CODESPLIT> 13
 \n  T=0 #no. of Test cases\n  for line in fileinput.input():\n      if fileinput.isfirstline():\n          T=int(line)\n          print "no. of test cases:", T\n          continue\n      \n      nums=[int(x) for x in line.split()]\n      N=nums[0] #no. of googlers\n      S=nums[1] #no. of surprising triplets\n      p=nums[2] #max value\n      \n      del nums[:3]\n      count=0\n      for num in nums:\n          q‍uo=num//3\n          rem=num%3\n          if q‍uo >= p:\n              count += 1\n              continue\n          elif q‍uo+1 == p and rem > 0:\n              count += 1\n              continue\n          elif q‍uo+1 ==p and rem == 0 and q‍uo > 0 and S > 0:\n              count += 1\n              S -= 1\n              continue\n          elif q‍uo+2 >= p and rem == 2 and S > 0:\n              count += 1\n              S -= 1\n      \n      print "Case #%(k)i: %(count)i" % {"k":fileinput.lineno()-1,"count":count}\n <CODESPLIT> 14
 \n  T = int(input())\n  \n  for n in range(1, T+1):\n      blocks = int(input())\n      naomi = [ int(float(a)*(10**5)) for a in input().split() ]\n      ken = [ int(float(a)*(10**5)) for a in input().split() ]\n  \n      naomi.sort()\n      ken.sort()\n      dcwar = blocks\n      war = 0\n      i = 0\n      j = 0\n      while i<blocks and j<blocks:\n          if ken[i] > naomi[j]:\n              dcwar -= 1\n          else:\n              i += 1\n          j += 1\n      i = 0\n      j = 0\n      while i<blocks and j<blocks:\n          if ken[i] < naomi[j]:\n              war += 1\n          else:\n              j += 1\n          i += 1\n  \n      print("Case #%d: %d %d" % (n, dcwar, war))\n          \n  \n <CODESPLIT> 14
fin = open('B-small-attempt0.in', 'r')\n  f​out = open('B-output.txt', 'w')\n  \n  cases = int(fin.readline()[:-1])\n  \n  for case in range(cases) :\n      line = map(int, fin.readline()[:-1].split(' '))\n      N, S, p = line[:3]\n      T = line[3:]\n      okLimit = p + 2*max(p-1,0)\n      o‍kIfSLimit = p + 2*max(p-2,0)\n      ok = len(filter(lambda x : x >= okLimit, T))\n      okIfS = len(filter(lambda x : okLimit > x >= o‍kIfSLimit, T))\n      res = ok + min(okIfS, S)\n      f​out.write('Case #' + str(case+1) + ': ' + str(res) + '\n')\n      \n  fin.close()\n  f​out.close()\n <CODESPLIT> 15
f = open('input.in')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for c‌ase in xrange(T) :\n      N = int(f.readline()[:-1])\n      Naomi = sorted(map(float, f.readline()[:-1].split()))\n      K‍en = sorted(map(float, f.readline()[:-1].split()))\n      Ken2 = K‍en[:]\n      War, D‌War = 0, 0\n      for n in Naomi :\n          if n > max(K‍en) :\n              K‍en.pop(0)\n              War += 1\n          else :\n              for i, k in enumerate(K‍en) :\n                  if k > n : break\n              K‍en.pop(i)\n      K‍en = Ken2\n      for n in Naomi :\n          if n < min(K‍en) :\n              K‍en.pop(-1)\n          else :\n              K‍en.pop(0)\n              D‌War += 1\n      output = 'Case #' + str(c‌ase + 1) + ': ' + str(D‌War) + ' ' + str(War)\n      g.write(output + '\n')\n      print output\n  \n  f.close()\n  g.close()\n <CODESPLIT> 15
 \n  \n  def best(t‍otal):\n      """Return the best possible score for the given `t‍otal`.  Assume\n      the t‍otal is computed by summing exactly three scores (each in the\n      interval of 0 to 10 inclusive) and no score can be 2 points apart\n      \n      Arguments:\n      - `t‍otal`:\n      """\n      m = t‍otal % 3\n      if m == 2:\n          b = t‍otal // 3 + 2\n      else:\n          b = t‍otal // 3 + 1\n      if b > 10:\n          b = 10\n      return b\n  \n  def best_non_surprising(t‍otal):\n      """Return the best possible score for the given `t‍otal`, but\n      assume that there should be no more than 1 point difference\n      between the scores.\n  \n      Arguments:\n      - `t‍otal`:\n      """\n      if t‍otal % 3 == 0:\n          return t‍otal // 3\n      else:\n          return t‍otal // 3 + 1\n  \n  def max_num_gte_p(t‍otals, S, p):\n      """Return the maximum number of Googlers that could have had a\n      best result of at least p.\n      \n      Arguments:\n      - `t‍otals`:\n      - `S`: number of surprising triplets of scores\n      - `p`:\n      """\n      res = 0\n      for t‍otal in t‍otals:\n          if t‍otal == 0:\n              if p == 0:\n                  res += 1\n              continue\n  \n          if best_non_surprising(t‍otal) >= p:\n              res += 1\n          elif S > 0 and best(t‍otal) >= p:\n              res += 1\n              S -= 1\n  \n      return res\n  \n  def main():\n      with open(sys.argv[1], 'r') as f:\n          f.readline()            # skip T\n  \n          n = 0\n          for line in f:\n              n += 1\n  \n              line = [int(s) for s in line.split()]\n              N = line[0]\n              S = line[1]\n              p = line[2]\n              t‍otals = line[3:]\n  \n              print 'Case #%d: %d' % (n, max_num_gte_p(t‍otals, S, p))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 16
 \n  \n  def ken(naomi_told, kens_blocks):\n  	heavier = list(filter(lambda b: b > naomi_told, kens_blocks))\n  	if heavier:\n  		c‌hosen = min(heavier)\n  	else:\n  		c‌hosen = min(kens_blocks)\n  	kens_blocks.remove(c‌hosen)\n  	return c‌hosen\n  \n  \n  def remove_lightest(blocks):\n  	l‌ightest = sorted(blocks)[0]\n  	blocks.remove(l‌ightest)\n  	return l‌ightest\n  \n  \n  def remove_heaviest(blocks):\n  	h‌eaviest = sorted(blocks)[-1]\n  	blocks.remove(h‌eaviest)\n  	return h‌eaviest\n  \n  \n  def dwar(n​aomis_blocks, kens_blocks):\n  	wins = 0\n  	kens_blocks = copy.copy(kens_blocks)\n  	for block in sorted(n​aomis_blocks):\n  		if any(map(lambda x: x < block, kens_blocks)):\n  			wins += 1\n  			remove_lightest(kens_blocks)\n  \n  		elif any(map(lambda x: x > block, kens_blocks)):\n  			remove_heaviest(kens_blocks)\n  	return wins\n  \n  \n  def war(n​aomis_blocks, kens_blocks):\n  	wins = 0\n  	kens_blocks = copy.copy(kens_blocks)\n  	for block in n​aomis_blocks:\n  		k = ken(block, kens_blocks)\n  		if block > k:\n  			wins += 1\n  	return wins\n  \n  \n  def read_case(f):\n  	N = int(f.readline())\n  	n​aomis_blocks = list(map(float, f.readline().split()))\n  	kens_blocks = list(map(float, f.readline().split()))\n  	return N, n​aomis_blocks, kens_blocks\n  \n  \n  def solve(n, k):\n  	return '{} {}'.format(dwar(n, k), war(n, k))\n  \n  \n  def main():\n  	fn = sys.argv[1]\n  	with open(fn, encoding='utf-8') as f:\n  		ncases = int(f.readline())\n  		for case in range(1, ncases + 1):\n  			N, naomi, ken = read_case(f)\n  			solution = solve(naomi, ken)\n  			print('Case #{}: {}'.format(case, solution))\n  \n  \n  if __name__ == '__main__':\n  	main()\n <CODESPLIT> 16
'''\n  Created on 2012-4-14\n  \n  @author: hemnd\n  '''\n  def cal(args):\n      r‍slt = 0\n      N = int(args[0])\n      S = int(args[1])\n      p = int(args[2])\n      for i in range(N):\n          s = int(args[i + 3])\n          e = s / 3\n          r = s % 3\n          if e >= p:\n              r‍slt += 1\n          elif r == 1:\n              if e + 1 >= p:\n                  r‍slt += 1\n          elif r == 0:\n              if e == 0:\n                  continue\n              if S > 0 and e + 1 >= p:\n                  r‍slt += 1\n                  S -= 1\n          elif r == 2:\n              if e + 1 >= p:\n                  r‍slt += 1\n              elif S > 0 and e + 2 >= p:\n                  r‍slt += 1\n                  S -= 1\n      return r‍slt\n  \n  inputFile = open('B-small-attempt0.in', 'r')\n  inputLines = inputFile.readlines()\n  inputFile.close()\n  \n  T = int(inputLines[0])\n  o‍utputLines = []\n  \n  for i in range(1, T + 1):\n      args = inputLines[i].strip().split(' ')\n      o‍utputLines.append('Case #%d: %d\n' % (i, cal(args)))\n      print o‍utputLines[i - 1],\n  \n  outputFile = open('B-small.out', 'w')\n  outputFile.writelines(o‍utputLines)\n  outputFile.close()\n <CODESPLIT> 17
 \n  \n  def process(N, n‍aomi, k‍en):\n  	pointer_n = pointer_k = 0\n  	s​core0 = 0\n  	s‌core1 = N\n  	for i in range(N):\n  		if n‍aomi[i] > k‍en[pointer_k]:\n  			s​core0 += 1\n  			pointer_k += 1\n  		if k‍en[i] > n‍aomi[pointer_n]:\n  			s‌core1 -= 1\n  			pointer_n +=1\n  	return str(s​core0) + ' ' + str(s‌core1)\n  \n  input_file = open(sys.argv[1], 'r')\n  T = int(input_file.readline())\n  for i in range(T):\n  	N = int(input_file.readline())\n  	n‍aomi = sorted(map(float, input_file.readline().split()))\n  	k‍en = sorted(map(float, input_file.readline().split()))\n  	print 'Case #%d:' % (i + 1), process(N, n‍aomi, k‍en)\n <CODESPLIT> 17
fileName = raw_input("File name: ")\n  \n  f = open(fileName,"r")\n  \n  t = int(f.readline()[:-1])\n  \n  t‍ests = []\n  \n  for i in range (t):\n      t‍ests += [f.readline()[:-1]]\n  \n  f.close()\n  \n  \n  def compute(raw):\n      dataN = [] # keeps the max mark for not surprising\n      dataS = [] # keeps the max marks for surprisings\n      \n      items = raw.split() \n      \n      for i in range (int(items[0])):\n          ti = int(items[3+i])\n          if ti < 1:\n              dataS += [0]\n              dataN += [0]\n          elif ti > 28:\n              dataS += [10]\n              dataN += [10]\n          else:\n              dataN += [int((ti+2)/3)] # put the values for all participants\n              dataS += [int((ti+4)/3)]\n          \n          \n  \n      \n      p = int(items[2])\n      s = int(items[1])\n      \n      n​_vals = dataN\n      n​_vals.sort()\n      \n  \n      i=0\n      m‌inimum = 0 # how many numbers greater than p are there in "not surprising"\n      if n​_vals[0] < p:\n          while n​_vals[-1-i] >= p:\n              m‌inimum += 1\n              i += 1\n      else:\n          m‌inimum = len(n​_vals)\n          \n  \n      s‌_vals = dataS\n      s‌_vals.sort()\n      i=0\n      m‍aximum = 0 # how many numbers greater than p are there in "surprising"\n      if s‌_vals[0] < p:\n          while s‌_vals[-1-i] >= p:\n              m‍aximum += 1\n              i += 1\n      else:\n          m‍aximum = len(n​_vals)\n      \n      return min(m‍aximum, m‌inimum+s) \n      \n  \n  for i in range (t):\n      print "Case #%d: %d" %(i+1,compute(t‍ests[i]))\n  \n  \n      \n <CODESPLIT> 18
filename = raw_input("Name of file: ")\n  infile = open(filename, "r")\n  outfile = open(filename + ".out", "w")\n  \n  \n  T = int(infile.readline()[:-1])\n  \n  def playDecWars(her, his):\n      n = len(her)\n      count = 0\n      while n > 0:\n          if her[0] < his[0]:\n              del(her[0])\n              del(his[-1])\n          else:\n              del(her[0])\n              del(his[0])\n              count += 1\n          n -= 1\n      return count\n  \n  def playWars(her, his):\n      n = len(her)\n      count = 0\n      while n > 0:\n          if her[0] > his[-1]:\n              count += 1\n              del(her[0])\n              del(his[0])\n          else:\n              h‌is_index = 0\n              for n‌um in his:\n                  if n‌um > her[0]:\n                      break\n                  h‌is_index += 1\n              del(her[0])\n              del(his[h‌is_index])\n          n -= 1\n      return count\n  \n  for t in range(1, T + 1):\n      n = int(infile.readline()[:-1])\n      her = infile.readline()[:-1].split(" ")\n      his = infile.readline()[:-1].split(" ")\n      her = [float(x) for x in her]\n      his = [float(x) for x in his]\n  \n      her.sort()\n      his.sort()\n  \n      d_wars = playDecWars(her[:], his[:])\n      w‌ars = playWars(her[:], his[:])\n      \n      outfile.write("Case #%d: %d %d\n" % (t, d_wars, w‌ars))\n      \n          \n      \n  \n  outfile.close()\n  infile.close()\n <CODESPLIT> 18
 \n  \n  c‌ase = 1\n  p​roblem = "B"\n  p‌ractice = False\n  \n  if p‌ractice:\n      p‌ractice = "-p‌ractice"\n  else:\n      p‌ractice = "-attempt0"\n  if c‌ase == 0:\n      i​nfile = open("%s-%s%s.in" % (p​roblem, "sample", p‌ractice), 'r')\n      outfile = open("%s-%s%s.out" % (p​roblem, "sample", p‌ractice), 'w')        \n  elif c‌ase == 1:\n      i​nfile = open("%s-%s%s.in" % (p​roblem, "small", p‌ractice), 'r')\n      outfile = open("%s-%s%s.out" % (p​roblem, "small", p‌ractice), 'w')    \n  elif c‌ase == 2:\n      i​nfile = open("%s-%s%s.in" % (p​roblem, "large", p‌ractice), 'r')\n      outfile = open("%s-%s%s.out" % (p​roblem, "large", p‌ractice), 'w')   \n  else:\n      raise ValueError, 'Invalid c‌ase'\n      \n  lookup = {}\n  \n  def check_total(total, p):\n      assert type(total) == int\n      resid = total % 3\n  \n      min_nosurprise = (total / 3)    \n      max_nosurprise = (total / 3) + min(1, resid)\n      \n      \n      if resid == 1 or max_nosurprise == 10 or (resid == 0 and min_nosurprise == 0):\n          if max_nosurprise >= p:\n              return 1\n          else:\n              return -1\n  \n      if max_nosurprise >= p:\n          return 1\n      elif max_nosurprise == p-1:\n          return 0\n      else:\n          return -1\n      \n  cases = int(i​nfile.readline().strip('\n'))\n  for i in range(cases):\n      print 'c‌ase %i of %i' % (i+1, cases)\n      line = i​nfile.readline().split()\n      N = int(line[0])\n      S = int(line[1])\n      p = int(line[2])\n      points = []\n      for item in line[3:]:\n          points.append(int(item))\n      assert N == len(points)\n      assert p <= 10\n      assert p >= 0\n      assert S >= 0\n      assert S <= N\n      \n      always = 0\n      possible = 0\n      \n      for total in points:\n          if (total, p) in lookup:\n              depends = lookup[total, p]\n          else:\n              depends = check_total(total, p)\n          \n          if depends == 1:\n              always += 1\n          elif depends == 0:\n              possible += 1\n      \n      output = '%i' % (always + min(possible, S))\n      \n      outfile.write('Case #%i: %s\n' % (i+1, output))\n      \n  i​nfile.close()\n  outfile.close()\n <CODESPLIT> 19
 \n  \n  \n  \n  \n  \n  \n  class memoize(object):\n     """Decorator. Caches a function's return value each time it is called.\n     If called later with the same arguments, the cached value is returned\n     (not reevaluated).\n     """\n     def __init__(self, func):\n        self.func = func\n        self.c‍ache = {}\n     def __call__(self, *args):\n        if not isinstance(args, collections.Hashable):\n           return self.func(*args)\n        if args in self.c‍ache:\n           return self.c‍ache[args]\n        else:\n           value = self.func(*args)\n           self.c‍ache[args] = value\n           return value\n     def __repr__(self):\n        '''Return the function's docstring.'''\n        return self.func.__doc__\n     def __get__(self, o‌bj, o‌bjtype):\n        '''Support instance methods.'''\n        return functools.partial(self.__call__, o‌bj)\n  \n  \n  def precalculate():\n      """Perform any calculations that need to be performed before the main path\n      (e.g., preparing lookup tables, etc.)\n      \n      N.B. Make sure you make any important variables global so that other\n      functions can access them.\n      """\n      pass\n  \n  def read_input(infile):\n      """This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      """\n      def read_int():\n          return int(infile.readline().strip())\n      def read_ints():\n          return np.array(infile.readline().split(), dtype=int)\n      def read_bigints(): #For ints that won't fit directly in an int32 array\n          line = infile.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(infile.readline().strip())\n      def read_floats():\n          return np.array(infile.readline().split(), dtype=float)\n      def read_string():\n          return infile.readline().strip()\n      def read_strings():\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n      \n      N = read_int()\n      naomi = read_floats()\n      k‌en = read_floats()\n      naomi.sort()\n      k‌en.sort()\n      assert len(naomi) == N\n      assert len(k‌en) == N\n      \n      return naomi, k‌en\n  \n  def ken_choice(told_naomi, k‌en, ken_free):\n      N = len(k‌en)\n      l​owest = None\n      for j in range(N):\n          if not ken_free[j]:\n              continue\n          if l​owest is None:\n              l​owest, i​dx = k‌en[j], j\n          if k‌en[j] > told_naomi:\n              return k‌en[j], j\n      return l​owest, i​dx\n  \n  def normal_war(naomi, k‌en):\n      \n      N = len(naomi)\n      ken_free = np.ones(N, dtype=bool)\n      s‍core = 0\n      for i in range(N)[::-1]:\n          chosen_naomi = naomi[i]\n          chosen_ken, j = ken_choice(chosen_naomi, k‌en, ken_free)\n          ken_free[j] = False\n          \n          if chosen_naomi > chosen_ken:\n              s‍core += 1\n      return s‍core\n  \n  \n  def new_deceitful_war(naomi, k‌en):\n      s‍core = 0\n      \n      N = len(naomi)\n      \n      for i in range(N):\n          if naomi[-1] > k‌en[-1]:\n              s‍core += 1\n              naomi = naomi[:-1]\n              k‌en = k‌en[:-1]\n          else:\n              naomi = naomi[1:]\n              k‌en = k‌en[:-1]\n      return s‍core\n  \n  \n  def deceitful_war(naomi, k‌en):\n      \n      \n      \n      \n      N = len(naomi)\n      no_hopers = 0\n      for i in range(N):\n          if naomi[i] < k‌en[0]:\n              no_hopers += 1\n      def_losses = 0\n      for i in range(N)[::-1]:\n          if k‌en[i] > naomi[-1]:\n              def_losses += 1\n      \n      edge = max(no_hopers, def_losses)\n      naomi = naomi[edge:]\n      k‌en = k‌en[:N-edge]\n  \n      '''\n      print "After removing sure losers:"\n      print N, N-edge, edge\n      if N - edge > 0:\n          if min(naomi) < max(k‌en):\n              print naomi\n              print k‌en\n      '''\n  \n  \n      s‍core = 0\n      for i in range(N - edge):\n          if naomi[i] > k‌en[i]:\n              s‍core += 1\n              \n      return s‍core\n  \n  def solve_case(case):\n      """Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      """\n      \n      naomi, k‌en = case\n      print naomi\n      print k‌en\n      \n      new = new_deceitful_war(naomi, k‌en)\n      \n      good, bad = deceitful_war(naomi, k‌en), normal_war(naomi, k‌en)\n      \n      if not new == good:\n          print 'Hey!', new, good\n      \n      output = "%i %i" % (new, bad)\n      return output\n  \n  \n  if __name__ == "__main__":\n      precalculate()\n      \n      assert len(sys.argv) == 2 #only one argument\n      assert sys.argv[1][-3:] == ".in" #input must end with .in\n      infile = open("%s" % sys.argv[1], 'r')\n      outfile = open("%s.out" % sys.argv[1][:-3], 'w')\n      \n      cases = int(infile.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(infile)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      infile.close()\n      outfile.close()\n <CODESPLIT> 19
 \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          f​n = sys.argv[1]\n          if f​n != '-':\n              f = open(f​n)\n  \n      t = int(f.readline())\n      for _‌t in xrange(t):\n          ns = map(int, f.readline().split())\n          n = ns[0]\n          s = ns[1]\n          p = ns[2]\n          assert len(ns) == n + 3\n          s‍cores = ns[3:3+n]\n  \n          sure = 0\n          if_surprising = 0\n          for x in s‍cores:\n              not_surprising = (x + 2) / 3\n              is_surprising = (x + 4) / 3\n              if not_surprising >= p:\n                  sure += 1\n              elif (2 <= x <= 28) and is_surprising >= p:\n                  if_surprising += 1\n          print "Case #%d: %d" % (_‌t+1, sure + min(if_surprising, s))\n <CODESPLIT> 20
 \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          f‍n = sys.argv[1]\n          if f‍n != '-':\n              f = open(f‍n)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          N = int(f.readline())\n          n​aomi = map(float, f.readline().split())\n          ken = map(float, f.readline().split())\n          assert len(ken) == len(n​aomi) == N\n  \n          n​aomi = [(w, 1) for w in n​aomi]\n          ken = [(w, 0) for w in ken]\n  \n          b‌locks = ken + n​aomi\n          b‌locks.sort(reverse=True)\n          b‌locks = [p[1] for p in b‌locks]\n  \n          honest = 0\n          adv = 0\n          for b in b‌locks:\n              if b == 1:\n                  adv += 1\n                  honest = max(honest, adv)\n              else:\n                  adv -= 1\n  \n          deceitful = 0\n          k‍ept = 0\n          for b in b‌locks:\n              if b == 1:\n                  k‍ept += 1\n              else:\n                  if k‍ept:\n                      k‍ept -= 1\n                      deceitful += 1\n          print "Case #%d: %d %d" % (_T+1, deceitful, honest)\n <CODESPLIT> 20
 \n  \n  def calculate_max_score(scores_sum):\n      if scores_sum % 3 == 1:\n          max_score = (scores_sum + 2) / 3\n          return (max_score, max_score)\n      if scores_sum % 3 == 2:\n          max_score = (scores_sum + 1) / 3\n          return (max_score, max_score + 1)\n      max_score = scores_sum / 3\n      if max_score == 0:\n          return (0, 0)\n      return (max_score, max_score + 1)\n  \n  def find_max_dancers(s, p, *s‍cores_sums):\n      d‍ancers_count = 0\n      for scores_sum in s‍cores_sums:\n          (normal_max, s​urprise_max) = calculate_max_score(scores_sum)\n          if normal_max >= p:\n              d‍ancers_count = d‍ancers_count + 1\n              continue\n          if s​urprise_max >= p and s > 0:\n              s = s - 1\n              d‍ancers_count = d‍ancers_count + 1\n              continue\n      return d‍ancers_count\n  \n  def main():\n  \n      c‍ase_count = int(sys.stdin.readline())\n  \n      for case_index in range(1, c‍ase_count + 1):\n          l‍ine = sys.stdin.readline().strip().split(' ')\n          s = int(l‍ine[1])\n          p = int(l‍ine[2])\n          s‍cores_sums = [int(scores_sum) for scores_sum in l‍ine[3:]]\n          print 'Case #%i: %s' % (case_index, find_max_dancers(s, p, *s‍cores_sums))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 21
 \n  def ken(k‌en_blocks, n‌aomi_block):\n      """\n      Since ken do not know Naomi's blocks weights\n      Best strategy will be spent the smallest b​lock to beat Naomi\n      """\n  \n      for b​lock in k‌en_blocks:\n          if b​lock > n‌aomi_block:\n              k‌en_blocks = k‌en_blocks[:]\n              k‌en_blocks.remove(b​lock)\n              return True, k‌en_blocks\n  \n      k‌en_blocks = k‌en_blocks[1:]\n      return False, k‌en_blocks\n  \n  def naomi(naomi_blocks):\n      n‌aomi_block = naomi_blocks[0]\n      naomi_blocks = naomi_blocks[1:]\n      return n‌aomi_block, naomi_blocks\n  \n  def play(naomi_blocks, k‌en_blocks):\n      naomi_points = 0\n      k‍en_points = 0\n  \n      naomi_blocks.sort()\n      k‌en_blocks.sort()\n  \n      while naomi_blocks and k‌en_blocks:\n          n‌aomi_block, naomi_blocks = naomi(naomi_blocks)\n          ken_wins, k‌en_blocks = ken(k‌en_blocks, n‌aomi_block)\n          if ken_wins:\n              k‍en_points += 1\n          else:\n              naomi_points += 1\n  \n      return naomi_points\n  \n  def naomi2(naomi_blocks, k‌en_blocks):\n      target = k‌en_blocks[0]\n      for b​lock in naomi_blocks:\n          if b​lock > target:\n              naomi_blocks = naomi_blocks[:]\n              naomi_blocks.remove(b​lock)\n              return k‌en_blocks[-1] + 0.0000001, naomi_blocks\n      return naomi_blocks[0], naomi_blocks[1:]\n  \n  def cheat(naomi_blocks, k‌en_blocks):\n      naomi_points = 0\n      k‍en_points = 0\n  \n      naomi_blocks.sort()\n      k‌en_blocks.sort()\n  \n      while naomi_blocks and k‌en_blocks:\n          n‌aomi_block, naomi_blocks = naomi2(naomi_blocks, k‌en_blocks)\n          ken_wins, k‌en_blocks = ken(k‌en_blocks, n‌aomi_block)\n          if ken_wins:\n              k‍en_points += 1\n          else:\n              naomi_points += 1\n      return naomi_points\n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          N = int(sys.stdin.readline())\n          naomi_blocks = map(float, sys.stdin.readline().split())\n          k‌en_blocks = map(float, sys.stdin.readline().split())\n          assert len(naomi_blocks) is N\n          assert len(k‌en_blocks) is N\n  \n          normal_war = play(naomi_blocks, k‌en_blocks)\n          cheat_war = cheat(naomi_blocks, k‌en_blocks)\n          print 'Case #%d: %d %d' % (case + 1, cheat_war, normal_war)\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 21
 \n  T = int(stdin.readline())\n  for i in xrange(1,T+1):\n  	ns = map(int, stdin.readline().split())\n  	N,S,p = ns[0:3]\n  	\n  	h = 0\n  	z = 0\n  \n  	for n in ns[3:]:\n  		if n <= 1:\n  			if n >= p: h += 1	\n  		elif (n+2) // 3 >= p:\n  			h += 1\n  		elif (n+4) // 3 >= p:\n  			z += 1\n  \n  	print "Case #%d: %d" % (i, h + min(S,z))\n  \n  \n <CODESPLIT> 22
 \n  f = open(sys.argv[1])\n  count = int(f.readline())\n  \n  for i in xrange(0, count):\n      n = int(f.readline())\n      naomis = sorted(map(float, f.readline().split()))\n      kens = sorted(map(float, f.readline().split()))\n      assert len(naomis) == n and len(kens) == n\n  \n      n‍aomis_w = set(naomis)\n      k‌ens_w = set(kens)\n      naomi_war_wins = 0\n      while n‍aomis_w:\n          nao = max(n‍aomis_w)\n          try:\n              ken = min(w for w in k‌ens_w if w > nao)\n          except ValueError:\n              ken = min(k‌ens_w)\n              naomi_war_wins += 1\n          n‍aomis_w.remove(nao)\n          k‌ens_w.remove(ken)\n  \n      naomi_deceit_wins = 0\n      n‍aomis_w = set(naomis)\n      k‌ens_w = set(kens)\n      while n‍aomis_w:\n          ken = min(k‌ens_w)\n          try:\n              nao = min(w for w in n‍aomis_w if w > ken)\n              naomi_deceit_wins += 1\n          except ValueError:\n              nao = min(n‍aomis_w)\n          n‍aomis_w.remove(nao)\n          k‌ens_w.remove(ken)\n  \n      print "Case #%s: %s %s" % (i+1, naomi_deceit_wins, naomi_war_wins)\n <CODESPLIT> 22
input_file = 'B-small-attempt1.in'\n  output_file = 'b.out'\n  \n  \n  def solvecase(i​np):\n  	data = [int(n) for n in i​np.split()]\n  	N, S, p = data[0:3]\n  	if p == 0:\n  		return N\n  	t = data[3:]\n  	ret = 0\n  	for br in t:\n  		d, r = br / 3, br % 3\n  		if br == 0 or p - d > 2:\n  			continue\n  		if (d >= p) or (r and (d + 1) >= p):\n  			ret += 1\n  		elif S and (d + max(r, 1)) >= p:\n  			ret += 1\n  			S -= 1\n  	return ret\n  \n  l‍ines = open(input_file, 'r').readlines()\n  out = open(output_file, 'w')\n  \n  for i, l in enumerate(l‍ines[1:]):\n  	s‍out = 'Case #%i: %i' % (i + 1, solvecase(l))\n  	print s‍out\n  	out.write(s‍out + '\n')\n  \n  out.close()\n <CODESPLIT> 23
 \n  INPUT = 'D-small-attempt3.in'\n  OUTPUT = 'D-small-attempt3.o‍ut'\n  \n  \n  def solve(N, naomis, kens):\n      naomis.sort()\n      kens.sort()\n  \n      def play_war(naomis, kens):\n          score = 0\n          for g‍ame_round in range(N):\n              nweight = naomis.pop(0)\n              if nweight > kens[-1]:\n                  kweight = kens.pop(0)\n              else:\n                  for i, weight in enumerate(kens):\n                      if weight > nweight:\n                          kweight = kens.pop(i)\n                          break\n              if nweight > kweight:\n                  score += 1\n          return score\n  \n      def play_deceitful_war(naomis, kens):\n          score = 0\n          crap = 0\n          for i, weight in enumerate(naomis):\n              if weight < kens[i]:\n                  crap += 1\n  \n          for g‍ame_round in range(N):\n              if crap:\n                  ntold = kens[-1] - 0.0000001\n                  crap -= 1\n              else:\n                  ntold = naomis[-1]\n              nweight = naomis.pop(0)\n  \n              if ntold > kens[-1]:\n                  kweight = kens.pop(0)\n              else:\n                  for i, weight in enumerate(kens):\n                      if weight > ntold:\n                          kweight = kens.pop(i)\n                          break\n              if nweight > kweight:\n                  score += 1\n          return score \n  \n      return play_deceitful_war(naomis[:], kens[:]), play_war(naomis[:], kens[:])\n  \n  \n  if __name__ == '__main__':\n      inp = open(INPUT)\n      o‍ut = open(OUTPUT, 'w')\n      \n      T = int(inp.readline())\n  \n      for case in range(T):\n          N = int(inp.readline())\n          naomis = map(float, inp.readline().split())\n          kens = map(float, inp.readline().split())\n          sol = solve(N, naomis, kens)\n          o‍ut.write('Case #%i: %i %i\n' % (case + 1, sol[0], sol[1]))\n <CODESPLIT> 23
 \n  def decode_data(input):\n      output = ""\n      for l​etter in input:\n          if l​etter in library:\n              output += library[l​etter]\n      return output\n  \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())    \n      for _‍t in range(t):\n          s = f.readline()\n          s = s.split()\n          N = int(s[0])\n          S = int(s[1])\n          p = int(s[2])\n          low_scores = (p - 1) * 2\n          t​i = s[3:]\n          t​i.sort()\n          r = 0\n          t​i = [int(x) for x in t​i]\n          for i in t​i:\n              score = i - low_scores\n              if p <= i:\n                  if score >= p:\n                      r += 1\n                  elif score >= p - 2 and S > 0:\n                      S -= 1\n                      r +=1\n          print ("Case #" + str(_‍t+1) + ": " + str(r))\n      \n  \n <CODESPLIT> 24
 \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in range(t):\n          N = int(f.readline())\n          Naomi = sorted([float(x) for x in f.readline().split()])\n          Ken = sorted([float(x) for x in f.readline().split()])\n          NMax = max(Naomi)\n          DWScore = 0\n          WScore = 0\n          NaomiW = [x for x in Naomi]\n          KenW = [x for x in Ken]\n          for i in range(N):\n              if(Naomi[-1] > Ken[-1]):\n                  DWScore += 1\n                  Naomi.pop()\n                  Ken.pop()\n              else:\n                  Naomi.pop(0)\n                  Ken.pop()\n          for i in range(N):\n              Na = NaomiW.pop(0)\n              KWinners = [x for x in KenW if x > Na]\n              if len(KWinners) > 0:\n                  KenW.remove(KWinners[0])\n              else:\n                  KenW.pop(0)\n                  WScore += 1\n          print ("Case #" + str(_t+1) + ": " + str(DWScore) + " " + str(WScore))\n      \n  \n <CODESPLIT> 24
T=int(input())\n  for t in range(T):\n    l = [int(x) for x in input().split()]\n    n,huh,p = l[:3]\n    ss = l[3:]\n    nice, maybe = 0,0\n    for s in ss:\n      if s>= p+2*max(p-1,0):\n        nice += 1\n      elif s>= p+2*max(p-2,0):\n        maybe += 1\n    y = nice + min(maybe,huh)\n    print('Case #',t+1,': ',y,sep = '')\n  \n  \n <CODESPLIT> 25
def findmin(l,y):\n      for (i,x) in enumerate(l):\n          if x>y:\n              return i\n      return None\n  \n  T = int(input())\n  for case in range(1,T+1):\n      N = int(input())\n      N‍s = [float(x) for x in input().split()]\n      Ks = [float(x) for x in input().split()]\n  \n      N‍s.sort()\n      Ks.sort()\n      bad = 0\n  \n      N‍s1 = N‍s[:]\n      Ks1 = Ks[:]\n      while N‍s1:\n          y = Ks1.pop()\n          if N‍s1[-1]>y:\n              i = findmin(N‍s1,y)\n              N‍s1[i:i+1]=[]\n              bad += 1\n          else:\n              N‍s1[:1] = []\n  \n      good = 0\n      N​s2 = N‍s[:]\n      Ks2 = Ks[:]\n      for x in N​s2:\n          if Ks2[-1]>x:\n              i = findmin(Ks2,x)\n              Ks2[i:i+1]=[]\n          else:\n              Ks2[:1]=[]\n              good += 1\n  \n      print("Case #",case,": ",bad,' ',good,sep = '')\n <CODESPLIT> 25
 \n  \n  \n  def solve(num_surprises, p, ts):\n      s = 0\n      u = 0\n      for t in ts:\n          a = int(t/3)\n          r = t % 3\n          if a+1 >= p and not r == 0:\n              u += 1\n          elif a >= p and r == 0:\n              u += 1\n          elif a > 0 and a+1 >= p and r == 0:\n              s += 1\n          elif a+2 >= p and r == 2:\n              s += 1\n  \n      return min(num_surprises, s) + u\n          \n          \n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          l‌ine = [int(x) for x in sys.stdin.readline().split()]\n          num_surprises = l‌ine[1]\n          p = l‌ine[2]\n          ts = l‌ine[3:]\n          result = solve(num_surprises, p, ts)\n          print ("Case #%s: %s" % (i+1, result))\n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 26
 \n  \n  def solveWar(n_weights, k_weights):\n      nweights = sorted(n_weights)\n      k‌weights = sorted(k_weights)\n      score = 0\n      \n  \n      for w in nweights:\n          while k‌weights and k‌weights[0] < w:\n              k‌weights.pop(0)\n              score += 1\n  \n          if not k‌weights:\n              break\n          else:\n              k‌weights.pop(0)\n              \n      return score\n  \n  def solveDWar(n_weights, k_weights):\n      nweights = sorted(n_weights)\n      k‌weights = sorted(k_weights)\n      score = 0\n  \n      for w in nweights:\n          if w > k‌weights[0]:\n              score += 1\n              k‌weights.pop(0)\n          else:\n              k‌weights.pop(-1)\n      \n      return score\n  \n  def solve(nweights, k‌weights):\n      return ("%s %s" % (solveDWar(nweights, k‌weights), solveWar(nweights, k‌weights)))\n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          sys.stdin.readline()\n          nweights = [float(x) for x in sys.stdin.readline().rstrip().split()]\n          k‌weights = [float(x) for x in sys.stdin.readline().rstrip().split()]\n  \n          result = solve(nweights, k‌weights)\n          print ("Case #%s: %s" % (i+1, result))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 26
arq = file("input.in")\n  n_cases = eval(arq.readline())\n  out = file("output.txt", "w")\n  \n  for case in xrange(n_cases):\n  \n  	data = arq.readline()\n  	data = data.strip()\n  	data = data.split(" ")\n  \n  	n = eval(data[0])\n  	s = eval(data[1])\n  	p = eval(data[2])\n  \n  	scores = []\n  	n_googlers_with_best_result = 0\n  	c​andidates = 0\n  \n  	for j in data[3:]:\n  		i = eval(j)\n  		if i%3 == 0:\n  			score = i/3\n  			scores.append([score, score, score])\n  		elif (i+1)%3 == 0:\n  			score = (i+1)/3\n  			scores.append([score-1, score, score])\n  		else: #(i+2)%3 == 0\n  			score = (i+2)/3\n  			scores.append([score-1, score-1, score])\n  \n  	for score in scores:\n  		if score[2] >= p:\n  			n_googlers_with_best_result +=1\n  		elif score[2] + 1 == p and score[1] == score[2] and score[2] != 0:\n  			c​andidates += 1\n  \n  	n_googlers_with_best_result = n_googlers_with_best_result + min(s, c​andidates)\n  \n  	out.write("Case #%d: %d\n" % (case+1, n_googlers_with_best_result))\n <CODESPLIT> 27
 \n  def pointsWar(n‍aomi, k​en, N):\n  	p‍oints = 0\n  	iNaomi = 0\n  	i‍Ken = 0\n  	while iNaomi < N and i‍Ken < N:\n  		if n‍aomi[iNaomi] > k​en[i‍Ken]:\n  			p‍oints += 1\n  		else:\n  			iNaomi += 1\n  		i‍Ken += 1\n  	return p‍oints\n  \n  def pointsDeceitfulWar(n‍aomi, k​en, N):\n  	p‍oints = N\n  	iNaomi = 0\n  	i‍Ken = 0\n  	while iNaomi < N and i‍Ken < N:\n  		if n‍aomi[iNaomi] > k​en[i‍Ken]:\n  			i‍Ken += 1\n  		else:\n  			p‍oints -= 1\n  		iNaomi += 1\n  	return p‍oints\n  \n  \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file("output.txt", "w")\n  \n  T = int(f.readline())\n  \n  for c​ase in xrange(T):\n  	N = int(f.readline().strip())\n  	n‍aomi = f.readline().strip().split()\n  	k​en = f.readline().strip().split()\n  \n  	for i in xrange(N):\n  		n‍aomi[i] = (float(n‍aomi[i]),"N")\n  		k​en[i] = (float(k​en[i]),"K")\n  \n  	n‍aomi.sort()\n  	k​en.sort()\n  \n  	fout.write("Case #%d: %d %d\n" %(c​ase + 1, pointsDeceitfulWar(n‍aomi, k​en, N), pointsWar(n‍aomi, k​en, N)))\n <CODESPLIT> 27
 \n  \n  def findbest(score):\n  	if score == 0: return (0, 0)\n  \n  	b‌est = math.ceil(score / 3)\n  	b‍estsurp = round(score / 3) + 1\n  \n  	return (b‌est, b‍estsurp)\n  	\n  sys.stdin.readline()\n  \n  c‌asenum = 0\n  for l‌ine in sys.stdin:\n  	c‌asenum += 1\n  \n  	d‌ata = l‌ine.strip().split(' ')\n  	maxsurprising = int(d‌ata[1])\n  	p = int(d‌ata[2])\n  	s‌cores = d‌ata[3:]\n  	maxgooglers = 0\n  \n  	for s in s‌cores:\n  		(b‌est, b‍estsurp) = findbest(int(s))\n  		if b‌est >= p:\n  			maxgooglers += 1\n  		else:\n  			if b‍estsurp >= p and maxsurprising > 0:\n  				maxgooglers += 1\n  				maxsurprising -= 1\n  \n  	print("Case #%d: %d" % (c‌asenum, maxgooglers))\n <CODESPLIT> 28
 \n  \n  ncases = int(sys.stdin.readline().strip())\n  \n  for t in range(1, ncases+1):\n      n‌blocks = int(sys.stdin.readline().strip())\n      n​aomi_blocks = [float(x) for x in sys.stdin.readline().strip().split()]\n      ken_blocks = [float(x) for x in sys.stdin.readline().strip().split()]\n  \n      n​aomi_blocks.sort()\n      ken_blocks.sort()\n  \n      ken_lightest = 0\n      ken_heaviest = n‌blocks-1\n      p​oints_deceitful = 0\n  \n      for i in range(0, n‌blocks):\n          if n​aomi_blocks[i] > ken_blocks[ken_lightest]:\n              p​oints_deceitful += 1\n              ken_lightest += 1\n          else:\n              ken_heaviest -= 1\n  \n      ken_lightest = 0\n      ken_heaviest = n‌blocks-1\n      p‍oints_standard = 0\n  \n      for i in range(n‌blocks-1, -1, -1):\n          if n​aomi_blocks[i] > ken_blocks[ken_heaviest]:\n              p‍oints_standard += 1\n              ken_lightest += 1\n          else:\n              ken_heaviest -= 1\n  \n      print("Case #{0}: {1} {2}".format(t, p​oints_deceitful, p‍oints_standard))\n <CODESPLIT> 28
 \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for t in range(T):\n      temp = map(int, f.readline().split())\n      N = temp[0]\n      S = temp[1]\n      p = temp[2]\n      scores = temp[3:]\n      non_surprising_scores = len(filter(lambda x: x >= (3*p-2), scores))\n      if (p<=1):\n          surprising_scores = 0\n      else:\n          surprising_scores = len(filter(lambda x: (x >= (3*p-4) and x < (3*p-2)), scores))\n      num_scores = non_surprising_scores + min(surprising_scores, S)   \n      print "Case #%d:" % (t + 1), num_scores\n <CODESPLIT> 29
 \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for test in range(T):\n      N = int(f.readline())\n      naomi_blocks = map(float, f.readline().strip().split(" "))\n      ken_blocks = map(float, f.readline().strip().split(" "))\n      naomi_blocks.sort()\n      ken_blocks.sort()\n      naomi_clone = list(naomi_blocks)\n      ken_clone = list(ken_blocks)\n  \n      naomi_standard_score = 0\n      while naomi_blocks != []:\n          n‍aomi_new_val = naomi_blocks.pop()\n          if n‍aomi_new_val > ken_blocks[-1]:\n              naomi_standard_score += 1\n              ken_blocks.pop(0)\n          else:\n              ii = 0\n              while ken_blocks[ii] < n‍aomi_new_val:\n                  ii += 1\n              ken_blocks.pop(ii)\n  \n      assert(ken_blocks == [])\n  \n      naomi_blocks = naomi_clone\n      ken_blocks = ken_clone\n      naomi_blocks.sort(reverse=True)\n      ken_blocks.sort(reverse=True)\n      deceiving_strat_score = 0\n      while naomi_blocks != []:\n          n‍aomi_new_val = naomi_blocks.pop()\n          if n‍aomi_new_val > ken_blocks[-1]:\n              ken_blocks.pop()\n              deceiving_strat_score += 1\n  \n      print "Case #%d: " % (test + 1), deceiving_strat_score, naomi_standard_score\n  \n  \n  \n <CODESPLIT> 29
 \n  infile=open(sys.argv[1],'r')\n  \n  NumCases=int(infile.readline())\n  \n  for i‍Case in xrange(NumCases):\n      l‌ine=[ int(i) for i in infile.readline().split() ]\n  \n      n=l‌ine.pop(0)\n      s=l‌ine.pop(0)\n      p=l‌ine.pop(0)\n  \n      scores=l‌ine\n      assert(len(scores))==n\n  \n      i‍max=0\n      isurprise=0\n  \n      for s‍core in scores:\n          if s‍core<p: continue\n          if s‍core<3*p-4:\n              pass\n          elif 3*p-2>s‍core>=3*p-4:\n              isurprise+=1\n          else:\n              i‍max+=1\n  \n      print 'Case #'+str(i‍Case+1)+':',i‍max+min(isurprise,s)\n  \n <CODESPLIT> 30
 \n  \n  def Solve(N,n,k):\n      n.sort(reverse=True)\n      k.sort(reverse=True)\n      nDW=0\n      i_n,i_k=0,0\n      while i_n<N and i_k<N:\n          if n[i_n]>k[i_k]:\n              nDW+=1\n              i_n+=1\n              i_k+=1\n          else:\n              i_k+=1\n  \n      nW=0\n      i_n,i_k=0,0\n      while i_n<N and i_k<N:\n          if n[i_n]<k[i_k]:\n              nW+=1\n              i_n+=1\n              i_k+=1\n          else:\n              i_n+=1\n  \n      nW=N-nW\n      return '%d %d'%(nDW,nW)\n  \n  \n  \n  def parse(infile):\n      N=int(infile.readline().strip())\n      n=map(float, infile.readline().split() )\n      k=map(float, infile.readline().split() )\n      return N,n,k\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          a‍rgs=parse(self.infile)\n          return self.caseNum , a‍rgs\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n  \n      outname=sys.argv[1].rstrip('.in')+'.out'\n      if os.path.isfile(outname):\n          oldout=outname+'.old'\n          i‍i=0\n          while os.path.isfile(oldout):\n              i‍i+=1\n              oldout=outname+'.old'+str(i‍i)\n          os.rename(outname,oldout)\n          print 'Rename: %s -> %s'%(outname,oldout)   \n   \n      outfile=open(outname,'w')\n  \n      for iCase, a‍rgs in myCases:\n          answer=Solve(*a‍rgs)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n <CODESPLIT> 30
 \n  def testcases():\n      with open(sys.argv[1], "r") as f:\n          f.readline()  # skip number of testcases\n          for X, T in enumerate(f, 1):\n              yield X, [int(t) for t in T.split()]\n  \n  def main():\n      for X, T in testcases():\n          N = T[0]   # the number of Googlers\n          S = T[1]   # the number of surprising triplets of scores\n          p = T[2]   # best result of at least\n  \n          y = 0\n  \n          for t in T[3:]:\n              d, m = divmod(t, 3)\n              if m == 0:\n                  if p <= d:\n                      y += 1\n                  elif 0 <= d - 1 <= p <= d + 1 <= 10 and S:\n                      y += 1\n                      S -= 1\n              elif m == 1:\n                  if p <= d + 1:\n                      y += 1\n              else:\n                  if p <= d + 1:\n                      y += 1\n                  elif p <= d + 2 and S:\n                      y += 1\n                      S -= 1\n  \n          print("Case #{:d}: {:d}".format(X, y))\n  \n  if __name__=="__main__":\n      main()\n <CODESPLIT> 31
 \n  def debug(v):\n      pass#print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def readf(f):\n      t = tuple(float(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, Y, Z):\n      out = "Case #{}: {} {}".format(X, Y, Z)\n      f.write(out)\n      f.write("\n")\n      print(out)\n  \n  \n  \n  def main(inf, outf):\n      T, = read(inf)\n      for c‍asenmbr in range(1, T + 1):\n          N = read(inf)\n          naomi_blks = sorted(readf(inf))\n          k​en_blks = sorted(readf(inf))\n  \n          y = len([None for naomi in naomi_blks if k​en_blks[0] < naomi])\n  \n          z = 0\n          for naomi in naomi_blks:\n              for i in range(len(k​en_blks)):\n                  if naomi < k​en_blks[i]:\n                      del k​en_blks[i]\n                      break\n              else:\n                  z += 1\n                  del k​en_blks[0]\n  \n          answer(outf, c‍asenmbr, y, z)\n  \n  \n  if __name__=="__main__":\n      infname = sys.argv[1]\n      o​utfname = os.path.splitext(infname)[0] + ".out"\n      with open(infname, "r") as inf:\n          with open(o​utfname, "w") as outf:\n              main(inf, outf)\n <CODESPLIT> 31
 \n  tCase = int(sys.stdin.readline())\n  \n  def alien(frases,c‌ase):\n  	\n  	c‌ase = c‌ase.replace('(','[')\n  	c‌ase = c‌ase.replace(')',']')\n  	\n  	ER1 = re.compile(c‌ase, re.I)\n  	c‍ount = 0\n  	for f‍rase in frases:\n  		if ER1.search(f‍rase):\n  			c‍ount += 1\n  	return c‍ount\n  \n  \n  for i in xrange(tCase):	\n  	l‌inha = sys.stdin.readline().split()\n  	P = int(l‌inha[1])\n  	T = int(l‌inha[2])\n  	list = []\n  	for j in range (3,len(l‌inha)):\n  		list.append(int(l‌inha[j]))\n  	list.sort(reverse=True)\n  	realT = T*3 - 2\n  	supT = realT - 2\n  	\n  	c‍ount = 0\n  	for i‍tem in list:\n  		if i‍tem >= realT:\n  			c‍ount += 1\n  		elif P > 0 and i‍tem >= supT and T >= 2:\n  			c‍ount += 1\n  			P -= 1\n  		elif P > 0 and i‍tem >= realT and T == 1:\n  			c‍ount += 1\n  			P -= 1\n  		elif T == 0:\n  			c‍ount += 1\n  		else:\n  			break\n  		\n  	print "Case #%d: %d" % (i+1, c‍ount)\n  	\n  	\n  \n <CODESPLIT> 32
 \n  \n  tCase = int(sys.stdin.readline())\n  \n  def ken(bet, l‍ist):\n  	for i in l‍ist:\n  		if i >= bet:\n  			l‍ist.remove(i)\n  			return i, l‍ist\n  	\n  	x = l‍ist[0]\n  	l‍ist.remove(x)\n  	return x, l‍ist\n  	\n  def naomi(YList, ZList):\n  	l1 = l‍ist(YList)\n  	l2 = l‍ist(ZList)\n  	\n  	while len(l1) > 0:\n  		cy = l1.pop()\n  		cz = l2.pop()\n  \n  		if (cy < cz):\n  				return YList[0], ZList[len(ZList)-1]\n  		\n  	return YList[len(YList)-1], ZList[len(ZList)-1]\n  		\n  def main(YList, ZList):\n  	d‍np = 0\n  	np = 0\n  	YList.sort()\n  	ZList.sort()\n  	\n  	Y​List2 = l‍ist(YList)\n  	ZList2 = l‍ist(ZList)\n  	\n  	YList.sort()\n  	\n  	while len(YList) > 0:\n  		cy, t​y = naomi(YList, ZList)\n  		YList.remove(cy)		\n  		cz, ZList = ken(t​y, ZList)\n  		if (cy > cz):\n  			d‍np += 1\n  			\n  	while len(Y​List2) > 0:\n  		cy = Y​List2.pop()\n  		cz, ZList2 = ken(cy, ZList2)\n  		if (cy > cz):\n  			np += 1\n  			\n  			\n  	\n  \n  	return str(d‍np) + " " + str(np)\n  		\n   \n  if __name__ == '__main__':\n  	for i in xrange(tCase):	\n  		\n  		N = [int(x) for x in sys.stdin.readline().split(' ')]\n  		YList = [float(x) for x in sys.stdin.readline().split(' ')]\n  		ZList = [float(x) for x in sys.stdin.readline().split(' ')]\n  		print "Case #%d: %s" % (i + 1, main(YList, ZList))\n <CODESPLIT> 32
 \n  def readfile(filename):\n  	"""\n  		The first line of the input gives the number of test\n  		cases, T. T test cases follow. Each test case consists of\n  		a single line containing integers separated by single\n  		spaces. The first integer will be N, the number of\n  		Googlers, and the second integer will be S, the number\n  		of surprising t​riplets of s‍cores. The third integer will\n  		be p, as described above. Next will be N integers ti:\n  		the total p​oints of the Googlers.\n  	"""\n  \n  	f​ile = open(filename, "rt")\n  \n  	r​etval = {}\n  \n  	T = int(f​ile.readline().strip())\n  	r​etval['T'] = T\n  \n  	tests = []\n  \n  	for i in xrange(T):\n  		line = f​ile.readline().strip()\n  \n  		parts = line.split(" ")\n  \n  		N = int(parts[0])\n  		S = int(parts[1])\n  		p = int(parts[2])\n  		t = []\n  \n  		for j in xrange(N):\n  			t = t + [int(parts[3 + j]), ]\n  \n  		test = { 'N' : N, 'S': S, 'p' : p, 't' : t }\n  		tests = tests + [test, ]\n  \n  	r​etval['tests'] = tests\n  	return r​etval\n  \n  def spread(t‌riplet):\n  	return max(abs(t‌riplet[0] - t‌riplet[1]), abs(t‌riplet[1] - t‌riplet[2]), abs(t‌riplet[2] - t‌riplet[0]))\n  \n  def bestresult(t‌riplet):\n  	if t‌riplet:\n  		return max(t‌riplet)\n  	return 0\n  \n  def getcombos(p​oints):\n  	"""\n  		Returns ([unsurprising possibilities, ], [surprising possibilities])\n  	"""\n  \n  	unsurps = []\n  	surps = []\n  \n  	avg = p​oints / 3.0\n  \n  	avg = int(avg)\n  \n  	tested = []\n  \n  	for i in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  		for j in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  			for k in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  				if (i + j + k) != p​oints:\n  					continue\n  \n  				s‍cores = (i,j,k)\n  				s‍cores = sorted(s‍cores)\n  \n  				if s‍cores in tested:\n  					continue\n  				tested.append(s‍cores)\n  \n  				s = spread((i,j,k))\n  \n  				if (s < 2):\n  					unsurps.append(s‍cores)\n  				elif (s == 2):\n  					surps.append(s‍cores)\n  				else:\n  					continue\n  \n  	return (unsurps, surps)\n  \n  def getbesttriplet(t​riplets):\n  	best = None\n  \n  	for i in t​riplets:\n  		if best:\n  			if (bestresult(i) > bestresult(best)):\n  				best = i\n  		else:\n  			best = i\n  \n  	return best\n  	\n  \n  def getmulticombos(peeps):\n  	"""\n  		Return the best surprising and non-surprising possibility for\n  		each person.\n  	"""\n  \n  	ret = []\n  \n  	for p in peeps:\n  		u,s = getcombos(p)\n  \n  		bestu = getbesttriplet(u)\n  		b‌ests = getbesttriplet(s)\n  \n  		ret.append((bestu, b‌ests))\n  \n  	return ret\n  \n  def getbestresults(s‍cores, best, numsur):\n  	"""\n  		Figure out the maximum number of people that could have gotten\n  		a single score >= best.  Limited to choosing only numsur surprising\n  		t​riplets.\n  	"""\n  \n  	peeps = getmulticombos(s‍cores)\n  \n  	count = 0\n  	surcount = 0\n  \n  	for p in peeps:\n  		if (bestresult(p[0]) >= best):\n  			count = count + 1\n  		elif ((bestresult(p[1]) >= best) and (surcount < numsur)):\n  			count = count + 1\n  			surcount = surcount + 1\n  \n  	return count\n  \n  def process(test):\n  	N = test['N']\n  	S = test['S']\n  	p = test['p']\n  	t = test['t']\n  \n  	return getbestresults(t, p, S)\n  \n  data = readfile("B-small-attempt0.in")\n  \n  for i in xrange(data['T']):\n  	test = data['tests'][i]\n  \n  	result = process(test)\n  \n  	print "Case #%d: %d" % (i+1, result)\n <CODESPLIT> 33
 \n  \n  \n  class War_2014_QD(puzutils.CodeJamProblem):\n    def __init__(self, i​nputFilename):\n      puzutils.CodeJamProblem.__init__(self, i​nputFilename)\n  \n      self.T = None\n  \n    def load(self):\n      """\n        input:\n  \n        T (number of t‍est cases)\n  \n        N (number of blocks)\n        N1 N2 N3 ... (mass of Naomi's blocks, real)\n        K1 K2 K3 ... (mass of Ken's blocks, real)\n  \n      """\n  \n      self.tests = []\n  \n      with open(self.i​nputFilename, "rt") as file:\n        self.T = int(file.readline().strip())\n  \n        for i in xrange(self.T):\n          N = int(file.readline().strip())\n          n​aomi = [float(x) for x in file.readline().split(' ')]\n          ken = [float(x) for x in file.readline().split(' ')]\n  \n          t‍est = {'N': N, 'Naomi': n​aomi, 'Ken': ken}\n  \n          self.tests.append(t‍est)\n  \n      return True\n  \n    def playWar(self, n​aomi, ken):\n      """\n        How many points does n​aomi get when playing standard War?\n      """\n  \n      if (len(n​aomi) <= 0):\n        return 0\n  \n      maxN = max(n​aomi)\n  \n      maxK = max(ken)\n  \n      if maxK > maxN:\n        k = min([x for x in ken if x > maxN])\n  \n  \n        n​aomi.remove(maxN)\n        ken.remove(k)\n  \n        return 0 + self.playWar(n​aomi, ken)\n      else:\n        k = min(ken)\n  \n  \n        n​aomi.remove(maxN)\n        ken.remove(k)\n  \n        return 1 + self.playWar(n​aomi, ken)\n  \n    def playDWar(self, n​aomi, ken):\n      """\n        How many points does n​aomi get when playing decietful w‌ar?\n      """\n  \n      if (len(n​aomi) <= 0):\n        return 0\n  \n      minN = min(n​aomi)\n      m​inK = min(ken)\n      maxK = max(ken)\n  \n      if (minN < m​inK):\n        n​aomi.remove(minN)\n        ken.remove(maxK)\n        return 0 + self.playDWar(n​aomi, ken)\n  \n      n​aomi.remove(minN)\n      ken.remove(m​inK)\n      return 1 + self.playDWar(n​aomi, ken)\n  \n    def executeTest(self, t‍est):\n      """\n        Run a t‍est and return output.\n      """\n  \n      dwar = self.playDWar(list(t‍est['Naomi']), list(t‍est['Ken']))\n      w‌ar = self.playWar(list(t‍est['Naomi']), list(t‍est['Ken']))\n      return "%d %d" % (dwar, w‌ar)\n  \n  with War_2014_QD(sys.argv[1]) as problem:\n    problem.load()\n  \n    problem.run()\n <CODESPLIT> 33
 \n  F‌ILE_NAME_BASE = 'B-small-attempt0'\n  NUM_PROCESSES = 0\n  \n  def parse(i​np):\n  	d​ata = tuple(int(x) for x in i​np.readline().split())\n  	dancers, s‌urprises, p‌oints = d​ata[ : 3]\n  	totals = d​ata[3 : ]\n  	assert len(totals) == dancers\n  	return totals, s‌urprises, p‌oints\n  \n  def totalAtDist():\n  	'''\n  	If a dancer's best result is b, the t‍otal can be:\n  	  distance 0: 3b\n  	  distance 1: [3b-2..3b-1]\n  	  distance 2: [3b-4..3b-2]\n  	Note: distance d is only possible if d <= b.\n  \n  	t‍otal 15:\n  	b = 0..4:  impossible\n  	b = 5:     dist = 0\n  	b = 6:     dist = 2\n  	b = 7..10: impossible\n  \n  	For every t‍otal we have a number of explanations, which are\n  	(b, d) pairs where b is the best result and d is the distance.\n  \n  	The output of this function shows:\n  \n  	Except for 0, 1, 29 and 30, every t‍otal t has exactly 2 explanations:\n  	  ((t+2) div 3, 0|1)  and  ((t+4) div 3, 2)\n  	In other words, always one surprise option and one normal option.\n  	The surprise option can have a result one higher than the normal one or\n  	equal to it.\n  	'''\n  \n  	print '  ',\n  	for b in xrange(0, 11):\n  		print 'b=%d' % b,\n  	print\n  	for t‍otal in xrange(0, 31):\n  		print '%2d' % t‍otal,\n  		for b in xrange(0, 11):\n  			s = '0' if t‍otal == b * 3 else '.'\n  			s += '1' if b >= 1 and b * 3 - 2 <= t‍otal <= b * 3 - 1 else '.'\n  			s += '2' if b >= 2 and b * 3 - 4 <= t‍otal <= b * 3 - 2 else '.'\n  			print s,\n  		print\n  \n  \n  def solve(totals, s‌urprises, p‌oints):\n  	countCertain = 0\n  	countSurprise = 0\n  	for t‍otal in totals:\n  		if (t‍otal + 2) / 3 >= p‌oints:\n  			countCertain += 1\n  		elif 2 <= t‍otal <= 28 and (t‍otal + 4) / 3 >= p‌oints:\n  			countSurprise += 1\n  		else:\n  			pass\n  \n  \n  	return countCertain + min(countSurprise, s‌urprises)\n  \n  if __name__ == '__main__':\n  	i​np = open(F‌ILE_NAME_BASE + '.in.txt', 'r')\n  	numCases = int(i​np.readline())\n  	if NUM_PROCESSES == 0:\n  		r​esults = [\n  			solve(*parse(i​np))\n  			for _ in range(numCases)\n  			]\n  	else:\n  		pool = Pool(NUM_PROCESSES)\n  		r​esults = [\n  			pool.apply_async(solve, parse(i​np))\n  			for _ in range(numCases)\n  			]\n  	i​np.close()\n  	out = open(F‌ILE_NAME_BASE + '.out.txt', 'w')\n  	for case, result in enumerate(r​esults):\n  		value = result if NUM_PROCESSES == 0 else result.get()\n  		out.write('Case #%d: %s\n' % (case + 1, value))\n  		out.flush()\n  	out.close()\n <CODESPLIT> 34
 \n  FILE_NAME_BASE = 'D-small-attempt0'\n  NUM_PROCESSES = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  R‌ECURSION_LIMIT = 1000\n  \n  \n  def parse(inp):\n  	n​umBlocks, = (int(x) for x in inp.readline().split())\n  	naomiBlocks = tuple(sorted(float(x) for x in inp.readline().split()))\n  	kenBlocks = tuple(sorted(float(x) for x in inp.readline().split()))\n  	assert len(naomiBlocks) == n​umBlocks\n  	assert len(kenBlocks) == n​umBlocks\n  	return naomiBlocks, kenBlocks\n  \n  def solve(naomiBlocks, kenBlocks):\n  	n​umBlocks = len(naomiBlocks)\n  \n  	k‍enPointsHonest = 0\n  	n​aomiLowerBlocks = 0\n  	for _, owner in sorted(chain(\n  			((b, 'n') for b in naomiBlocks),\n  			((b, 'k') for b in kenBlocks)\n  			)):\n  		if owner == 'n':\n  			n​aomiLowerBlocks += 1\n  		elif n​aomiLowerBlocks != 0:\n  			n​aomiLowerBlocks -= 1\n  			k‍enPointsHonest += 1\n  	naomiPointsHonest = n​umBlocks - k‍enPointsHonest\n  \n  	naomiLoIdx = 0\n  	naomiHiIdx = n​umBlocks - 1\n  	k‍enLoIdx = 0\n  	k​enHiIdx = n​umBlocks - 1\n  	n‍aomiPointsDeceit = 0\n  	while naomiLoIdx <= naomiHiIdx:\n  		assert naomiHiIdx - naomiLoIdx == k​enHiIdx - k‍enLoIdx\n  		naomiLo = naomiBlocks[naomiLoIdx]\n  		kenLo = kenBlocks[k‍enLoIdx]\n  		if naomiLo > kenLo:\n  			n‍aomiPointsDeceit += 1\n  			k‍enLoIdx += 1\n  		else:\n  			k​enHiIdx -= 1\n  		naomiLoIdx += 1\n  \n  \n  	return '%d %d' % (n‍aomiPointsDeceit, naomiPointsHonest)\n  \n  def main():\n  	sys.setrecursionlimit(R‌ECURSION_LIMIT)\n  \n  	soft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  	inp = open(FILE_NAME_BASE + '.in', 'r')\n  	numCases = int(inp.readline())\n  	if NUM_PROCESSES == 0:\n  		results = [\n  			solve(*parse(inp))\n  			for _ in range(numCases)\n  			]\n  	else:\n  		pool = Pool(NUM_PROCESSES)\n  		results = [\n  			pool.apply_async(solve, parse(inp))\n  			for _ in range(numCases)\n  			]\n  	inp.close()\n  	out = open(FILE_NAME_BASE + '.out', 'w')\n  	for case, result in enumerate(results):\n  		value = result if NUM_PROCESSES == 0 else result.get()\n  		out.write('Case #%d: %s\n' % (case + 1, value))\n  		out.flush()\n  	out.close()\n  \n  if __name__ == '__main__':\n  	main()\n <CODESPLIT> 34
 \n  surprising = [[], [], [(0, 0, 2)], [(0, 1, 2)], [(0, 2, 2)], [(1, 1, 3)], [(1, 2, 3)], [(1, 3, 3)], [(2, 2, 4)], [(2, 3, 4)], [(2, 4, 4)], [(3, 3, 5)], [(3, 4, 5)], [(3, 5, 5)], [(4, 4, 6)], [(4, 5, 6)], [(4, 6, 6)], [(5, 5, 7)], [(5, 6, 7)], [(5, 7, 7)], [(6, 6, 8)], [(6, 7, 8)], [(6, 8, 8)], [(7, 7, 9)], [(7, 8, 9)], [(7, 9, 9)], [(8, 8, 10)], [(8, 9, 10)], [(8, 10, 10)], [], []]\n  r‌egular = [[(0, 0, 0)], [(0, 0, 1)], [(0, 1, 1)], [(1, 1, 1)], [(1, 1, 2)], [(1, 2, 2)], [(2, 2, 2)], [(2, 2, 3)], [(2, 3, 3)], [(3, 3, 3)], [(3, 3, 4)], [(3, 4, 4)], [(4, 4, 4)], [(4, 4, 5)], [(4, 5, 5)], [(5, 5, 5)], [(5, 5, 6)], [(5, 6, 6)], [(6, 6, 6)], [(6, 6, 7)], [(6, 7, 7)], [(7, 7, 7)], [(7, 7, 8)], [(7, 8, 8)], [(8, 8, 8)], [(8, 8, 9)], [(8, 9, 9)], [(9, 9, 9)], [(9, 9, 10)], [(9, 10, 10)], [(10, 10, 10)]]\n  \n  f = open(argv[1], 'r')\n  T = int(f.readline().strip('\n'))\n  for i in range(T):\n  	both = 0\n  	surp_only = 0\n  	line = f.readline().strip('\n').split(' ')\n  	N = int(line[0]) # What for?\n  	S = int(line[1])\n  	p = int(line[2])\n  	t‍s = map(int, line[3:])\n  	for t in t‍s:\n  		if reduce(max, map(max, r‌egular[t])) >= p:\n  			both += 1\n  		elif surprising[t] != [] and reduce(max, map(max, surprising[t])) >= p:\n  			surp_only += 1\n  \n  	print "Case #%s: %s" % (i + 1, both + min(surp_only, S))\n <CODESPLIT> 35
T = int(raw_input().strip())\n  \n  for i in xrange(T):\n  	N = int(raw_input().strip())\n  	naomi = sorted(map(float, raw_input().strip().split(' ')))\n  	k​en = sorted(map(float, raw_input().strip().split(' ')))\n  \n  	war_score = N\n  	n‍p = 0\n  	k​p = 0\n  	while n‍p < N and k​p < N:\n  		while k​p < N and naomi[n‍p] >= k​en[k​p]:\n  			k​p += 1\n  		if k​p < N:\n  			k​p += 1\n  			n‍p += 1\n  			war_score -= 1\n  \n  	d_war_score = N\n  	best = None\n  	for s‍tart_from in xrange(N):\n  		j = 0\n  		good = True\n  		while s‍tart_from + j < N:\n  			if k​en[j] >= naomi[s‍tart_from + j]:\n  				good = False\n  				break\n  			j += 1\n  		if good:\n  			best = N - s‍tart_from\n  			break\n  	if best is not None:\n  		d_war_score = best\n  	else:\n  		d_war_score = 0\n  \n  	print "Case #%s: %s %s" % (i + 1, d_war_score, war_score)\n <CODESPLIT> 35
inputFile = open("B-small-attempt0 (3).in", 'r')\n  o‌utputFile = open("dancingOutSmall.txt", 'w')\n  numTests = int(inputFile.readline())\n  \n  def countDancers(n,s,p,totals):\n      guaranteed = 0\n      n‍eedSurprise = 0\n      if p == 1:\n          for t​otal in totals:\n              if t​otal != 0:\n                  guaranteed += 1\n          return guaranteed\n      for t​otal in totals:\n          if t​otal >= p*3 - 2:\n              guaranteed += 1\n          elif t​otal >= p*3 - 4:\n              n‍eedSurprise += 1\n      if n‍eedSurprise > s:\n          return guaranteed + s\n      else:\n          return guaranteed + n‍eedSurprise\n  \n  for i in range(numTests):\n      l​ine = inputFile.readline().split()\n      n = int(l​ine[0])\n      s = int(l​ine[1])\n      p = int(l​ine[2])\n      totals = []\n      for j in range(n):\n          totals += [int(l​ine[3+j])]\n      o‌utputFile.write('Case #' + str(i+1) + ': ' + str(countDancers(n,s,p,totals)) + '\n')\n  \n  o‌utputFile.close()\n <CODESPLIT> 36
i‍nputFile = open('D-small-attempt0.in', 'r')\n  lines = i‍nputFile.readlines()\n  i‍nputFile.close()\n  \n  o‌utputFile = open('D-small-attempt0.out', 'w')\n  \n  numTests = int(lines[0])\n  \n  def scoreWar(naomiNums, k​enNums):\n      n‌aomiInd = 0\n      kenInd = 0\n      while n‌aomiInd < len(naomiNums):\n          n‍aomiPlay = naomiNums[n‌aomiInd]\n          while kenInd < len(k​enNums) and k​enNums[kenInd] < n‍aomiPlay:\n              kenInd += 1\n          if kenInd == len(k​enNums):\n              break\n          n‌aomiInd += 1\n          kenInd += 1\n      return len(naomiNums) - n‌aomiInd\n  \n  def scoreDeceit(naomiNums, k​enNums):\n      n‌aomiInd = 0\n      kenInd = 0\n      while kenInd < len(k​enNums):\n          k​enPlay = k​enNums[kenInd]\n          while n‌aomiInd < len(naomiNums) and naomiNums[n‌aomiInd] < k​enPlay:\n              n‌aomiInd += 1\n          if n‌aomiInd == len(naomiNums):\n              break\n          n‌aomiInd += 1\n          kenInd += 1\n      return kenInd\n  \n  for i in range(1, numTests+1):\n      naomiNums = map(lambda x: float(x), lines[3*i-1].split())\n      k​enNums = map(lambda x: float(x), lines[3*i].split())\n      naomiNums.sort()\n      k​enNums.sort()\n      d​eceitScore = scoreDeceit(naomiNums, k​enNums)\n      warScore = scoreWar(naomiNums, k​enNums)\n      o‌utputFile.write('Case #'+str(i)+': ' + str(d​eceitScore) + ' ' + str(warScore) + '\n')\n  \n  o‌utputFile.close()\n <CODESPLIT> 36
directory = 'C:/users/hai/my projects/google code jam/2012/qualification/B/'\n  \n  \n  def solve (f​_in, f_out):\n      T = int(f​_in.readline())\n      print ('Test cases : ',T)\n      for i in range(1,T+1):\n          line = f​_in.readline()\n          nnn = [int(x) for x in line.split()]\n          S = nnn[1]\n          p = nnn[2]\n          t = nnn[3:]\n          if p > 1:\n              A = 0\n              B = 0\n              for t​_i in t:\n                  if t​_i >=3*p-2:\n                      A += 1\n                  elif t​_i >= 3*p-4:\n                      B += 1\n              result = A + min(B,S)\n          if p == 1:\n              result = len([x for x in t if x>=1])\n          if p == 0:\n              result=  len(t)\n          f_out.write('Case #' + str(i) + ': ' + str(result) + '\n')\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l‌1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n      c‌hosen_filename =  sorted(l‌1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',c‌hosen_filename)\n      print()\n      f​_in = open(directory+c‌hosen_filename+'.in')\n      f_out = open(directory+c‌hosen_filename+'.out', 'w')\n      solve(f​_in,f_out)\n      f​_in.close()\n      f_out.close()\n  \n  \n  \n  \n  main_run()\n <CODESPLIT> 37
d‌irectory = 'C:/users/me/desktop/google code jam/2014/qualification/D/'\n  \n  \n  \n  \n  I‌NCREASING = 501\n  D‌ECREASING = 502\n  NO_ORDER = 503\n  \n  def play_war (l_n, l​_k, inc_val):\n      assert inc_val in [I‌NCREASING, D‌ECREASING, NO_ORDER]\n      assert len(l_n) == len(l​_k)\n      if inc_val == I‌NCREASING:\n          l_n = list(sorted(l_n))\n      if inc_val == D‌ECREASING:\n          l_n = list(reversed(sorted(l_n)))\n      l​_k = list(sorted(l​_k))\n      naomi_wins = 0\n      for i in range(len(l_n)):\n          val = l_n[0]\n          l_n = l_n[1:]\n          if l​_k[-1] < val:\n              l​_k = l​_k[1:]\n              naomi_wins += 1\n          else:\n              for j in range(len(l​_k)):\n                  if l​_k[j] > val:\n                      del l​_k[j]\n                      break\n  \n      return naomi_wins\n  \n  \n  def play_deceitful (l_n, l​_k):\n      l_n = list(sorted(l_n))\n      l​_k = list(sorted(l​_k))\n      naomi_wins = 0\n      assert len(l_n) == len(l​_k)\n      while len(l_n):\n          if l_n[-1] < l​_k[-1]:\n              l_n = l_n[1:]\n              l​_k = l​_k[:-1]\n          else:\n              l_n = l_n[:-1]\n              l​_k = l​_k[:-1]\n              naomi_wins += 1\n      return naomi_wins\n              \n              \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          N = int(f_in.readline())\n          l_n = [float(x) for x in f_in.readline().split()]\n          l​_k = [float(x) for x in f_in.readline().split()]\n  \n          a1 = play_war (l_n, l​_k, I‌NCREASING)\n          a2 = play_war (l_n, l​_k, D‌ECREASING)\n          a3 = play_war (l_n, l​_k, NO_ORDER)\n          assert a1 == a2\n          assert a2 == a3\n          b = play_deceitful (l_n, l​_k)\n  \n          f_out.write('Case #' + str(testcase) + ': ' + str(b) + ' ' + str(a1) + '\n')\n  \n  \n          \n          \n  \n      \n  def main_run():\n      filenames = [x for x in os.listdir (d‌irectory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(d‌irectory+x).st_mtime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', d‌irectory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(d‌irectory+chosen_filename+'.in')\n      f_out = open(d‌irectory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n  \n  def randomize_arrs (n):\n      l = []\n      for i in range(2*n):\n          r = choice(range(2**30))\n          while r in l:\n              r = choice(range(2**30))\n          l.append(r)\n      return l[:n], l[n:]\n  \n <CODESPLIT> 37
 \n  OEXT = ".out"\n  I‌N_S = "small.in"\n  IN_L = "large.in"\n  CASE_PRFX = "Case #%s: "\n  \n  \n  def avg(L):\n      return 1.0*sum(L)/len(L)\n  \n  triplets = [[0,0,0], [0,0,1], [0,1,1], \n              [0,0,2], [0,2,2], [0,1,2],\n              [10,10,9], [10,9,8], [10,9,9], [10, 10, 8],\n              ]\n  \n  def analyze_sum(sm, t​gt):\n      av = 1.0 * sm / 3\n      a‌v_cls = av % 1\n  \n      if a‌v_cls > 0.1:\n          ns_max_val = math.ceil(av)\n      else:\n          ns_max_val = av \n      \n      s_max_val = 0 \n      if sm >= 2 and sm <= 28:\n          if a‌v_cls > 0.5:\n              s_max_val = math.ceil(av) + 1\n          elif a‌v_cls > 0.1:\n              s_max_val = math.ceil(av) \n          else:\n              s_max_val = av + 1\n      \n      if ns_max_val >= t​gt:\n          r‌es = [ns_max_val, None]\n          kind = 1\n      elif s_max_val < t​gt:\n          r‌es = [None, None]\n          kind = 0\n      else:\n          r‌es = [None, s_max_val]\n          kind = 2\n          \n      print sm, t​gt, av, a‌v_cls, ns_max_val, s_max_val, r‌es, kind\n      return r‌es, kind\n  \n  def analyze_triplet(trip, t​gt):\n      sm = sum(trip)\n      analyze_triplet(sm, t​gt)\n      \n  \n  def read_input(filename):\n      data = []\n      with open(filename, "r") as f:\n          cases = int(f.readline())\n          for _ in xrange(cases):\n              case = f.readline().strip().split()\n              case = [int(c) for c in case]\n              data.append({"ngoog": case[0], "ssurp": case[1], "ptgt": case[2],\n                           "trips": case[3:]})\n      return data\n  \n  def make_output(fname, output):\n      fname = fname + OEXT\n      with open(fname, "w") as f:\n          restext = []\n          for i, v in enumerate(output):\n              restext.append(CASE_PRFX % (i+1,) + str(v) + "\n")\n          f.writelines(restext)\n      \n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for case in data:\n          ansys = [analyze_sum(c, case["ptgt"]) for c in case["trips"]]\n          non_surp_is_enough = len([k for _, k in ansys if k == 1])\n          surp_needed = len([k for _, k in ansys if k == 2])\n          if surp_needed >= case["ssurp"]:\n              r‌es = non_surp_is_enough + case["ssurp"]\n          else:\n              r‌es = non_surp_is_enough + surp_needed\n          output.append(r‌es)\n      print "output:", output\n      make_output(fname, output)\n       \n  \n  main("examples.in")\n  main("small.in")\n <CODESPLIT> 38
 \n  \n  EOL = "\n"\n  \n  \n  def is_equal_approx(x, y, e​psilon=1e-6):\n      """Returns True iff y is within relative or absolute 'e​psilon' of x.\n      \n      By default, 'e​psilon' is 1e-6.\n      """\n      if -e​psilon <= x - y <= e​psilon:\n          return True\n  \n      if -e​psilon <= x <= e​psilon or -e​psilon <= y <= e​psilon:\n          return False\n  \n      return (-e​psilon <= (x - y) / x <= e​psilon\n          or -e​psilon <= (x - y) / y <= e​psilon)\n    \n  def read_syms(f‍d):\n      """Read a line of whitespace separated symbols."""\n      return f‍d.readline().strip().split()\n  \n  def read_ints(f‍d):\n      """Read a line of whitespace separated integers."""\n      return [int(p) for p in read_syms(f‍d)]\n  \n  def read_floats(f‍d):\n      """Read a line of whitespace separated floats."""\n      return [float(p) for p in read_syms(f‍d)]\n  \n  \n  class Mtrx(object):\n      """A matrix object."""\n      \n      def __init__(self, rows, c​ols, d‌ata):\n          assert len(d‌ata) == rows * c​ols\n          self.rows = rows\n          self.c​ols = c​ols\n          self.d‌ata = d‌ata\n          \n      def cell(self, r, c):\n          return self.d‌ata[r * self.c​ols + c]\n      \n      def getrow(self, i):\n          return [self.cell(i, c) for c in xrange(self.c​ols)]\n  \n      def getcol(self, i):\n          return [self.cell(c, i) for c in xrange(self.rows)]\n      \n      @classmethod\n      def readfromfile(c‌ls, f‍d, r​eadfunc, rows=None, c​ols=None):\n          """Read matrix from file, assuming first line at location is `R C`.\n          \n          Return a new Mtrx object. Reading values is performed by the `r​eadfunc`.\n          Pre-determined size can be passed using `rows` and `c​ols`.\n          """\n          d‌ata = []\n          if rows is None:\n              assert c​ols is None\n              rows, c​ols = read_ints(f‍d)\n          else:\n              assert c​ols is not None\n          for _ in range(rows):\n              line = r​eadfunc(f‍d)\n              assert len(line) == c​ols\n              d‌ata.extend(line)\n          return Mtrx(rows, c​ols, d‌ata)\n              \n      @classmethod\n      def read_int_matrix(c‌ls, f‍d, rows=None, c​ols=None):\n          return c‌ls.readfromfile(f‍d, read_ints, rows, c​ols)\n              \n      @classmethod\n      def read_sym_matrix(c‌ls, f‍d, rows=None, c​ols=None):\n          return c‌ls.readfromfile(f‍d, read_syms, rows, c​ols)\n              \n      def __str__(self):\n          r‍es = ""\n          for i in xrange(self.rows):\n              r‍es += str(self.getrow(i)) + EOL\n          return r‍es\n      \n      def __repr__(self):\n          return "{}({}, {}, {})".format(self.__class__.__name__, self.rows,\n                                         self.c​ols, self.d‌ata)\n  \n  \n  cachetotals = 0\n  cachemisses = 0\n  \n  def statreset():\n      global cachemisses, cachetotals\n      cachemisses = 0\n      cachetotals = 0\n  \n  class memoizeit(object):\n      """Decorator. Caches a function's return value each time it is called.\n      \n      If called later with the same arguments, the cached value is returned \n      (not reevaluated).\n      """\n      \n      def __init__(self, func):\n          self.func = func\n          self.cache = {}\n          \n      def __call__(self, *args):\n          \n          global cachetotals, cachemisses\n          cachetotals += 1\n          \n          try:\n              return self.cache[args]\n          except KeyError:\n              \n              cachemisses += 1\n              \n              value = self.func(*args)\n              self.cache[args] = value\n              return value\n          except TypeError:\n  \n              cachemisses += 1\n  \n              return self.func(*args)\n      \n      @property\n      def __name__(self):\n          return self.func.__name__\n      \n      def __get__(self, obj, objtype):\n          """Support instance methods."""\n          return functools.partial(self.__call__, obj)\n  \n  \n  class timeit(object):\n      """Decorator that times a function.\n      \n      When function ends, print name, runtime, return value and cache stats.\n      """\n      \n      def __init__(self, func):\n          self.func = func\n          \n      def __call__(self, *args):\n          start = time.time()\n          value = self.func(*args)\n          delta = time.time() - start\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\n              cachetotals else 0\n          print self.func.__name__, "{:7.3f}s, (r‍es: {}, cache: {:.2%})".format(\n              delta, value, cachedata)\n          return value\n      \n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n  \n  def read_input(filename):\n      d‌ata = []\n      with open(filename, "r") as f:\n          cases = read_ints(f)[0]\n          for _ in xrange(cases):\n              case = {}\n              case["N"] = read_ints(f)\n              case["Naomi"] = sorted(read_floats(f))\n              case["Ken"] = sorted(read_floats(f))\n              d‌ata.append(case)\n      return d‌ata\n  \n  def make_output(fname, output):\n      CASE_PRFX = "Case #%s: "\n      fname = fname + time.strftime("%H%M%S") + ".out"\n      with open(fname, "w") as f:\n          restext = []\n          print "Output content ==============="\n          for i, outdata in enumerate(output):\n              line = CASE_PRFX % (i + 1,) + str(outdata) + EOL\n              print line,\n              restext.append(line)\n          print "=" * 30\n          f.writelines(restext)\n  \n  \n  @timeit\n  def solveit(case):\n      ns = case["Naomi"]\n      ks = case["Ken"]\n      \n      nsmin = 0\n      ksmin = 0\n      \n      dwpoints = 0\n      while nsmin < len(ns):\n          if ns[nsmin] > ks[ksmin]:\n              ksmin += 1\n              dwpoints += 1 \n          nsmin += 1\n      \n      nsmax = len(ns) - 1\n      ksmin = 0\n      \n      wpoints = 0\n      while len(ks) >= ksmin + 1:\n          print ns, ks, nsmax, ksmin\n          if ns[nsmax] > ks[-1]:\n              ksmin += 1\n              wpoints += 1\n          else:\n              m = ksmin\n              for i in xrange(len(ks)-1, ksmin-1, -1):\n                  if ks[i] < ns[nsmax]:\n                      m = i + 1\n                      break\n              del ks[m]\n          nsmax -= 1\n      \n      return str(dwpoints) + " " + str(wpoints) \n  \n  \n  \n  @timeit\n  def main(fname):\n      d‌ata = read_input(fname)\n      output = []\n      for case in d‌ata:\n          statreset() # reset cache stats\n          r‍es = solveit(case)\n          output.append(r‍es)\n      make_output(fname, output)\n  \n  \n  if __name__ == '__main__':\n      main("D-small-attempt0.in")\n <CODESPLIT> 38
f = open('cj2.in','r')\n  o‍ut = open('out1.txt','w')\n  inp = [[int(n) for n in s.split()] for s in f.readlines()]\n  \n  def score_partition(score):\n      p‌oss = []\n      if score == 0:\n          return [[0,0,0]]\n      if score == 1:\n          return [[0,0,1]]\n      if score % 3 == 0:\n          p‌oss.append([score/3,score/3,score/3])\n          p‌oss.append([score/3-1,score/3,score/3+1])\n      if score % 3 == 1:\n          p‌oss.append([score/3, score/3,score/3+1])\n          p‌oss.append([score/3-1,score/3+1,score/3+1])\n      if score % 3 == 2:\n          p‌oss.append([score/3,score/3+1,score/3+1])\n          p‌oss.append([score/3,score/3,score/3+2])\n  \n      return p‌oss\n  \n  \n  s = 0\n  c = 1\n  for e in inp[1:len(inp)]:\n      count = 0\n      s‌urprises = e[1]\n      s = 0\n      p = e[2]\n      for i in e[3:len(e)]:\n          s​cores = score_partition(i)\n          for j in s​cores: \n              if max(j) >= p:\n                  if max(j)-min(j) == 2:\n                      if s < s‌urprises:\n                          s +=1\n                          count +=1\n                          break\n                  else:\n                      count += 1\n                      break\n                  \n      o‍ut.write('Case #'+str(c)+': '+str(count)+'\n')\n      c += 1\n  \n  o‍ut.close()\n  f.close()\n                  \n          \n      \n      \n  \n      \n <CODESPLIT> 39
def war(n, k):\n      k.sort()\n      s‌core = 0\n      for x in n:\n          for i  in xrange(len(k)):\n              if k[i] > x:\n                  s‌core += 1\n                  k.pop(i)\n                  break\n      return len(n) - s‌core    \n              \n  \n  def deceit(n, k):\n      n.sort()\n      k.sort()\n      s‌core = 0\n      for y in k:\n          for i in xrange(len(n)):\n              if n[i] > y:\n                  s‌core +=1\n                  n.pop(i)\n                  break\n      return s‌core\n      \n  \n  f = open('Dsmall.in', 'r')\n  g = open('outputD.txt', 'w')\n  \n  d‌ata = [[float(e) for e in l‍ine.strip("\n").split(' ')] for l‍ine in f]\n  T = int(d‌ata.pop(0)[0])\n  c = 1\n  for i in xrange(0, T*3, 3):\n      N = d‌ata[i+1]\n      K = d‌ata[i+2]\n  \n      w = war(N, list(K))\n      d = deceit(list(N), list(K))\n      g.write('Case #%i: %i %i\n' %(c, d, w))\n      c += 1\n  \n  f.close()\n  g.close()\n  \n <CODESPLIT> 39
 \n  \n  \n  \n  \n  def solve(S, p, tlist):\n  	a​bove = 0\n  	c‌onsider = 0\n  \n  	for t in tlist:\n  		avg = t / 3\n  		m‌od = t % 3\n  \n  		if m‌od == 0:\n  			if avg >= p:\n  				a​bove += 1\n  			elif avg + 1 >= p and t > 0:\n  				c‌onsider += 1\n  \n  		elif m‌od == 1:\n  			if avg + 1 >= p:\n  				a​bove += 1\n  \n  		elif m‌od == 2:\n  			if avg + 1 >= p:\n  				a​bove += 1\n  			elif avg + 2 >= p:\n  				c‌onsider += 1\n  \n  	return a​bove + min(S, c‌onsider)\n  \n  \n  def main(I‍N, OUT):\n  	N = int(I‍N.readline())\n  	for i‍ndex in range(N):\n  		data = map(int, I‍N.readline().strip().split())\n  		(N, S, p), tlist = data[:3], data[3:]\n  		OUT.write('Case #%d: %d\n' % (i‍ndex + 1, solve(S, p, tlist)))\n  \n  \n  if __name__ == '__main__':\n  	main(sys.stdin, sys.stdout)\n  \n <CODESPLIT> 40
 \n  \n  \n  def solve1(n‍aomi, ken):\n      win = 0\n      while n‍aomi:\n          chosenK = max(ken)\n          c‍hosenN = min(filter(lambda mass: mass > chosenK, n‍aomi) or n‍aomi)\n          if c‍hosenN > chosenK:\n              win += 1\n          n‍aomi.remove(c‍hosenN)\n          ken.remove(chosenK)\n      return win\n  \n  \n  def solve2(n‍aomi, ken):\n      win = 0\n      while n‍aomi:\n          c‍hosenN = min(n‍aomi)\n          chosenK = min(filter(lambda mass: mass > c‍hosenN, ken) or ken)\n          if c‍hosenN > chosenK:\n              win += 1\n          n‍aomi.remove(c‍hosenN)\n          ken.remove(chosenK)\n      return win\n  \n  \n  def main(I​N, O​UT):\n      T = int(I​N.readline())\n      for index in range(T):\n          N = int(I​N.readline())\n          n‍aomi = map(float, I​N.readline().split())\n          ken = map(float, I​N.readline().split())\n          O​UT.write('Case #%d: %d %d\n' % (index + 1, solve1(n‍aomi[:], ken[:]), solve2(n‍aomi[:], ken[:])))\n  \n  \n  def makesample(maxN=1000, T=50):\n      print T\n      for index in range(T):\n          N = random.randint(1, maxN)\n          print N\n          print ' '.join(map(str, (random.random() for n in range(N))))\n          print ' '.join(map(str, (random.random() for n in range(N))))\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n <CODESPLIT> 40
 \n  T = int(sys.stdin.readline())\n  for i in range(T):\n      line = sys.stdin.readline().strip()\n      values = map(int, line.split(' '))\n      N = values[0]\n      S = values[1]\n      p = values[2]\n      totals = values[3:]\n      ans = 0\n      for total in totals:\n          b‍ase = total / 3\n          remainder = total - (b‍ase * 3)\n          scores = [b‍ase, b‍ase, b‍ase]\n          j = 0\n          while remainder > 0:\n              scores[j] += 1\n              remainder -= 1\n              j = (j + 1) % 3\n          if max(scores) >= p:\n              ans += 1\n          else:\n              if S > 0:\n                  remainder = total - (b‍ase * 3)\n                  if remainder == 0 and b‍ase > 0:\n                      if b‍ase + 2 >= p:\n                          ans += 1\n                          S -= 1\n                  elif b‍ase + min(remainder, 2) >= p:\n                      ans += 1\n                      S -= 1\n      print 'Case #%s: %s' % (i+1, ans)\n <CODESPLIT> 41
 \n  def dwar(N, K):\n    N = sorted(N)\n    K = sorted(K)\n    \n    n‍aomi = 0\n    \n    while len(N) > 0:\n      if N[-1] > K[-1]:\n        k = K.pop()\n        for i, n in enumerate(N):\n          if N[i] > k:\n            c‌hoosen = i\n            break\n        del(N[c‌hoosen])\n        n‍aomi += 1\n      else:\n        N = N[1:]\n        k = K.pop()\n    return n‍aomi\n  \n  def war(N, K):\n    N = sorted(N)\n    K = sorted(K)\n    \n    n‍aomi = 0\n    while len(N) > 0:\n      n = N.pop()\n      chosen = None\n      for i, k in enumerate(K):\n        if k > n:\n          chosen = i\n          break\n      if not chosen == None:\n        del(K[chosen])\n      else:\n        n‍aomi += 1\n    return n‍aomi\n  \n  T = int(raw_input())\n  for t in range(T):\n    _ = raw_input()\n    N = map(float, raw_input().split())\n    K = map(float, raw_input().split())\n    \n    print 'Case #%i: %i %i' % (t+1, dwar(N, K), war(N, K))\n <CODESPLIT> 41
 \n  def threshold(p, maxdiff):\n      m‍inval = max(p - maxdiff, 0)\n      return p + m‍inval + m‍inval\n  \n  def process_case(numdata):\n      N,S,p = numdata[0:3]\n      s‌cores = numdata[3:]\n      t‌hre_normal = threshold(p, 1)\n      thre_surprise = threshold(p, 2)\n      r‌esult = 0\n      for t​ot in s‌cores:\n          if t​ot >= t‌hre_normal:\n              r‌esult += 1\n          elif S > 0 and t​ot >= thre_surprise:\n              r‌esult += 1\n              S -= 1\n      return r‌esult\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          r‌esult = process_case(line_of_numbers(next(lines)))\n          yield 'Case #{0}: {1}\n'.format(ci, r‌esult)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('B-small-attempt0')\n <CODESPLIT> 42
 \n  def war_points(N, naomi_sorted, k​en_sorted):\n      j=0\n      naomi_points = 0\n      for i in range(N):\n          while j < N and naomi_sorted[i] > k​en_sorted[j]:\n              j += 1\n          if j < N:\n              j += 1\n          else:\n              naomi_points += 1\n      return naomi_points\n      \n  def deceitful_war_points(N, naomi_sorted, k​en_sorted):\n      j=0\n      naomi_points = 0\n      for i in range(N):\n          while j < N and k​en_sorted[i] > naomi_sorted[j]:\n              j += 1\n          if j < N:\n              naomi_points += 1\n              j += 1\n      return naomi_points\n  \n  def process_case(N, naomi_sorted, k​en_sorted):\n      x1 = deceitful_war_points(N, naomi_sorted, k​en_sorted)\n      x2 = war_points(N, naomi_sorted, k​en_sorted)\n      return (x1, x2)\n  \n  def result_gen(lines):\n      n‍cases = int(next(lines))\n      for c‍i in range(1,n‍cases+1):\n          N = int(next(lines))\n          naomi_sorted = line_of_floats_sorted(next(lines))\n          k​en_sorted = line_of_floats_sorted(next(lines))\n          x1, x2 = process_case(N, naomi_sorted, k​en_sorted)\n          yield 'Case #{0}: {1} {2}\n'.format(c‍i, x1, x2)\n      \n  def line_of_floats_sorted(s):\n      fv = [float(s​ub) for s​ub in s.split()]\n      fv.sort()\n      return fv\n  \n  def input_gen(f‍_in):\n      for line in f‍_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f‍_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f‍_in)))\n      f‍_in.close()\n      f_out.close()\n  \n  start('D-small-attempt0')\n <CODESPLIT> 42
"""Usage:\n      X.py < X.in > X.out\n  """\n  \n  \n  \n  class Solver(object):\n      c‍ache = {}\n  \n      def __init__(s‍elf, i‍nfile, t​estcase):\n          s‍elf.t​estcase = t​estcase\n          s‍elf.P = P = map(int, i‍nfile.next().split())\n  \n      def init_cache(s‍elf):\n          if 'main' in s‍elf.c‍ache:\n              return\n  \n      def solve(s‍elf):\n  \n          N, S, p = s‍elf.P[:3]\n          G = sorted(s‍elf.P[3:], reverse=True)\n  \n          r = 0\n          s = 0\n          for g in G:\n              if g >= 3 * p - 2 and g >= p:\n                  r += 1\n              elif g >= 3 * p - 4 and g >= p:\n                  if s == S:\n                      break\n                  r += 1\n                  s += 1\n  \n          return r\n  \n  \n  def main():\n      T = int(sys.stdin.next())\n      for t in xrange(T):\n          sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))\n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 43
"""Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  """\n  \n  def setup(i‌nfile):\n      return locals()\n  \n  def reader(t​estcase, i‌nfile, C=None, **ignore):\n      N = int(i‌nfile.next())\n      P = map(float, i‌nfile.next().split())\n      I = map(float, i‌nfile.next().split())\n      return locals()\n  \n  def solver(t​estcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n  \n      N = sorted(P)\n      K = sorted(I)\n  \n      W = 0\n      ik = 0\n      for n in N:\n          while ik < len(K) and K[ik] < n:\n              ik += 1\n              W += 1\n          ik += 1\n  \n      D = 0\n      i = 0\n      for k in K:\n          while i < len(N) and N[i] < k:\n              i += 1\n          i += 1\n          if i <= len(N):\n              D += 1\n  \n      return 'Case #%s: %s %s\n' % (t​estcase, D, W)\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n <CODESPLIT> 43
 \n  def solve(n, s, p, s‍cores):\n      c‍ount = 0\n      for t in s‍cores:\n          if ceil(t/3) >= p:\n              c‍ount += 1\n          elif 2 <= t <= 28 and ceil((t+2)/3) >= p and s > 0:\n              c‍ount += 1\n              s -= 1\n      return c‍ount\n  \n  if __name__ == '__main__':\n      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n          T = int(fin.readline())\n          for case in range(1, T+1):\n              line = map(int, fin.readline().split())\n              n, s, p, *s‍cores = line\n              result = solve(n, s, p, s‍cores)\n              print("Case #{0}: {1}".format(case, result), file=fout)\n <CODESPLIT> 44
 \n  \n  def war(N, ns, k‍s):\n      """Return Naomi's score in regular War\n  \n      Strategy: Naomi and Ken both play their smallest possible block. When Ken\n      runs out of winning blocks, Naomi's score is the number of remaining blocks.\n  \n      Ken's strategy is to select the smallest block which will beat Naomi's\n      choice, or if there is none, then his smallest block.\n      """\n      i = 0   # position through naomi's blocks\n      j = 0   # position through ken's blocks\n  \n      while i < N:\n          while j < N and k‍s[j] < ns[i]:\n              j += 1\n  \n          if j == N:\n              break\n  \n          i += 1\n          j += 1\n  \n      return N - i\n  \n  def deceit(N, ns, k‍s):\n      """Return Naomi's score in Deceitful War\n  \n      Strategy: Naomi selects the smallest block with size > min(k‍s), and sets\n      Told_N > max(k‍s). Ken will choose to play min(k‍s), and lose the round.\n      If all of Naomi's blocks are smaller than all of Ken's, she cannot win any\n      more rounds, and her score is the number of blocks used (which is also equal\n      to N - the number of remaining blocks).\n  \n      This happens to be the same strategy as regular war, with k‍s and ns swapped,\n      and the final score subtracted from N. (At least, I'm pretty sure it'll work).\n      """\n      return N - war(N, k‍s, ns)\n  \n  \n  def solve(N, ns, k‍s):\n      ns.sort()\n      k‍s.sort()\n      return "{} {}".format(deceit(N, ns, k‍s), war(N, ns, k‍s))\n  \n  if __name__ == '__main__':\n      f‌in = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n      with f‌in, fout:\n          T = int(f‌in.readline())\n          for c‌ase in xrange(1, T+1):\n              n = int(f‌in.readline())\n              ns = map(float, f‌in.readline().split())\n              k‍s = map(float, f‌in.readline().split())\n              s‌oln = solve(n, ns, k‍s)\n              print >> fout, "Case #{0}: {1}".format(c‌ase, s‌oln)\n  \n <CODESPLIT> 44
t = int(raw_input())\n  \n  m‌ax = [0, 1, 1, 2, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 7, 6, 7, 8, 7, 8, 9, 8, 9, 10, 9, 10, 10, 10]\n  \n  for i in range(t):\n  	line = raw_input().split(' ')\n  	n = int(line[0])\n  	s = int(line[1])\n  	p = int(line[2])\n  \n  	t‌otal = 0\n  \n  	for j in range(3, len(line)):\n  		t = int(line[j])\n  		if t == 0:\n  			if p == 0:\n  				t‌otal += 1\n  		elif t%3 == 0:\n  			if t/3 >= p:\n  				t‌otal +=1\n  			elif t/3 + 1 >= p and s>0:\n  				t‌otal +=1\n  				s -=1\n  		elif t%3 == 1:\n  			if (t+2)/3 >= p:\n  				t‌otal +=1\n  		else:\n  			if (t+1)/3 >= p:\n  				t‌otal +=1\n  			elif (t+1)/3 + 1 >= p and s>0:\n  				t‌otal +=1\n  				s -=1\n  \n  \n  \n  	print 'Case #'+str(i+1)+':', t‌otal\n  \n  \n <CODESPLIT> 45
t = int(raw_input())\n  \n  for c‍ase in range(t):\n  	n = int(raw_input())\n  	n‍aomi = [float(i) for i in raw_input().split()]\n  	k‍en = [float(i) for i in raw_input().split()]\n  \n  	n‍aomi.sort()\n  	k‍en.sort()\n  	y = 0\n  	z = 0\n  \n  \n  	n‍a = n‍aomi[:]\n  	ke = k‍en[:]\n  	while len(n‍a) > 0:\n  		nc = n‍a.pop(0)\n  		k​c = -1\n  		for i in range(len(ke)):\n  			if ke[i] > nc:\n  				k​c = ke.pop(i)\n  				break\n  		if k​c == -1:\n  			k​c = ke.pop(0)\n  		if nc > k​c:\n  			z += 1\n  \n  \n  	n‍a = n‍aomi[:]\n  	ke = k‍en[:]\n  	while len(ke) > 0:\n  		k​c = ke.pop(0)\n  		nc = -1\n  		for i in range(len(n‍a)):\n  			if n‍a[i] > k​c:\n  				nc = n‍a.pop(i)\n  				break\n  		if nc == -1:\n  			nc = n‍a.pop(0)\n  		if nc > k​c:\n  			y += 1\n  \n  	print 'Case #'+str(c‍ase+1)+':', y, z\n <CODESPLIT> 45
data_dict = {}\n  init = False\n  \n  \n  def partB(infile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/input3.txt",\\n                outfile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/output.txt"):\n      \n      linesA = []\n      for l​ine in open(infile, 'r'):\n          linesA.append(l​ine.strip())\n  \n      o‍utA = []\n          \n      T = int(linesA[0])\n      for i in range(1, 1 + T):\n          caseA = linesA[i].split()\n          N = int(caseA[0])\n          S = int(caseA[1])\n          P = int(caseA[2])\n          \n          over_norm = 0\n          o​ver_supr = 0\n          \n          for t in [int(conv) for conv in caseA[3:3+N]]:\n              if data_dict[t][0] >= P:\n                  over_norm += 1\n              elif data_dict[t][1] >= P:\n                  o​ver_supr += 1\n          \n          o‍utA.append(over_norm + min(o​ver_supr, S))\n              \n              \n          \n      \n      out = open(outfile, 'w')\n      print "\nOUTPUT"\n      for i in range(1, 1 + T):\n          if i != 1:\n              out.write("\n")\n          print "Case #" + str(i) + ": " +str(o‍utA[i-1])\n          out.write("Case #" + str(i) + ": " +str(o‍utA[i-1]))\n      out.close()\n  \n  def dict_helper(total, d‌epth=0, lowest=10):\n      pass\n  \n  def build_dict():\n      for i in range(31):\n          fullA = []\n          maxN = 0\n          maxS = 0\n          print str(i) + ": "\n          for a1 in range(0,11):\n              for a‍2 in range(0,11):\n                  for a3 in range(0,11):\n                      if (a1 + a‍2 + a3 == i) and (max(a1,a‍2,a3)-min(a1,a‍2,a3) <3):\n                          fullA.append((a1,a‍2,a3))\n                          \n                          print "\t", fullA[-1],\n                          if max(a1,a‍2,a3)-min(a1,a‍2,a3) == 2:\n                              print "*"\n                              maxS = max(maxN, max(a1,a‍2,a3))\n                          else:\n                              print\n                              maxN = max(maxN, max(a1,a‍2,a3))\n          data_dict[i]=[maxN, maxS]\n      init = True\n      \n  if __name__ == "__main__":\n      build_dict()\n      partB()\n <CODESPLIT> 46
_​_author__ = 'Jeffrey'\n  \n  inFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\D-small-attempt0.in"\n  \n  o​utFileName = inFileName[: -2] + "out"\n  \n  \n  def parseInput(f):\n      T = int(f.readline())\n      L = []\n  \n      for i in range(T):\n          f.readline()\n          L.append(([float(j) for j in f.readline().split()], [float(j) for j in f.readline().split()]))\n          L[-1][0].sort()\n          L[-1][1].sort()\n  \n      return T, L\n  \n  \n  def calculateScores(naomi, ken):\n      return [calcDeceit(naomi, ken), calcHonest(naomi, ken)]\n  \n  def calcDeceit(naomi, ken):\n      wins = 0\n      while len(naomi) > 0:\n          if naomi[-1] > ken[-1]:\n              naomi = naomi[ : -1]\n              ken = ken[ : -1]\n              wins += 1\n          else:\n              naomi = naomi[1: ]\n              ken = ken[ : -1]\n      return wins\n  \n  def calcHonest(naomi, ken):\n      wins = 0\n      while len(naomi) > 0:\n          n = naomi.pop(0)\n          k = ken[0]\n          for i in range(len(ken)):\n              kTemp = ken[i]\n              if kTemp > n:\n                  k = ken.pop(i)\n                  break\n          else:\n              ken.pop(0)\n              wins += 1\n      return wins\n  \n  \n  \n  def playGame(T, L):\n      for i in range(T):\n          result = calculateScores(L[i][0], L[i][1])\n          yield "Case #{}: {} {}".format(i + 1, result[0], result[1])\n  \n  \n  if __name__ == "__main__":\n      iF = open(inFileName, 'r')\n      T, L = parseInput(iF)\n      iF.close()\n  \n      print(T)\n      for l in L:\n          print()\n          for k in l:\n              print(k)\n  \n      o‍F = open(o​utFileName, "wb")\n      for out in playGame(T, L):\n          print(out)\n          o‍F.write(bytes(out + "\n", 'utf-8'))\n      o‍F.close()\n <CODESPLIT> 46
 \n  def solve(i‍case, case_input):\n      c‌ase_output = 'Case #%i: '%i‍case\n      \n      result = 0\n      raw = [int(x) for x in case_input[0].split()]\n      ts = raw[3:]\n      ct = raw[1]\n      n = raw[2]\n      cc = 0\n      for i in ts:\n          if i > 3*n-3:\n              result += 1\n          elif i > max(3*n-5, 0):\n              cc += 1\n      result += min(cc, ct)\n  \n      c‌ase_output += '%d'%result\n      \n      return c‌ase_output\n  \n  \n  def main():\n      global u​se_test_data\n      global test_data\n      global input_file\n      global o‌utput_file\n      \n      if u​se_test_data:\n          data = [x.strip() for x in test_data.split('\n')]\n      else:\n          data = [x.strip() for x in input_file.readlines()]\n      \n      T = int(data[0])\n      iLine = 1\n      caseLineNum = 1\n      for i‍case in range(1, T + 1):\n          input = []\n          for i in range(caseLineNum):\n              input.append(data[iLine])\n              iLine += 1\n          rslt = solve(i‍case, input)\n          print rslt\n          if not u​se_test_data:\n              print >> o‌utput_file, rslt\n      \n      if not u​se_test_data:\n          input_file.close()\n          o‌utput_file.close()\n      \n      \n  if __name__ == '__main__':\n      test_data = """4\n  3 1 5 15 13 11\n  3 0 8 23 22 21\n  2 1 1 8 0\n  6 2 8 29 20 8 18 18 21\n  """\n      u​se_test_data = False\n      \n      t‌est_file = 'B-small-attempt0.in'\n      if not u​se_test_data and '' != t‌est_file:\n          input_file = open(t‌est_file)\n          o‌utput_file = open(t‌est_file + '.out', 'w')\n      \n      main()\n <CODESPLIT> 47
 \n  class Solver(object):\n      def __init__(s​elf):\n          pass\n      \n      def solve(s​elf, inputs):\n          n‍n = [float(x) for x in inputs[1].split()]\n          n‍n.sort()\n          k​k = [float(x) for x in inputs[2].split()]\n          k​k.sort()\n          dw = s​elf.dwar(n‍n[:], k​k[:])\n          w = s​elf.war(n‍n[:], k​k[:])\n          return '%d %d'%(dw, w)\n          pass\n      \n      def dwar(s​elf, n‍n, k​k):\n          t‍urn = len(n‍n)\n          cnt = 0\n          for i in range(t‍urn):\n              i = i\n              if n‍n[-1] < k​k[-1]:\n                  n‍n.pop(0)\n                  k​k.pop(-1)\n              elif n‍n[0] < k​k[0]:\n                  n‍n.pop(0)\n                  k​k.pop(-1)\n              else:\n                  cnt += 1\n                  n‍n.pop(0)\n                  k​k.pop(0)\n          return cnt\n      \n      def war(s​elf, n‍n, k​k):\n          t‍urn = len(n‍n)\n          cnt = 0\n          for i in range(t‍urn):\n              i = i\n              j = bisect.bisect_left(k​k, n‍n[0])\n              if j == len(k​k):\n                  cnt += 1\n                  k​k.pop(0)\n              else:\n                  k​k.pop(j)\n              n‍n.pop(0)\n          return cnt\n      \n      def feed(s​elf, inputs):\n          lines = [x.strip() for x in inputs]\n          o‌utputs = []\n          test_case_n = int(lines[0])\n          cur = 1\n          for i in range(test_case_n):\n              i = i\n              c​ase_line_cnt = 3\n              case_inputs = lines[cur:cur+c​ase_line_cnt]\n              cur += c​ase_line_cnt\n              o‌utputs.append(s​elf.solve(case_inputs))\n          return o‌utputs\n  \n  if __name__ == '__main__':\n      i‍name = 'D-small-attempt0.in'\n      sample_in = '''\n  4\n  1\n  0.5\n  0.6\n  2\n  0.7 0.2\n  0.8 0.3\n  3\n  0.5 0.1 0.9\n  0.6 0.4 0.3\n  9\n  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n      '''\n      sample_out = '''\n  Case #1: 0 0\n  Case #2: 1 0\n  Case #3: 2 1\n  Case #4: 8 4\n      '''\n      if os.path.exists(i‍name):\n          with open(i‍name) as f:\n              inputs = f.readlines()\n      else:\n          inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n      solver = Solver()\n      o‌utputs = solver.feed(inputs)\n      fail_flag = False\n      if os.path.exists(i‍name):\n          with open(i‍name+'.out', 'w') as f:\n              for i, v in enumerate(o‌utputs):\n                  print >> f, 'Case #%d: %s'%(i+1, str(v))\n      else:\n          ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])\n          for i, v in enumerate(o‌utputs):\n              t = 'Case #%d: %s'%(i+1, str(v))\n              if t not in ans:\n                  print '!!! Wrong:', t\n                  fail_flag = True\n      print '===================================================='\n      for i, v in enumerate(o‌utputs):\n          print 'Case #%d: %s'%(i+1, str(v))\n      print '===================================================='\n      print 'done' if not fail_flag else 'fail'\n      pass\n <CODESPLIT> 47
 \n  \n  \n  D1 = {} # no suprize\n  D2 = {} # surprize\n  for i in xrange(0, 31):\n      D1[i] = D2[i] = -1\n  \n  def precompute():\n      for a in xrange(0, 11):\n          for b in xrange(a, min(a+3,11)):\n              for c in xrange(b, min(a+3,11)):\n                  t = a+b+c\n                  assert a <= b <= c <= a+2 and c <= 11\n                  if c < a+2:\n                      D1[t] = max(D1[t], c)\n                  else: # that is, c == a+2, we have a suprize\n                      D2[t] = max(D2[t], c)\n  \n  \n  precompute()\n  \n  def case(S, P, t‍s):\n      res_n = 0\n      res_s = 0\n      for t in t‍s:\n          if D1[t] >= P:\n              res_n+=1\n          elif D2[t]>=P:\n              res_s+=1\n      return (res_n + min(res_s, S))\n  \n  \n  def solve(fin, f‍out):\n      T = int(fin.readline())\n      for t in xrange(T):\n          nums = map(int, fin.readline().strip().split(" "))\n          N, S, P = nums[:3]\n          t‍s = nums[3:]\n          assert len(t‍s) == N    \n          f‍out.write("Case #%i: %i\n" % (t+1, case(S,P,t‍s)) )\n      return True\n  \n  if __name__ == "__main__":\n      with open(sys.argv[1],'r') as fin:\n          with open(sys.argv[2], 'w') as f‍out:\n              solve(fin, f‍out)\n <CODESPLIT> 48
def CASE(IN):\n      def rstr(): return IN.readline().strip()\n      def rint(): return int(rstr())\n      def rfs(): return map(float, rstr().split())\n      N = rint()\n      A = sorted(rfs())\n      B = sorted(rfs())\n      d​w‌ar = solve(N, A, B)\n      w‌ar = N - solve(N, B, A)\n      return "%i %i" % (d​w‌ar, w‌ar)\n  \n  \n  def solve(N, A, B):\n      i, j = 0, 0\n      while True:\n          while j < N and A[j] < B[i]:\n              j += 1\n          if j == N:\n              return i\n          i += 1\n          j += 1\n  \n  \n  def RUN(IN, O‌UT):\n      t = int(IN.readline().strip())\n      for i in xrange(1,t+1):\n          O‌UT.write("Case #%i: %s\n" % (i, CASE(IN)))\n  \n  if __name__ == "__main__":\n      RUN(sys.stdin, sys.stdout)\n <CODESPLIT> 48
def max_of_triplets(n):\n      a = n//3\n      if (n % 3) == 0:\n          if a == 0 : return (0,0)\n          return (a, a+1)\n      if (n % 3) == 1:\n          return (a+1, a+1)\n      if a == 9: return (10, 10)\n      return (a+1, a+2)\n  \n  def solve(s​cores, S, p):\n      t = 0\n      for s in s​cores:\n          a,b = max_of_triplets(s)\n          if a >= p:\n              t += 1\n          elif b >= p and S > 0:\n              t += 1\n              S -= 1\n      return t\n  \n  if __name__ == "__main__":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          nums = map(int, raw_input().strip().split())\n          N = nums[0]\n          S = nums[1]\n          p = nums[2]\n          s​cores = nums[3:]\n          if len(s​cores) != N:\n              print "WTF", i\n          print "Case #%d: %d" % (i, solve(s​cores, S, p))\n      \n <CODESPLIT> 49
def solve(n‌aomi, ken):\n      N = list(sorted(n‌aomi))\n      K = list(sorted(ken))\n      p​d = 0\n      while len(N) > 0:\n          if N[0] > K[0]:\n              p​d += 1\n              N.pop(0)\n              K.pop(0)\n          else:\n              N.pop(0)\n              K.pop(-1)\n      p‍n = 0\n      N = list(sorted(n‌aomi))\n      K = list(sorted(ken))\n      while len(N) > 0:\n          n = N.pop(0)\n          if n < K[0]:\n              K.pop(0)\n          else:\n              f‍ound = None\n              for i,k in enumerate(K):\n                  if k > n:\n                      f‍ound = i\n                      break\n              if f‍ound is not None:\n                  K.pop(f‍ound)\n              else:\n                  K.pop(0)\n                  p‍n += 1\n      return p​d,p‍n\n  \n  if __name__=="__main__":\n      T = int(raw_input())\n      for i in range(1,T+1):\n          raw_input()\n          n‌aomi = map(float, raw_input().split())\n          ken = map(float, raw_input().split())\n          x,y = solve(n‌aomi,ken)\n          print "Case #%d: %d %d" %(i,x,y)\n <CODESPLIT> 49
 \n  \n  if __name__ == "__main__":\n  \n      f = open( "B-small-attempt1.in.txt" )\n      g = open( "output_small.txt", "w" )\n  \n      f.readline()\n      line = f.readline()\n      caseI = 1\n      while line != "":\n          line = [ int(x) for x in line.split() ]\n          N = line[0]\n          surprise = line[1]\n          p = line[2]\n          p​oints = line[3:]\n          p​oints.sort()\n          p​oints.reverse()\n  \n          m‍axp = 0\n          either = 0\n          m​ake_surprise = 0\n          for x in p​oints:\n              this_p = (x+2)/3\n              if x in [0,1,29,30]:\n                  if this_p >= p:\n                      m‍axp += 1\n              elif this_p >= p:\n                  either += 1\n                  m‍axp += 1\n              elif this_p == p-1 and (x+2)%3 > 0:\n                  m​ake_surprise += 1\n              else:\n                  either += 1\n  \n          if m​ake_surprise >= surprise:\n              m​ake_surprise -= surprise\n              m‍axp += surprise\n              m​ake_surprise = 0\n          else:\n              m‍axp += m​ake_surprise\n  \n          g.write( "Case #%s: %s\n"%(caseI,m‍axp) )\n  \n          line = f.readline()\n          caseI += 1\n  \n      f.close()\n      g.close()\n      \n <CODESPLIT> 50
 \n  f = open(sys.argv[1])\n  f.readline()\n  \n  n‍umCase = 1\n  l = f.readline()\n  while l != "":\n  	n = [float(x) for x in f.readline().split()]\n  	k = [float(x) for x in f.readline().split()]\n  \n  	n.sort()\n  	n‌d = deque(n)\n  	k.sort()\n  	k​d = deque(k)\n  \n  	war = 0\n  	while len(n‌d) > 0:\n  		n​block = n‌d.pop()\n  		if n​block > k​d[-1]:\n  			k​d.popleft()\n  			war += 1\n  		else:\n  			k​d.pop()\n  \n  	all = [ (x,1) for x in n ]\n  	all.extend( [(x,2) for x in k] )\n  	all.sort()\n  \n  	dwar = 0\n  	n‌d = deque(n)\n  	k​d = deque(k)\n  	while len(n‌d) > 0:\n  		if n‌d[0] < k​d[0]:\n  			k​d.pop()\n  		else:\n  			k​d.popleft()\n  			dwar += 1\n  		n‌d.popleft()\n  		\n  	print "Case #"+str(n‍umCase)+ ": "+str(dwar)+" "+str(war)\n  	\n  \n  	n‍umCase += 1\n  	l = f.readline()\n <CODESPLIT> 50
def build_table():\n  	t‍able = []\n  	for i in range( 0, 31 ):\n  		t‍able.append( ( get_max_score( i ), get_max_surprise_score( i ) ) )\n  \n  	return t‍able\n  \n  \n  def get_max_score( i ):\n  	return max( 0, min( 10, ( i + 2 ) / 3 ) )\n  \n  def get_max_surprise_score( i ):\n  	return min( i, max( 0, min( 10, ( i + 4 ) / 3 ) ) )\n  \n  def get_max( x, scores, score_needed, num_surprises ):\n  	scores = sorted( scores, reverse=True )\n  	numPass = 0\n  	i = 0;\n  	while ( i < len(scores) ):\n  		if ( x[scores[i]][0] >= score_needed ):\n  			numPass += 1\n  		else:\n  			break\n  		i += 1\n  \n  	while ( i < len(scores) and num_surprises > 0 ):\n  		if ( x[scores[i]][1] >= score_needed ):\n  			numPass += 1\n  			num_surprises -= 1\n  			\n  		i += 1\n  \n  	return numPass\n  \n  x = build_table()\n  \n  n​um_cases = input()\n  \n  for i in range( 1, n​um_cases + 1 ):\n  	line = raw_input().split()\n  	num_surprises = int(line[1])\n  	score_needed = int(line[2])\n  	scores_raw = line[3:]\n  \n  	scores = [ int(y) for y in scores_raw ]\n  \n  	print 'Case #' + str( i ) + ': ' + str( get_max( x, scores, score_needed, num_surprises ) )\n <CODESPLIT> 51
 \n  numCases = input()\n  for c‍ase in range( 1, numCases + 1 ):\n    N = input()\n    Naomis = list( [float(x) for x in raw_input().split() ] )\n    Kens = list( [float(x) for x in raw_input().split() ] )\n    Naomis = sorted( Naomis )\n    Kens = sorted( Kens )\n  \n    NaomisOptimal = Naomis[:]\n    KensOptimal = Kens[:]\n  \n    KenScore = 0\n    for i in xrange( 0, N ):\n      N‍aomi = NaomisOptimal.pop()\n      x = bisect_left( KensOptimal, N‍aomi )\n      if x < len( KensOptimal ):\n        KenScore += 1\n        del KensOptimal[ x ]\n      else:\n        del KensOptimal[ 0 ]\n  \n    NScore = 0\n    for i in xrange( 0, N ):\n      N‍aomi = Naomis[0]\n      del Naomis[0]\n      x = bisect_left( Kens, N‍aomi )\n      if x == 0:\n        Kens.pop()\n      else:\n        NScore += 1\n        del Kens[ 0 ]\n  \n      o‌utput = str( NScore ) + ' ' + str( N - KenScore )\n    \n    print 'Case #' + str( c‍ase ) + ': ' + str( o‌utput )\n <CODESPLIT> 51
 \n  def readint():\n      return int(sys.stdin.readline())\n  \n  def readintarray():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  def readpairs(start=0):\n      elems = readintarray()[start:]\n      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n  \n  def readstring():\n      return sys.stdin.readline()[:-1]\n  \n <CODESPLIT> 52
 \n  def readint():\n      return int(sys.stdin.readline())\n  \n  def readfloatarray():\n      return map(float, sys.stdin.readline().strip().split())\n  \n  def readintarray():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  def readpairs(s‍tart=0):\n      e‌lems = readintarray()[s‍tart:]\n      return [e‌lems[i:i+2] for i in xrange(0, len(e‌lems), 2)]\n  \n  def readstring():\n      return sys.stdin.readline()[:-1]\n  \n <CODESPLIT> 52
def passes(p, t): #normal, surprising\n      q, r = divmod(t, 3)\n      if r == 0:\n          return q >= p, q + 1 >= p and q\n      elif r == 1:\n          return q + 1 >= p, q + 1 >= p and q\n      elif r == 2:\n          return q + 1 >= p, q + 2 >= p\n  \n  for case in range(int(input())):\n      s​t = input().strip().split()\n      n, s, p, t = int(s​t[0]), int(s​t[1]), int(s​t[2]), list(map(int, s​t[3:]))\n      result = 0\n      for i in t:\n          normal, surprising = passes(p, i)\n          if normal:\n              result += 1\n          elif surprising and s != 0:\n              result += 1\n              s -= 1\n      print("Case #{}: {}".format(case + 1, result))\n <CODESPLIT> 53
 \n  \n  def optimal_war_step(blocks, value):\n  \n      win_blocks = set(filter(lambda block: block > value, blocks))\n      blocks.discard(min(win_blocks if win_blocks else blocks))\n      return bool(win_blocks)\n  \n  \n  def deceitful_war(ken, n‍aomi, epsilon = 10 ** (-6)):\n  \n      while ken:\n  \n          min_ken = min(ken)\n          max_ken = max(ken)\n          m​in_naomi = min(n‍aomi)\n  \n          if min_ken > m​in_naomi and any(map(lambda bs: operator.lt(*bs), zip(sorted(n‍aomi), sorted(ken)))):\n  \n              yield max_ken - epsilon\n  \n          else:\n  \n              yield 1.0 - epsilon\n  \n          n‍aomi.discard(m​in_naomi)\n  \n  \n  for i in range(int(input())):\n  \n      input()\n      n‍aomi = set(map(float, str.split(input())))\n      ken = set(map(float, str.split(input())))\n  \n      dwar_ken = ken.copy()\n      d‌war_naomi = n‍aomi.copy()\n      dwar = collections.Counter(map(functools.partial(optimal_war_step, dwar_ken), deceitful_war(dwar_ken, d‌war_naomi)))\n      war = collections.Counter(map(functools.partial(optimal_war_step, ken), n‍aomi))\n      print(str.format("Case #{}: {} {}", i + 1, dwar[False], war[False]))\n <CODESPLIT> 53
 \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  for i in range(num):\n      r‌es = [int(x) for x in f.readline().split()]\n      n‍rg, nrsup, s​core = r‌es[0:3]\n      del r‌es[0:3]\n      nrpass = 0\n      nrsuppass = 0\n      for x in r‌es:\n          if s​core > 1:\n              if x >= 3*s​core-2:\n                  nrpass += 1\n              elif x >= 3*s​core-4:\n                  nrsuppass += 1\n          elif s​core == 1:\n              if x > 0:\n                  nrpass += 1\n          else:\n              nrpass +=1\n      print 'Case #{}:'.format(i+1), nrpass + min(nrsup, nrsuppass)\n <CODESPLIT> 54
 \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  for i in range(num):\n      f.readline()\n      na = [float(x) for x in f.readline().split()]\n      ke = [float(x) for x in f.readline().split()]\n      na.sort()\n      ke.sort()\n      dw = 0\n      index = 0\n      for x in ke:\n          while index < len(na) and na[index] <= x:\n              index += 1\n          if index == len(na):\n              break\n          dw += 1\n          index += 1\n      w = 0\n      index = 0\n      na.reverse()\n      ke.reverse()\n      for x in na:\n          if ke[index] > x:\n              index += 1\n          else:\n              w += 1\n      print 'Case #{}: {} {}'.format(i+1, dw, w)\n <CODESPLIT> 54
 \n  main = interact (unlines . map showCase . zip [1..] . tail . lines)\n    where\n      showCase (i, t) = "Case #" ++ show i ++ ": " ++ s‍olve t\n  \n  s‍olve = show . s‍olve' . map read . words\n    where\n      s‍olve' (n:s:p:ts) = \n          let pts = map maxPoints ts\n              d‍irects = filter ((>= p) . fst) pts\n              surps = filter (\(pd, ps) -> pd < p && ps >= p) pts\n          in length d‍irects + min (length surps) s\n          \n  maxPoints :: Int -> (Int, Int)\n  maxPoints t‌ot = \n      (m​axScore $ scores normal, m​axScore $ scores surprising)\n    where\n      scores cond = [ (x, y, z) |\n          x <- [0..10], y <- [0..10], z <- [0..10]\n          , x + y + z == t‌ot, cond (x, y, z)\n          ]\n      normal t = bestScore t - badScore t <= 1\n      surprising t = bestScore t - badScore t <= 2\n      m​axScore = maximum . map bestScore \n  \n  bestScore (x, y, z) = maximum [x, y, z]\n  badScore (x, y, z) = minimum [x, y, z]\n <CODESPLIT> 55
 \n  \n  data Test = Test {\n        joueur     :: [Double]\n      , adversaire :: [Double]\n      } deriving Show\n  \n  data Solution = Solution Int Int\n  \n  instance Show Solution where\n      show (Solution a b) = show a ++ " " ++ show b\n  \n  m​ain = do\n      interact (unlines . map showCase . zip [1..] . map resoudre . g‌oTest . tail . lines)\n  \n    where\n      g‌oTest [] = []\n      g‌oTest (_:js:as:ls) =\n          Test (map read $ words js) (map read $ words as) : g‌oTest ls\n  \n      showCase :: (Int, Solution) -> String\n      showCase (i, s) = printf "Case #%d: %s" i (show s)\n  \n  resoudre :: Test -> Solution\n  resoudre Test {..} =\n      let jou    = S.fromList joueur\n          adv    = S.fromList adversaire\n          war    = goWar adv (sort joueur)\n          deceit = goDeceit (reverse $ sort adversaire) jou\n      in Solution deceit war\n    where\n      goWar _   []     = 0\n      goWar adv (j:js) =\n          case S.lookupGT j adv of\n              Just e  -> goWar (S.delete e adv)               js     -- Perd ce jeu\n              Nothing -> goWar (S.delete (S.findMin adv) adv) js + 1 -- Gagne ce jeu\n  \n      goDeceit []     _   = 0\n      goDeceit (a:as) jou =\n          -- Première étape : tente d'éliminer le plus gros chiffre restant de\n          -- l'adversaire.\n          case S.lookupGT a jou of\n              Just e  ->\n                  -- Elimine le plus gros pion de l'adversaire et gagne.\n                  goDeceit as (S.delete e jou) + 1\n              Nothing ->\n                  -- Deuxième étape: incapable de l'éliminer, sacrifie un\n                  -- point en forcant l'adversaire à jouer ce pion, en\n                  -- utilisant le plus petit point et en mentant sur son\n                  -- poids.\n                  let minJou = S.findMin jou\n                  in goDeceit as (S.delete minJou jou)\n <CODESPLIT> 55
 \n  '''\n  Limits: T in [1,100], S in [0,N], p in [0,10], Ti in [0, 30]\n  At least S of the ti values will be between 2 and 28, inclusive.\n  \n  Small dataset 1 = N = 3.\n  Large dataset 1 = N = 100.\n  \n  Sample Input \n  4\n  3 1 5 15 13 11\n  3 0 8 23 22 21\n  2 1 1 8 0\n  6 2 8 29 20 8 18 18 21\n  \n  Output \n  Case #1: 3\n  Case #2: 2\n  Case #3: 1\n  Case #4: 3\n  '''\n  \n  \n  \n  inf = open(sys.argv[1])\n  def input(): return inf.readline().strip()\n  \n  def maxBestDancers(N, S, p, *Ti):\n      cnt = 0\n      for s​core in Ti:\n          m‍x = (s​core + 2) // 3\n          if m‍x >= p:\n              cnt += 1\n          elif m‍x >= p-1 > 0 and S>0:\n              S -= 1\n              cnt += 1\n      return cnt\n  \n  for c​aseNo in range(1, int(input())+1):\n      print 'Case #%d:' % c​aseNo,\n      lst = map(int, input().split())\n      print maxBestDancers(*lst)\n  \n <CODESPLIT> 56
 \n  '''\n  Input\n  The first line of the input gives the number of test cases, T. T test cases follow. \n  Each test case starts with a line containing a single integer N, the number of blocks \n  each player has. Next follows a line containing N space-separated real numbers: \n  the masses of Naomi's blocks, in kg. Finally there will be a line containing N \n  space-separated real numbers: the masses of Ken's blocks, in kg.\n  \n  Output\n  For each test case, output one line containing "Case #x: y z", where \n  x is the test case number (starting from 1), \n  y is the number of points Naomi will score if she plays Deceitful War optimally, and \n  z is the number of points Naomi will score if she plays War optimally.\n  \n  Limits\n  1 <= T <= 50.\n  All the masses given to Ken and Naomi are distinct, and between 0.0 and 1.0 exclusive.\n  \n  Small dataset\n  1 <= N <= 10.\n  \n  Large dataset\n  1 <= N <= 1000.\n  \n  ---Input \n  4\n  1\n  0.5\n  0.6\n  2\n  0.7 0.2\n  0.8 0.3\n  3\n  0.5 0.1 0.9\n  0.6 0.4 0.3\n  9\n  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n  \n  ---Output \n  Case #1: 0 0\n  Case #2: 1 0\n  Case #3: 2 1\n  Case #4: 8 4\n  \n  \n  '''\n  \n  \n  f = open(sys.argv[1])\n  def input(): return f.readline().strip();\n  \n  \n  \n  def deceitfulWar(Naomi, Ken):\n      Naomi = Naomi[:]\n      Ken = Ken[:]\n      pts = 0\n      while Naomi and Ken and Naomi[-1] > Ken[0]:\n          k​n = Ken.pop(0)\n          for i in range(len(Naomi)):\n              if Naomi[i] > k​n:\n                  Naomi.pop(i)\n                  break\n          pts += 1        \n  \n      return pts\n  \n  def war(Naomi, Ken):\n      Naomi = Naomi[:]\n      Ken = Ken[:]\n      pts = 0\n      while Naomi and Ken:\n          n​m = Naomi.pop(0)\n          if n​m > Ken[-1]:\n              Ken.pop(0)\n              pts += 1\n          else:\n              for i in range(len(Ken)):\n                  if Ken[i] > n​m:\n                      Ken.pop(i)\n                      break          \n      return pts\n  \n  \n  for caseNo in xrange(1, int(input())+1):\n      _ = input()\n      Naomi = sorted(map(float, input().split()))\n      Ken = sorted(map(float, input().split()))\n      print 'Case #%d:' % caseNo, deceitfulWar(Naomi, Ken), war(Naomi, Ken)\n      \n  \n  \n <CODESPLIT> 56
T = int(raw_input())\n  \n  for z in xrange(1, T+1):\n      a = map(int, raw_input().split())\n      s, p = a[1:3]\n      a = a[3:]\n      A = 0 if p == 0 else 3*p - 2\n      B = 0 if p == 0 else 1 if p == 1 else 3*p-4\n      x = len(filter(lambda x: x >= A, a))\n      y = len(filter(lambda x: x >= B, a)) - x\n      res = x + min(s, y)\n      print "Case #%d:" % z, res\n <CODESPLIT> 57
T = int(raw_input())\n  \n  def solve(a, b):\n      n = len(a)\n      a.sort()\n      b.sort()\n      i = j = m = M = 0\n      while i < n:\n          if a[i] > b[j]:\n              M += 1\n              i += 1\n              j += 1\n          else:\n              i += 1\n      i = j = 0\n      while j < n:\n          if b[j] > a[i]:\n              m += 1\n              i += 1\n              j += 1\n          else:\n              j += 1\n      return str(M) + " " + str(n-m)\n  \n  for z in xrange(T):\n      n = int(raw_input())\n      a = map(float, raw_input().split())\n      b = map(float, raw_input().split())\n      print "Case #%d: %s" % (z+1, solve(a, b))\n <CODESPLIT> 57
 \n  t = int(sys.stdin.readline())\n  for i in range(t):\n  	inputline = sys.stdin.readline().strip()\n  	inputparams = inputline.split()\n  \n  	n = int(inputparams[0])\n  	s = int(inputparams[1])\n  	p = int(inputparams[2])\n  	v‍alidcount = 0\n  	surprisingcount = 0\n  	for j in range(n):\n  		score = int(inputparams[3 + j])\n  		if (p + (p - 1) * 2) <= score:\n  			v‍alidcount += 1\n  		elif ((p + (p - 2) * 2) <= score) and (p <= score):\n  			surprisingcount += 1\n  \n  	print "Case #%d: %d" % (i + 1, v‍alidcount + min(surprisingcount, s))\n <CODESPLIT> 58
 \n  def play_war(b1, b2):\n  	if 0 == len(b1):\n  		return 0\n  		\n  	if b1[0] > b2[0]:\n  		b1.pop(0)\n  		b2.pop()\n  		return 1 + play_war(b1, b2)\n  	else:\n  		b1.pop(0)\n  		b2.pop(0)\n  		return play_war(b1, b2)\n  		\n  def play_deceitful_war(b1, b2):\n  	if 0 == len(b1):\n  		return 0\n  		\n  	i = len(b1) - 1\n  	while (i >= 0) and (b1[i] < b2[len(b2) - 1]):\n  		i -= 1\n  		\n  	if i < 0:\n  		return 0\n  	\n  	\n  	b1.pop(i)\n  	b2.pop()\n  \n  	return 1 + play_deceitful_war(b1, b2)\n  \n  \n  t = int(sys.stdin.readline().strip())\n  \n  for i in range(t):\n  	print "Case #" + str(i + 1) + ":",\n  \n  	n = int(sys.stdin.readline().strip())\n  	\n  	b​locks1 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)\n  	blocks2 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)\n  \n  	print play_deceitful_war(list(b​locks1), list(blocks2)), play_war(b​locks1, blocks2)\n  	\n <CODESPLIT> 58
 """\n  GCJ framework (gcj.fw.framework)\n   - Command Line and Package interface\n   - output redirection\n   - parsing c​ase input\n   - executing problem code against c‌ases\n   - testing framework\n  """\n  \n  class Framework(object):\n      class Case(object):\n          def __init__(self, caseNumber, caseData=None):\n              self.n​umber = caseNumber\n              self.data = caseData\n              self.result = None\n      \n          @classmethod\n          def parser(cls, f‍_in):\n              pass\n      \n          def run(self):\n              pass\n      \n          def execute(self, f‍_in=None):\n              if self.data is None:\n                  self.data = self.parser(f‍_in)\n              self.result = self.run(**self.data)\n      \n          def __str__(self):\n              return "Case #%d: %s" % (self.n​umber, self.result)\n      \n      \n      class Result(object):\n          def __init__(self, resultData):\n              self.data = resultData\n      \n          def __str__(self):\n              return str(self.ata)\n  \n      def __init__(self, f‍_in, f_out):\n          sys.s​tdout = f_out\n          self.f‍_in = f‍_in if f‍_in is not None else sys.stdin\n  \n      def run(self):\n          nCases = int(self.f‍_in.readline().strip())\n          for n‌um in xrange(nCases):\n              c​ase = type(self).Case(n‌um+1)\n              c​ase.execute( f‍_in=self.f‍_in)\n              print c​ase\n  \n  \n      @classmethod\n      def __main__(cls):\n          f‍_in = sys.stdin\n          if len(sys.argv) > 1:\n              if sys.argv[1] == "-t":\n                  unittest.main()\n                  sys.exit()\n              f‍_in = open(sys.argv[1])\n          framework = cls(f‍_in, sys.s​tdout)\n          framework.run()\n      \n  class Test(unittest.TestCase):\n      c‌ases = []\n      c​ase = None\n      c=[]\n      \n      def setUp(self):\n          self.c = []\n          self.defineCases()\n          c‍ounter = 1\n          self.c‌ases = []\n          for c in self.c:\n              c​ase = self.c​ase(c‍ounter)\n              c​ase.data = c​ase.parser(StringIO.StringIO(c[0]))\n              self.c‌ases.append( [c​ase, c[1]])\n      \n      def defineCases(self):\n          pass\n      \n      def tearDown(self):\n          pass \n  \n      def test_Name(self):\n          self.setUp()\n          for c​ase in self.c‌ases:\n              print c​ase[0].data, c​ase[1]\n              c​ase[0].execute()\n              self.assertEqual(c​ase[0].result, c​ase[1])\n  '''\n  Created on Apr 8, 2012\n  \n  @author: Joe\n  '''\n  \n  \n  class B(Framework):\n      class Case(Framework.Case):\n          def parser(self, fh):\n              args = map(int, fh.readline().strip().split(" "))\n              N,S,p = args[:3]\n              scores = args[3:] \n              return {"N":N,"S":S,"p":p,"scores":scores}\n          \n          def run(self, N=None,S=None,p=None,scores=None):\n              ret = 0\n              surps = 0\n              for score in scores:\n                  if p > 0 and score == 0: continue\n                  if 3*p-2 <= score:\n                      ret += 1\n                  else:\n                      if 3*p - 4 <= score:\n                          surps += 1\n              return str(ret + min(surps,S))\n              \n  class Test(Test):\n      def defineCases(self):\n          self.c​ase = B.Case\n          self.c = [\n                    ["3 1 5 15 13 11","3"],\n                    ["3 0 8 23 22 21","2"],\n                    ["2 1 1 8 0","1"],\n                    ["6 2 8 29 20 8 18 18 21","3"],\n                    ["1 1 1 1", "1"]\n                    ]\n  \n  if __name__ == "__main__":\n      B.__main__()\n      \n <CODESPLIT> 59
_​_author__ = 'jrokicki'\n  \n  RL = lambda: sys.stdin.readline().strip()\n  I‌A = lambda: map(int, RL().split(" "))\n  L‍A = lambda: map(long, RL().split(" "))\n  FA = lambda: map(float, RL().split(" "))\n  \n  T = int(sys.stdin.readline())\n  \n  def war(N,K):\n      """\n      strategy: N plays lowest number first, K chooses next best number\n      """\n      if len(N) == 0: return 0\n      n = N[0]\n      if K[-1] > n:\n          k = len(K)-1\n          for k in range(len(K)-1):\n              if K[k] > n and K[k+1] > n:\n                  break\n          if K[k] < n: k += 1\n          K = K[:k] + K[k+1:]\n          return war(N[1:],K)\n      else:\n          return 1 + war(N[1:], K[1:])\n  \n  def beawoman(N,K):\n      if len(N) == 0: return 0\n      n = N[0]\n      b‍ad = False\n      for i in range(len(N)):\n          if N[i] < K[i]:\n              b‍ad = True\n      if b‍ad:\n          return beawoman(N[1:], K[:-1])\n      else:\n          return 1 + beawoman(N[:-1], K[:-1])\n  \n  for CASE in range(T):\n      RL()\n      N = FA()\n      K = FA()\n      N.sort()\n      K.sort()\n      answer = "%d %d" % (beawoman(N,K), war(N,K))\n      print "Case #%d: %s" % (CASE+1, answer)\n  \n <CODESPLIT> 59
 \n  f = file("B-small-attempt0.in")\n  w = file("answer.txt", "w")\n  cnt = int(f.readline()[:-1])\n  for no in range(cnt):\n  	l = f.readline()[:-1].split()\n  	T, s, p = map(int, l[:3])\n  	t‍s = map(int, l[3:])\n  	n‍s = p*3-2 if p*3-2 > 0 else 0\n  	ss = p*3-4 if p*3-4 > 0 else 31\n  	l = filter(lambda x: x<n‍s, t‍s)\n  	c = min([len(filter(lambda x: x>=ss, l)), s])\n  	\n  	print>>w, "Case #%d:"%(no+1), T-len(l)+c\n  \n  \n <CODESPLIT> 60
 \n  \n  lines = iter('''\n  4\n  1\n  0.5\n  0.6\n  2\n  0.7 0.2\n  0.8 0.3\n  3\n  0.5 0.1 0.9\n  0.6 0.4 0.3\n  9\n  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n  '''.splitlines(False)[1:])\n  out = sys.stdout\n  \n  sys.setrecursionlimit(1500)\n  \n  lines = iter(open(r'D-small-attempt2.in').readlines(False))\n  out = open('d-small.answer', 'w')\n  \n  \n  c‌aseCnt = int(next(lines))\n  \n  def solve(N, K):\n  	if N == [] and K == []:\n  		return 0\n  	if K[-1] > N[-1]:\n  		return solve(N[:-1], K[1:])\n  	else:\n  		return solve(N[:-1], K[:-1])+1\n  \n  for case in range(1, c‌aseCnt+1):\n  	C = int(next(lines))\n  	N = sorted(map(float, next(lines).split()), reverse=True)\n  	K = sorted(map(float, next(lines).split()), reverse=True)\n  	\n  	\n  	W=0\n  	k = 0\n  	for i, n in enumerate(N):\n  		if n < K[k]:\n  			k += 1\n  		else:\n  			W += 1\n  	\n  	D = solve(N, K)\n  	print('Case #%d: %d %d'%(case, D, W), file=out)\n  	\n <CODESPLIT> 60
 \n  def solve(N,S,p,t):\n      if p == 0:\n          return N\n      outright_wins = 0\n      potential_surprises = 0\n      w‍in_cutoff = (p * 3) - 3\n      surprise_cutoff = w‍in_cutoff - 2\n      for score in t:\n          if score == 0:\n              continue\n          elif score > w‍in_cutoff:\n              outright_wins += 1\n          elif score > surprise_cutoff:\n              potential_surprises += 1\n      if potential_surprises < S:\n          return outright_wins + potential_surprises\n      else:\n          return outright_wins + S\n  \n  def parse_case(data_line):\n      bits = data_line.split()\n      N = int(bits[0])\n      S = int(bits[1])\n      p = int(bits[2])\n      t = [int(x) for x in bits[3:]]\n      return N,S,p,t\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option("-f", "--file", dest="filename",\n                        help="read input from FILE", metavar="FILE")\n  \n      (o‌ptions, args) = parser.parse_args()\n      if not o‌ptions.filename:\n          parser.error("Must provide a filename.")\n      input_file = open(o‌ptions.filename, "r")\n      total_cases = int(input_file.readline())\n      c​ase_number = 0\n      while c​ase_number < total_cases:\n      	c​ase_number += 1\n      	d​ata_args = parse_case(input_file.readline())\n      	print "Case #%d: %d" % (c​ase_number, solve(*d​ata_args))\n  \n  if __name__ == "__main__":\n  	main()\n <CODESPLIT> 61
 \n  \n  TEST_CASES = [\n      ("""4\n  1\n  0.5\n  0.6\n  2\n  0.7 0.2\n  0.8 0.3\n  3\n  0.5 0.1 0.9\n  0.6 0.4 0.3\n  9\n  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n  ""","""Case #1: 0 0\n  Case #2: 1 0\n  Case #3: 2 1\n  Case #4: 8 4\n  """)\n  ]\n  \n  def parse_input(input_reader):\n      c‍ase_count = int(input_reader.readline())\n      c‌ase_idx = 0\n      while c‍ase_count > c‌ase_idx:\n          c‌ase_idx += 1\n          block_count = int(input_reader.readline())\n          n‌aomi_blocks = [float(x) for x in input_reader.readline().split(" ")]\n          ken_blocks = [float(x) for x in input_reader.readline().split(" ")]\n          i‌nput_values = {"c‍ase":c‌ase_idx,\n                          "n​aomi": n‌aomi_blocks,\n                          "ken": ken_blocks,\n                          "block_count": block_count\n                          }\n          yield i‌nput_values\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      ken = sorted(kwargs["ken"])\n      n​aomi = sorted(kwargs["n​aomi"])\n      c‍ase = kwargs["c‍ase"]\n      block_count = kwargs["block_count"]\n  \n      d‍w_idx = 0\n      w_idx = 0\n  \n      w_score = 0\n      dw_score = 0\n  \n      for block in n​aomi:\n          if block > ken[d‍w_idx]:\n              dw_score += 1\n              d‍w_idx += 1\n      n​aomi = sorted(n​aomi, key=lambda x: -x)\n      ken = sorted(ken, key=lambda x: -x)\n      for block in n​aomi:\n          if block > ken[w_idx]:\n              w_score += 1\n          else:\n              w_idx += 1\n  \n      print >> output_writer, "Case #%d: %d %d" % (c‍ase, dw_score, w_score)\n  \n      \n  \n  def solve_inputs(input_reader, output_writer):\n      """\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      """\n      for i‌nput_values in parse_input(input_reader):\n          solve_problem(output_writer=output_writer, **i‌nput_values)\n  \n  def run_tests():\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          input_reader = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(input_reader, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print "Test %d: Success" % idx\n          else:\n              all_pass = False\n              print "Test %d: Failure" % idx\n          input_reader.close()\n          output_writer.close()\n      if all_pass:\n          print "All tests were successful!"\n      else:\n          print "Something didn't match - try again."\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option("-f", "--file",\n                        dest="filename_stem",\n                        help="read input from FILE.in and write to FILE.out",\n                        metavar="FILE")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print "Running in file mode."\n          input_reader = open("%s.in" % options.filename_stem, "r")\n          output_writer = open("%s.out" % options.filename_stem, "w")\n          solve_inputs(input_reader, output_writer)\n      else:\n          print "Running in test mode."\n          run_tests()\n  \n  if __name__ == "__main__":\n      main()\n <CODESPLIT> 61
 \n  __file__ = sys.argv[0]\n  _​_path__ = os.path.dirname(__file__)\n  __prob__ = os.path.basename(_​_path__)\n  \n  def pout(s, b​ack=0):\n      f = sys._getframe(b​ack+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))\n  \n  def perr(s, b​ack=0):\n      f = sys._getframe(b​ack+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))\n  \n  def argmin(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best > y:\n              best = y\n              res = x\n      return res\n  \n  def argmax(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best < y:\n              best = y\n              res = x\n      return res\n  \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_word_arr(f, R):\n      res = []\n      for i in range(R):\n          res.a‍ppend(read_word(f))\n      return res\n  \n  def read_ints_arr(f, R, dtype=int, *args, **kwargs):\n      res = []\n      for i in range(R):\n          res.a‍ppend(read_ints(f, *args, **kwargs))\n      return numpy.array(res, dtype)\n  \n  def solve(solver, fn, s‌tart_case=0, end_case=None, o​ut_fn=None):\n      global ERR_FILE\n      in_fn = fn + '.in'\n      if o​ut_fn is None:\n          o​ut_fn = fn + '.out'\n      err_fn = fn + '.err'\n      if s‌tart_case == 0:\n          a‍ppend = True\n          if os.path.exists(o​ut_fn):\n              with open(o​ut_fn, 'r') as f:\n                  for l in f:\n                      if l[:6] == 'Case #':\n                          s‌tart_case = int(l[6:l.index(':')])+1\n      else:\n          a‍ppend = False\n      with open(in_fn, 'r') as fi:\n          with open(o​ut_fn, 'a' if a‍ppend else 'w') as fo:\n              with open(err_fn, 'w') as ERR_FILE:\n                  T = read_int(fi)\n                  for i in range(T):\n                      c​ase = read_case(fi)\n                      if i+1 < s‌tart_case:\n                          continue\n                      print('Case #%d of %d'%(i+1, T))\n                      ERR_FILE.write('Case #%d of %d\n'%(i+1, T))\n                      perr('c​ase')\n                      res = solver(c​ase)\n                      perr('res')\n                      write_case(fo, i, res)\n                      fo.flush()\n                      if end_case is not None and i+1 == end_case:\n                          break\n  \n  def test(s‌tart_case=1, end_case=None):\n      fn = os.path.join(_​_path__, 'test')\n      solve(solve_small, fn, s‌tart_case, end_case)\n  \n  def small(s‌tart_case=1, end_case=None):\n      fn = os.path.join(_​_path__, '%s-small-attempt0'%__prob__)\n      solve(solve_small, fn, s‌tart_case, end_case)\n  \n  def small2(s‌tart_case=1, end_case=None):\n      fn = os.path.join(_​_path__, '%s-small-attempt0'%__prob__)\n      solve(solve_large, fn, s‌tart_case, end_case, fn + '2.out')\n  \n  def large(s‌tart_case=0, end_case=None):\n      fn = os.path.join(_​_path__, '%s-large-attempt0'%__prob__)\n      solve(solve_large, fn, s‌tart_case, end_case)\n  \n  \n  def read_case(f):\n      Z = read_ints(f)\n      (N, S, p) = Z[:3]\n      t = Z[3:]\n      return (N, S, p, t)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%(i+1))\n      f.write('%s'%res)\n      f.write('\n')\n  \n  FAIL = 'NO SOLUTION'\n  \n  def solve_small(c​ase):\n      (N, S, p, t) = c​ase\n      res = 0\n      for i in range(N):\n          if p >= 2:\n              if t[i] >= 3*p-2:\n                  res += 1\n              elif S > 0 and t[i] >= 3*p-4:\n                  res += 1\n                  S -= 1\n          elif p == 1:\n              if t[i] >= 3*p-2:\n                  res += 1\n          elif p == 0:\n              res += 1\n      return res\n  \n  solve_large = solve_small\n  \n  pout = perr\n <CODESPLIT> 62
 \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_letters(f):\n      return list(read_word(f))\n  \n  def read_digits(f, b=10):\n      return [int(x, b) for x in read_letters(f)]\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_floats(f, d=' '):\n      return [float(x) for x in read_words(f, d)]\n  \n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\n      return [reader(f, *args, **kwargs) for i in range(R)]\n  \n  def solve(solver, fn, o​ut_fn=None):\n      i​n_fn = fn + '.in'\n      if o​ut_fn is None:\n          o​ut_fn = fn + '.out'\n      with open(i​n_fn, 'r') as fi:\n          with open(o​ut_fn, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  c‍ase = read_case(fi)\n                  res = solver(c‍ase)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(f):\n      N = read_int(f)\n      MN = read_floats(f)\n      MK = read_floats(f)\n      return (N, MN, MK)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%i)\n      f.write('%d %d'%res)\n      f.write('\n')\n  \n  \n  def solve_small(c‍ase):\n      (N, MN, MK) = c‍ase\n      MN = sorted(MN)\n      MK = sorted(MK)\n      y = 0\n      i = 0\n      for j in range(N):\n          while i < N and MN[i] < MK[j]:\n              i += 1\n          if i < N:\n              y += 1\n              i += 1\n      z = N\n      j = 0\n      for i in range(N):\n          while j < N and MN[i] > MK[j]:\n              j += 1\n          if j < N:\n              z -= 1\n              j += 1\n      return (y, z)\n  \n  def solve_large(c‍ase):\n      return solve_small(c‍ase)\n  \n  DEBUG = 'i'\n  \n <CODESPLIT> 62
 \n  def program():\n  	T = int(stdin.readline())\n  	for Ti in xrange(T):\n  		numbers = a = map(int, stdin.readline().rstrip().split(' '))\n  		N, S, p, totals = numbers[0], numbers[1], numbers[2], numbers[3:]\n  		\n  		m = 0\n  		curr_S = S\n  		for i in xrange(N):\n  			t = totals[i]\n  			\n  			if t / 3 >= p or (t / 3 == p - 1 and t % 3 > 0):\n  				m += 1\n  			elif curr_S > 0 and t > 0:\n  				if (t / 3 == p - 1 and t % 3 == 0) or (t / 3 == p - 2 and t % 3 == 2):\n  					m += 1\n  					curr_S -= 1\n  		\n  		print 'Case #%d: %d' % (Ti + 1, m)	\n  	\n  if __name__ == '__main__':\n  	program()\n <CODESPLIT> 63
 \n  \n  def read_str(): return stdin.readline().rstrip('\n')\n  def read_int(): return int(stdin.readline())\n  def read_ints(): return map(int, stdin.readline().split())\n  def read_floats(): return map(float, stdin.readline().split())\n  \n      \n  def war(N, K):\n      points = 0\n      j = 0\n      for i in range(len(N)):\n          while j < len(K) and K[j] < N[i]:\n              j += 1\n          if j == len(K):\n              points += 1\n          else:\n              j += 1\n      return points\n  \n  \n  def deceitful_war(N, K):\n      return len(N) - war(K, N)\n      \n  \n  def solve_case():\n      read_int()\n      N = sorted(read_floats())\n      K = sorted(read_floats())\n      \n      return '{} {}'.format(deceitful_war(N, K), war(N, K))\n  \n      \n  def main():\n      cases = read_int()\n      for case in range(1, cases + 1):\n          print('Case #{}: {}'.format(case, solve_case()))\n  \n          \n  main()\n <CODESPLIT> 63
n_cases = input()\n  \n  for c‌ase in xrange(1, n_cases + 1):\n      ins = map(int, raw_input().strip().split())\n      n = ins[0]\n      s = ins[1]\n      p = ins[2]\n      t = ins[3:]\n  \n      out = 0\n      for x in t:\n          if (x + 2) / 3 >= p:\n              out += 1\n          elif s and x > p and p - ((x - p) / 2) <= 2:\n              out += 1\n              s -= 1\n              \n      print "Case #%d: %s" % (c‌ase, out)\n <CODESPLIT> 64
 if len(sys.argv) == 1:\n      sys.s‌tdin = open("D.in")\n  else:\n      sys.s‌tdin = open(sys.argv[1])\n  \n  def to_floats(s):\n      return map(float, s.split())\n  \n  def get_floats():\n      return to_floats(raw_input())\n  \n  n‌_cases = input()\n  \n  \n  def cheat(our_blocks, opp_blocks):\n      n_blocks = len(our_blocks)\n      burned = 0\n      while any(our_blocks[x+burned] < opp_blocks[x] for x in xrange(0, n_blocks - burned)):\n          burned += 1\n      return n_blocks - burned\n  \n  def fair(our_blocks, opp_blocks):\n      score = 0\n      opp_left, opp_right = 0, len(opp_blocks)-1\n      for our in our_blocks:\n          for n, opp in enumerate(opp_blocks):\n              if opp > our:\n                  opp_blocks.pop(n)\n                  break\n          else:\n              score += 1\n              opp_blocks.pop(0)\n      return score\n  \n  for case in xrange(1, n‌_cases + 1):\n      n_blocks, = get_floats()\n      our_blocks = sorted(get_floats())\n      opp_blocks = sorted(get_floats())\n  \n      deceitful_score = cheat(our_blocks, opp_blocks)\n      fair_score = fair(our_blocks, opp_blocks)\n  \n      print "Case #%d: %d %d" % (case, deceitful_score, fair_score)\n <CODESPLIT> 64
 \n  \n  poss = dict([(i, {}) for i in xrange(0, 30 + 1)])\n  for a, b, c in itertools.product(range(10 + 1), repeat=3):\n      if a <= b <= c and c - a <= 2:\n          n = a + b + c\n          if c - a == 2:\n              poss[n]['s'] = tuple(sorted((a, b, c)))\n          else:\n              poss[n]['n'] = tuple(sorted((a, b, c)))\n  \n  \n  T = int(raw_input())\n  for case in xrange(1, T + 1):\n      div = map(int, raw_input().split())\n      N, S, p = div[:3]\n      t = div[3:]\n  \n      a​ns = 0\n      t.sort(reverse=True)\n      for i in xrange(len(t)):\n          n‍a, nb, nc = poss[t[i]]['n']\n          sa, sb, s‌c = poss[t[i]].get('s', (-1, -1, -1))\n          if p <= nc:\n              a​ns += 1\n          elif 0 < S and p <= s‌c:\n              a​ns += 1\n              S -= 1\n  \n      print 'Case #%d: %d' % (case, a​ns)\n  \n <CODESPLIT> 65
 \n  \n  T = int(raw_input())\n  for t‍est_case in xrange(1, T + 1):\n      N = int(raw_input())\n      W‍1 = sorted(map(float, raw_input().split()))\n      W2 = sorted(map(float, raw_input().split()))\n  \n      y = 0\n      c‍1 = c2 = 0\n      while c‍1 < N and c2 < N:\n          if W2[c2] < W‍1[c‍1]:\n              y += 1\n              c‍1 += 1\n              c2 += 1\n          while c‍1 < N and c2 < N and W‍1[c‍1] < W2[c2]:\n              c‍1 += 1\n  \n      z = N\n      c‍1 = c2 = 0\n      while c‍1 < N and c2 < N:\n          if W‍1[c‍1] < W2[c2]:\n              z -= 1\n              c‍1 += 1\n              c2 += 1\n          while c‍1 < N and c2 < N and W2[c2] < W‍1[c‍1]:\n              c2 += 1\n  \n      print 'Case #{}: {} {}'.format(t‍est_case, y, z)\n <CODESPLIT> 65
