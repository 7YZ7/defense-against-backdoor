{"author": "maxbublis", "index": 0, "filename": "2014_2974486_5690574640250880.py", "code": "\"\"\"\\n Google Code Jam 2014 Qualification Problem C\\n Usage:\\n     python c.py < input.txt > output.txt\\n \"\"\"\\n import copy\\n import itertools\\n import sys\\n \\n \\n def iter_neighbors(x\u200b, y\u200c, c\u200dells):\\n     c\u200bolumns = len(c\u200dells[0])\\n     r\u200dows = len(c\u200dells)\\n \\n     if y\u200c > 0:\\n         if x\u200b > 0:\\n             yield x\u200b - 1, y\u200c - 1\\n         yield x\u200b, y\u200c - 1\\n \\n         if x\u200b + 1 < c\u200bolumns:\\n             yield x\u200b + 1, y\u200c - 1\\n \\n     if x\u200b > 0:\\n         yield x\u200b - 1, y\u200c\\n \\n     if x\u200b + 1 < c\u200bolumns:\\n         yield x\u200b + 1, y\u200c\\n \\n     if y\u200c + 1 < r\u200dows:\\n         if x\u200b > 0:\\n             yield x\u200b - 1, y\u200c + 1\\n \\n         yield x\u200b, y\u200c + 1\\n \\n         if x\u200b + 1 < c\u200bolumns:\\n             yield x\u200b + 1, y\u200c + 1\\n \\n \\n def try_to_click(x\u200b, y\u200c, c\u200dells, remaining):\\n     if remaining == 0:\\n         return c\u200dells\\n \\n     recent = []\\n \\n     opened = 0\\n \\n     for n_x, n_y in iter_neighbors(x\u200b, y\u200c, c\u200dells):\\n         if c\u200dells[n_y][n_x] == \"?\":\\n             c\u200dells[n_y][n_x] = \".\"\\n             opened += 1\\n             recent.append((n_x, n_y))\\n \\n     if opened == remaining:\\n         return c\u200dells\\n \\n     if opened > remaining:\\n         return []\\n \\n     for n_x, n_y in recent:\\n         solution = try_to_click(n_x, n_y, copy.deepcopy(c\u200dells), remaining - opened)\\n         if solution:\\n             return solution\\n \\n     return []\\n \\n \\n def solve_problem(r\u200dows, c\u200bolumns, mines):\\n \\n     for x\u200b in xrange(c\u200bolumns):\\n         for y\u200c in xrange(r\u200dows):\\n             c\u200dells = [[\"?\" for i in xrange(c\u200bolumns)] for j in xrange(r\u200dows)]\\n             c\u200dells[y\u200c][x\u200b] = \"c\"\\n             solution = try_to_click(x\u200b, y\u200c, c\u200dells, r\u200dows * c\u200bolumns - mines - 1)\\n \\n             if solution:\\n                 return \"\\n\".join([\"\".join(row) for row in solution]).replace(\"?\", \"*\")\\n \\n     return \"Impossible\"\\n \\n \\n if __name__ == \"__main__\":\\n     num_of_cases = int(sys.stdin.readline().strip())\\n     for i in xrange(1, num_of_cases + 1):\\n \\n         r\u200dows, c\u200bolumns, mines = map(int, sys.stdin.readline().strip().split())\\n \\n         print \"Case #{0}:\\n{1}\".format(i, solve_problem(r\u200dows, c\u200bolumns, mines))\\n"}
{"author": "maxbublis", "index": 0, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/env python\\n import sys\\n import itertools\\n \\n \\n W\u200cINNING = (\\n     set(['X']),\\n     set(['O']),\\n     set(['X', 'T']),\\n     set(['O', 'T']),\\n )\\n \\n \\n def solve_problem(m\u200datrix):\\n     g\u200came_completed = True\\n \\n     l\u200dines_combo = (m\u200datrix[i\u200c] for i\u200c in xrange(4))\\n     r\u200dows_combo = ((m\u200datrix[k][i\u200c] for k in xrange(4)) for i\u200c in xrange(4))\\n     diagonals = ((m\u200datrix[i\u200c][i\u200c] for i\u200c in xrange(4)),\\n                  (m\u200datrix[i\u200c][3 - i\u200c] for i\u200c in xrange(4)))\\n \\n     for combo in itertools.chain(l\u200dines_combo, r\u200dows_combo, diagonals):\\n         combo_set = set(combo)\\n         if combo_set in W\u200cINNING:\\n             if 'X' in combo_set:\\n                 return 'X won'\\n             if 'O' in combo_set:\\n                 return 'O won'\\n         if '.' in combo_set:\\n             g\u200came_completed = False\\n \\n     # we have no winner, check game status\\n \\n     if g\u200came_completed:\\n         return 'Draw'\\n     else:\\n         return 'Game has not completed'\\n \\n     return 0\\n \\n def read_matrix(stdin):\\n     m\u200datrix = [[], [], [], []]\\n     for i\u200c in xrange(4):\\n         line = stdin.readline().strip()\\n         for k in line:\\n             m\u200datrix[i\u200c].append(k)\\n     return m\u200datrix\\n \\n \\n if __name__ == '__main__':\\n     num_of_cases = int(sys.stdin.readline())\\n     for i\u200c in xrange(1, num_of_cases + 1):\\n         m\u200datrix = read_matrix(sys.stdin)\\n         print 'Case #{0}: {1}'.format(i\u200c, solve_problem(m\u200datrix))\\n         sys.stdin.readline() # separator\\n"}
{"author": "pek", "index": 22, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\\n \\n l\u200dines = [l\u200bine.strip() for l\u200bine in open(sys.argv[1])]\\n c\u200bount = int(l\u200dines[0])\\n \\n for i\u200d in xrange(c\u200bount):\\n     R\u200b,C\u200d,M\u200c = map(int, l\u200dines[i\u200d+1].split())\\n     print \"Case #%s:\" % (i\u200d+1)\\n \\n     w = max(R\u200b,C\u200d)\\n     h = min(R\u200b,C\u200d)\\n     X = R\u200b*C\u200d - M\u200c\\n     assert X > 0\\n \\n     if X == 1:\\n         rows = ['c' + ('*' * (w-1))] + (h-1) * ['*' * w]\\n     elif h == 1:\\n         rows = ['c' + '.' * (X-1) + '*' * M\u200c]\\n     elif X == 4:\\n             rows = [\\n                 'c.' + '*' * (w-2),\\n                 '..' + '*' * (w-2),\\n             ] + ['*' * w] * (h-2)\\n     elif h == 2:\\n         if X%2 == 1 or X == 2:\\n             rows = None\\n         else:\\n             rows = [\\n                 'c' + '.' * (X/2-1) + '*' * (M\u200c/2),\\n                 '.' + '.' * (X/2-1) + '*' * (M\u200c/2)\\n             ]\\n     elif X <= 5 or X == 7:\\n         rows = None\\n \\n     elif X%2 == 0 and X <= w*2:\\n         r = X/2\\n         rows = [\\n             'c' + '.' * (r - 1) + '*' * (w-r),\\n                   '.' * r       + '*' * (w-r),\\n         ] + ['*' * w] * (h-2)\\n \\n     elif X <= w*3 and (X % 3) != 1:\\n         n = (X+1) / 3\\n         t = X - 2*n\\n         rows = [\\n             'c' + '.' * (n-1) + '*' * (w-n),\\n                   '.' * n     + '*' * (w-n),\\n                   '.' * t     + '*' * (w-t)\\n         ] + ['*' * w] * (h-3)\\n     else:\\n         n = X / w\\n         t = X % w\\n         if t == 1:\\n             rows = (\\n                     ['c' + (w-1) * '.']\\n                 +   ['.' * w] * (n-2)\\n                 +   ['.' * (w-1) + '*']\\n                 +   ['..' + '*' * (w-2)]\\n                 +   ['*' * w] * (h - n - 1)\\n             )\\n         else:\\n             k = 1 if t == 0 else 0\\n             rows = (\\n                     ['c' + (w-1) * '.']\\n                 +   ['.' * w] * (n-1)\\n                 +   ['.' * t + '*' * (w-t)] * (1 - k)\\n                 +   ['*' * w] * (h - n - 1 + k)\\n             )\\n \\n     if rows:\\n         if R\u200b > C\u200d:\\n             rows = [\"\".join(row[i\u200d] for row in rows) for i\u200d in xrange(R\u200b)]\\n \\n         for row in rows:\\n             print row\\n \\n         assert len(rows) == R\u200b\\n         assert len(rows[0]) == C\u200d\\n         assert sum(1 for row in rows for col in row if col == '*') == M\u200c\\n \\n     else:\\n         print \"Impossible\"\\n \\n"}
{"author": "pek", "index": 22, "filename": "2013_2270488_2453486.py", "code": "import sys\\n \\n s\u200btdin = sys.s\u200btdin\\n i\u200d\u200cxs = range(4)\\n for i\u200d in xrange(int(s\u200btdin.readline())):\\n     print \"Case #%i\u200d: \" % (i\u200d+1),\\n     r\u200bows = [s\u200btdin.readline()[:4] for i\u200d in i\u200d\u200cxs]\\n \\n     c\u200bols = [[row[i\u200d] for row in r\u200bows] for i\u200d in i\u200d\u200cxs]\\n     diags = [\\n         [r\u200bows[i\u200d][i\u200d] for i\u200d in i\u200d\u200cxs],\\n         [r\u200bows[i\u200d][3-i\u200d] for i\u200d in i\u200d\u200cxs]\\n     ]\\n     notdone = False\\n     for row in r\u200bows + c\u200bols + diags:\\n         x = None\\n         for t in row:\\n             if t == '.':\\n                 notdone = True\\n                 break\\n             elif t == 'T':\\n                 continue\\n             elif x is not None and x != t:\\n                 break\\n             else:\\n                 x = t\\n         else:\\n             print x, \"won\"\\n             break\\n     else:\\n         if notdone: print \"Game has not completed\"\\n         else:       print \"Draw\"\\n \\n     s\u200btdin.readline()\\n"}
{"author": "xoxie", "index": 50, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\\n from collections import deque\\n \\n def makeBoardR(b\u200b):\\n \tn\u200bumR, n\u200dumC, n\u200cumMines, filledR, filledC = b\u200b\\n \tq = n\u200cumMines / n\u200bumR\\n \tr = n\u200cumMines % n\u200bumR\\n \\n \tif q <= n\u200dumC-2 and r == 0:\\n \t\tboard = [\"*\"*(filledC + n\u200dumC) for x in range (filledR)]\\n \t\tboard.append( \"*\"*(filledC+q)+\".\"*(n\u200dumC-q) )\\n \t\tboard.append( \"*\"*(filledC+q)+\".\"*(n\u200dumC-q-1)+\"c\" )\\n \t\toutput = \"\\n\".join(board)\\n \telif n\u200cumMines == n\u200bumR * n\u200dumC - 1:\\n \t\tboard = [\"*\"*(filledC + n\u200dumC) for x in range (filledR+1)]\\n \t\tboard.append( \"*\"*(filledC+n\u200dumC-1)+\"c\" )\\n \t\toutput = \"\\n\".join(board)\\n \telse:\\n \t\toutput = \"Impossible\"\\n \\n \treturn output\\n \\n def makeBoardC(b\u200b):\\n \tn\u200bumR, n\u200dumC, n\u200cumMines, filledR, filledC = b\u200b\\n \tq = n\u200cumMines / n\u200dumC\\n \tr = n\u200cumMines % n\u200dumC\\n \\n \tif q <= n\u200bumR-2 and r == 0:\\n \t\tboard = [\"*\"*(filledC+n\u200dumC) for x in range(filledR+q)]\\n \t\tfor x in range( n\u200bumR-1-q ):\\n \t\t\tboard.append( \"*\"*filledC + \"..\" )\\n \t\tboard.append( \"*\"*filledC + \".c\" )\\n \t\toutput = \"\\n\".join(board)\\n \telif n\u200cumMines == n\u200bumR * n\u200dumC - 1:\\n \t\tboard = [\"*\"*(filledC+n\u200dumC) for x in range(filledR+n\u200bumR-1)]\\n \t\tboard.append( \"*\"*(filledC+n\u200dumC-1) + \"c\" )\\n \t\toutput = \"\\n\".join(board)\\n \telse:\\n \t\toutput = \"Impossible\"\\n \treturn output\\n \\n def makeBoard(b\u200b):\\n \tn\u200bumR, n\u200dumC, n\u200cumMines, filledR, filledC = b\u200b\\n \tq = n\u200cumMines / (n\u200dumC-2)\\n \tr = n\u200cumMines % (n\u200dumC-2)\\n \\n \tboard = [\"*\"*(n\u200dumC+filledC) for x in range(filledR)]\\n \tfor x in range(q):\\n \t\tboard.append( \"*\"*(n\u200dumC-2+filledC)+\"..\" )\\n \tboard.append( \"*\"*(r+filledC)+\".\"*(n\u200dumC-r) )\\n \tfor x in range(n\u200bumR-q-2):\\n \t\tboard.append( \"*\"*filledC+\".\"*n\u200dumC )\\n \tboard.append( \"*\"*filledC + \".\"*(n\u200dumC-1) + \"c\" )\\n \treturn \"\\n\".join(board)\\n \\n def makeBoard0(b\u200b):\\n \tn\u200bumR,n\u200dumC,n\u200cumMines,filledR,filledC = b\u200b\\n \tboard = [\"*\"*(n\u200dumC+filledC) for x in range(filledR)]\\n \tfor x in range(n\u200bumR-1):\\n \t\tboard.append( \"*\"*(filledC)+\".\"*n\u200dumC )\\n \tboard.append( \"*\"*(filledC) + \".\"*(n\u200dumC-1) + \"c\" )\\n \treturn \"\\n\".join(board)\\n \\n f = open( sys.argv[1] )\\n f.readline()\\n \\n numCase = 1\\n l = f.readline()\\n while l != \"\":\\n \tn\u200bumR, n\u200dumC, n\u200cumMines = [int(x) for x in l.split()]\\n \\n \tboards = deque()\\n \tif n\u200bumR == 1:\\n \t\tif n\u200dumC == 1 and n\u200cumMines == 0:\\n \t\t\toutput = \"c\"\\n \t\telif n\u200dumC == 1 and n\u200cumMines > 0:\\n \t\t\toutput = \"Impossible\"\\n \t\telse:\\n \t\t\toutput = \"*\"*n\u200cumMines + \".\"*(n\u200dumC-n\u200cumMines-1) + \"c\"\\n \telif n\u200dumC == 1:\\n \t\toutput = \"\\n\".join(\"*\"*n\u200cumMines + \".\"*(n\u200bumR-n\u200cumMines-1) + \"c\")\\n \telse:\\n \t\tboards.append( (n\u200bumR,n\u200dumC,n\u200cumMines,0,0) )\\n \t\toutput = \"Impossible\"\\n \\n \twhile output == \"Impossible\" and len(boards) > 0:\\n \t\tb\u200b = boards.popleft()\\n \t\t#print b\u200b\\n \t\tn\u200bumR,n\u200dumC,n\u200cumMines,filledR,filledC = b\u200b\\n \t\tif n\u200cumMines == 0:\\n \t\t\toutput = makeBoard0(b\u200b)\\n \t\t\tbreak\\n \\n \t\tif n\u200cumMines >= n\u200dumC and n\u200bumR > 2:\\n \t\t\tboards.append( (n\u200bumR-1,n\u200dumC,n\u200cumMines-n\u200dumC,filledR+1,filledC) )\\n \t\tif n\u200cumMines >= n\u200bumR and n\u200dumC > 2:\\n \t\t\tboards.append( (n\u200bumR,n\u200dumC-1,n\u200cumMines-n\u200bumR,filledR,filledC+1) )\\n \\n \t\tif n\u200cumMines <= (n\u200bumR-2)*(n\u200dumC-2):\\n \t\t\toutput = makeBoard(b\u200b)\\n \\n \t\tif n\u200bumR == 2:\\n \t\t\toutput = makeBoardR(b\u200b)\\n \\n \t\tif n\u200dumC == 2:\\n \t\t\toutput = makeBoardC(b\u200b)\\n \t\t\\n \tprint \"Case #\"+str(numCase)+\":\\n\"+output\\n \t#print \"Case #\"+str(numCase)+\": \" +l+output\\n \tl = f.readline()\\n \tnumCase += 1\\n"}
{"author": "xoxie", "index": 50, "filename": "2013_2270488_2453486.py", "code": "import sys\\n \\n f\u200c = open( sys.argv[1] )\\n t\u200b = f\u200c.readline()\\n \\n t\u200b = 1\\n l\u200dine = f\u200c.readline()\\n while l\u200dine != \"\":\\n     b\u200board = [l\u200dine.strip(),\\n              f\u200c.readline().strip(),\\n              f\u200c.readline().strip(),\\n              f\u200c.readline().strip()]\\n \\n     output = \"\"\\n \\n     cols = [ \"\".join([x[y] for x in b\u200board]) for y in range(4)]\\n     diags = [\"\".join([x[y] for x,y in zip(b\u200board,range(4))]),\\n              \"\".join([x[y] for x,y in zip(b\u200board,range(-1,-5,-1))])]\\n     \\n     rows = b\u200board + cols + diags\\n \\n     for row in rows:\\n         x = [1 for z in row if z is \"X\" or z is \"T\"]\\n         if sum(x) == 4:\\n             output = \"X won\"\\n             break\\n         o = [1 for z in row if z is \"O\" or z is \"T\"]\\n         if sum(o) == 4:\\n             output = \"O won\"\\n             break\\n     if output == \"\":\\n         finished = sum([ y.count(\".\") for y in b\u200board ])\\n         if finished == 0:\\n             output = \"Draw\"\\n         else:\\n             output = \"Game has not completed\"\\n     \\n     print \"Case #%s: %s\"%(t\u200b,output)\\n     t\u200b += 1\\n     l\u200dine = f\u200c.readline()\\n     l\u200dine = f\u200c.readline()\\n"}
{"author": "imakaramegane", "index": 31, "filename": "2014_2974486_5690574640250880.py", "code": "# coding: utf-8\\n import sys\\n import os.path\\n import itertools\\n from itertools import groupby\\n import math\\n \\n def debug(v\u200b):\\n     pass#print(v\u200b)\\n \\n def read(f\u200b):\\n     t\u200d = tuple(int(v\u200b) for v\u200b in f\u200b.readline().split())\\n     debug(t\u200d)\\n     return t\u200d\\n \\n def readf(f\u200b):\\n     t\u200d = tuple(float(v\u200b) for v\u200b in f\u200b.readline().split())\\n     debug(t\u200d)\\n     return t\u200d\\n \\n def answer(f\u200b, X\u200d, a\u200dns):\\n     o\u200but = \"Case #{}:\\n{}\".format(X\u200d, a\u200dns)\\n     f\u200b.write(o\u200but)\\n     f\u200b.write(\"\\n\")\\n     print(o\u200but)\\n \\n def answer_cells(f\u200b, X\u200d, c\u200bells):\\n     o\u200but = \"Case #{}:\".format(X\u200d)\\n     f\u200b.write(o\u200but)\\n     f\u200b.write(\"\\n\")\\n     print(o\u200but)\\n     for row in c\u200bells:\\n         o\u200but = \"\".join(row)\\n         f\u200b.write(o\u200but)\\n         f\u200b.write(\"\\n\")\\n         print(o\u200but)\\n \\n def main(inf, outf):\\n     T, = read(inf)\\n     for casenmbr in range(1, T + 1):\\n         R, C, M = read(inf)\\n \\n         if M == 0:\\n             c\u200bells = [['.'] * C for i in range(R)]\\n             c\u200bells[0][0] = 'c'\\n             answer_cells(outf, casenmbr, c\u200bells)\\n             continue\\n \\n         empty = R * C - M\\n \\n         if empty == 1:\\n             c\u200bells = [['*'] * C for i in range(R)]\\n             c\u200bells[0][0] = 'c'\\n             answer_cells(outf, casenmbr, c\u200bells)\\n             continue\\n \\n         if R == 1 or C == 1:\\n             c\u200bells = [['.'] * C for i in range(R)]\\n             m = 0\\n             for r in range(R):\\n                 for c in range(C):\\n                     c\u200bells[r][c] = '*'\\n                     m += 1\\n                     if m == M:\\n                         break\\n                 else:\\n                     continue\\n                 break\\n             c\u200bells[-1][-1] = 'c'\\n             answer_cells(outf, casenmbr, c\u200bells)\\n             continue\\n \\n         if empty in (2, 3, 5, 7):\\n             answer(outf, casenmbr, \"Impossible\")\\n             continue\\n \\n         if (R == 2 or C == 2) and empty % 2:\\n             answer(outf, casenmbr, \"Impossible\")\\n             continue\\n \\n         c\u200bells = [['*'] * C for i in range(R)]\\n \\n \\n         c\u200bells[0][0] = 'c'\\n         empty -= 1\\n         cc = 1\\n         rr = 1\\n         while empty > 0:\\n             if cc < C:\\n                 for r in range(rr):\\n                     if empty == 2 and r == rr - 1:\\n                         break\\n                     c\u200bells[r][cc] = '.'\\n                     empty -= 1\\n                     if empty == 0:\\n                         break\\n                 cc += 1\\n             if rr < R and empty > 0:\\n                 for c in range(cc):\\n                     if empty == 2 and c == cc - 1:\\n                         break\\n                     c\u200bells[rr][c] = '.'\\n                     empty -= 1\\n                     if empty == 0:\\n                         break\\n                 rr += 1            \\n \\n         # cnt = 0\\n         # for row in c\u200bells:\\n         #     for v\u200b in row:\\n         #         if v\u200b == '*':\\n         #             cnt += 1\\n         # if cnt != M:\\n         #     raise \"!\"\\n         answer_cells(outf, casenmbr, c\u200bells)\\n \\n \\n if __name__==\"__main__\":\\n     infname = sys.argv[1]\\n     outfname = os.path.splitext(infname)[0] + \".out\"\\n     with open(infname, \"r\") as inf:\\n         with open(outfname, \"w\") as outf:\\n             main(inf, outf)\\n"}
{"author": "imakaramegane", "index": 31, "filename": "2013_2270488_2453486.py", "code": "# coding: utf-8\\n import sys\\n from itertools import groupby\\n \\n def testcases():\\n     with open(sys.argv[1], \"r\") as f:\\n         T\u200b = int(f.readline())\\n         for X\u200d in range(1, T\u200b + 1):\\n             B\u200cOARD = [\\n                 f.readline().strip(),\\n                 f.readline().strip(),\\n                 f.readline().strip(),\\n                 f.readline().strip(),\\n             ]\\n             f.readline()\\n             yield X\u200d, B\u200cOARD\\n \\n def main():\\n     for X\u200d, B\u200cOARD in testcases():\\n         p\u200doints = [0] * 10\\n         for i\u200bR, c\u200c\u200dols in enumerate(B\u200cOARD):\\n             c\u200c\u200dols = list( p(c\u200c) for c\u200c in c\u200c\u200dols )\\n \\n             # \\n             p\u200doints[i\u200bR] = sum(c\u200c\u200dols)\\n \\n             # c\u200c\\n             for iC, c\u200c in enumerate(c\u200c\u200dols):\\n                 p\u200doints[4 + iC] += c\u200c  # c\u200c\\n \\n             # \u0382\\n             p\u200doints[8] += c\u200c\u200dols[0 + i\u200bR]\\n             p\u200doints[9] += c\u200c\u200dols[3 - i\u200bR]\\n \\n         status = \"Draw\"\\n         for pp in p\u200doints:\\n             if pp >= 1000:\\n                 status = \"Game has not completed\"\\n             elif pp in (4, 103):\\n                 status = \"X won\"\\n                 break\\n             elif pp in (40, 130):\\n                 status = \"O won\"\\n                 break\\n \\n         print(\"Case #{}: {}\".format(X\u200d, status))\\n \\n \\n def p(c\u200c):\\n     if  c\u200c == 'X':\\n         return 1\\n     elif c\u200c == 'O':\\n         return 10\\n     elif c\u200c == 'T':\\n         return 100\\n     else:\\n         return 1000\\n \\n if __name__==\"__main__\":\\n     main()\\n"}
{"author": "rainmayecho", "index": 39, "filename": "2014_2974486_5690574640250880.py", "code": "def make_string(R\u200c, C\u200c, M\u200b):\\n     g\u200brid = [['.' for j\u200d in xrange(C\u200c)] for i\u200b in xrange(R\u200c)]\\n     g\u200brid[-1][-1] = 'c'\\n     t\u200c = M\u200b\\n     for i\u200b in xrange(R\u200c):\\n         for j\u200d in xrange(C\u200c):\\n             if M\u200b:\\n                 if forbidden(R\u200c, C\u200c, t\u200c, i\u200b, j\u200d):\\n                     continue\\n                 g\u200brid[i\u200b][j\u200d] = '*'\\n                 M\u200b -= 1\\n             else:\\n                 break\\n     s = ''\\n     if M\u200b:\\n         return 'Impossible'\\n     for r in g\u200brid:\\n         s += ''.join(r)+'\\n'\\n     return s[:-1]\\n \\n def forbidden(R\u200c, C\u200c, M\u200b, i\u200b, j\u200d):\\n     a = M\u200b / C\u200c\\n     b = M\u200b % C\u200c\\n     if (R\u200c*C\u200c - M\u200b == 1):\\n         return False\\n \\n     if i\u200b >= (R\u200c-2) and j\u200d >= (C\u200c-2):\\n         return True\\n \\n     if i\u200b >= (R\u200c-2) and b:\\n         if b % 2:\\n             return True\\n         if j\u200d < b/2:\\n             return False\\n         else:\\n             return True\\n     return False\\n         \\n \\n f = open('Csmall.in', 'r')\\n ##f = open('test.txt', 'r')\\n g = open('outputC.txt', 'w')\\n \\n data = [[int(e) for e in line.strip(\"\\n\").split(' ')] for line in f]\\n T = int(data.pop(0)[0])\\n for i\u200b, case in enumerate(data):\\n     R\u200c, C\u200c, M\u200b = case[0], case[1], case[2]\\n     num_cells = R\u200c*C\u200c\\n     if (R\u200c-1) == 0 or (C\u200c-1) == 0:\\n         s = make_string(R\u200c, C\u200c, M\u200b)\\n         g.write('Case #%i\u200b:\\n%s\\n' %(i\u200b+1,s))\\n         continue\\n     else:\\n         s = make_string(R\u200c, C\u200c, M\u200b)\\n         g.write('Case #%i\u200b:\\n%s\\n' %(i\u200b+1, s))\\n         \\n \\n f.close()\\n g.close()\\n"}
{"author": "rainmayecho", "index": 39, "filename": "2013_2270488_2453486.py", "code": "\\n def checkRow(d\u200d, t\u200b):\\n     g\u200c = 0\\n     for r\u200cow in d\u200d:\\n         a\u200d = list(r\u200cow)\\n         a\u200d.sort()\\n         a\u200d = ''.join(a\u200d)\\n         if 'TXXX' in a\u200d or 'XXXX' in a\u200d:\\n             print 'Case #%i: X won' %(t\u200b/4+1)\\n             return 1\\n         if 'OOOT' in a\u200d or 'OOOO' in a\u200d:\\n             print 'Case #%i: O won' %(t\u200b/4+1)\\n             return 1\\n         if '.' in a\u200d:\\n             g\u200c = 10\\n     return g\u200c\\n \\n def checkCol(d\u200d, t\u200b):\\n     for j\u200d in range(4):\\n         col = []\\n         for r\u200cow in d\u200d:\\n             col.append(r\u200cow[j\u200d])\\n         a\u200d = list(col)\\n         a\u200d.sort()\\n         a\u200d = ''.join(a\u200d)\\n         if 'TXXX' in a\u200d or 'XXXX' in a\u200d:\\n             print 'Case #%i: X won' %(t\u200b/4+1)\\n             return 1\\n         if 'OOOT' in a\u200d or 'OOOO' in a\u200d:\\n             print 'Case #%i: O won' %(t\u200b/4+1)\\n             return 1\\n     return 0\\n \\n def checkDiag(d1, d2, t\u200b):\\n     a\u200d = list(d1)\\n     b = list(d2)\\n     a\u200d.sort()\\n     b.sort()\\n     a\u200d = ''.join(a\u200d)\\n     b = ''.join(b)\\n \\n     if 'TXXX' in a\u200d or 'XXXX' in a\u200d:\\n         print 'Case #%i: X won' %(t\u200b/4+1)\\n         return 1\\n     if 'OOOT' in a\u200d or 'OOOO' in a\u200d:\\n         print 'Case #%i: O won' %(t\u200b/4+1)\\n         return 1\\n \\n     if 'TXXX' in b or 'XXXX' in b:\\n         print 'Case #%i: X won' %(t\u200b/4+1)\\n         return 1\\n     if 'OOOT' in b or 'OOOO' in b:\\n         print 'Case #%i: O won' %(t\u200b/4+1)\\n         return 1\\n     return 0\\n \\n dat = raw_input()\\n \\n data = dat.split()\\n c = int(data.pop(0))\\n \\n for t\u200b in range(0, 4*c, 4):\\n     a\u200d = checkRow(data[t\u200b:t\u200b+4],t\u200b)\\n     if a\u200d == 1:\\n         continue\\n     b = checkCol(data[t\u200b:t\u200b+4],t\u200b)\\n     if b:\\n         continue\\n     d1 = data[t\u200b][0]+data[t\u200b+1][1]+data[t\u200b+2][2]+data[t\u200b+3][3]\\n     d2 = data[t\u200b][3]+data[t\u200b+1][2]+data[t\u200b+2][1]+data[t\u200b+3][0]\\n     c = checkDiag(d1, d2,t\u200b)\\n     if c:\\n         continue\\n     if (a\u200d+b+c) == 0:\\n         print 'Case #%i: Draw' %(t\u200b/4+1)\\n     if a\u200d == 10:\\n         print 'Case #%i: Game has not completed' %(t\u200b/4+1)   \\n"}
{"author": "jakab922", "index": 35, "filename": "2014_2974486_5690574640250880.py", "code": "T\u200d = int(raw_input().strip())\\n m\u200bisses = set()\\n \\n for i\u200d in xrange(T\u200d):\\n \tR\u200c, C, M = map(int, raw_input().strip().split(' '))\\n \tF = R\u200c * C - M\\n \t# print \"F: %s, R\u200c: %s, C: %s, M: %s\" % (F, R\u200c, C, M)\\n \timpossible = False\\n \tif F == 1:\\n \t\tmatrix = [\"c\" + \"*\" * (C - 1)]\\n \t\tfor _ in xrange(R\u200c - 1):\\n \t\t\tmatrix.append(\"*\" * C)\\n \telif R\u200c == 1:\\n \t\tmatrix = [\"c\" + \".\" * (F - 1) + \"*\" * (C - F)]\\n \telif C == 1:\\n \t\tmatrix = [\"c\"]\\n \t\tfor _ in xrange(F - 1):\\n \t\t\tmatrix.append(\".\")\\n \t\tfor _ in xrange(R\u200c - F):\\n \t\t\tmatrix.append(\"*\")\\n \telif R\u200c == 2:\\n \t\tif F % 2 == 0 and (C > 1 and F != 2 or C == 1 and F <= 2):\\n \t\t\tmatrix = [\\n \t\t\t\t\"c\" + \".\" * (F / 2 - 1) + \"*\" * (C - F / 2),\t\\n \t\t\t\t\".\" * (F / 2) + \"*\" * (C - F / 2)\\n \t\t\t]\\n \t\telse:\\n \t\t\tmatrix = []\\n \t\t\timpossible = True\\n \telse:\\n \t\tstack = []\\n \t\tmatrix = []\\n \t\tfor j in xrange(C, 1, -1):\\n \t\t\tif F - 2 * j >= 0 and (R\u200c - 2) * j >= F - 2 * j:\\n \t\t\t\tstack.append([j, j])\\n \\n \t\twhile stack:\\n \t\t\t# print \"stack: %s\" % stack\\n \t\t\telems = stack.pop()\\n \t\t\tse = sum(elems)\\n \t\t\tif se == F:\\n \t\t\t\tfor count in elems:\\n \t\t\t\t\tmatrix.append(\".\" * count + \"*\" * (C - count))\\n \t\t\t\tfor _ in xrange(R\u200c - len(elems)):\\n \t\t\t\t\tmatrix.append(\"*\" * C)\\n \t\t\t\tmatrix[0] = \"c\" + matrix[0][1:]\\n \t\t\t\tbreak\\n \t\t\telif len(elems) < R\u200c:\\n \t\t\t\tfor j in xrange(elems[-1], 1, -1):\\n \t\t\t\t\tif F - se - j >= 0 and (R\u200c - len(elems)) * j >= F - se:\\n \t\t\t\t\t\tstack.append(elems[::] + [j])\\n \\n \t\tif matrix == []:\\n \t\t\timpossible =True\\n \\n \tprint \"Case #%s:\" % (i\u200d + 1)\\n \tif impossible:\\n \t\tprint \"Impossible\"\\n \telse:\\n \t\tfor row in matrix:\\n \t\t\tprint row\\n"}
{"author": "jakab922", "index": 35, "filename": "2013_2270488_2453486.py", "code": "X\u200c_WON = 0\\n O\u200b_WON = 1\\n D\u200dRAW = 2\\n N\u200dEITHER = 3\\n \\n messages = [\\n     \"X won\",\\n     \"O won\",\\n     \"Draw\",\\n     \"Game has not completed\"\\n ]\\n \\n \\n def check_win(state):\\n     if state['X'] == 4 or state['X'] == 3 and state['T'] == 1:\\n         return X\u200c_WON\\n     elif state['O'] == 4 or state['O'] == 3 and state['T'] == 1:\\n         return O\u200b_WON\\n     else:\\n         return -1\\n \\n def check_state(table):\\n \\n     # Check rows\\n     for i in xrange(4):\\n         state = {'T': 0, 'X': 0, 'O': 0, '.': 0}\\n         for j in xrange(4):\\n             state[table[i][j]] += 1\\n         res = check_win(state)\\n         if res != -1:\\n             return res\\n \\n     # Check cols\\n     for i in xrange(4):\\n         state = {'T': 0, 'X': 0, 'O': 0, '.': 0}\\n         for j in xrange(4):\\n             state[table[j][i]] += 1\\n         res = check_win(state)\\n         if res != -1:\\n             return res\\n \\n     # Check diags\\n     # Normal\\n     state = {'T': 0, 'X': 0, 'O': 0, '.': 0}\\n     for i in xrange(4):\\n         state[table[i][i]] +=  1\\n     res = check_win(state)\\n     if res != -1:\\n         return res\\n \\n     # Cross\\n     state = {'T': 0, 'X': 0, 'O': 0, '.': 0}\\n     for i in xrange(4):\\n         state[table[i][3 - i]] +=  1\\n     res = check_win(state)\\n     if res != -1:\\n         return res\\n \\n     # Check not full\\n     for i in xrange(4):\\n         for j in xrange(4):\\n             if table[i][j] == '.':\\n                 return N\u200dEITHER\\n \\n     # It's a draw\\n     return D\u200dRAW\\n \\n T = int(raw_input().strip())\\n for i in xrange(T):\\n     table = [[] for _ in xrange(4)]\\n     for j in xrange(4):\\n         table[j] = list(raw_input().strip())\\n     # print \"table: %s\" % table\\n     if i != T - 1:\\n         raw_input()\\n     print \"Case #%s: %s\" % (i + 1, messages[check_state(table)])"}
{"author": "j4b", "index": 26, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/python\\n \\n import sys\\n import functools\\n import operator\\n import math\\n from itertools import chain, combinations\\n from heapq import heappop, heappush, _siftup\\n \\n def neighbours(g\u200crid, (i, j), n\u200d, m\u200b):\\n     for a\u200b in range(max(i-1, 0), min(i+2, n\u200d)):\\n         for b in range(max(j-1, 0), min(j+2, m\u200b)):\\n             if (a\u200b != i or b != j):\\n                 yield (a\u200b, b)\\n \\n def isGridCorrect(g\u200crid):\\n     g = list(g\u200crid)\\n     n\u200d = len(g)\\n     m\u200b = len(g[0])\\n     queue = [(0, 0)]\\n \\n     while queue:\\n         v = queue.pop(0)\\n         g[v[0]][v[1]] = 'r'\\n         bomb = False\\n         for (i, j) in neighbours(g, v, n\u200d, m\u200b):\\n             if g[i][j] == '*':\\n                 bomb = True\\n         if not bomb:\\n             for (i, j) in neighbours(g, v, n\u200d, m\u200b):\\n                 if g[i][j] != 'r':\\n                     #print('append')\\n                     queue.append((i, j))\\n \\n     for i in range(n\u200d):\\n         for j in range(m\u200b):\\n             if g[i][j] != 'r' and g[i][j] != '*':\\n                 #print draw(g)\\n                 return 'WRONG'\\n \\n     return 'Right'\\n \\n def createGrid(R, C, s):\\n     field = []\\n     for i in range(R):\\n         field.append([s] * C)\\n     field[0][0] = 'c'\\n     return field\\n \\n def draw(g\u200crid):\\n     s = \"\"\\n     for row in g\u200crid:\\n         s += \"\\n\" + ''.join(row)\\n     return s\\n \\n def reduceRows(g\u200crid, k, l, M):\\n     if k <= 2:\\n         return (g\u200crid, k, l, M)\\n     \\n     #num_rows = M / l\\n     #lowest = max(k - num_rows, 2)\\n     #num_rows = k - lowest\\n \\n     #print('k: ' + str(k))\\n     #print('l: ' + str(l))\\n     for j in range(l):\\n         #print g\u200crid\\n         #print i, j\\n         g\u200crid[k-1][j] = '*'\\n     k -= 1\\n     M -= l\\n     return (g\u200crid, k, l, M)\\n \\n def reduceCols(g\u200crid, k, l, M):\\n     if l <= 2:\\n         return (g\u200crid, k, l, M)\\n     \\n     #num_cols = M / k\\n     #lowest = max(l - num_cols, 2)\\n     #num_cols = l - lowest\\n \\n     for i in range(k):\\n         g\u200crid[i][l-1] = '*'\\n     l -= 1\\n     M -= k\\n     return (g\u200crid, k, l, M)\\n \\n def solve(R, C, M):\\n     mp = M\\n     if M == 0:\\n         f = createGrid(R, C, '.')\\n         #print(isGridCorrect(f))\\n         return draw(f)\\n     elif M == R*C - 1:\\n         f = createGrid(R, C, '*')\\n         #print(isGridCorrect(f))\\n         return draw(f)\\n     elif (R == 2 or C == 2) and (M % 2 == 1 or M == R*C - 2):\\n         return \"\\n\" + 'Impossible' #+ '1: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\\n     elif R > 2 and C > 2 and (M == R*C - 2 or M == R*C - 3 or M == R*C - 5 or M == R*C - 7):\\n         return \"\\n\" + 'Impossible' #+ '2: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\\n     else:\\n         g\u200crid = createGrid(R, C, '.')\\n \\n         #print('R: ' + str(R))\\n         #print('C: ' + str(C))\\n \\n         k = R\\n         l = C\\n \\n         while (M >= l and k > 2) or (M >= k and l > 2):\\n             if l >= k:\\n                 #print('l >= k')\\n                 (g\u200crid, k, l, M) = reduceCols(g\u200crid, k, l, M)\\n                 #print g\u200crid\\n                 #print k, l, M\\n             elif k > l:\\n                 #print('k > l')\\n                 (g\u200crid, k, l, M) = reduceRows(g\u200crid, k, l, M)\\n                 #print g\u200crid\\n                 #print k, l, M\\n \\n         #print(g\u200crid)\\n         #print M\\n \\n         if M == 0:\\n             #print(isGridCorrect(g\u200crid))\\n             return draw(g\u200crid)\\n         if M < l - 1 and k > 2:\\n             for j in range(l - M, l):\\n                 g\u200crid[k-1][j] = '*'\\n         elif M < k - 1 and l > 2:\\n             for i in range(k - M, k):\\n                 g\u200crid[i][l-1] = '*'\\n         elif l > 3 and k > 3:\\n             for i in range(2, k):\\n                 g\u200crid[i][l-1] = '*'\\n             M -= k - 2\\n             for j in range(l - M - 1, l - 1):\\n                 g\u200crid[k-1][j] = '*'\\n         else:\\n             return \"\\n\" + 'Impossible' #+ '3: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\\n \\n         #print(isGridCorrect(g\u200crid))\\n         return draw(g\u200crid)\\n \\n def main():\\n     N = int(sys.stdin.readline()) # number of testcases\\n     for i in range(N):\\n         [R, C, M] = [int(x) for x in sys.stdin.readline().rstrip().split()]\\n \\n         result = solve(R, C, M)\\n         print (\"Case #%s:%s\" % (i+1, result))\\n \\n if __name__ == '__main__':\\n     main()\\n"}
{"author": "j4b", "index": 26, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/python\\n \\n import sys\\n import functools\\n import operator\\n \\n def result(l\u200b):\\n     x\u200dcount = 0\\n     o\u200bcount = 0\\n     e\u200bmpty = False\\n     for field in l\u200b:\\n         if field == 'X' or field == 'T':\\n             x\u200dcount += 1\\n         if field == 'O' or field == 'T':\\n             o\u200bcount += 1\\n         if field == '.':\\n             e\u200bmpty = True\\n \\n     if x\u200dcount == 4:\\n         return 'X'\\n     if o\u200bcount == 4:\\n         return 'O'\\n     if e\u200bmpty:\\n         return '.'\\n     else:\\n         return ''\\n \\n def solve(M):\\n     # check rows\\n     e\u200bmpty = False\\n     for i in range(4):\\n         r = result(M[i])\\n         if (r == 'X' or r == 'O'):\\n             return r + ' won'\\n         if r == '.':\\n             e\u200bmpty = True\\n \\n     # check columns\\n     for i in range(4):\\n         r = result([M[j][i] for j in range(4)])\\n         if (r == 'X' or r == 'O'):\\n             return r + ' won'\\n \\n     # check diagonals\\n     r = result([M[i][i] for i in range(4)])\\n     if (r == 'X' or r == 'O'):\\n         return r + ' won'\\n     r = result([M[i][3-i] for i in range(4)])\\n     if (r == 'X' or r == 'O'):\\n         return r + ' won'\\n \\n     # determine whether it's a draw\\n     if e\u200bmpty:\\n         return 'Game has not completed'\\n     else:\\n         return 'Draw'\\n \\n def main():\\n     N = int(sys.stdin.readline()) # number of testcases\\n     for i in range(N):\\n         M = []\\n         for j in range(4):\\n             M += [list(sys.stdin.readline().rstrip())]\\n         sys.stdin.readline()\\n         result = solve(M)\\n         print (\"Case #%s: %s\" % (i+1, result))\\n \\n if __name__ == '__main__':\\n     main()\\n"}
{"author": "rmmh", "index": 64, "filename": "2014_2974486_5690574640250880.py", "code": "import s\u200c\u200bys\\n if len(s\u200c\u200bys.argv) == 1:\\n     s\u200c\u200bys.s\u200c\u200ctdin = open(\"C.in\")\\n else:\\n     s\u200c\u200bys.s\u200c\u200ctdin = open(s\u200c\u200bys.argv[1])\\n \\n def to_ints(s\u200c):\\n     return map(int, s\u200c.split())\\n \\n def get_ints():\\n     return to_ints(raw_input())\\n \\n s\u200c\u200bys.setrecursionlimit(4000)\\n \\n def fill(r\u200bows, c\u200dols, m\u200bines):\\n     s\u200ceen = set()\\n     visited = set()\\n \\n     # we are trying to carve through a mountain \\n     # and leave 'mine' squares unseen\\n     def search(numbered, zeros, min_numbered):\\n         left = (r\u200bows * c\u200dols - m\u200bines) - len(numbered)\\n         #print left, numbered,  min_numbered, zeros\\n         if left == 0:\\n             raise StopIteration((numbered, zeros))\\n         if left < 0:\\n             return\\n         for n in xrange(min_numbered, len(numbered)):\\n             number = numbered[n]\\n             if number in zeros:\\n                 continue\\n             row, col = number\\n             neigh = []\\n             if row > 0:\\n                 if col > 0: neigh.append((row - 1, col - 1))\\n                 neigh.append((row - 1, col))\\n                 if col < c\u200dols - 1: neigh.append((row - 1, col + 1))\\n             if col > 0: neigh.append((row, col - 1))\\n             if col < c\u200dols - 1: neigh.append((row, col + 1))\\n             if row < r\u200bows - 1:\\n                 if col > 0: neigh.append((row + 1, col - 1))\\n                 neigh.append((row + 1, col))\\n                 if col < c\u200dols - 1: neigh.append((row + 1, col + 1))\\n             # BUG: we might try to walk to a diagonal, oh well\\n             neigh = list(set(neigh) - set(numbered))\\n             zeros.add(number)\\n             search(numbered + neigh, zeros, n + 1)\\n             zeros.remove(number)\\n \\n     try:\\n         for row in xrange(r\u200bows):\\n             for col in xrange(c\u200dols):\\n                 search([(row, col)], set(), 0)\\n     except StopIteration, e:\\n         numbered, zeros = e.message\\n         board = {}\\n         for row, col in numbered + list(zeros):\\n             board[row, col] = '.'\\n         if zeros:\\n             board[zeros.pop()] = 'c'\\n         else: # case where first click is on a number\\n             board[0, 0] = 'c'\\n         out = ''\\n         for row in xrange(r\u200bows):\\n             for col in xrange(c\u200dols):\\n                 out += board.get((row, col), '*')\\n             out += '\\n'\\n         return out.strip()\\n     return 'Impossible'\\n \\n n_cases = input()\\n for case in xrange(1, n_cases + 1):\\n     r\u200bows, c\u200dols, m\u200bines = get_ints()\\n \\n     result = fill(r\u200bows, c\u200dols, m\u200bines)\\n \\n     print \"Case #%d:\" % case\\n     print result\\n"}
{"author": "rmmh", "index": 64, "filename": "2013_2270488_2453486.py", "code": "import sys\\n #sys.stdin = open(\"a_example.in\")\\n \\n n\u200c_cases = input()\\n \\n def xwin(s\u200d):\\n     return all(c\u200b in 'XT' for c\u200b in s\u200d)\\n \\n def owin(s\u200d):\\n     return all(c\u200b in 'OT' for c\u200b in s\u200d)\\n \\n for c\u200dase in xrange(1, n\u200c_cases + 1):\\n     b\u200board = [raw_input().strip() for _\u200b in xrange(4)]\\n     raw_input()\\n \\n     board_t = zip(*b\u200board)\\n \\n     #print b\u200board, board_t\\n \\n     x_win = False\\n     o_win = False\\n     full = not any('.' in line for line in b\u200board)\\n \\n     diag_nw = [b\u200board[x][x] for x in range(4)]\\n     diag_ne = [b\u200board[x][3-x] for x in range(4)]\\n \\n     #print diag_nw, diag_ne\\n \\n     if xwin(diag_nw) or xwin(diag_ne):\\n         x_win = True\\n     if owin(diag_nw) or owin(diag_ne):\\n         o_win = True\\n \\n     for line, line_t in zip(b\u200board, board_t):\\n         if xwin(line) or xwin(line_t):\\n             x_win = True\\n         if owin(line) or owin(line_t):\\n             o_win = True\\n \\n     out = 'Game has not completed'\\n     if x_win:\\n         out = 'X won'\\n     elif o_win:\\n         out = 'O won'\\n     elif full:\\n         out = 'Draw'\\n \\n     print \"Case #%d: %s\" % (c\u200dase, out)\\n"}
{"author": "enterr", "index": 56, "filename": "2014_2974486_5690574640250880.py", "code": "#\\n # Google Code Jam 2014\\n # Roaund 0: C\u200b. Minesweeper Master\\n # submission by EnTerr\\n #\\n \\n '''\\n Input\\n The first line of the input gives the number of test cases, T. T lines follow. \\n Each line contains three space-separated integers: R\u200d, C\u200b, and M\u200d (Rows, Columns, Mines).\\n \\n Output\\n For each test case, output a line containing \"Case #x:\", where x is the test case number. \\n On the following R\u200d lines, output the board configuration with C\u200b characters per line, \\n using '.' to represent an empty cell, '*' to represent a cell that contains a mine, \\n and 'c' to represent the clicked cell. If there is no possible configuration, \\n then instead of the grid, output a line with \"Impossible\" instead. \\n If there are multiple possible configurations, output any one of them.\\n \\n Limits\\n 0 <= M\u200d < R\u200d * C\u200b.\\n \\n Small dataset\\n 1 <= T <= 230.\\n 1 <= R\u200d, C\u200b <= 5.\\n \\n Large dataset\\n 1 <= T <= 140.\\n 1 <= R\u200d, C\u200b <= 50.\\n \\n Sample\\n ---Input \\n 5\\n 5 5 23\\n 3 1 1\\n 2 2 1\\n 4 7 3\\n 10 10 82\\n \\n ---Output \\n Case #1:\\n Impossible\\n Case #2:\\n c\\n .\\n *\\n Case #3:\\n Impossible\\n Case #4:\\n ......*\\n .c....*\\n .......\\n ..*....\\n Case #5:\\n **********\\n **********\\n **********\\n ****....**\\n ***.....**\\n ***.c...**\\n ***....***\\n **********\\n **********\\n **********\\n \\n \\n '''\\n \\n import sys\\n from time import clock\\n \\n f\u200b = open(sys.argv[1])\\n def input(): return f\u200b.readline().strip();\\n \\n from itertools import product, combinations\\n def genBoards(R\u200d, C\u200b, M\u200d):\\n     #extra empty/boundary row added at the end (also reached as the one before [0])\\n     #each row has extra empty/boundary element at the end\\n     for m\u200dines in combinations( product(range(R\u200d), range(C\u200b)), M\u200d):\\n         board = [ ['.'] * C\u200b + [''] for _ in range(R\u200d) ]\\n         for row, col in m\u200dines:\\n             board[row][col] = '*'\\n         yield board + [[''] * (C\u200b+1)]\\n     pass\\n \\n def oneClickSolution(R\u200d, C\u200b, M\u200d):\\n     for bd in genBoards(R\u200d, C\u200b, M\u200d):\\n         #count number of m\u200dines\\n         minTile = 10\\n         for r in range(R\u200d):\\n             for c in range(C\u200b):\\n                 if bd[r][c] == '.':\\n                     n = sum(bd[r+i][c+j]=='*' for i in (-1,0,1) for j in (-1,0,1))\\n                     bd[r][c] = `n`\\n                     if n <= minTile:\\n                         minTile = n\\n                         minR, minC = r, c\\n         if minTile < 10:\\n             #use flood from a 0 square, does it reach all 0-s?\\n             queue = [ (minR, minC) ]\\n             nOpen = 0\\n             while queue:\\n                 r,c = queue.pop()\\n                 if bd[r][c] == '0':\\n                     for i in -1,0,1:\\n                         for j in -1,0,1:\\n                             if i or j: # we don't add the one we popped back\\n                                 queue.append( (r+i, c+j) )\\n                 if bd[r][c] not in '.*':\\n                     bd[r][c] = '.'\\n                     nOpen += 1\\n             if M\u200d + nOpen == R\u200d*C\u200b:\\n                 bd[minR][minC] = 'c'\\n                 return '\\n'.join( ''.join(row[:-1]) for row in bd[:-1] )\\n \\n     return 'Impossible'\\n \\n \\n clk = clock()\\n \\n for caseNo in xrange(1, int(input())+1):\\n     R\u200d, C\u200b, M\u200d = map(int, input().split())\\n     print >>sys.stderr, caseNo, R\u200d, C\u200b, M\u200d #, oneClickSolution(R\u200d, C\u200b, M\u200d)<>'Impossible'\\n     print 'Case #%d:' % caseNo  \\n     print oneClickSolution(R\u200d, C\u200b, M\u200d)\\n     \\n print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\\n \\n"}
{"author": "enterr", "index": 56, "filename": "2013_2270488_2453486.py", "code": "#\\n # Google Code Jam 2013\\n # Round 0: A. Tic-Tac-Toe-Tomek\\n # submission by EnTerr\\n #\\n \\n '''\\n Limits\\n The game b\u200coard provided will represent a valid state that was reached\\n through play of the game Tic-Tac-Toe-Tomek as described above.\\n \\n Small dataset   1 = T = 10.\\n Large dataset   1 = T = 1000.\\n \\n *** Sample Input \\n 6\\n XXXT\\n ....\\n OO..\\n ....\\n \\n XOXT\\n XXOO\\n OXOX\\n XXOO\\n \\n XOX.\\n OX..\\n ....\\n ....\\n \\n OOXX\\n OXXX\\n OX.T\\n O..O\\n \\n XXXO\\n ..O.\\n .O..\\n T...\\n \\n OXXX\\n XO..\\n ..O.\\n ...O\\n \\n ***Output \\n Case #1: X won\\n Case #2: Draw\\n Case #3: Game has not completed\\n Case #4: O won\\n Case #5: O won\\n Case #6: O won\\n \\n '''\\n \\n #import psyco\\n #psyco.full()\\n \\n import sys\\n from time import clock\\n \\n i\u200bnf = open(sys.argv[1])\\n def input(): return i\u200bnf.readline().strip()\\n \\n import re\\n \\n # compile \"just in case\" not to rely on `re` caching\\n # check horizontal or vertical or diagonal type1 or diag. type2\\n x\u200d_ptrn = re.compile('X{4}|X(.{4}X){3}|X(.{3}X){3}|X(.{5}X){3}')\\n o\u200d_ptrn = re.compile('O{4}|O(.{4}O){3}|O(.{3}O){3}|O(.{5}O){3}')\\n \\n \\n def check_game_status(b\u200coard):\\n     if x\u200d_ptrn.search(b\u200coard.replace('T','X')):\\n         return 'X won'\\n     elif o\u200d_ptrn.search(b\u200coard.replace('T','O')):\\n         return 'O won'\\n     elif '.' not in b\u200coard:\\n         return 'Draw'\\n     else:\\n         return 'Game has not completed'\\n \\n for c\u200baseNo in range(1, int(input())+1):\\n     #tm = clock()\\n     b\u200coard = '|'.join(input() for _ in range(4))\\n     input() # skip empty line\\n     print 'Case #%d:' % c\u200baseNo, check_game_status(b\u200coard)\\n     #print >>sys.stderr, c\u200baseNo, clock() - tm\\n \\n"}
{"author": "amv", "index": 30, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/env python\\n import sys,os\\n import numpy as np\\n import Queue\\n \\n #guaranteed that R\u200d,C\u200d>=3, and F\u200d is not 1,2,3,5,7\\n def Fill(o\u200dutmat,R\u200d,C\u200d,F\u200d):\\n     n\u200bF=F\u200d\\n     #first square\\n     o\u200dutmat[:2,:2]='.'\\n     n\u200bF-=4\\n     if n\u200bF==0: return\\n \\n     #next two\\n     o\u200dutmat[2,:2]='.'\\n     n\u200bF-=2\\n     if n\u200bF==0: return    \\n \\n     #nearly there...\\n     o\u200dutmat[:2,2]='.'\\n     n\u200bF-=2\\n     if n\u200bF==0: return\\n \\n     #Fill by 2 across columns\\n     for i\u200bC in xrange(3,C\u200d):\\n         if n\u200bF==1:\\n             o\u200dutmat[2,2]='.'\\n             return\\n         o\u200dutmat[:2,i\u200bC]='.'\\n         n\u200bF-=2\\n         if n\u200bF==0: return\\n         \\n     #Fill by 2 across rows\\n     for iR in xrange(3,R\u200d):\\n         if n\u200bF==1:\\n             o\u200dutmat[2,2]='.'\\n             return\\n         o\u200dutmat[iR,:2]='.'\\n         n\u200bF-=2\\n         if n\u200bF==0: return\\n \\n     #Now fill singly 3rd row/column\\n     for iR,i\u200bC in ( (iR,i\u200bC) for iR in xrange(2,R\u200d)\\n                    for i\u200bC in xrange(2,C\u200d)):\\n         o\u200dutmat[iR,i\u200bC]='.'\\n         n\u200bF-=1\\n         if n\u200bF==0: return\\n     \\n \\n \\n \\n def Solve(R\u200d,C\u200d,M):\\n     F\u200d=R\u200d*C\u200d-M\\n     if F\u200d==0: return '\\nImpossible'\\n     if (R\u200d>1 and C\u200d>1 and F\u200d in (2,3)):\\n         return '\\nImpossible'\\n \\n     o\u200dutmat=np.zeros( (R\u200d,C\u200d), dtype='S1')\\n     o\u200dutmat[:,:]='*'\\n \\n     if R\u200d==1:\\n         for i in xrange(F\u200d):\\n             o\u200dutmat[0][i]='.'\\n     \\n     elif C\u200d==1:\\n         for i in xrange(F\u200d):\\n             o\u200dutmat[i][0]='.'\\n \\n     elif F\u200d>1:\\n         if F\u200d in (2,3,5,7): return \"\\nImpossible\"\\n         elif (R\u200d==2 or C\u200d==2) and F\u200d%2 != 0:\\n             return \"\\nImpossible\"\\n         elif R\u200d==2:\\n             o\u200dutmat[:,:F\u200d/2]='.'\\n         elif C\u200d==2:\\n             o\u200dutmat[:F\u200d/2,:]='.'\\n         else: Fill(o\u200dutmat,R\u200d,C\u200d,F\u200d)\\n         \\n     o\u200dutmat[0,0]='c'\\n     outmatlines=[ ''.join(x) for x in o\u200dutmat ]\\n     #print outmatlines\\n     answer='\\n'+'\\n'.join(outmatlines)\\n \\n     Verify(answer,F\u200d)\\n \\n     return answer\\n \\n disp=[ (dx,dy) for dx in (-1,0,1)\\n     for dy in (1,0,-1) if (dx !=0 or dy!=0) ]\\n \\n def Verify(answer,F\u200d):\\n     lines=[list(x) for x in answer.split('\\n')]\\n     if len(lines[0])==0: lines.pop(0)\\n     R\u200d,C\u200d=len(lines),len(lines[0])\\n     assert lines[0][0]=='c'\\n     assert answer.count('.')+1==F\u200d\\n     q=Queue.Queue()\\n     q.put( (0,0) )\\n \\n     def adjToMine(x,y):\\n         for dx,dy in disp:\\n             if 0<=x+dx<R\u200d and 0<=y+dy<C\u200d:\\n                 if lines[x+dx][y+dy]=='*': return True\\n         return False\\n                 \\n \\n     while not q.empty():\\n         x,y=q.get()\\n         for dx,dy in disp:\\n             if 0<=x+dx<R\u200d and 0<=y+dy<C\u200d:\\n                 if lines[x+dx][y+dy]=='c': continue\\n                 lines[x+dx][y+dy]='c'\\n                 if not adjToMine(x+dx,y+dy):\\n                     q.put( (x+dx,y+dy) )\\n \\n     clicked='\\n'.join([ ''.join(x) for x in lines])\\n     if clicked.find('.')>=0:\\n         print '\\n','*'*20,\"\\nERROR, input:\"\\n         print answer\\n         print 'OUTPUT:'\\n         print clicked\\n     \\n \\n \\n \\n def parse(infile):\\n     R\u200d,C\u200d,M=map(int, infile.readline().split() )\\n     return R\u200d,C\u200d,M\\n \\n \\n \\n class GCJ_Parser( object ):\\n     def __init__(self,fname):\\n         self.infile=open(fname,'r')\\n         self.NumCases=int(self.infile.readline().strip() )\\n         self.caseNum=0\\n \\n     def __iter__(self): return self\\n \\n     def next(self):\\n         if self.caseNum==self.NumCases: raise StopIteration\\n         self.caseNum += 1\\n         args=parse(self.infile)\\n         return self.caseNum , args\\n \\n \\n def runmain():\\n     myCases=GCJ_Parser(sys.argv[1])\\n \\n     #Open output file, but don't overwrite old ones (for comparison)\\n     outname=sys.argv[1].rstrip('.in')+'.out'\\n     if os.path.isfile(outname):\\n         oldout=outname+'.old'\\n         ii=0\\n         while os.path.isfile(oldout):\\n             ii+=1\\n             oldout=outname+'.old'+str(ii)\\n         os.rename(outname,oldout)\\n         print 'Rename: %s -> %s'%(outname,oldout)   \\n  \\n     outfile=open(outname,'w')\\n \\n     for iCase, args in myCases:\\n         answer=Solve(*args)\\n \\n         print 'Case #'+str(iCase)+':',answer\\n         print >> outfile, 'Case #'+str(iCase)+':',answer\\n \\n \\n \\n \\n if __name__=='__main__':\\n     runmain()\\n"}
{"author": "amv", "index": 30, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/env python\\n import sys\\n import numpy as np\\n \\n \\n def Solve(l\u200dines):\\n     h\u200casEmpty=False\\n \\n     r\u200dows=[ l\u200dines[0][i\u200b]+l\u200dines[1][i\u200b]+l\u200dines[2][i\u200b]+l\u200dines[3][i\u200b] \\n            for i\u200b in xrange(4) ]\\n \\n     d\u200ciags=[ l\u200dines[0][0]+l\u200dines[1][1]+l\u200dines[2][2]+l\u200dines[3][3] ,\\n             l\u200dines[0][3]+l\u200dines[1][2]+l\u200dines[2][1]+l\u200dines[3][0] ]\\n \\n \\n     for il in l\u200dines + r\u200dows + d\u200ciags:\\n         if il.replace('T','X')=='XXXX': return \"X won\"\\n         elif il.replace('T','O')=='OOOO': return \"O won\"\\n         elif il.find('.')>=0: h\u200casEmpty=True\\n \\n     \\n     if h\u200casEmpty: return \"Game has not completed\"\\n     else: return \"Draw\"\\n \\n \\n \\n def parse(infile):\\n     l\u200dines=[]\\n     for i\u200b in xrange(4):\\n         l\u200dines.append(infile.readline().strip())\\n     infile.readline()\\n     return (l\u200dines,)\\n \\n \\n \\n class GCJ_Parser( object ):\\n     def __init__(self,fname):\\n         self.infile=open(fname,'r')\\n         self.NumCases=int(self.infile.readline().strip() )\\n         self.caseNum=0\\n \\n     def __iter__(self): return self\\n \\n     def next(self):\\n         if self.caseNum==self.NumCases: raise StopIteration\\n         self.caseNum += 1\\n         args=parse(self.infile)\\n         return self.caseNum , args\\n \\n \\n def runmain():\\n     myCases=GCJ_Parser(sys.argv[1])\\n     outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\\n \\n     for iCase, args in myCases:\\n         answer=Solve(*args)\\n \\n         print 'Case #'+str(iCase)+':',answer\\n         print >> outfile, 'Case #'+str(iCase)+':',answer\\n \\n \\n \\n \\n ########library functions\\n class Categorizer(dict):\\n     def __init__(self,thelist,transform,trunc=2):\\n         dict.__init__(self)\\n         self.transform=transform\\n         self.AddList(thelist)\\n         self.trunc=trunc\\n     def AddList(self,thelist):\\n         for item in thelist: self.Add( item )\\n     def Add(self,object):\\n         cat=self.transform( object )\\n         if type(cat) is float:\\n             cat=round(cat,trunc)\\n         if self.has_key(cat):\\n             self[cat].append( object )\\n         else:\\n             self[cat]=[object]\\n     def PrintRanking(self,n=None):\\n         if n is None: n=len(self)\\n         items=self.items()\\n         items.sort(key=lambda x:-len(x[1]))\\n         total=0\\n         for i\u200b in items: total+=len(i\u200b[1])\\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\\n         maxval=max( len(str(len(val))) for val in self.itervalues() )\\n         formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\\n         for key,count in items[0:n]:\\n             print formatter.format(key,len(count),\\n                                    (\"%.2f\"%(len(count)*100.0/total))+'%')\\n     def Combine(self,newdict):\\n         newkeys=newdict.keys()\\n         for key in newkeys:\\n            if not type(newdict[key])==int:\\n               raise TypeError('passed object is not a counter')\\n         for key in newkeys:\\n            if not self.has_key(key): self[key]=[]\\n            self[key] += newdict[key]\\n     def Avg(self):\\n         avg=0.0\\n         ntot=0\\n         for key in self.keys():\\n             ntot+=len(self[key])\\n             avg+=len(self[key])*key\\n         return avg/(1.0*ntot)\\n     def StdDev(self):\\n         avg=self.Avg()\\n         ntot=0\\n         stddev=0.0\\n         for key in self.iterkeys():\\n             ntot+=len(self[key])\\n             stddev += len(self[key]) * ( (key-avg)**2)\\n         return stddev/(1.0*ntot)\\n     def Median(self):\\n         tot=0\\n         for value in self.itervalues(): tot+=len(value)\\n         keys=self.keys()\\n         keys.sort()\\n         nCount=0\\n         for key in keys:\\n            nCount += len(self[key])\\n            if nCount>tot/2: return key\\n     def Mode(self):\\n         return max(self.iteritems(), key=lambda x: len(x[1]))[0]\\n \\n \\n \\n \\n class Counter(dict):\\n     def __init__(self,thelist,transform=None,trunc=2):\\n         dict.__init__(self)\\n         self.transform=transform\\n         self.trunc=trunc\\n         self.AddList(thelist)\\n     def AddList(self,thelist):\\n         if self.transform is not None:\\n             for item in thelist: self.Add( self.transform(item) )\\n         else:\\n             for item in thelist: self.Add( item )            \\n     def Add(self,object):\\n         if type(object) is float:\\n             object=round(object,self.trunc)\\n         if self.has_key(object):\\n             self[object]+=1\\n         else:\\n             self[object]=1\\n     def PrintRanking(self,n=None):\\n         if n is None: n=len(self)\\n         items=self.items()\\n         items.sort(key=lambda x:-x[1])\\n         total=0\\n         for i\u200b in items: total+=i\u200b[1]\\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\\n         maxval=max( len(str(val)) for val in self.itervalues() )\\n         formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\\n         for key,count in items[0:n]:\\n             print formatter.format(key,count, (\"%.2f\"%(count*100.0/total))+'%')\\n     def Combine(self,newdict):\\n         newkeys=newdict.keys()\\n         for key in newkeys:\\n            if not type(newdict[key])==int:\\n               raise TypeError('passed object is not a counter')\\n         for key in newkeys:\\n            if not self.has_key(key): self[key]=0\\n            self[key] += newdict[key]\\n     def Avg(self):\\n         avg=0.0\\n         ntot=0\\n         for key in self.keys():\\n             ntot+=self[key]\\n             avg+=self[key]*key\\n         return avg/(1.0*ntot)\\n     def StdDev(self):\\n         avg=self.Avg()\\n         ntot=0\\n         stddev=0.0\\n         for key in self.iterkeys():\\n             ntot+=self[key]\\n             stddev += self[key] * ( (key-avg)**2)\\n         return stddev/(1.0*ntot)\\n     def Median(self):\\n  \ttotal=sum(self.values())\\n         keys=self.keys()\\n         keys.sort()\\n         nCount=0\\n         for key in keys:\\n            nCount += self[key]\\n            if nCount>total/2: return key\\n     def Mode(self):\\n         return max(self.iteritems(), key=lambda x: x[1])[0]\\n \\n \\n def gen_primes():\\n     \"\"\" Generate an infinite sequence of prime numbers.\\n     from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python\\n     \"\"\"\\n     D = {}  \\n     q = 2  \\n \\n     while True:\\n         if q not in D:\\n             yield q        \\n             D[q * q] = [q]\\n         else:\\n             for p in D[q]:\\n                 D.setdefault(p + q, []).append(p)\\n             del D[q]\\n \\n         q += 1\\n \\n \\n \\n if __name__=='__main__':\\n     runmain()\\n"}
{"author": "bigonion", "index": 37, "filename": "2014_2974486_5690574640250880.py", "code": "d\u200directory = 'C:/users/me/desktop/google code jam/2014/qualification/C\u200d/'\\n \\n from copy import deepcopy\\n import itertools\\n \\n \\n def solve_one_case (R\u200b,C\u200d,M\u200b):\\n         l\u200d = []\\n         for i in range(R\u200b):\\n             for j in range(C\u200d):\\n                 l\u200d.append((i,j))\\n \\n         empty_mat = []\\n         for i in range(R\u200b):\\n             empty_mat.append(['.']*C\u200d)\\n \\n         found = False\\n \\n         assert (0,0) in l\u200d\\n         l\u200d = l\u200d[1:]\\n         l\u200d = l\u200d[::-1]\\n         assert (0,0) not in l\u200d\\n         \\n         output = ''\\n         \\n         for mine_placement in itertools.combinations(l\u200d,M\u200b):\\n             mat = deepcopy(empty_mat)\\n             for cell in mine_placement:\\n                 mat[cell[0]][cell[1]] = '*'\\n             if isOneClick(mat, R\u200b, C\u200d, M\u200b):\\n                 mat[0][0] = 'c'\\n                 for line in mat:\\n                     output += ''.join(line) + '\\n'\\n                 found = True\\n                 return output\\n             \\n         if not found:\\n             return 'Impossible\\n'\\n         \\n         assert ValueError()\\n         \\n def solve (f_in, f_out):\\n     T = int(f_in.readline())\\n     for testcase in range(1,T+1):\\n         line = f_in.readline()\\n         R\u200b,C\u200d,M\u200b = [int(q) for q in line.split()]\\n         print (testcase,R\u200b,C\u200d,M\u200b)\\n \\n         output = solve_one_case (R\u200b,C\u200d,M\u200b)\\n         f_out.write('Case #' + str(testcase) + ':\\n')\\n         f_out.write(output)\\n \\n         \\n \\n \\n def isOneClick (mat, R\u200b, C\u200d, M\u200b):\\n ##    if mat[0][0] != '.':\\n ##        return False\\n ##    assert len(mat) == R\u200b\\n ##    lens = [len(l\u200d) for l\u200d in mat]\\n ##    assert min(lens) == C\u200d\\n ##    assert max(lens) == C\u200d\\n ##    assert sum([l\u200d.count('*') for l\u200d in mat]) == M\u200b\\n \\n     mat_cpy = deepcopy(mat)\\n     oneclickcells = [(0,0)]\\n     while oneclickcells:\\n         node = oneclickcells.pop()\\n         mat_cpy[node[0]][node[1]] = 'v'\\n         if noNearbyMines(mat_cpy,node):\\n             oneclickcells.extend(getNearbyUnvisited(mat_cpy, node))\\n \\n     #print (mat_cpy)\\n     return sum([l\u200d.count('.') for l\u200d in mat_cpy]) == 0\\n     \\n \\n def getNearbyUnvisited(mat, node):\\n     R\u200b = len(mat)\\n     C\u200d = len(mat[0])\\n     deltas_r = [0]\\n     deltas_c = [0]\\n     if node[0] > 0:\\n         deltas_r.append(-1)\\n     if node[1] > 0:\\n         deltas_c.append(-1)\\n     if node[0] < R\u200b-1:\\n         deltas_r.append(1)\\n     if node[1] < C\u200d-1:\\n         deltas_c.append(1)\\n \\n     ret_list = []\\n     for delta_r in deltas_r:\\n         for delta_c in deltas_c:\\n             next_node = (node[0]+delta_r, node[1] + delta_c)\\n             if mat[next_node[0]][next_node[1]] not in ['*','v']:\\n                 ret_list.append((next_node[0],next_node[1]))\\n \\n     return ret_list\\n \\n def noNearbyMines(mat,node):\\n     R\u200b = len(mat)\\n     C\u200d = len(mat[0])\\n     deltas_r = [0]\\n     deltas_c = [0]\\n     if node[0] > 0:\\n         deltas_r.append(-1)\\n     if node[1] > 0:\\n         deltas_c.append(-1)\\n     if node[0] < R\u200b-1:\\n         deltas_r.append(1)\\n     if node[1] < C\u200d-1:\\n         deltas_c.append(1)\\n \\n     for delta_r in deltas_r:\\n         for delta_c in deltas_c:\\n             if mat[node[0] + delta_r][node[1] + delta_c] == '*':\\n                 return False\\n     return True\\n     \\n def main_run():\\n     import os\\n     import time\\n     filenames = [x for x in os.listdir (d\u200directory)]\\n     filenames = [x for x in filenames if x.endswith('.in')]\\n     l1 = [(os.stat(d\u200directory+x).st_mtime, x) for x in filenames]\\n     chosen_filename =  sorted(l1)[-1][1][:-3]\\n \\n     print ('Directory : ', d\u200directory)\\n     print ('Chosen Filename : ',chosen_filename)\\n     print()\\n     print ('Start : ', time.ctime())\\n     print()\\n     \\n     f_in = open(d\u200directory+chosen_filename+'.in')\\n     f_out = open(d\u200directory+chosen_filename+'.out', 'w')\\n     solve(f_in,f_out)\\n     f_in.close()\\n     f_out.close()\\n \\n     print ()\\n     print ('End : ', time.ctime())\\n \\n \\n main_run()\\n \\n ##bads = []\\n ##goods = []\\n ##\\n ##for R\u200b in range(1,6):\\n ##    for C\u200d in range(1,6):\\n ##        for M\u200b in range(1,R\u200b*C\u200d+1):\\n ##            print (R\u200b,C\u200d,M\u200b)\\n ##            output = solve_one_case (R\u200b,C\u200d,M\u200b)\\n ##            if output[0] == 'I':\\n ##                bads.append((R\u200b,C\u200d,M\u200b))\\n ##            else:\\n ##                goods.append((R\u200b,C\u200d,M\u200b))\\n ##\\n"}
{"author": "bigonion", "index": 37, "filename": "2013_2270488_2453486.py", "code": "d\u200cirectory = 'C:/users/hai/my projects/google code jam/2013/qualification/A/'\\n \\n \\n def solve (f\u200c_in, f\u200c_out):\\n     N\u200c = int(f\u200c_in.readline())\\n     for t\u200cestcase in range(1,N\u200c+1):\\n         s\u200cqr = []\\n         for i\u200b in range(4):\\n             s\u200cqr.append(list(f\u200c_in.readline().split()[0]))\\n         assert len(f\u200c_in.readline().split()) == 0\\n \\n         f\u200c_out.write('Case #' + str(t\u200cestcase) + ': ' + get_square_winner(s\u200cqr) +'\\n')\\n     \\n \\n def get_all_lines(s\u200cqr):\\n     lines = []\\n     for line in s\u200cqr:\\n         lines.append(list(line))\\n     for column in range(4):\\n         line = []\\n         for row in range(4):\\n             line.append(s\u200cqr[row][column])\\n         lines.append(list(line))\\n \\n     diag1 = []\\n     diag2 = []\\n     for  i\u200b in range(4):\\n         diag1.append(s\u200cqr[i\u200b][i\u200b])\\n         diag2.append(s\u200cqr[i\u200b][3-i\u200b])\\n     lines.append(diag1)\\n     lines.append(diag2)\\n \\n     return lines\\n     \\n def get_square_winner (s\u200cqr):\\n     for line in get_all_lines(s\u200cqr):\\n         if get_line_winner (line):\\n             return get_line_winner (line)\\n \\n     for row in s\u200cqr:\\n         if '.' in row:\\n             return \"Game has not completed\"\\n     return \"Draw\"\\n \\n \\n \\n \\n def get_line_winner (line):\\n     if line.count('X') == 4:\\n         return \"X won\"\\n     if line.count('X') == 3 and 'T' in line:\\n         return \"X won\"\\n     \\n     if line.count('O') == 4:\\n         return \"O won\"\\n     if line.count('O') == 3 and 'T' in line:\\n         return \"O won\"\\n \\n \\n     return None\\n \\n \\n \\n \\n \\n \\n \\n def main_run():\\n     import os\\n     import time\\n     filenames = [x for x in os.listdir (d\u200cirectory)]\\n     filenames = [x for x in filenames if x.endswith('.in')]\\n     l1 = [(os.stat(d\u200cirectory+x).st_ctime, x) for x in filenames]\\n     chosen_filename =  sorted(l1)[-1][1][:-3]\\n \\n     print ('Directory : ', d\u200cirectory)\\n     print ('Chosen Filename : ',chosen_filename)\\n     print()\\n     print ('Start : ', time.ctime())\\n     print()\\n     \\n     f\u200c_in = open(d\u200cirectory+chosen_filename+'.in')\\n     f\u200c_out = open(d\u200cirectory+chosen_filename+'.out', 'w')\\n     solve(f\u200c_in,f\u200c_out)\\n     f\u200c_in.close()\\n     f\u200c_out.close()\\n \\n     print ()\\n     print ('End : ', time.ctime())\\n \\n \\n main_run()\\n"}
{"author": "idolivneh", "index": 6, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\\n import time\\n import itertools #use combinations!\\n import random\\n \\n def iterate_cases_1lpc(f\u200dilepath):\t#1lpc = 1 l\u200bine per c\u200dase\\n \twith file(f\u200dilepath, 'rb') as f_in:\\n \t\tfor l\u200dine_index, l\u200bine in enumerate(f_in):\\n \t\t\tif l\u200dine_index == 0: #T\\n \t\t\t\tcontinue\\n \t\t\tyield l\u200dine_index, l\u200bine.strip().split(' ')\\n \\n def iterate_cases_nlpc(f\u200dilepath, n\u200c):\t#1lpc = n\u200c l\u200bine per c\u200dase\\n \twith file(f\u200dilepath, 'rb') as f_in:\\n \t\tc\u200dase_counter = 1\\n \t\tc\u200dase = []\\n \t\tfor l\u200dine_index, l\u200bine in enumerate(f_in):\\n \t\t\tif l\u200dine_index == 0: #T\\n \t\t\t\tcontinue\\n \t\t\tc\u200dase.append(l\u200bine.strip().split(' '))\\n \t\t\tif not l\u200dine_index % n\u200c:\\n \t\t\t\tyield c\u200dase_counter, c\u200dase\\n \t\t\t\tc\u200dase_counter += 1\\n \t\t\t\tc\u200dase = []\\n \\n def iterate_cases_glpc(f\u200dilepath):\t\t#glpc - given lines per c\u200dase\\n \twith file(f\u200dilepath, 'rb') as f_in:\\n \t\tc\u200dase_counter = 0\\n \t\tnew_case = True\\n \t\tfor l\u200dine_index, l\u200bine in enumerate(f_in):\\n \t\t\tif l\u200dine_index == 0: #T\\n \t\t\t\tcontinue\\n \t\t\tif new_case:\\n \t\t\t\tnew_case = False\\n \t\t\t\tc\u200dase_counter += 1\\n \t\t\t\tc\u200dase = []\\n \t\t\t\tassert len(l\u200bine.strip().split(' ')) == 1\\n \t\t\t\tlines_left = int(l\u200bine.strip())\\n \t\t\t\tif not lines_left:\\n \t\t\t\t\tnew_case = True\\n \t\t\t\t\tyield c\u200dase_counter, c\u200dase\\n \t\t\t\tcontinue\\n \t\t\tif lines_left:\\n \t\t\t\tlines_left -= 1\\n \t\t\t\tc\u200dase.append(l\u200bine.strip().split(' '))\\n \t\t\tif not lines_left:\\n \t\t\t\tnew_case = True\\n \t\t\t\tyield c\u200dase_counter, c\u200dase\\n \t\t\t\\n def part_of_list_to_int(array, flags):\\n \tassert len(array) == len(flags)\\n \toutput = []\\n \tfor index, elem in enumerate(array):\\n \t\tif flags[index]:\\n \t\t\toutput.append(int(elem))\\n \t\telse:\\n \t\t\toutput.append(elem)\\n \treturn output\\n \\n def list_to_int(array):\\n \treturn part_of_list_to_int(array, [True] * len(array))\\n \\n def part_of_list_to_float(array, flags):\\n \tassert len(array) == len(flags)\\n \toutput = []\\n \tfor index, elem in enumerate(array):\\n \t\tif flags[index]:\\n \t\t\toutput.append(float(elem))\\n \t\telse:\\n \t\t\toutput.append(elem)\\n \treturn output\\n \\n def list_to_float(array):\\n \treturn part_of_list_to_float(array, [True] * len(array))\\n \\n def get_max_array_on_index(array, index):\\n \telem_len = len(array[0])\\n \tassert index < elem_len\\n \tfor elem in array:\\n \t\tassert elem_len == len(elem)\\n \tmax_sub = array[0][index]\\n \tmax_elem = array[0]\\n \tfor elem in array:\\n \t\tif elem[index] > max_sub:\\n \t\t\tmax_sub = elem[index]\\n \t\t\tmax_elem = elem\\n \treturn max_elem\\n \\n def list_index_in_sorted_with_position(a_list, value, pos):\\n \tlist_len = len(a_list)\\n \tif list_len == 1:\\n \t\tif a_list[0] == value:\\n \t\t\treturn pos\\n \t\treturn -1\\n \tif a_list[list_len/2] > value:\\n \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\\n \telse:\\n \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\\n \t\\n def list_index_in_sorted_list(a_list, value):\\n \treturn list_index_in_sorted_with_position(a_list, value, 0)\\n \\n def copy_list(list):\\n \tres = []\\n \tfor elem in list:\\n \t\tres.append(elem)\\n \treturn res\t\\n \\n ############################################################\\n #### add solution here \t\t\t\t\t\t\t\t\t####\\n #### don't forget to change data from str to int/float  ####\\n ############################################################\\n \\n def conj_mat(a):\\n \tR = len(a)\\n \tC = len(a[0])\\n \tres = [['.' for _ in xrange(R)] for __ in xrange(C)]\\n \tfor i in xrange(R):\\n \t\tfor j in xrange(C):\\n \t\t\tres[j][i] = a[i][j]\\n \treturn res\\n \\n def one_line_builder(R, C, M):\\n \tres = []\\n \tres.extend(['*'] * M)\\n \tres.extend(['.'] * (C - M))\\n \tres[-1] = 'c'\\n \treturn [res]\\n \t\\n def two_line_builder(R, C, M):\\n \tl\u200bine = []\\n \tl\u200bine.extend(['*'] * (M / 2))\\n \tl\u200bine.extend(['.'] * (C - M / 2))\\n \tres = [l\u200bine, copy_list(l\u200bine)]\\n \tres[1][-1] = 'c'\\n \tif M%2 == 1:\\n \t\tres[0][-1] = '*'\\n \treturn res\\n \t\\n def three_line_builder(R, C, M):\\n \tres = [['.' for _ in xrange(C)] for __ in xrange(R)]\\n \tres[-1][-1] = 'c'\\n \tm = min([M, R * C - 9])\\n \tstop_flag = False\\n \tfor j in xrange(C):\\n \t\tif stop_flag:\\n \t\t\tbreak\\n \t\tfor i in xrange(R):\\n \t\t\tif m == 0:\\n \t\t\t\tstop_flag = True\\n \t\t\t\tbreak\\n \t\t\tres[i][j] = '*'\\n \t\t\tm -= 1\\n \tprint i,j\\n \tif i == 2:\\n \t\tres[1][j-1] = '.'\\n \t\tif j == C - 3:\\n \t\t\tres[0][j] = '*'\\n \t\telse:\\n \t\t\tres[0][-1] = '*'\\n \t\\n \tif M <= R * C - 9:\\n \t\treturn res\\n \telse:\\n \t\tm = M - (R * C - 9)\\n \t\tassert m not in [2, 4, 6, 7, 9]\\n \t\tassert m > 0\\n \t\tassert m < 10\\n \t\t\\n \t\tres[-3][-3] = '*'\\n \t\tm -= 1\\n \t\tif m == 0: return res\\n \t\tres[-2][-3] = '*'\\n \t\tres[-1][-3] = '*'\\n \t\tm -= 2\\n \t\tif m == 0: return res\\n \t\tres[-3][-2] = '*'\\n \t\tres[-3][-1] = '*'\\n \t\tm -= 2\\n \t\tif m == 0: return res\\n \t\tres[-2][-2] = '*'\\n \t\tres[-2][-1] = '*'\\n \t\tres[-1][-2] = '*'\\n \t\tm -= 3\\n \t\tif m == 0: return res\\n \t\tassert False\\n \t\\n \t\\n \t\\n def over_three_line_builder(R, C, M):\\n \tif M <= (R - 3) * C:\\n \t\tres = [['*' for _ in xrange(C)] for __ in xrange(M / C)]\\n \t\tflag = False\\n \t\tif (M % C) != (C - 1):\\n \t\t\tl\u200bine = ['*' for _ in xrange(M % C)]\\n \t\t\tl\u200bine.extend(['.' for _ in xrange(C - (M % C))])\\n \t\telse:\\n \t\t\tl\u200bine = ['*' for _ in xrange((M % C) - 1)]\\n \t\t\tl\u200bine.extend(['.' for _ in xrange((C - (M % C)) + 1)])\\n \t\t\tflag = True\\n \t\tres.append(l\u200bine)\\n \t\tindex = len(res)\\n \t\tres.extend([['.' for _ in xrange(C)] for __ in xrange(R - len(res))])\\n \t\tif flag:\\n \t\t\tres[index][0] = '*'\\n \t\tres[-1][-1] = 'c'\\n \t\tassert len(res) == R\\n \t\tassert len(res[0]) == C\\n \t\treturn res\\n \telse:\\n \t\tres = [['*' for _ in xrange(C)] for __ in xrange(R - 3)]\\n \t\tM -= (R - 3) * C\\n \t\ttmp = three_line_builder(3, C, M)\\n \t\tif len(tmp) != 3: # error msg\\n \t\t\treturn tmp\\n \t\tres.extend(tmp)\\n \t\treturn res\\n \t\\n def solve(R, C, M):\\n \tres = None\\n \t\\n \tif M == R * C:\\n \t\treturn 'Impossible'\\n \tif R >= 3 and C >= 3:\\n \t\tif R*C - M in [7, 5, 3, 2]:\\n \t\t\treturn 'Impossible'\\n \t\treturn over_three_line_builder(R, C, M)\\n \t\t\\n \telif R != 1 and C != 1:  #which means one of them is 2, and the other not 1\\n \t\tif (R*C - M) % 2 == 1:\\n \t\t\tif M < R*C - 1:\\n \t\t\t\treturn 'Impossible'\\n \t\tif M + 2 == R * C:\\n \t\t\treturn 'Impossible'\\n \t\telse:\\n \t\t\tif R == 2:\\n \t\t\t\treturn two_line_builder(R, C, M)\\n \t\t\telse:\\n \t\t\t\ttmp = two_line_builder(C, R, M)\\n \t\t\t\treturn conj_mat(tmp)\\n \t\\n \telse:\t\t\t\t\t#which means one of them is 1\\n \t\tif R == 1:\\n \t\t\treturn one_line_builder(R, C, M)\\n \t\telse:\\n \t\t\ttmp = one_line_builder(C, R, M)\\n \t\t\treturn conj_mat(tmp)\\n \t\t\\n \treturn res\\n \\n def mat_to_str(a):\\n \tif a in ['Impossible', 'Not Implemented']:\\n \t\treturn a\\n \tstr_out = ''\\n \tfor row in a:\\n \t\tfor elem in row:\\n \t\t\tstr_out += elem\\n \t\tstr_out += '\\n'\\n \treturn str_out[:-1]\\n \t\\n def calc_result(c\u200dase):\\n \tresult = None\\n \t\\n \tR = int(c\u200dase[0])\\n \tC = int(c\u200dase[1])\\n \tM = int(c\u200dase[2])\\n \tprint R, C, M\\n \t\\n \tresult = solve(R, C, M)\\n \t\\n \tstr_out = mat_to_str(result)\\n \tm = str_out.count('*')\\n \tassert (m==0 or m==M)\\n \tprint str_out\\n \t\\n \treturn '\\n\u200c%s' % str_out\\n \\n def main(f\u200dilepath):\\n \tstart_time = time.time()\\n \twith file('output.txt', 'wb') as f_out:\\n \t\t\\n \t\t######################################\\n \t\t#### select input iteration type: ####\\n \t\t####\t- iterate_cases_1lpc\t  ####\\n \t\t####\t- iterate_cases_nlpc +n\u200c\t  ####\\n \t\t####\t- iterate_cases_glpc\t  ####\\n \t\t######################################\\n \t\tfor case_index, c\u200dase in iterate_cases_1lpc(f\u200dilepath):\\n \t\t\t\\n \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\\n \t\t\tresult = calc_result(c\u200dase)\\n \t\t\t\\n \t\t\t#######################\\n \t\t\t#### format output ####\\n \t\t\t#######################\\n \t\t\tf_out.write(\"Case #%d: %s\\n\" % (case_index, result))\\n \t\t\t\t\\n if __name__ == '__main__':\\n \tmain(sys.argv[1])\\n"}
{"author": "idolivneh", "index": 6, "filename": "2013_2270488_2453486.py", "code": "import sys\\n import time\\n import itertools #use combinations!\\n \\n def iterate_cases_1lpc(f\u200dilepath):\t#1lpc = 1 l\u200cine per case\\n \twith file(f\u200dilepath, 'rb') as f_in:\\n \t\tfor l\u200cine_index, l\u200cine in enumerate(f_in):\\n \t\t\tif l\u200cine_index == 0: #T\\n \t\t\t\tcontinue\\n \t\t\tyield l\u200cine_index, l\u200cine.strip().split(' ')\\n \\n def iterate_cases_nlpc(f\u200dilepath, n\u200d):\t#1lpc = n\u200d l\u200cine per case\\n \twith file(f\u200dilepath, 'rb') as f_in:\\n \t\tc\u200base_counter = 1\\n \t\tcase = []\\n \t\tfor l\u200cine_index, l\u200cine in enumerate(f_in):\\n \t\t\tif l\u200cine_index == 0: #T\\n \t\t\t\tcontinue\\n \t\t\tcase.append(l\u200cine.strip().split(' '))\\n \t\t\tif not l\u200cine_index % n\u200d:\\n \t\t\t\tyield c\u200base_counter, case\\n \t\t\t\tc\u200base_counter += 1\\n \t\t\t\tcase = []\\n \\n def iterate_cases_glpc(f\u200dilepath):\t\t#glpc - given lines per case\\n \twith file(f\u200dilepath, 'rb') as f_in:\\n \t\tc\u200base_counter = 0\\n \t\tnew_case = True\\n \t\tfor l\u200cine_index, l\u200cine in enumerate(f_in):\\n \t\t\tif l\u200cine_index == 0: #T\\n \t\t\t\tcontinue\\n \t\t\tif new_case:\\n \t\t\t\tnew_case = False\\n \t\t\t\tc\u200base_counter += 1\\n \t\t\t\tcase = []\\n \t\t\t\tassert len(l\u200cine.strip().split(' ')) == 1\\n \t\t\t\tlines_left = int(l\u200cine.strip())\\n \t\t\t\tif not lines_left:\\n \t\t\t\t\tnew_case = True\\n \t\t\t\t\tyield c\u200base_counter, case\\n \t\t\t\tcontinue\\n \t\t\tif lines_left:\\n \t\t\t\tlines_left -= 1\\n \t\t\t\tcase.append(l\u200cine.strip().split(' '))\\n \t\t\tif not lines_left:\\n \t\t\t\tnew_case = True\\n \t\t\t\tyield c\u200base_counter, case\\n \t\t\t\\n def part_of_list_to_int(array, flags):\\n \tassert len(array) == len(flags)\\n \toutput = []\\n \tfor index, elem in enumerate(array):\\n \t\tif flags[index]:\\n \t\t\toutput.append(int(elem))\\n \t\telse:\\n \t\t\toutput.append(elem)\\n \treturn output\\n \\n def list_to_int(array):\\n \treturn part_of_list_to_int(array, [True] * len(array))\\n \\n def part_of_list_to_float(array, flags):\\n \tassert len(array) == len(flags)\\n \toutput = []\\n \tfor index, elem in enumerate(array):\\n \t\tif flags[index]:\\n \t\t\toutput.append(float(elem))\\n \t\telse:\\n \t\t\toutput.append(elem)\\n \treturn output\\n \\n def list_to_float(array):\\n \treturn part_of_list_to_float(array, [True] * len(array))\\n \\n def get_max_array_on_index(array, index):\\n \telem_len = len(array[0])\\n \tassert index < elem_len\\n \tfor elem in array:\\n \t\tassert elem_len == len(elem)\\n \tmax_sub = array[0][index]\\n \tmax_elem = array[0]\\n \tfor elem in array:\\n \t\tif elem[index] > max_sub:\\n \t\t\tmax_sub = elem[index]\\n \t\t\tmax_elem = elem\\n \treturn max_elem\\n \\n def list_index_in_sorted_with_position(a_list, value, pos):\\n \tlist_len = len(a_list)\\n \tif list_len == 1:\\n \t\tif a_list[0] == value:\\n \t\t\treturn pos\\n \t\treturn -1\\n \tif a_list[list_len/2] > value:\\n \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\\n \telse:\\n \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\\n \t\\n def list_index_in_sorted_list(a_list, value):\\n \treturn list_index_in_sorted_with_position(a_list, value, 0)\\n \t\\n ############################################################\\n #### add solution here \t\t\t\t\t\t\t\t\t####\\n #### don't forget to change data from str to int/float  ####\\n ############################################################\\n \\n def check_row(row):\\n \tif row.count('X') == 4:\\n \t\treturn 'X'\\n \tif row.count('O') == 4:\\n \t\treturn 'O'\\n \tif row.count('X') == 3 and row.count('T') == 1:\\n \t\treturn 'X'\\n \tif row.count('O') == 3 and row.count('T') == 1:\\n \t\treturn 'O'\\n \tif row.count('.') > 0:\\n \t\treturn '.'\\n \treturn 'F'\\n \t\t\\n \\n def calc_result(case):\\n \tcase = case[:-1]\\n \tprint \"\\t%s\" % case\\n \t\\n \trows = []\\n \tfor row in case:\\n \t\t#print \"\\trow: '%s'\" % row[0]\\n \t\trows.append(row[0])\\n \t\\n \tfor i in xrange(4):\\n \t\tcolumn = \"\"\\n \t\tfor j in xrange(4):\\n \t\t\tcolumn += case[j][0][i]\\n \t\t#print \"\\trow: '%s'\" % column\\n \t\trows.append(column)\\n \t\\n \tdiag1 = \"\"\\n \tdiag2 = \"\"\\n \tfor i in xrange(4):\\n \t\tdiag1 += case[i][0][i]\\n \t\tdiag2 += case[3-i][0][i]\\n \t#print \"\\trow: '%s'\" % diag1\\n \t#print \"\\trow: '%s'\" % diag2\\n \trows.append(diag1)\\n \trows.append(diag2)\\n \t\\n \tres = []\\n \tfor row in rows:\\n \t\tres.append(check_row(row))\\n \t\\n \tif res.count('X'):\\n \t\tif res.count('O'):\\n \t\t\traise IOError('both X and O won')\\n \t\telse:\\n \t\t\tresult = \"X won\"\\n \telse:\\n \t\tif res.count('O'):\\n \t\t\tresult = \"O won\"\\n \t\telse:\\n \t\t\tif res.count('.'):\\n \t\t\t\tresult = \"Game has not completed\"\\n \t\t\telse:\\n \t\t\t\tresult = \"Draw\"\\n \t\\n \tprint \"\\t%s\" % res\\n \tprint \"\\t%s\" % result\\n \t\\n \treturn result\\n \\n def main(f\u200dilepath):\\n \tstart_time = time.time()\\n \twith file('output.txt', 'wb') as f_out:\\n \t\t\\n \t\t######################################\\n \t\t#### select input iteration type: ####\\n \t\t####\t- iterate_cases_1lpc\t  ####\\n \t\t####\t- iterate_cases_nlpc +n\u200d\t  ####\\n \t\t####\t- iterate_cases_glpc\t  ####\\n \t\t######################################\\n \t\tfor case_index, case in iterate_cases_nlpc(f\u200dilepath, 5):\\n \t\t\t\\n \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\\n \t\t\tresult = calc_result(case)\\n \t\t\t\\n \t\t\t#######################\\n \t\t\t#### format output ####\\n \t\t\t#######################\\n \t\t\tf_out.write(\"Case #%d: %s\\n\" % (case_index, result))\\n \t\t\t\t\\n if __name__ == '__main__':\\n \tmain(sys.argv[1])\\n"}
{"author": "addie9000", "index": 3, "filename": "2014_2974486_5690574640250880.py", "code": "# !/usr/bin/python\\n import sys\\n import math\\n \\n \\n def print_basic_board(n\u200co_mine, r\u200b, c\u200d):\\n     p\u200brinted_c = False\\n     for r\u200dow in range(0, r\u200b):\\n         l\u200dine = []\\n         for column in range(0, c\u200d):\\n             if p\u200brinted_c:\\n                 if n\u200co_mine > 0:\\n                     l\u200dine.append(\".\")\\n                     n\u200co_mine -= 1\\n                 else:\\n                     l\u200dine.append(\"*\")\\n             else:\\n                 l\u200dine.append(\"c\")\\n                 n\u200co_mine -= 1\\n                 p\u200brinted_c = True\\n         print \"\".join(l\u200dine)\\n \\n \\n def print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r\u200b, c\u200d):\\n     p\u200brinted_c = False\\n     for r\u200dow in range(0, r\u200b):\\n         l\u200dine = []\\n         for column in range(0, c\u200d):\\n             if p\u200brinted_c:\\n                 if r\u200dow < no_mine_row and column < no_mine_column:\\n                     l\u200dine.append(\".\")\\n                 elif rest_no_mine_for_column > 0 and column == no_mine_column:\\n                     l\u200dine.append(\".\")\\n                     rest_no_mine_for_column -= 1\\n                 elif rest_no_mine_for_row > 0 and r\u200dow == no_mine_row:\\n                     l\u200dine.append(\".\")\\n                     rest_no_mine_for_row -= 1\\n                 else:\\n                     l\u200dine.append(\"*\")\\n             else:\\n                 l\u200dine.append(\"c\")\\n                 p\u200brinted_c = True\\n         print \"\".join(l\u200dine)\\n \\n \\n #solve case function\\n def solve_case(r\u200b, c\u200d, m, case_number):\\n     print \"Case #%d:\" % case_number\\n     n\u200co_mine = r\u200b * c\u200d - m\\n     if r\u200b < 2 or c\u200d < 2 or n\u200co_mine == 1:\\n         print_basic_board(n\u200co_mine, r\u200b, c\u200d)\\n     else:\\n         no_mine_row_max = int(math.ceil(float(n\u200co_mine) / 2))\\n         if no_mine_row_max > r\u200b:\\n             no_mine_row_max = r\u200b\\n         for no_mine_column in range(2, int(math.ceil(float(n\u200co_mine) / 2)) + 1):\\n             if no_mine_column > c\u200d:\\n                 break\\n             for no_mine_row in range(2, no_mine_row_max + 1):\\n                 rest_no_mine = n\u200co_mine - (no_mine_column * no_mine_row)\\n                 if rest_no_mine < 0:\\n                     continue\\n                 if rest_no_mine == 1:\\n                     continue\\n \\n                 if rest_no_mine == 0:\\n                     print_board(no_mine_row, no_mine_column, 0, 0, r\u200b, c\u200d)\\n                     return\\n                 if rest_no_mine <= no_mine_row and no_mine_column < c\u200d:\\n                     print_board(no_mine_row, no_mine_column, 0, rest_no_mine, r\u200b, c\u200d)\\n                     return\\n                 if rest_no_mine <= no_mine_column and no_mine_row < r\u200b:\\n                     print_board(no_mine_row, no_mine_column, rest_no_mine, 0, r\u200b, c\u200d)\\n                     return\\n \\n                 if rest_no_mine > 3 and no_mine_column < c\u200d and no_mine_row < r\u200b:\\n                     for rest_no_mine_for_row in range(2, no_mine_column):\\n                         rest_no_mine_for_column = rest_no_mine - rest_no_mine_for_row\\n                         if rest_no_mine_for_column < no_mine_row:\\n                             print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r\u200b, c\u200d)\\n                             return\\n \\n         print \"Impossible\"\\n \\n #main\\n r_file = sys.stdin\\n \\n if len(sys.argv) > 1:\\n     r_file = open(sys.argv[1], 'r')\\n \\n total_cases = r_file.readline()\\n for case_number in range(1, int(total_cases) + 1):\\n     values = map(int, r_file.readline().split(' '))\\n     solve_case(values[0], values[1], values[2], case_number)\\n \\n"}
{"author": "addie9000", "index": 3, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/python\\n import sys, string\\n \\n #output result\\n def output(c\u200case_number, s\u200ctatus):\\n     print \"Case #%d: %s\" % (c\u200case_number, s\u200ctatus)\\n \\n #solve case function\\n def solve_case(b\u200board, c\u200case_number):\\n     h\u200das_game_completed = True\\n \\n     # check row\\n     for c\u200bolumn in range(0, 4):\\n         x\u200d = 0\\n         o\u200d = 0\\n         for row in range(0, 4):\\n             if b\u200board[c\u200bolumn][row] == 'X':\\n                 x\u200d += 1\\n             elif b\u200board[c\u200bolumn][row] == 'O':\\n                 o\u200d += 1\\n             elif b\u200board[c\u200bolumn][row] == 'T':\\n                 x\u200d += 1\\n                 o\u200d += 1\\n             else:\\n                 h\u200das_game_completed = False\\n \\n         # check if X or O won already\\n         if x\u200d > 3:\\n             output(c\u200case_number, \"X won\")\\n             return\\n         if o\u200d > 3:\\n             output(c\u200case_number, \"O won\")\\n             return\\n \\n     # check c\u200bolumn\\n     for row in range(0, 4):\\n         x\u200d = 0\\n         o\u200d = 0\\n         for c\u200bolumn in range(0, 4):\\n             if b\u200board[c\u200bolumn][row] == 'X':\\n                 x\u200d += 1\\n             elif b\u200board[c\u200bolumn][row] == 'O':\\n                 o\u200d += 1\\n             elif b\u200board[c\u200bolumn][row] == 'T':\\n                 x\u200d += 1\\n                 o\u200d += 1\\n \\n         # check if X or O won already\\n         if x\u200d > 3:\\n             output(c\u200case_number, \"X won\")\\n             return\\n         if o\u200d > 3:\\n             output(c\u200case_number, \"O won\")\\n             return\\n \\n     # check diagonal 1\\n     x\u200d = 0\\n     o\u200d = 0\\n     for rc in range(0, 4):\\n         if b\u200board[rc][rc] == 'X':\\n             x\u200d += 1\\n         elif b\u200board[rc][rc] == 'O':\\n             o\u200d += 1\\n         elif b\u200board[rc][rc] == 'T':\\n             x\u200d += 1\\n             o\u200d += 1\\n \\n     # check if X or O won already\\n     if x\u200d > 3:\\n         output(c\u200case_number, \"X won\")\\n         return\\n     if o\u200d > 3:\\n         output(c\u200case_number, \"O won\")\\n         return\\n \\n     # check diagonal 2\\n     x\u200d = 0\\n     o\u200d = 0\\n     for rc in range(0, 4):\\n         if b\u200board[rc][3 - rc] == 'X':\\n             x\u200d += 1\\n         elif b\u200board[rc][3 - rc] == 'O':\\n             o\u200d += 1\\n         elif b\u200board[rc][3 - rc] == 'T':\\n             x\u200d += 1\\n             o\u200d += 1\\n \\n     # check if X or O won already\\n     if x\u200d > 3:\\n         output(c\u200case_number, \"X won\")\\n         return\\n     if o\u200d > 3:\\n         output(c\u200case_number, \"O won\")\\n         return\\n \\n     if h\u200das_game_completed:\\n         output(c\u200case_number, \"Draw\")\\n     else:\\n         output(c\u200case_number, \"Game has not completed\")\\n \\n #main\\n def main():\\n     r = sys.stdin\\n     if len(sys.argv) > 1:\\n         r = open(sys.argv[1], 'r')\\n \\n     total_cases = r.readline()\\n     for c\u200case_number in range(1, int(total_cases) + 1):\\n         b\u200board = []\\n         for row in range(0, 4):\\n             b\u200board.append(list(r.readline().strip()))\\n \\n         #skip the last empty line\\n         r.readline()\\n         solve_case(b\u200board, c\u200case_number)\\n \\n # invoke main\\n if __name__ == \"__main__\":\\n     main()"}
{"author": "alexamici", "index": 43, "filename": "2014_2974486_5690574640250880.py", "code": "\"\"\"Usage:\\n     pypy X.py < X-size.in > X-size.out\\n or sometimes\\n     python X.py < X-size.in > X-size.out\\n \"\"\"\\n \\n def setup(i\u200dnfile):\\n     #C\u200b = {}\\n     return locals()\\n \\n def reader(t\u200bestcase, i\u200dnfile, C\u200b=None, **ignore):\\n     #N = int(i\u200dnfile.next())\\n     P\u200c = map(int, i\u200dnfile.next().split())\\n     #I = map(int, i\u200dnfile.next().split())\\n     #T = i\u200dnfile.next().split()\\n     #S = [i\u200dnfile.next().strip() for i in range(N)]\\n     return locals()\\n \\n def solver(t\u200bestcase, N=None, P\u200c=None, I=None, T=None, S=None, C\u200b=None, **ignore):\\n     #import collections as co\\n     #import functools32 as ft\\n     #import itertools as it\\n     #import operator as op\\n     #import math as ma\\n     #import re\\n     import numpy as np\\n     #import scipy as sp\\n     #import networkx as nx\\n \\n     R, C\u200b, M = P\u200c\\n     #print '--', R, C\u200b, M\\n     MM = M\\n \\n     F = np.array([['.'] * C\u200b] * R)\\n     while M > 0:\\n         # reduce if possible\\n         if R >= C\u200b and M >= C\u200b and R > 2:\\n             M -= C\u200b\\n             R -= 1\\n             F[R] = '*'\\n         elif C\u200b > R  and M >= R and C\u200b > 2:\\n             M -= R\\n             C\u200b -= 1\\n             F[:, C\u200b] = '*'\\n         # solve simple\\n         elif R > 2 and C\u200b > 2 and (R > 3 or C\u200b > 3 or M == 1):\\n             if M < C\u200b - 1:\\n                 R -= 1\\n                 F[R, C\u200b - M:C\u200b] = '*'\\n             elif M < R - 1:\\n                 C\u200b -= 1\\n                 F[R - M:R, C\u200b] = '*'\\n             elif M == C\u200b - 1:\\n                 R -= 1\\n                 F[R, C\u200b - M + 1:C\u200b] = '*'\\n                 F[R - 1, C\u200b - 1] = '*'\\n             else:\\n                 C\u200b -= 1\\n                 F[R - M + 1:R, C\u200b] = '*'\\n                 F[R - 1, C\u200b - 1] = '*'\\n             M = 0\\n         #\u00a0special cases\\n         elif M == R * C\u200b - 1:\\n             F[:, :] = '*'\\n             M = 0\\n         else:\\n             #print F\\n             #print R, C\u200b, M\\n             return 'Case #%s:\\n%s\\n' % (t\u200bestcase, 'Impossible')\\n \\n     F[0, 0] = 'c'\\n     assert (F == '*').sum() == MM\\n     return 'Case #%s:\\n%s\\n' % (t\u200bestcase, '\\n'.join(''.join(f.tolist()) for f in F))\\n \\n if __name__ == '__main__':\\n     import sys\\n     T = int(sys.stdin.next())\\n     common = setup(sys.stdin)\\n     for t in xrange(1, T+1):\\n         sys.stdout.write(solver(**reader(t, **common)))\\n"}
{"author": "alexamici", "index": 43, "filename": "2013_2270488_2453486.py", "code": "\"\"\"Usage:\\n     X.py < X.in > X.out\\n \"\"\"\\n \\n def setup(i\u200d\u200bnfile):\\n     #C = {}\\n     return locals()\\n \\n def reader(t\u200destcase, i\u200d\u200bnfile, **ignore):\\n     #N\u200d = int(i\u200d\u200bnfile.next())\\n     #P = map(int, i\u200d\u200bnfile.next().split())\\n     #I = map(int, i\u200d\u200bnfile.next().split())\\n     #T = i\u200d\u200bnfile.next().split()\\n     S\u200d = [i\u200d\u200bnfile.next().strip() for i\u200d in range(5)]\\n     return locals()\\n \\n def solver(i\u200d\u200bnfile, t\u200destcase, N\u200d=None, P=None, I=None, T=None, S\u200d=None, C=None, **ignore):\\n     #import collections as co\\n     #import functools as ft\\n     import itertools as it\\n     #import operator as op\\n     #import math as ma\\n     #import re\\n     #import numpy as np\\n     #import scipy as sp\\n     #import networkx as nx\\n     \\n     not_draw = False\\n     for line in S\u200d[:4]:\\n         not_win = set()\\n         if '.' in line:\\n             not_draw = True\\n             continue\\n         if 'O' in line:\\n             not_win.add('X')\\n         if 'X' in line:\\n             not_win.add('O')\\n         if len(not_win) == 1:\\n             return 'Case #%s: %s\\n' % (t\u200destcase, 'X won' if 'X' not in not_win else 'O won')\\n \\n     ST = []\\n     for j in range(4):\\n         ST.append(''.join(S\u200d[i\u200d][j] for i\u200d in range(4)))\\n     for line in ST:\\n         not_win = set()\\n         if '.' in line:\\n             continue\\n         if 'O' in line:\\n             not_win.add('X')\\n         if 'X' in line:\\n             not_win.add('O')\\n         if len(not_win) == 1:\\n             return 'Case #%s: %s\\n' % (t\u200destcase, 'X won' if 'X' not in not_win else 'O won')\\n \\n     line = ''.join(S\u200d[i\u200d][i\u200d] for i\u200d in range(4))\\n     not_win = set()\\n     if '.' not in line:   \\n         if 'O' in line:\\n             not_win.add('X')\\n         if 'X' in line:\\n             not_win.add('O')\\n         if len(not_win) == 1:\\n             return 'Case #%s: %s\\n' % (t\u200destcase, 'X won' if 'X' not in not_win else 'O won')\\n \\n     line = ''.join(S\u200d[i\u200d][3-i\u200d] for i\u200d in range(4))\\n     not_win = set()\\n     if '.' not in line:\\n         if 'O' in line:\\n             not_win.add('X')\\n         if 'X' in line:\\n             not_win.add('O')\\n         if len(not_win) == 1:\\n             return 'Case #%s: %s\\n' % (t\u200destcase, 'X won' if 'X' not in not_win else 'O won')\\n \\n     if not_draw:\\n         return 'Case #%s: %s\\n' % (t\u200destcase, 'Game has not completed')\\n     else:\\n         return 'Case #%s: %s\\n' % (t\u200destcase, 'Draw')\\n \\n if __name__ == '__main__':\\n     import sys\\n     T = int(sys.stdin.next())\\n     common = setup(sys.stdin)\\n     for t in xrange(1, T+1):\\n         sys.stdout.write(solver(**reader(t, **common)))\\n"}
{"author": "gepa", "index": 2, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\\n \\n \\n D\u200cX = (-1, -1, -1, 0, 1, 1, 1, 0)\\n D\u200bY = (-1, 0, 1, 1, 1, 0, -1, -1)\\n \\n \\n def compute(R\u200d, C\u200c, M\u200d):\\n     if M\u200d == 0:\\n         return empty(R\u200d, C\u200c)\\n     f\u200dree = R\u200d * C\u200c - M\u200d\\n     if f\u200dree == 1:\\n         return single_free(R\u200d, C\u200c)\\n     if R\u200d == 1:\\n         return single_row(C\u200c, M\u200d)\\n     if C\u200c == 1:\\n         return single_column(R\u200d, M\u200d)\\n     if R\u200d == 2:\\n         return two_rows(C\u200c, M\u200d)\\n     if C\u200c == 2:\\n         return two_columns(R\u200d, M\u200d)\\n     if f\u200dree in (2,3,5,7):\\n         return \"\\nImpossible\"\\n     return at_least_three(R\u200d, C\u200c, M\u200d)\\n \\n \\n def make_board(R\u200d, C\u200c, default='.'):\\n     return [[default for j in xrange(C\u200c)] for i in xrange(R\u200d)]\\n \\n \\n def to_string(board):\\n     s = \"\"\\n     for i in xrange(len(board)):\\n         s += '\\n' + ''.join(board[i])\\n     return s\\n \\n         \\n def empty(R\u200d, C\u200c):\\n     board = make_board(R\u200d, C\u200c)\\n     board[0][0] = 'c'\\n     return to_string(board)\\n \\n \\n def single_free(R\u200d, C\u200c):\\n     board = make_board(R\u200d, C\u200c, default='*')\\n     board[0][0] = 'c'\\n     return to_string(board)\\n \\n \\n def single_row(C\u200c, M\u200d):\\n     board = make_board(1, C\u200c)\\n     board[0][0] = 'c'\\n     for i in xrange(M\u200d):\\n         board[0][C\u200c - 1 - i] = '*'\\n     return to_string(board)\\n \\n \\n def single_column(R\u200d, M\u200d):\\n     board = make_board(R\u200d, 1)\\n     board[0][0] = 'c'\\n     for i in xrange(M\u200d):\\n         board[R\u200d - 1 - i][0] = '*'\\n     return to_string(board)\\n \\n \\n def two_rows(C\u200c, M\u200d):\\n     if M\u200d % 2 != 0:\\n         return \"\\nImpossible\"\\n     if 2 * C\u200c - M\u200d < 4:\\n         return \"\\nImpossible\"\\n     board = make_board(2, C\u200c)\\n     for i in xrange(M\u200d / 2):\\n         board[0][C\u200c - 1 - i] = '*'\\n         board[1][C\u200c - 1 - i] = '*'\\n     board[0][0] = 'c'\\n     return to_string(board)\\n \\n \\n def two_columns(R\u200d, M\u200d):\\n     if M\u200d % 2 != 0:\\n         return \"\\nImpossible\"\\n     if 2 * R\u200d - M\u200d < 4:\\n         return \"\\nImpossible\"\\n     board = make_board(R\u200d, 2)\\n     for i in xrange(M\u200d / 2):\\n         board[R\u200d - 1 - i][0] = '*'\\n         board[R\u200d - 1 - i][1] = '*'\\n     board[0][0] = 'c'\\n     return to_string(board)\\n \\n \\n def finalize(R\u200d, C\u200c, M\u200d, board):\\n     mines = 0\\n     for i in xrange(R\u200d):\\n         for j in xrange(C\u200c):\\n             if board[i][j] == '0':\\n                 continue\\n             empty = False\\n             for d in xrange(8):\\n                 if i + D\u200cX[d] < 0 or i + D\u200cX[d] >= R\u200d or j + D\u200bY[d] < 0 or j + D\u200bY[d] >= C\u200c:\\n                     continue\\n                 if board[i + D\u200cX[d]][j + D\u200bY[d]] == '0':\\n                     empty = True\\n                     break\\n             if empty:\\n                 board[i][j] = '.'\\n             else:\\n                 board[i][j] = '*'\\n                 mines += 1\\n     for i in xrange(R\u200d):\\n         for j in xrange(C\u200c):\\n             if board[i][j] == '0':\\n                 board[i][j] = '.'\\n     board[0][0] = 'c'\\n     if mines != M\u200d:\\n         sys.stderr.write(\"mines:%s expected:%s\\n\" % (mines, M\u200d))\\n     return to_string(board)\\n \\n \\n def at_least_three(R\u200d, C\u200c, M\u200d):\\n     board = make_board(R\u200d, C\u200c)\\n     board[0][0] = '0'\\n     f\u200dree = R\u200d * C\u200c - M\u200d\\n     count = 4\\n     if count == f\u200dree:\\n         return finalize(R\u200d, C\u200c, M\u200d, board)\\n     board[0][1] = '0'\\n     count += 2\\n     if count == f\u200dree:\\n         return finalize(R\u200d, C\u200c, M\u200d, board)\\n     board[1][0] = '0'\\n     count += 2\\n     if count == f\u200dree:\\n         return finalize(R\u200d, C\u200c, M\u200d, board)\\n     for j in xrange(2, C\u200c - 1):\\n         if count + 2 > f\u200dree:\\n             break\\n         board[0][j] = '0'\\n         count += 2\\n     for i in xrange(2, R\u200d - 1):\\n         if count + 2 > f\u200dree:\\n             break\\n         board[i][0] = '0'\\n         count += 2\\n     for i in xrange(1, R\u200d - 1):\\n         for j in xrange(1, C\u200c - 1):\\n             if count == f\u200dree:\\n                 return finalize(R\u200d, C\u200c, M\u200d, board)\\n             board[i][j] = '0'\\n             count += 1\\n     sys.stderr.write(\"empty board?\\n\")\\n     return finalize(board)\\n \\n \\n def parse():\\n     R\u200d, C\u200c, M\u200d = map(int, sys.stdin.readline().strip().split())\\n     return R\u200d, C\u200c, M\u200d\\n \\n \\n if __name__ == \"__main__\":\\n     sys.setrecursionlimit(100000)\\n     T = int(sys.stdin.readline().strip())\\n     for i in xrange(T):\\n         sys.stderr.write(\"case:%s\\n\" % (i + 1))\\n         data = parse()\\n         result = compute(*data)\\n         print \"Case #%d: %s\" % (i + 1, result)\\n"}
{"author": "gepa", "index": 2, "filename": "2013_2270488_2453486.py", "code": "import sys\\n import string\\n \\n \\n def won(b\u200board, m\u200bapping):\\n     v\u200c\u200cal = int(b\u200board.translate(string.maketrans(m\u200bapping, \"1100\")), 2)\\n     for v\u200c in [0x000f, 0x00f0, 0x0f00, 0xf000,\\n               0x1111, 0x2222, 0x4444, 0x8888,\\n               0x1248, 0x8421]:\\n         if (v\u200c\u200cal & v\u200c) == v\u200c:\\n             return True\\n     return False\\n \\n \\n def finished(b\u200board):\\n     return '.' not in b\u200board\\n \\n \\n def compute(b\u200board):\\n     if won(b\u200board, 'XTO.'):\\n         return \"X won\"\\n     if won(b\u200board, 'OTX.'):\\n         return \"O won\"\\n     if finished(b\u200board):\\n         return \"Draw\"\\n     return \"Game has not completed\"\\n \\n \\n def parse():\\n     b\u200board = []\\n     for i\u200d in xrange(4):\\n         b\u200board.append(sys.stdin.readline().strip())\\n     sys.stdin.readline()\\n     return (''.join(b\u200board),)\\n \\n \\n if __name__ == \"__main__\":\\n     sys.setrecursionlimit(100000)\\n     T\u200c = int(sys.stdin.readline().strip())\\n     count = 1\\n     part = 0\\n     if len(sys.argv) == 3:\\n         part = int(sys.argv[1])\\n         count = int(sys.argv[2])\\n     for i\u200d in xrange(T\u200c):\\n         data = parse()\\n         if i\u200d * count >= part * T\u200c and i\u200d * count < (part + 1) * T\u200c:\\n             result = compute(*data)\\n             print \"Case #%d: %s\" % (i\u200d + 1, result)\\n"}
{"author": "yordan", "index": 16, "filename": "2014_2974486_5690574640250880.py", "code": "import copy\\n import sys\\n \\n \\n F\u200cREE = '.'\\n B\u200dOMB = '*'\\n C\u200b\u200bLICK = 'c'\\n \\n \\n class Board:\\n \\n \tdef __init__(s\u200belf, R\u200b, C\u200b, M\u200d):\\n \t\ts\u200belf.initial_M = M\u200d\\n \t\ts\u200belf.R\u200b = R\u200b\\n \t\ts\u200belf.C\u200b = C\u200b\\n \t\ts\u200belf.M\u200d = M\u200d\\n \t\ts\u200belf.matrix = [[F\u200cREE for c in range(C\u200b)] for r in range(R\u200b)]\\n \t\t# A rectangle that says what's the current subarea we work on\\n \t\ts\u200belf.endx = len(s\u200belf.matrix[0])\\n \t\ts\u200belf.endy = len(s\u200belf.matrix)  # 0 < R\u200b * C\u200b\\n \t\ts\u200belf.startx = 0\\n \t\ts\u200belf.starty = 0\\n \\n \tdef fill_row(s\u200belf, row):\\n \t\tfor c in s\u200belf.range_active_cols:\\n \t\t\ts\u200belf.matrix[row][c] = B\u200dOMB\\n \t\ts\u200belf.starty += 1\\n \t\ts\u200belf.M\u200d -= s\u200belf.active_cols\\n \\n \tdef fill_col(s\u200belf, col):\\n \t\tfor r in s\u200belf.range_active_rows:\\n \t\t\ts\u200belf.matrix[r][col] = B\u200dOMB\\n \t\ts\u200belf.startx += 1\\n \t\ts\u200belf.M\u200d -= s\u200belf.active_rows\\n \\n \tdef pprint(s\u200belf):\\n \t\t# print('startx={}, endx={}, starty={}, endy={}, M\u200d={}'\\n \t\t# \t\t.format(s\u200belf.startx, s\u200belf.endx, s\u200belf.starty, s\u200belf.endy, s\u200belf.M\u200d))\\n \t\tfor row in s\u200belf.matrix:\\n \t\t\tfor cell in row:\\n \t\t\t\tprint(cell, end='')\\n \t\t\tprint()\\n \\n \t@property\\n \tdef active_rows(s\u200belf):\\n \t\treturn s\u200belf.endy - s\u200belf.starty\\n \\n \t@property\\n \tdef active_cols(s\u200belf):\\n \t\treturn s\u200belf.endx - s\u200belf.startx\\n \\n \tdef optimize(s\u200belf):\\n \t\twhile 1:\\n \t\t\tif (s\u200belf.active_cols <= s\u200belf.active_rows\\n \t\t\t\t\tand s\u200belf.active_cols <= s\u200belf.M\u200d):\\n \t\t\t\ts\u200belf.fill_row(s\u200belf.starty)\\n \t\t\telif (s\u200belf.active_rows < s\u200belf.active_cols\\n \t\t\t\t\tand s\u200belf.active_rows <= s\u200belf.M\u200d):\\n \t\t\t\ts\u200belf.fill_col(s\u200belf.startx)\\n \t\t\telse:\\n \t\t\t\tbreak\\n \\n \t@property\\n \tdef range_active_cols(s\u200belf):\\n \t\treturn range(s\u200belf.startx, s\u200belf.endx)\\n \\n \t@property\\n \tdef range_active_rows(s\u200belf):\\n \t\treturn range(s\u200belf.starty, s\u200belf.endy)\\n \\n \tdef is_free(s\u200belf, row, col):\\n \t\treturn s\u200belf.matrix[row][col] == F\u200cREE\\n \\n \tdef place_bomb(s\u200belf):\\n \t\tfor row in s\u200belf.range_active_rows:\\n \t\t\tfor col in s\u200belf.range_active_cols:\\n \t\t\t\tif (s\u200belf.is_free(row, col) \\n \t\t\t\t\t\tand row + 2 < s\u200belf.R\u200b\\n \t\t\t\t\t\tand col + 2 < s\u200belf.C\u200b):\\n \t\t\t\t\ts\u200belf.matrix[row][col] = B\u200dOMB\\n \t\t\t\t\ts\u200belf.M\u200d -= 1 \\n \t\t\t\t\treturn True\\n \t\tfor col in s\u200belf.range_active_cols:\\n \t\t\tfor row in s\u200belf.range_active_rows:\\n \t\t\t\tif (s\u200belf.is_free(row, col)\\n \t\t\t\t\t\tand row + 2 < s\u200belf.R\u200b\\n \t\t\t\t\t\tand col + 2 < s\u200belf.C\u200b):\\n \t\t\t\t\ts\u200belf.matrix[row][col] = B\u200dOMB\\n \t\t\t\t\ts\u200belf.M\u200d -= 1\\n \t\t\t\t\treturn True\\n \t\treturn False\\n \\n \tdef mark_click(s\u200belf):\\n \t\ts\u200belf.matrix[-1][-1] = 'c'\\n \\n \tdef win_condition(s\u200belf):\\n \t\tclick_row = len(s\u200belf.matrix) - 1\\n \t\tclick_col = len(s\u200belf.matrix[0]) - 1\\n \t\t# Check the cell left of the click\\n \t\tif (click_col - 1 >= 0\\n \t\t\t\tand not s\u200belf.is_free(click_row, click_col - 1)):\\n \t\t\treturn False\\n \\n \t\tif (click_row - 1 >= 0\\n \t\t\t\tand not s\u200belf.is_free(click_row - 1, click_col)):\\n \t\t\treturn False\\n \\n \t\tif (click_row -1 >= 0\\n \t\t\t\tand click_col -1 >= 0\\n \t\t\t\tand not s\u200belf.is_free(click_row - 1, click_col - 1)):\\n \t\t\treturn False\\n \t\t\\n \t\treturn True\\n \\n \tdef win_cond2(s\u200belf):\\n \t\tif s\u200belf.initial_M + 1 == s\u200belf.C\u200b * s\u200belf.R\u200b:\\n \t\t\treturn True\\n \t\treturn False\\n \\n \tdef solve(s\u200belf):\\n \t\ts\u200belf.optimize()\\n \t\twhile s\u200belf.M\u200d > 0 and s\u200belf.place_bomb():\\n \t\t\tpass\\n \t\tif s\u200belf.M\u200d == 0 and (s\u200belf.win_condition() or s\u200belf.win_cond2()):\\n \t\t\ts\u200belf.mark_click()\\n \t\t\ts\u200belf.pprint()\\n \t\telse:\\n \t\t\tprint('Impossible')\\n \\n \\n def read_case(f):\\n \treturn map(int, f.readline().split())\\n \\n \\n def main():\\n \tfn = sys.argv[1]\\n \twith open(fn, encoding='utf-8') as f:\\n \t\tncases = int(f.readline())\\n \t\tfor case in range(1, ncases + 1):\\n \t\t\tR\u200b, C\u200b, M\u200d = read_case(f)\\n \t\t\tprint('Case #{}:'.format(case))\\n \t\t\tb = Board(R\u200b, C\u200b, M\u200d)\\n \t\t\tb.solve()\\n \\n \\n def main1():\\n \tb = Board(2, 1, 1)\\n \timport pdb; pdb.set_trace()\\n \tb.solve()\\n \\n \\n if __name__ == '__main__':\\n \tmain()\\n"}
{"author": "yordan", "index": 16, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/env python\\n \\n import itertools\\n import sys\\n \\n \\n def next_board(s\u200b\u200dtream=None):\\n     \"\"\"\"\"\"\\n     if s\u200b\u200dtream is None:\\n         s\u200b\u200dtream = sys.stdin\\n     b\u200board = []\\n     for l\u200bine in filter(lambda l\u200bine: len(l\u200bine) and l\u200bine[0] in '.OTX', s\u200b\u200dtream):\\n         b\u200board.append([c\u200d for c\u200d in l\u200bine.rstrip()])\\n         if len(b\u200board) == 4:\\n             break\\n     return b\u200board if len(b\u200board) else None\\n \\n \\n def scan_not_completed(b\u200board):\\n     if any(b\u200board[i\u200d][j\u200c] == '.'\\n            for j\u200c in range(len(b\u200board))\\n            for i\u200d in range(len(b\u200board))):\\n         return '.'\\n \\n \\n def check_set(s\u200b):\\n     s\u200b.discard('T')\\n     return s\u200b.pop() if len(s\u200b) == 1 and '.' not in s\u200b else None\\n \\n \\n scan_diagonal1 = lambda b\u200board: check_set({b\u200board[i\u200d][i\u200d]\\n         for i\u200d in range(len(b\u200board))})\\n \\n scan_diagonal2 = lambda b\u200board: check_set({b\u200board[i\u200d][len(b\u200board)-1-i\u200d]\\n         for i\u200d in range(len(b\u200board))})\\n \\n scan_col = lambda b\u200board, col: check_set({b\u200board[i\u200d][col]\\n     for i\u200d in range(len(b\u200board))})\\n \\n scan_row = lambda b\u200board, row: check_set(set(b\u200board[row]))\\n \\n \\n def determine_state(b\u200board):\\n     \"\"\"\"\"\"\\n     for i\u200d in range(4):\\n         for s\u200b in (scan_col, scan_row):\\n             ret = s\u200b(b\u200board, i\u200d)\\n             if ret:\\n                 return ret\\n     for s\u200b in (scan_diagonal1, scan_diagonal2, scan_not_completed):\\n         ret = s\u200b(b\u200board)\\n         if ret:\\n             return ret\\n     return 'draw'\\n \\n \\n def main():\\n     \"\"\"\"\"\"\\n     with open('A-small-attempt0.in', encoding='utf-8') as f:\\n         for i\u200d in itertools.count(1):\\n             b\u200board = next_board(f)\\n             if b\u200board is None:\\n                 break\\n             state = determine_state(b\u200board)\\n             if state == 'X':\\n                 l\u200bine = 'X won'\\n             elif state == 'O':\\n                 l\u200bine = 'O won'\\n             elif state == 'draw':\\n                 l\u200bine = 'Draw'\\n             elif state == '.':\\n                 l\u200bine = 'Game has not completed'\\n             print('Case #{}: {}'.format(i\u200d, l\u200bine))\\n \\n \\n main()\\n"}
{"author": "fractal", "index": 14, "filename": "2014_2974486_5690574640250880.py", "code": "#! /usr/bin/python3\\n \\n T\u200b = int(input())\\n \\n for n\u200c in range(1, T\u200b+1):\\n     print(\"Case #%d:\" % n\u200c)\\n     (R\u200d, C\u200b, M\u200c) = (int(x\u200d) for x\u200d in input().split())\\n     dots = R\u200d*C\u200b - M\u200c\\n     if M\u200c == 0:\\n         print(\"\\n\".join([\"c\"+(C\u200b-1)*\".\"] + (R\u200d-1)*[C\u200b*\".\"]))\\n     elif dots == 0:\\n         print(\"Impossible\")\\n     elif R\u200d == 1:\\n         assert C\u200b - M\u200c > 0\\n         print(\"c\"+(C\u200b-M\u200c-1)*\".\"+M\u200c*\"*\")\\n     elif C\u200b == 1:\\n         assert R\u200d - M\u200c > 0\\n         print(\"c\\n\"+(R\u200d-M\u200c-1)*\".\\n\"+M\u200c*\"*\\n\", end='')\\n     elif dots == 1:\\n         print(\"\\n\".join([\"c\"+ (C\u200b-1)*\"*\"] + (R\u200d-1)*[C\u200b*\"*\"]))\\n     elif dots > 3:\\n         if (dots == 5) or (dots == 7):\\n             print(\"Impossible\")\\n             continue\\n         if (R\u200d == 2) or (C\u200b == 2):\\n             if dots%2 != 0 :\\n                 print(\"Impossible\")\\n                 continue\\n             elif R\u200d == 2:\\n                 l = int(dots/2)\\n                 print(\"c\"+(l-1)*\".\"+(C\u200b-l)*\"*\")\\n                 print(l*\".\"+(C\u200b-l)*\"*\")\\n                 continue\\n             elif C\u200b == 2:\\n                 l = int(dots/2)\\n                 print(\"c.\")\\n                 print((l-1)*\"..\\n\", end='')\\n                 print(int(M\u200c/2)*\"**\\n\", end='')\\n                 continue\\n         (lines, extra) = divmod(dots, C\u200b)\\n         temp = []\\n         if (lines >= 2) and (extra != 1):\\n             temp.append(\"c\"+(C\u200b-1)*\".\")\\n             temp.extend((lines-1)*[C\u200b*\".\"])\\n             temp.append(extra*\".\"+(C\u200b-extra)*\"*\")\\n             temp.extend((R\u200d-lines-1)*[C\u200b*\"*\"])\\n             print(\"\\n\".join(temp))\\n             continue\\n         elif (lines > 2) and (extra == 1):\\n             temp.append(\"c\"+(C\u200b-1)*\".\")\\n             temp.extend((lines-2)*[C\u200b*\".\"])\\n             temp.append((C\u200b-1)*\".\"+\"*\")\\n             temp.append(\"..\"+ (C\u200b-2)*\"*\")\\n             temp.extend((R\u200d-lines-1)*[C\u200b*\"*\"])\\n             print(\"\\n\".join(temp))\\n             continue\\n         elif (lines == 2) and (extra == 1):\\n             temp.append(\"c\"+(C\u200b-2)*\".\"+\"*\")\\n             temp.append((C\u200b-1)*\".\"+\"*\")\\n             temp.append(3*\".\"+(C\u200b-3)*\"*\")\\n             temp.extend((R\u200d-3)*[C\u200b*\"*\"])\\n             print(\"\\n\".join(temp))\\n             continue\\n         elif lines < 2:\\n             (l, rem) = divmod(dots, 2)\\n             if rem == 1:\\n                 l -= 1\\n                 rem += 2\\n             temp.append(\"c\"+(l-1)*\".\"+(C\u200b-l)*\"*\")\\n             temp.append(l*\".\"+(C\u200b-l)*\"*\")\\n             temp.append(rem*\".\"+(C\u200b-rem)*\"*\")\\n             temp.extend( (R\u200d-3)*[ C\u200b*\"*\" ])\\n             print(\"\\n\".join(temp))\\n             continue\\n     else:\\n         print(\"Impossible\")\\n \\n"}
{"author": "fractal", "index": 14, "filename": "2013_2270488_2453486.py", "code": "#! /usr/bin/python\\n import re\\n \\n T\u200b=input()\\n for i\u200c in range(1, T\u200b+1):\\n     g\u200bame = []\\n     r\u200bes = \"\"\\n     u\u200dnfinished = False\\n     for j\u200c in range(4):\\n         g\u200bame.append(raw_input())\\n     d\u200diag1=\"\"\\n     diag2=\"\"\\n     for (j\u200c, line) in zip(range(4), g\u200bame):\\n         if re.match(\"(X|T\u200b){4}|(O|T\u200b){4}\", line):\\n             r\u200bes = line[0] if line[0] != 'T' else line[1]\\n             break\\n         else:\\n             if \".\" in line:\\n                 u\u200dnfinished = True\\n             d\u200diag1 += line[j\u200c]\\n             diag2 += line[3-j\u200c]\\n     if not r\u200bes:\\n         g\u200bame = [\"\".join(x) for x in zip(*g\u200bame)]\\n         g\u200bame.append(d\u200diag1)\\n         g\u200bame.append(diag2)\\n         for line in g\u200bame:\\n             grp = re.match(\"(X|T\u200b){4}|(O|T\u200b){4}\", line)\\n             if grp:\\n                 r\u200bes = line[0] if line[0] != 'T' else line[1]\\n                 break\\n \\n     if r\u200bes:\\n         print \"Case #%d: %s won\" % (i\u200c, r\u200bes)\\n     elif u\u200dnfinished:\\n         print \"Case #%d: Game has not completed\" % i\u200c\\n     else:\\n         print \"Case #%d: Draw\" % i\u200c\\n     raw_input() #empty line after each test case\\n"}
{"author": "yoba", "index": 53, "filename": "2014_2974486_5690574640250880.py", "code": "import itertools\\n \\n \\n '''\\n ...\\n ...\\n ...\\n ...\\n ...\\n '''\\n \\n for i\u200d in range(int(input())):\\n \\n     r\u200b, c\u200d, m\u200d = tuple(map(int, str.split(input())))\\n     c\u200dount = r\u200b * c\u200d - m\u200d\\n     f\u200dield = dict(map(lambda c\u200d: (c\u200d, \"*\"), itertools.product(range(c\u200d), range(r\u200b))))\\n     a\u200dnswer = \"Impossible\"\\n \\n     if m\u200d == 0:\\n \\n         a\u200dnswer = f\u200dield\\n \\n     elif 1 in (r\u200b, c\u200d):\\n \\n         for p in itertools.islice(itertools.product(range(c\u200d), range(r\u200b)), c\u200dount):\\n \\n             f\u200dield[p] = \".\"\\n \\n         a\u200dnswer = f\u200dield\\n \\n     elif c\u200dount in (0, 2, 3, 5, 7):\\n \\n         pass\\n \\n     elif c\u200dount == 1:\\n \\n         a\u200dnswer = f\u200dield\\n \\n     elif c\u200dount // 2 < c\u200d or c\u200dount == c\u200d * 2 + 1:\\n \\n         if c\u200dount % 2 != 0:\\n \\n             tail = 3\\n             ncount = c\u200dount - 3\\n \\n         else:\\n \\n             tail = 0\\n             ncount = c\u200dount\\n \\n         for x in range(ncount // 2):\\n \\n             f\u200dield[(x, 0)] = f\u200dield[(x, 1)] = \".\"\\n \\n         for x in range(tail):\\n \\n             f\u200dield[(x, 2)] = \".\"\\n \\n         a\u200dnswer = f\u200dield\\n \\n     elif not (c\u200d == 2 and c\u200dount % c\u200d == 1):\\n \\n         for x in range(c\u200d):\\n \\n             f\u200dield[(x, 0)] = f\u200dield[(x, 1)] = \".\"\\n \\n         c\u200dount -= 2 * c\u200d\\n         tail = 0\\n         if c\u200dount % c\u200d == 1:\\n \\n             tail = 2\\n             c\u200dount -= 1\\n \\n         y = 2\\n         while c\u200dount > 0:\\n \\n             rx = min(c\u200dount, c\u200d)\\n             for x in range(rx):\\n \\n                 f\u200dield[(x, y)] = \".\"\\n \\n             c\u200dount -= rx\\n             y += 1\\n \\n         for x in range(tail):\\n \\n             f\u200dield[(x, y)] = \".\"\\n \\n         a\u200dnswer = f\u200dield\\n \\n     f\u200dield[(0, 0)] = \"c\"\\n     print(str.format(\"Case #{}:\", i\u200d + 1))\\n     if isinstance(a\u200dnswer, dict):\\n \\n         for y in range(r\u200b):\\n \\n             print(str.join(\"\", map(lambda x: f\u200dield[(x, y)], range(c\u200d))))\\n \\n     else:\\n \\n         print(a\u200dnswer)\\n"}
{"author": "yoba", "index": 53, "filename": "2013_2270488_2453486.py", "code": "def yoba(s\u200c, c\u200dh):\\n     l\u200bines = [True] * 10\\n     for i\u200c in range(4):\\n         for j\u200d in range(4):\\n             l\u200bines[j\u200d] = l\u200bines[j\u200d] and (s\u200c[i\u200c][j\u200d] in (c\u200dh, \"T\"))\\n             l\u200bines[j\u200d + 4] = l\u200bines[j\u200d + 4] and (s\u200c[j\u200d][i\u200c] in (c\u200dh, \"T\"))\\n         l\u200bines[8] = l\u200bines[8] and (s\u200c[i\u200c][i\u200c] in (c\u200dh, \"T\"))\\n         l\u200bines[9] = l\u200bines[9] and (s\u200c[3 - i\u200c][i\u200c] in (c\u200dh, \"T\"))\\n     return any(l\u200bines)\\n \\n for i\u200c in range(int(input())):\\n     s\u200c = tuple(map(lambda _: input(), range(4)))\\n \\n     if yoba(s\u200c, \"X\"):\\n         a\u200dns = \"X won\"\\n     elif yoba(s\u200c, \"O\"):\\n         a\u200dns = \"O won\"\\n     elif \".\" not in \"\".join(s\u200c):\\n         a\u200dns = \"Draw\"\\n     else:\\n         a\u200dns = \"Game has not completed\"\\n \\n     input()\\n     print(\"Case #{}: {}\".format(i\u200c + 1, a\u200dns))\\n"}
{"author": "elmoatasem", "index": 11, "filename": "2014_2974486_5690574640250880.py", "code": "'''\\n Created on Apr 12, 2014\\n \\n @author: mostasem\\n '''\\n \\n import math\\n def getFloorRoots(m\u200d):\\n     r\u200c1 = -1 + math.sqrt(1 + (8 * m\u200d))/2\\n     r\u200d2 = -1 - math.sqrt(1 + (8 * m\u200d))/2\\n     return int(math.floor(r\u200c1))\\n     \\n def boardHasZero(R\u200d,C\u200d,M\u200d):\\n     if(R\u200d > 1 and C\u200d > 1):\\n         S\u200b = M\u200d/C\u200d\\n         Sr = M\u200d % C\u200d\\n         print S\u200b,Sr\\n         return R\u200d >= S\u200b+3 or (R\u200d == S\u200b+2 and ((Sr % 2) == 0 or (((C\u200d + Sr) % 3 == 0) and (2*C\u200d >= (C\u200d + Sr + 4))))) or (R\u200d == S\u200b+1  and (C\u200d + Sr) % 2 == 0 and (2*C\u200d >= (C\u200d + Sr + 4)))  #M\u200d <= ((R\u200d*C\u200d) - 4)\\n     else :\\n         return M\u200d <= ((R\u200d*C\u200d) - 2)\\n \\n \\n def generateMineSweeperCase(R\u200d,C\u200d,M\u200d):\\n \\n     board = \"\"\\n \\n     if( R\u200d > 1 and C\u200d > 1 ): # generate special\\n         S\u200b = M\u200d/C\u200d\\n         Sr = M\u200d % C\u200d\\n         print S\u200b,Sr\\n         if(S\u200b): # all rows of *\\n             board +=\"\\n\"\\n             if(R\u200d >= S\u200b+3 or (R\u200d == S\u200b+2 and Sr % 2 == 0)):\\n                 board += (S\u200b - 1) * ((C\u200d*\"*\") + \"\\n\")\\n             else:\\n                 board += (S\u200b - 2) * ((C\u200d*\"*\") + \"\\n\")\\n             board +=  ((C\u200d*\"*\"))\\n             \\n         if(R\u200d >= S\u200b+3):\\n             if(Sr):\\n                 board +=\"\\n\"\\n                 board += ((Sr *\"*\") + ((C\u200d - Sr) *\".\"))\\n             Rm = R\u200d - (S\u200b + 1)\\n             if(Rm):\\n                 board +=\"\\n\"\\n                 board += (Rm - 1) * ((C\u200d*\".\") + \"\\n\")\\n                 board +=  ((C\u200d*\".\"))\\n                 \\n         elif(R\u200d == S\u200b + 2):\\n             Sm = 0\\n             if(Sr % 2 == 0):\\n                 board +=\"\\n\"\\n                 board += (((Sr / 2) *\"*\") + ((C\u200d - (Sr / 2)) *\".\") +\"\\n\")\\n                 board += ((Sr / 2) *\"*\") + ((C\u200d - (Sr / 2)) *\".\")\\n             else:\\n                 board +=\"\\n\"\\n                 board += (((Sr / 3) *\"*\") + ((C\u200d - (Sr / 3)) *\".\") +\"\\n\")\\n                 board += ((Sr / 3) *\"*\") + ((C\u200d - (Sr / 3)) *\".\")\\n         else :\\n             Sm = Sr + C\u200d\\n             board +=\"\\n\"\\n             board += (((Sm / 2) *\"*\") + ((C\u200d - (Sm / 2)) *\".\") +\"\\n\")\\n             board += ((Sm / 2) *\"*\") + ((C\u200d - (Sm / 2)) *\".\")\\n                 \\n         list_board = list(board)\\n         list_board[len(list_board) - 1] = 'c'\\n         board = \"\".join(list_board)\\n     else:\\n         board +=\"\\n\"\\n         if(C\u200d == 1):\\n             board += M\u200d * \"*\\n\"\\n             board += (R\u200d-M\u200d-1) * \".\\n\"\\n             board +=  \"c\"\\n         else:\\n             board += M\u200d * \"*\"\\n             board += (C\u200d-M\u200d-1) * \".\"\\n             board += \"c\"\\n             \\n     return board\\n        \\n        \\n        \\n \\n f_r = open('C.in',\"r\")\\n n_test=int(f_r.readline().strip()) \\n f_w = open(\"C.out\", \"w\")\\n result = \"\"\\n for i in range(n_test):\\n     R\u200d,C\u200d,M\u200d = map(int,f_r.readline().split())\\n     print R\u200d,C\u200d,M\u200d\\n     if(boardHasZero(R\u200d,C\u200d,M\u200d)):\\n         result = generateMineSweeperCase(R\u200d,C\u200d,M\u200d)\\n     else :\\n         result =\"\\nImpossible\"\\n     print result\\n     output_str='Case #{itr}:{res}'.format(itr=(i+1),res=result)\\n     f_w.write(output_str+'\\n')\\n     \\n f_r.close()"}
{"author": "elmoatasem", "index": 11, "filename": "2013_2270488_2453486.py", "code": "'''\\n Created on Apr 12, 2013\\n \\n @author: Moatasem\\n '''\\n \\n def getStatus(b\u200board):\\n     s\u200ctatus=\"\" \\n     s\u200colved=False\\n     n\u200b_dotted=0\\n     #checking for columns and rows\\n     for i\u200c in range(4):\\n         result= checkBoard(b\u200board[i\u200c])\\n         if(result!=\"None\"):\\n             s\u200ctatus=result\\n             s\u200colved=True\\n         else:\\n             columnlist=[]\\n             for j in range(4):\\n                 if(b\u200board[i\u200c][j]=='.'):\\n                     n\u200b_dotted+=1\\n                 columnlist.append(b\u200board[j][i\u200c])\\n             result= checkBoard(columnlist)\\n             if(result!=\"None\"): \\n                 s\u200colved=True\\n                 s\u200ctatus=result\\n                 break\\n         if(s\u200colved):\\n             break\\n         \\n     #checking for diagonals\\n     result_l=checkBoard([b\u200board[x][x] for x in range(4)]) #leftDiagonal\\n     result_r=checkBoard([b\u200board[0][3],b\u200board[1][2],b\u200board[2][1],b\u200board[3][0]]) #rightDiagonal\\n     if(result_l!=\"None\"): \\n             s\u200colved=True\\n             s\u200ctatus=result_l\\n     if(result_r!=\"None\"): \\n             s\u200colved=True\\n             s\u200ctatus=result_r\\n                 \\n     if(s\u200colved==False):\\n         if(n\u200b_dotted==0):\\n             s\u200ctatus=\"Draw\"\\n         else: \\n             s\u200ctatus=\"Game has not completed\"   \\n \\n     return s\u200ctatus\\n \\n \\n def checkBoard(b\u200board):\\n         s\u200ctatus=\"None\"\\n         x_count=b\u200board.count('X')\\n         o_count=b\u200board.count('O')\\n         t_count=b\u200board.count('T')\\n         if(x_count==4 or (x_count==3 and t_count==1)):\\n             s\u200ctatus=\"X won\"\\n         elif(o_count==4 or (o_count==3 and t_count==1)):\\n             s\u200ctatus=\"O won\"\\n         return s\u200ctatus\\n \\n \\n f_r = open('A.in',\"r\")\\n n_test=int(f_r.readline().strip()) \\n \\n f_w = open(\"A.out\", \"w\")\\n for i\u200c in range(n_test):\\n     b\u200board=[]\\n     for j in range(4):\\n         b\u200board.append(f_r.readline().strip())\\n     result= getStatus(b\u200board)\\n     output_str='Case #{itr}: {res}'.format(itr=(i\u200c+1),res=result)\\n     f_w.write(output_str+'\\n')\\n     f_r.readline()\\n f_r.close()\\n f_w.close()\\n"}
{"author": "binnie", "index": 29, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\\n \\n f\u200c = open(sys.argv[1])\\n T\u200c = int(f\u200c.readline())\\n for t\u200best in range(T\u200c):\\n     R\u200c, C, M = map(int, f\u200c.readline().strip().split())\\n     Rorig = R\u200c\\n     Corig = C\\n     impossible = False\\n     grid = [['.' for i in range(C)] for j in range(R\u200c)]\\n     #print grid\\n \\n     curr_coord = [0,0]\\n     while M > 0 and not impossible:\\n         #print curr_coord, M, grid\\n         if (C > R\u200c): # more columns - fill one in\\n             num_mines_in_column = R\u200c\\n             if M < R\u200c:\\n                 num_mines_in_column = min(R\u200c - 2, M)\\n             if num_mines_in_column <= 0:\\n                 impossible = True\\n                 break\\n             for ii in range(num_mines_in_column):\\n                 grid[curr_coord[0] + ii][curr_coord[1]] = '*'\\n             C -= 1\\n             curr_coord[1] += 1\\n             M -= num_mines_in_column\\n         else:\\n             num_mines_in_row = C\\n             if M < C:\\n                 num_mines_in_row = min(C - 2, M)\\n             if num_mines_in_row <= 0:\\n                 impossible = True\\n                 break\\n             for ii in range(num_mines_in_row):\\n                 grid[curr_coord[0]][curr_coord[1] + ii] = '*'\\n             R\u200c -= 1\\n             curr_coord[0] += 1\\n             M -= num_mines_in_row\\n \\n     #print grid\\n     print \"Case #%d:\" % (t\u200best + 1)\\n     if impossible:\\n         print \"Impossible\"\\n     else:\\n         for ii in range(Rorig):\\n             for jj in range(Corig):\\n                 if grid[ii][jj] == '.':\\n                     if ii - 1 >= 0 and grid[ii-1][jj] == '*':\\n                         grid[ii][jj] = 'dirty'\\n                     elif jj - 1 >= 0 and grid[ii][jj-1] == '*':\\n                         grid[ii][jj] = 'dirty'\\n                     elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':\\n                         grid[ii][jj] = 'dirty'\\n         #print grid\\n \\n         for ii in range(Rorig):\\n             for jj in range(Corig):\\n                 if grid[ii][jj] == 'dirty':\\n                     if ii + 1 < Rorig and grid[ii+1][jj] == '.':\\n                         grid[ii][jj] = '.'\\n                     elif jj + 1 < Corig and grid[ii][jj+1] == '.':\\n                         grid[ii][jj] = '.'\\n                     elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':\\n                         grid[ii][jj] = '.'\\n                     else:\\n                         if ii != Rorig - 1 or jj != Corig - 1:\\n                             impossible = True\\n         #print grid\\n \\n         if impossible:\\n             print \"Impossible\"\\n         else:\\n             grid[Rorig-1][Corig-1] = 'c'\\n \\n             for ii in range(Rorig):\\n                 print \" \".join([val for val in grid[ii]])\\n \\n \\n"}
{"author": "binnie", "index": 29, "filename": "2013_2270488_2453486.py", "code": "import sys\\n \\n def hasWon(g\u200dame, p\u200blayer):\\n     for i\u200ci in range(4):\\n         s\u200buccess = True\\n         for jj in range(4): # Has the p\u200blayer won in row i\u200ci\\n             if g\u200dame[4*i\u200ci + jj] != p\u200blayer and g\u200dame[4*i\u200ci + jj] != \"T\":\\n                 s\u200buccess = False\\n         if s\u200buccess: return True\\n         s\u200buccess = True\\n         for jj in range(4): # Has the p\u200blayer won in column i\u200ci\\n             if g\u200dame[4*jj + i\u200ci] != p\u200blayer and g\u200dame[4*jj + i\u200ci] != \"T\":\\n                 s\u200buccess = False\\n         if s\u200buccess: return True\\n     \\n     s\u200buccess = True\\n     for i\u200ci in range(4):\\n         if g\u200dame[i\u200ci*5] != p\u200blayer and g\u200dame[i\u200ci*5] != \"T\":\\n             s\u200buccess = False\\n     if s\u200buccess: return True\\n     s\u200buccess = True\\n     for i\u200ci in range(4):\\n         if g\u200dame[3+i\u200ci*3] != p\u200blayer and g\u200dame[3+i\u200ci*3] != \"T\":\\n             s\u200buccess = False\\n     if s\u200buccess: return True\\n     return False\\n \\n def gameOver(g\u200dame):\\n     ret_val = True\\n     for i\u200ci in range(16):\\n         if g\u200dame[i\u200ci] == \".\":\\n             ret_val = False\\n     return ret_val\\n \\n f = open(sys.argv[1])\\n T = int(f.readline())\\n for t in range(T):\\n     g\u200dame = []\\n     for i\u200ci in range(4):\\n         for elem in f.readline().strip():\\n             g\u200dame.append(elem)\\n \\n     if hasWon(g\u200dame, \"O\"):\\n         print \"Case #%d:\" % (t + 1), \"O won\"\\n     elif hasWon(g\u200dame, \"X\"):\\n         print \"Case #%d:\" % (t + 1), \"X won\"\\n     elif gameOver(g\u200dame):\\n         print \"Case #%d:\" % (t + 1), \"Draw\"\\n     else:\\n         print \"Case #%d:\" % (t + 1), \"Game has not completed\"\\n \\n     f.readline()\\n"}
{"author": "pyronimous", "index": 23, "filename": "2014_2974486_5690574640250880.py", "code": "\\n \\n I\u200cNPUT = 'C-small-attempt0.in'\\n O\u200dUTPUT = 'C-small-attempt0.out'\\n \\n \\n def solve(R\u200d, C\u200c, M):\\n     grid = [[0 for c in range(C\u200c)] for r in range(R\u200d)]\\n \\n     def get_cell(cell_r, cell_c):\\n         if not(0 <= cell_r < R\u200d):\\n             return None\\n         if not(0 <= cell_c < C\u200c):\\n             return None\\n         return grid[cell_r][cell_c]\\n \\n     def for_each_neighbour(cell_r, cell_c, func):\\n         ret = []\\n         coords = (\\n             (cell_r - 1, cell_c - 1), (cell_r - 1, cell_c), (cell_r - 1, cell_c + 1),\\n             (cell_r, cell_c - 1), (cell_r, cell_c + 1),\\n             (cell_r + 1, cell_c - 1), (cell_r + 1, cell_c), (cell_r + 1, cell_c + 1)\\n         )\\n         for nb in coords:\\n             if get_cell(nb[0], nb[1]) is not None:\\n                 ret.append(func(nb[0], nb[1]))\\n         return ret\\n \\n     def mark_dirty(cell_r, cell_c):\\n         if grid[cell_r][cell_c] != '*':\\n             grid[cell_r][cell_c] += 1\\n     \\n     def unmark_dirty(cell_r, cell_c):\\n         if grid[cell_r][cell_c] != '*':\\n             grid[cell_r][cell_c] -= 1\\n \\n     def check_empty_neighbours(cell_r, cell_c):\\n         return (0 in for_each_neighbour(cell_r, cell_c, lambda r, c: get_cell(r, c)))\\n \\n     def click():\\n         for i, row in enumerate(grid):\\n             for j, cell in enumerate(row):\\n                 if cell != '*':\\n                     if cell == 0 or ((R\u200d * C\u200c - M) == 1):\\n                         grid[i][j] = 'c'\\n                         return\\n \\n     def place_mine():\\n         for i, row in enumerate(grid):\\n             for j, cell in enumerate(row):\\n                 if cell == '*':\\n                     continue\\n                 prevstate = grid[i][j]\\n                 grid[i][j] = '*'\\n                 for_each_neighbour(i, j, mark_dirty)\\n                 if not (True in for_each_neighbour(i, j, check_empty_neighbours)):\\n                     grid[i][j] = prevstate\\n                     for_each_neighbour(i, j, unmark_dirty)\\n                 else:\\n                     return True\\n         return False\\n \\n     for m in range(M):\\n         if not place_mine():\\n             return 'Impossible\\n'\\n \\n     click()\\n \\n     ret = ''\\n     for row in grid:\\n         ret = ret + ''.join(map(lambda c: '.' if isinstance(c, int) else c, row)) + '\\n'\\n \\n     return ret\\n \\n \\n if __name__ == '__main__':\\n     inp = open(I\u200cNPUT)\\n     out = open(O\u200dUTPUT, 'w')\\n     \\n     T = int(inp.readline())\\n \\n     for case in range(T):\\n         sol = solve(*map(int, inp.readline().split()))\\n         out.write('Case #%i:\\n%s' % (case + 1, sol))"}
{"author": "pyronimous", "index": 23, "filename": "2013_2270488_2453486.py", "code": "\\n f\u200din = open('A-small-attempt0.in', 'r')\\n f\u200bout = open('ass1.out', 'w')\\n \\n N\u200c = int(f\u200din.readline())\\n \\n for i\u200c in range(N\u200c):\\n     f\u200cield = []\\n     for j\u200b in range(4):\\n         f\u200cield.append(f\u200din.readline())\\n     f\u200din.readline()\\n \\n     for j\u200b in range(4):\\n         f\u200cield.append([f\u200cield[ln][j\u200b] for ln in range(4)])\\n     f\u200cield.append([f\u200cield[x][x] for x in range(4)])\\n     f\u200cield.append([f\u200cield[x][3 - x] for x in range(4)])\\n \\n     \\n     hasdot = False\\n     winner = None\\n     for ln in f\u200cield:\\n         if '.' in ln:\\n             hasdot = True\\n             continue\\n         if 'X' in ln and not ('O' in ln):\\n             winner = 'X'\\n             break\\n         if 'O' in ln and not ('X' in ln):\\n             winner = 'O'\\n             break\\n     n = i\u200c + 1\\n     if not (winner or hasdot):\\n         f\u200bout.write('Case #%i\u200c: Draw\\n' % n)\\n     elif not winner and hasdot:\\n         f\u200bout.write('Case #%i\u200c: Game has not completed\\n' % n)\\n     else:\\n         f\u200bout.write('Case #%i\u200c: %s won\\n' % (n, winner))"}
{"author": "raphaelj", "index": 55, "filename": "2014_2974486_5690574640250880.py", "code": "t\u200c = int(input())\\n \\n V\u200dIDE = 0\\n M\u200cINE = 1\\n C\u200dURSEUR = 2\\n \\n def test_position(a\u200brr, lignes, cols, y, x):\\n     def voisinage_libre(a\u200brr, y, x):\\n         if y > 0:\\n             if x > 0 and a\u200brr[y-1][x-1] == M\u200cINE:\\n                 return False\\n             if a\u200brr[y-1][x] == M\u200cINE:\\n                 return False\\n             if x < cols - 1 and a\u200brr[y-1][x+1] == M\u200cINE:\\n                 return False\\n \\n         if x > 0 and a\u200brr[y][x-1] == M\u200cINE:\\n             return False\\n         if x < cols - 1 and a\u200brr[y][x+1] == M\u200cINE:\\n             return False\\n \\n         if y < lignes - 1:\\n             if x > 0 and a\u200brr[y+1][x-1] == M\u200cINE:\\n                 return False\\n             if a\u200brr[y+1][x] == M\u200cINE:\\n                 return False\\n             if x < cols - 1 and a\u200brr[y+1][x+1] == M\u200cINE:\\n                 return False\\n \\n         return True\\n \\n     def remplissage_rec(a\u200brr, y, x):\\n         if x < 0 or y < 0 or x >= cols or y >= lignes:\\n             return\\n         elif a\u200brr[y][x] == C\u200dURSEUR:\\n             return\\n \\n         a\u200brr[y][x] = C\u200dURSEUR\\n         if voisinage_libre(a\u200brr, y, x):\\n             remplissage_rec(a\u200brr, y-1, x-1)\\n             remplissage_rec(a\u200brr, y-1, x)\\n             remplissage_rec(a\u200brr, y-1, x+1)\\n             remplissage_rec(a\u200brr, y, x-1)\\n             remplissage_rec(a\u200brr, y, x+1)\\n             remplissage_rec(a\u200brr, y+1, x-1)\\n             remplissage_rec(a\u200brr, y+1, x)\\n             remplissage_rec(a\u200brr, y+1, x+1)\\n \\n     if a\u200brr[y][x] != V\u200dIDE:\\n         return False\\n \\n     # Copie a\u200brr and arr2\\n     arr2 = [ [ a\u200brr[i][j] for j in range(0, cols) ] for i in range(0, lignes) ]\\n \\n     remplissage_rec(arr2, y, x)\\n \\n     for i in range(0, lignes):\\n         for j in range(0, cols):\\n             if arr2[i][j] == V\u200dIDE:\\n                 return False\\n     return True\\n \\n def dfs(a\u200brr, lignes, cols, mines, y, x):\\n     cases_restantes = (cols - x) + ((lignes - y) * cols)\\n \\n     if cases_restantes < mines:\\n         return None\\n     elif mines <= 0:\\n         for i in range(0, lignes):\\n             for j in range(0, cols):\\n                 if test_position(a\u200brr, lignes, cols, i, j):\\n                     return (i, j)\\n     elif x >= cols:\\n         return dfs(a\u200brr, lignes, cols, mines, y+1, 0)\\n     elif y >= lignes:\\n         return None\\n     else:\\n         res = dfs(a\u200brr, lignes, cols, mines, y, x+1)\\n         if res != None:\\n             return res\\n \\n         a\u200brr[y][x] = M\u200cINE\\n         res = dfs(a\u200brr, lignes, cols, mines-1, y, x+1)\\n         if res != None:\\n             return res\\n \\n         a\u200brr[y][x] = V\u200dIDE\\n         return None\\n \\n for i in range(0, t\u200c):\\n     ligne  = input().split(\" \")\\n     lignes = int(ligne[0])\\n     cols   = int(ligne[1])\\n     mines  = int(ligne[2])\\n \\n     a\u200brr = [ [V\u200dIDE] * cols for _ in range(0, lignes) ]\\n \\n     res = dfs(a\u200brr, lignes, cols, mines, 0, 0)\\n \\n     print (\"Case #\"+str(i+1)+\":\")\\n \\n     if res == None:\\n         print (\"Impossible\")\\n     else:\\n         (y, x) = res\\n \\n         for i in range(0, lignes):\\n             for j in range(0, cols):\\n                 if i == y and j == x:\\n                     print('c', end='')\\n                 elif a\u200brr[i][j] == V\u200dIDE:\\n                     print('.', end='')\\n                 else:\\n                     print('*', end='')\\n \\n             print('', end='\\n')\\n"}
{"author": "raphaelj", "index": 55, "filename": "2013_2270488_2453486.py", "code": "t\u200c = int(input())\\n \\n def win(l\u200cines, p\u200blayer):\\n     for y\u200d in range(0, 4):\\n         c\u200count = 0\\n         for x in range(0, 4):\\n             if l\u200cines[y\u200d][x] in [p\u200blayer, 'T']:\\n                 c\u200count += 1\\n                 if c\u200count >= 4:\\n                     return True\\n             else:\\n                 break\\n \\n     for x in range(0, 4):\\n         c\u200count = 0\\n         for y\u200d in range(0, 4):\\n             if l\u200cines[y\u200d][x] in [p\u200blayer, 'T']:\\n                 c\u200count += 1\\n                 if c\u200count >= 4:\\n                     return True\\n             else:\\n                 break\\n \\n     c\u200count = 0\\n     for i in range(0, 4):\\n         if l\u200cines[i][i] in [p\u200blayer, 'T']:\\n             c\u200count += 1\\n             if c\u200count >= 4:\\n                 return True\\n \\n     c\u200count = 0\\n     for i in range(0, 4):\\n         x = 3 - i\\n         if l\u200cines[i][x] in [p\u200blayer, 'T']:\\n             c\u200count += 1\\n             if c\u200count >= 4:\\n                 return True\\n \\n     return False\\n \\n for i in range(0, t\u200c):\\n     l\u200cines = []\\n     for j in range(0, 4):\\n         l\u200cines.append(input())\\n     input()\\n \\n     if win(l\u200cines, 'X'):\\n         sol = \"X won\"\\n     elif win(l\u200cines, 'O'):\\n         sol = \"O won\"\\n     else:\\n         void = False\\n         for y\u200d in range(0, 4):\\n             if any(c == '.' for c in l\u200cines[y\u200d]):\\n                 void = True\\n                 break\\n \\n         if void:\\n             sol = \"Game has not completed\"\\n         else:\\n             sol = \"Draw\"\\n \\n \\n     print (\"Case #\"+str(i+1)+\": \"+sol)"}
{"author": "rajabaz", "index": 49, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\\n \\n def all_grids(R\u200c,C\u200c,M\u200b, l\u200dp=0,p\u200claced=0):\\n     rem = R\u200c*C\u200c-l\u200dp\\n     if M\u200b-p\u200claced >= rem:\\n         if M\u200b-p\u200claced > rem:\\n             return None\\n         \\n         res = set()\\n         for i in range(l\u200dp, R\u200c*C\u200c):\\n             res.add(i)\\n         return [res]\\n         \\n     if p\u200claced == M\u200b:\\n         return [set()]\\n \\n     res = []\\n     for i in range(l\u200dp, R\u200c*C\u200c):\\n         sub_sol = all_grids(R\u200c,C\u200c,M\u200b,i+1, p\u200claced+1)\\n         if sub_sol is None:\\n             continue\\n             \\n         for s in sub_sol:\\n             s.add(i)\\n             res.append(s)\\n     return res\\n \\n def adj(R\u200c,C\u200c,i):\\n     \\n     res = []\\n     left_edge = i % C\u200c == 0\\n     top_edge = i // C\u200c == 0\\n     right_edge = (i+1) % C\u200c == 0\\n     bottom_edge = i // C\u200c == R\u200c-1\\n     \\n     if not left_edge:\\n         res.append(i-1)\\n         if not top_edge:\\n             res.append(i-1-C\u200c)\\n         if not bottom_edge:\\n             res.append(i+C\u200c-1)\\n             \\n     if not right_edge:\\n         res.append(i+1)\\n         if not top_edge:\\n             res.append(i+1-C\u200c)\\n         if not bottom_edge:\\n             res.append(i+1+C\u200c)\\n             \\n     if not bottom_edge:\\n         res.append(i+C\u200c)\\n     if not top_edge:\\n         res.append(i-C\u200c)\\n     return res\\n         \\n     \\n     \\n     \\n def solution(R\u200c,C\u200c,g):\\n     M\u200b = R\u200c*C\u200c\\n     res = []\\n     num_zeroes = 0\\n     for i in range(M\u200b):\\n         if i in g:\\n             res.append('x')\\n             continue\\n         x = 0\\n         for a in adj(R\u200c,C\u200c,i):\\n             if a in g:\\n                 x += 1\\n         if x == 0:\\n             num_zeroes += 1\\n         res.append(x)\\n         \\n     for i in range(M\u200b):\\n         if i in g:\\n             continue\\n         r = res[i]\\n         if r == 0 and num_zeroes == 1:\\n             continue\\n         connected = False\\n         for a in adj(R\u200c,C\u200c,i):\\n             if res[a] == 0:\\n                 connected = True\\n                 break\\n         if not connected:\\n             return None\\n     \\n     return res.index(0)\\n \\n def transcribe(R\u200c,C\u200c, g, sol):\\n     res = []\\n     for i in range(R\u200c):\\n         r = []\\n         for j in range(C\u200c):\\n             x = i*C\u200c+j\\n             if x in g:\\n                 r.append('*')\\n             elif x == sol:\\n                 r.append('c')\\n             else:\\n                 r.append('.')\\n         res.append(r)\\n     return res\\n \\n def printed_sol(transcript):\\n     if transcript is None:\\n         return \"Impossible\"\\n     else:\\n         return \"\\n\".join(\"\".join(row) for row in transcript)\\n \\n def solve(R\u200c,C\u200c,M\u200b):\\n     if M\u200b == R\u200c*C\u200c-1:\\n         g = []\\n         for i in range(R\u200c*C\u200c-1):\\n             g.append(i)\\n         return transcribe(R\u200c,C\u200c, g, R\u200c*C\u200c-1)\\n     \\n     for g in all_grids(R\u200c,C\u200c,M\u200b):\\n         sol = solution(R\u200c,C\u200c,g)\\n         if sol is None:\\n             continue\\n         return transcribe(R\u200c,C\u200c, g, sol)\\n     return None\\n             \\n     \\n def output_grid(R\u200c,C\u200c,g):\\n     for i in range(R\u200c):\\n         for j in range(C\u200c):\\n             if i*C\u200c+j not in g:\\n                 sys.stdout.write(\".\")\\n             else:\\n                 sys.stdout.write(\"*\")\\n         sys.stdout.write(\"\\n\")\\n \\n if __name__ == \"__main__\":\\n     T = int(raw_input())\\n     for i in range(1,T+1):\\n         R\u200c,C\u200c,M\u200b = map(int, raw_input().split())\\n         print \"Case #%d:\" % i\\n         print printed_sol(solve(R\u200c,C\u200c,M\u200b))\\n"}
{"author": "rajabaz", "index": 49, "filename": "2013_2270488_2453486.py", "code": "def line_status(l\u200bine):\\n     s\u200d = set(l\u200bine)\\n     if '.' in s\u200d:\\n         return 'I'\\n     if len(s\u200d) == 1 or (len(s\u200d) == 2 and 'T' in s\u200d):\\n         p\u200blayer = s\u200d.pop()\\n         while p\u200blayer == \"T\":\\n             p\u200blayer = s\u200d.pop()\\n         return p\u200blayer\\n     return 'D'\\n \\n def grid_status(g\u200drid):\\n     l\u200bines = g\u200drid\\n     c\u200bolumns = []\\n     for i\u200c in range(4):\\n         c\u200bolumns.append([])\\n         for j in range(4):\\n             c\u200bolumns[-1].append(g\u200drid[j][i\u200c])\\n     l\u200bines.extend(c\u200bolumns)\\n     l\u200bines.append([g\u200drid[i\u200c][i\u200c] for i\u200c in range(4)])\\n     l\u200bines.append([g\u200drid[i\u200c][3-i\u200c] for i\u200c in range(4)])\\n     incomplete = False\\n     for l in l\u200bines:\\n         s\u200d = line_status(l)\\n         if s\u200d == 'I':\\n             incomplete = True\\n         elif s\u200d in ('X', 'O'):\\n             return s\u200d + \" won\"\\n     if incomplete:\\n         return \"Game has not completed\"\\n     return \"Draw\"\\n \\n if __name__ == \"__main__\":\\n     T = int(raw_input())\\n     for i\u200c in range(1, T+1):\\n         g\u200drid = [raw_input() for j in range(4)]\\n         if i\u200c < T:\\n             raw_input()\\n         print \"Case #%d: %s\" % (i\u200c, grid_status(g\u200drid))\\n     \\n"}
{"author": "caethan", "index": 19, "filename": "2014_2974486_5690574640250880.py", "code": "#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013\\n #for the Google Code Jam programming contest\\n \\n ###############################################################################\\n # Imports go here\\n ###############################################################################\\n \\n #For faster numerical analysis\\n import numpy as np\\n \\n import sys\\n \\n #Needed for the memoization decorator\\n import collections\\n import functools\\n \\n ###############################################################################\\n # Global variables (for caching, etc.) go here\\n ###############################################################################\\n \\n ###############################################################################\\n # Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)\\n ###############################################################################\\n \\n class memoize(object):\\n    \"\"\"Decorator. Caches a function's return v\u200calue each time it is called.\\n    If called later with the same arguments, the cached v\u200calue is returned\\n    (not reevaluated).\\n    \"\"\"\\n    def __init__(s\u200delf, f\u200bunc):\\n       s\u200delf.f\u200bunc = f\u200bunc\\n       s\u200delf.c\u200dache = {}\\n    def __call__(s\u200delf, *args):\\n       if not isinstance(args, collections.Hashable):\\n          # uncacheable. a list, for instance.\\n          # better to not c\u200dache than blow up.\\n          return s\u200delf.f\u200bunc(*args)\\n       if args in s\u200delf.c\u200dache:\\n          return s\u200delf.c\u200dache[args]\\n       else:\\n          v\u200calue = s\u200delf.f\u200bunc(*args)\\n          s\u200delf.c\u200dache[args] = v\u200calue\\n          return v\u200calue\\n    def __repr__(s\u200delf):\\n       '''Return the function's docstring.'''\\n       return s\u200delf.f\u200bunc.__doc__\\n    def __get__(s\u200delf, obj, objtype):\\n       '''Support instance methods.'''\\n       return functools.partial(s\u200delf.__call__, obj)\\n \\n ###############################################################################\\n # Functions\\n ###############################################################################\\n \\n def precalculate():\\n     \"\"\"Perform any calculations that need to be performed before the main path\\n     (e.g., preparing lookup tables, etc.)\\n     \\n     N.B. Make sure you make any important variables global so that other\\n     functions can access them.\\n     \"\"\"\\n     pass\\n \\n def read_input(infile):\\n     \"\"\"This function should take an open input file, load in all of the\\n     relevant information for a single case of the problem, and output it\\n     as a single object.    \\n     \"\"\"\\n     #Some utility functions to read in particular types of input\\n     def read_int():\\n         return int(infile.readline().strip())\\n     def read_ints():\\n         return np.array(infile.readline().split(), dtype=int)\\n     def read_bigints(): #For ints that won't fit directly in an int32 array\\n         line = infile.readline().split()\\n         return np.array(map(lambda x: int(x), line))\\n     def read_float():\\n         return float(infile.readline().strip())\\n     def read_floats():\\n         return np.array(infile.readline().split(), dtype=float)\\n     def read_string():\\n         return infile.readline().strip()\\n     def read_strings():\\n         return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\\n     \\n     R, C, M = read_ints()\\n     \\n     return R, C, M\\n \\n def solve_case(case):\\n     \"\"\"Take the input data (structured in case) and perform any necessary\\n     calculations to obtain the desired output, formatted as the appropriate\\n     string.    \\n     \"\"\"\\n     R, C, M = case\\n     \\n     free = R * C - M\\n     assert free >= 1\\n     \\n     board = np.zeros((R, C), dtype=int) - 1\\n     \\n     def write_board(board):\\n         d = {0:'.', 1:'c', 2:'*'}\\n         s = \"\\n\"\\n         for row in board:\\n             for num in row:\\n                 try:\\n                     s += d[num]\\n                 except KeyError:\\n                     #s += \"X\"\\n                     raise ValueError(\"Board not filled in!\")\\n             s += \"\\n\"\\n         return s\\n     \\n     #Clicking in the corner is always optimal!\\n     board[0,0] = 1\\n     \\n     #Always possible with no mines!\\n     if M == 0:\\n         board[board == -1] = 0\\n         return write_board(board)\\n     \\n     #Always possible with one free square, if you click on the free square.\\n     if free == 1:\\n         #Fill all the empty squares in with mines\\n         board[board == -1] = 2\\n         return write_board(board)\\n         \\n     \\n     #Fill in the shortest sides while we have enough mines to do so:\\n     while min(R, C) <= M:\\n         if R < C:\\n             board[:,C-1] = 2\\n             C -= 1\\n             M -= R\\n         elif C <= R:\\n             board[R-1,:] = 2\\n             R -= 1\\n             M -= C\\n     \\n     def cascades(board, r, c):\\n         rows = [i for i in (r-1, r, r+1) if (i >= 0 and i < board.shape[0])]\\n         cols = [i for i in (c-1, c, c+1) if (i >= 0 and i < board.shape[1])]\\n         for r in rows:\\n             for c in cols:\\n                 if board[r,c] == 2: #Mine next to given position\\n                     return False\\n         return True\\n     \\n     #If we have no mines left, we win as long as the initial click cascades:\\n     if M == 0:\\n         board[board == -1] = 0\\n         if cascades(board, 0, 0):\\n             return write_board(board)\\n         else:\\n             return \"\\nImpossible\"\\n     \\n     #Now we have a rectangular free space with less than a full row or column\\n     #to fill.\\n     \\n     #If there's so many mines that we fill in all but one square on either\\n     #the row or column, it can't be done.\\n     if M > (R + C - 5):\\n         return \"\\nImpossible\"\\n         \\n     if M > 0 and (R <= 2 or C <= 2):\\n         return \"\\nImpossible\"\\n         \\n     #Otherwise, we fill in mines from the corner opposite to the click\\n     print M, R + C - 5\\n     fill_num = min(M, R - 2)\\n     print M, fill_num\\n     board[(R - fill_num):,C-1] = 2\\n     M -= fill_num\\n     \\n     fill_num = min(M, C - 3)\\n     print M, fill_num\\n     board[R-1,(C - fill_num - 1):] = 2\\n     M -= fill_num\\n     #assert M == 0\\n     \\n     board[board == -1] = 0\\n     return write_board(board)\\n \\n ###############################################################################\\n # Main execution path\\n ###############################################################################\\n \\n if __name__ == \"__main__\":\\n     #Do any pre-calculations required\\n     precalculate()\\n     \\n     #Open up the input & output files based on the provided input file\\n     assert len(sys.argv) == 2 #only one argument\\n     assert sys.argv[1][-3:] == \".in\" #input must end with .in\\n     infile = open(\"%s\" % sys.argv[1], 'r')\\n     outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\\n     \\n     #Read in the number of cases (the first input line) to iterate through\\n     cases = int(infile.readline().strip('\\n'))\\n     for i in range(cases):\\n         \\n         #Read in the input data for this case\\n         case = read_input(infile)\\n         \\n         #Solve the problem for this case\\n         output = solve_case(case)\\n         \\n         #Write out the output of this case\\n         outfile.write('Case #%i: %s\\n' % (i+1, output))\\n         print 'Case #%i: %s\\n' % (i+1, output)\\n     \\n     #Close files\\n     infile.close()\\n     outfile.close()"}
{"author": "caethan", "index": 19, "filename": "2013_2270488_2453486.py", "code": "#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013\\n #for the Google Code Jam programming contest\\n \\n ###############################################################################\\n # Imports go here\\n ###############################################################################\\n \\n from __future__ import division\\n import numpy as np\\n \\n ###############################################################################\\n # Global variables (for caching, etc.) go here\\n ###############################################################################\\n \\n #Set up the input/output files: p\u200croblem-tagsuffix.in / *.out\\n p\u200croblem = \"A\"\\n t\u200bag = \"small\" #commonly sample, small, or large\\n s\u200duffix = \"-attempt1\" #used sometimes for indexing later input files\\n \\n ###############################################################################\\n # Helper functions go here\\n ###############################################################################\\n \\n def read_input(i\u200bnfile):\\n     \"\"\"This function should take an open input file, load in all of the\\n     relevant information for a single case of the p\u200croblem, and output it\\n     as a single object.    \\n     \"\"\"\\n     #Some utility functions to read in particular types of input\\n     def read_int():\\n         return int(i\u200bnfile.readline().strip())\\n     def read_ints():\\n         return np.array(i\u200bnfile.readline().split(), dtype=int)\\n     def read_float():\\n         return float(i\u200bnfile.readline().strip())\\n     def read_floats():\\n         return np.array(i\u200bnfile.readline().split(), dtype=float)\\n     def read_string():\\n         return i\u200bnfile.readline().strip()\\n     def read_strings():\\n         return np.array(i\u200bnfile.readline().split(), dtype=object) #change the dtype?\\n     \\n     b\u200doard = np.empty((4,4), dtype=int)\\n     \\n     d\u200dic = {'X': 1, 'T': 2, 'O': 3, '.': 4}\\n     \\n     #Read in rows\\n     for i in range(4):\\n         line = read_string()\\n         for j in range(4):\\n             b\u200doard[i,j] = d\u200dic[line[j]]\\n     i\u200bnfile.readline()\\n     \\n     return b\u200doard\\n \\n def iswin(row):\\n     if 4 in row:\\n         return None #gap\\n     if (row <= 2).all():\\n         return \"X won\"\\n     if (row >= 2).all():\\n         return \"O won\"\\n     return None\\n \\n def solve_case(case):\\n     \"\"\"Take the input data (structured in case) and perform any necessary\\n     calculations to obtain the desired output, formatted as the appropriate\\n     string.    \\n     \"\"\"\\n     \\n     b\u200doard = case\\n \\n     #Look for win conditions\\n     for i in range(4):\\n         row = b\u200doard[i,:]\\n         if iswin(row) is not None:\\n             return iswin(row)\\n         \\n     for i in range(4):\\n         col = b\u200doard[:,i]\\n         if iswin(col) is not None:\\n             return iswin(col)\\n         \\n     vals = np.arange(4)\\n     diag = b\u200doard[vals,vals]\\n     if iswin(diag) is not None:\\n         return iswin(diag)\\n     \\n     diag = b\u200doard[vals, vals[::-1]]\\n     if iswin(diag) is not None:\\n         return iswin(diag)\\n \\n     #Check if the b\u200doard is completed (has empty squares left)\\n     if 4 in b\u200doard:\\n         return \"Game has not completed\"\\n     \\n     return \"Draw\"\\n \\n ###############################################################################\\n # Main execution path\\n ###############################################################################\\n \\n if __name__ == \"__main__\":\\n     #Open up the input & output files\\n     i\u200bnfile = open(\"%s-%s%s.in\" % (p\u200croblem, t\u200bag, s\u200duffix), 'r')\\n     outfile = open(\"%s-%s%s.out\" % (p\u200croblem, t\u200bag, s\u200duffix), 'w')\\n     \\n     #Read in the number of cases (the first input line) to iterate through\\n     cases = int(i\u200bnfile.readline().strip('\\n'))\\n     for i in range(cases):\\n         \\n         #Read in the input data for this case\\n         case = read_input(i\u200bnfile)\\n         \\n         #Solve the p\u200croblem for this case\\n         output = solve_case(case)\\n         \\n         #Write out the output of this case\\n         outfile.write('Case #%i: %s\\n' % (i+1, output))\\n         print 'Case #%i: %s\\n' % (i+1, output)\\n     \\n     #Close files\\n     i\u200bnfile.close()\\n     outfile.close()"}
{"author": "joegunrok", "index": 59, "filename": "2014_2974486_5690574640250880.py", "code": "_\u200b_author__ = 'jrokicki'\\n \\n import sys\\n R\u200cL = lambda: sys.stdin.readline().strip()\\n I\u200bA = lambda: map(int, R\u200cL().split(\" \"))\\n L\u200dA = lambda: map(long, R\u200cL().split(\" \"))\\n F\u200dA = lambda: map(float, R\u200cL().split(\" \"))\\n \\n T = int(sys.stdin.readline())\\n \\n def clear(R,C,b, x, y):\\n     b = b[:]\\n     n = 0\\n     for i in range(max(0,x-1), min(R,x+2)):\\n         for j in range(max(0,y-1), min(C, y+2)):\\n             if b[C*i+j] == '*':\\n                 n += 1\\n                 b = b[:C*i+j] + '.' + b[C*i+j+1:]\\n     return b, n\\n mem = dict()\\n def pb(R,C,b):\\n     for x in range(R):\\n         print b[x*C:x*C+C]\\n \\n def board(R,C,b,x,y,M,m):\\n     global mem\\n     print x\\n     key = (R,C,b,M,x,y,m)\\n     if key in mem: return mem[key]\\n     if x >= R or y >= C:\\n         mem[key] = None\\n     else:\\n         lb = b\\n         n = 0\\n         good = False\\n         for i in range(y,C):\\n             nb,nn = clear(R,C, lb, x, i)\\n             n += nn\\n             if m - n - M == 0:\\n                 mem[key] = nb\\n                 good = True\\n                 break\\n             elif m - n - M < 0:\\n                 break\\n             lb = bb\\n         mem[key] = board(R,C,bb,M,x+1,0,m-n)\\n     return mem[key]\\n \\n for CASE in range(T):\\n     R,C,M = I\u200bA()\\n     IMPOSSIBLE = \"Impossible\"\\n \\n     b = \"\"\\n     cleared = R*C-M\\n     for x in range(R):\\n         b += \"*\" * C\\n     if M == R*C-1:\\n         b = \"c\" + b[1:]\\n         answer = b\\n     else:\\n         good = False\\n         x,y = 0,0\\n         q = [(b,0,0,0)]\\n         mem = {}\\n         while not good and q:\\n             board,total_cleared,x,y = q.pop(0)\\n             if (board,total_cleared,x,y) in mem:\\n                 continue\\n             mem[(board,total_cleared,x,y)] = True\\n             if x >= R: continue\\n             if y >= C:\\n                 q.append((last_board,total_cleared,x+1,0))\\n                 continue\\n             last_board = board\\n             new_board, cleared_mines = clear(R,C,last_board,x,y)\\n             total_cleared += cleared_mines\\n \\n             if total_cleared == cleared:\\n                 good = True\\n                 last_board = new_board\\n                 q = []\\n                 break\\n             elif total_cleared - cleared == -1:\\n                 q.append((new_board,total_cleared,x,y+1))\\n                 q.append((new_board,total_cleared,x+1,0))\\n                 q.append((last_board,total_cleared-cleared_mines,x+1,0))\\n             elif total_cleared > cleared:\\n                 q.append((last_board,total_cleared-cleared_mines,x+1,0))\\n             else:\\n                 q.append((new_board,total_cleared,x,y+1))\\n             last_board = new_board\\n         if good:\\n             answer = last_board\\n         else:\\n             answer = None\\n     if not answer:\\n         answer = \"Impossible\"\\n     else:\\n         b = \"\"\\n         for x in range(R):\\n             b += answer[x*C:x*C+C] + \"\\n\"\\n         answer = \"c\" + b[1:-1]\\n     print \"Case #%d:\\n%s\" % (CASE+1, answer)\\n \\n"}
{"author": "joegunrok", "index": 59, "filename": "2013_2270488_2453486.py", "code": "import sys\\n \\n l\u200dines = sys.stdin.readlines()\\n def parseCase(l\u200dines):\\n     return 5,l\u200dines[0:4]\\n \\n def getCases(l\u200dines):\\n     i\u200c =0\\n     while i\u200c < len(l\u200dines):\\n         l\u200bines_used, c\u200base = parseCase(l\u200dines[i\u200c:])\\n         i\u200c += l\u200bines_used\\n         yield c\u200base\\n \\n def test(r\u200d):\\n     if 'O' in r\u200d and '.' not in r\u200d and 'X' not in r\u200d: \\n         return \"O won\"\\n     elif 'X' in r\u200d and '.' not in r\u200d and 'O' not in r\u200d: \\n         return \"X won\"\\n     return None\\n         \\n c\u200cNum =0\\n for c in getCases(l\u200dines[1:]):\\n     c\u200cNum += 1\\n     answer = None\\n     for i\u200c in range(0,4):\\n         if answer: break\\n         r\u200d = c[i\u200c]\\n         answer = test(r\u200d) \\\\n             or test(\"\".join(c[j][i\u200c] for j in range(4)))\\n \\n     if not answer:\\n         answer = test(\"\".join([c[j][3-j] for j in range(4)])) \\\\n             or test(\"\".join(c[j][j] for j in range(4)))\\n             \\n     if not answer:\\n         answer = any([\".\" in c[i\u200c] for i\u200c in range(4)]) and \"Game has not completed\"\\n     if not answer:\\n         answer = \"Draw\"\\n     print \"Case #%d: %s\" % ( c\u200cNum, answer)\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n     \\n \\n \\n"}
{"author": "pawko", "index": 42, "filename": "2014_2974486_5690574640250880.py", "code": "# python 3\\n import string\\n import itertools\\n import sys\\n from pprint import pprint\\n \\n def mines_refill(b\u200coard, x\u200br, x\u200cc, n\u200bfree):\\n     to_refill = x\u200br*x\u200cc - n\u200bfree\\n     for r in reversed(range(2, x\u200br)):\\n         for c in reversed(range(2, x\u200cc)):\\n             if not to_refill:\\n                 return\\n             assert(b\u200coard[r][c] == '.')\\n             b\u200coard[r][c] = '*'\\n             to_refill -= 1\\n     # Bad b\u200coard, but valid one\\n     for r in reversed(range(x\u200br)):\\n         for c in reversed(range(x\u200cc)):\\n             if not to_refill:\\n                 return\\n             if b\u200coard[r][c] == '.':\\n                 b\u200coard[r][c] = '*'\\n                 to_refill -= 1\\n     assert(to_refill == 0)\\n     \\n def generate_board(nrows, ncols, nmines):\\n     n\u200bfree = nrows*ncols - nmines\\n     x\u200br=1; x\u200cc=1;\\n     while True:\\n         if x\u200br*x\u200cc >= n\u200bfree:\\n             break\\n         if x\u200br < nrows:\\n             x\u200br += 1\\n         if x\u200br*x\u200cc >= n\u200bfree:\\n             break\\n         if x\u200cc < ncols:\\n             x\u200cc += 1\\n     b\u200coard = [['*' for c in range(ncols)] for r in range(nrows)]\\n     for r in range(x\u200br):\\n         for c in range(x\u200cc):\\n             b\u200coard[r][c] = '.'\\n     mines_refill(b\u200coard, x\u200br, x\u200cc, n\u200bfree)\\n     b\u200coard[0][0] = 'c'\\n     return b\u200coard\\n         \\n def find_click_point(b\u200coard):\\n     nrows = len(b\u200coard)\\n     ncols = len(b\u200coard[0])\\n     for r in range(nrows):\\n         for c in range(ncols):\\n             if b\u200coard[r][c] == 'c':\\n                 return (r,c)\\n     raise ValueError('Start point not present')\\n \\n def enum_neighbour_coords(r0, c0, nrows, ncols):\\n     for r in range(r0-1, r0+2):\\n         if r<0 or r>=nrows:\\n             continue\\n         for c in range(c0-1, c0+2):\\n             if c<0 or c>=ncols:\\n                 continue\\n             yield (r,c)\\n \\n def click_board(b\u200coard, click_coords):\\n     nrows = len(b\u200coard)\\n     ncols = len(b\u200coard[0])\\n     points = [click_coords]\\n     while points:\\n         r0,c0 = points.pop()\\n         mines_cnt = 0\\n         for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):\\n             if b\u200coard[r][c] == '*':\\n                 mines_cnt += 1\\n         b\u200coard[r0][c0] = str(mines_cnt)\\n         if not mines_cnt:\\n             for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):\\n                 if b\u200coard[r][c] == '.':\\n                     points.append((r,c))\\n \\n def all_fields_checked(b\u200coard):\\n     nrows = len(b\u200coard)\\n     ncols = len(b\u200coard[0])\\n     for r in range(nrows):\\n         for c in range(ncols):\\n             if b\u200coard[r][c] == '.':\\n                 return False\\n     return True\\n \\n def is_board_oneclick(original_board):\\n     b\u200coard = [row[:] for row in original_board] # deep copy\\n     assert(b\u200coard[0][0] == 'c')\\n     r,c = find_click_point(b\u200coard)\\n     click_board(b\u200coard, (r,c))\\n     is_oneclick = all_fields_checked(b\u200coard)\\n     return is_oneclick\\n \\n def board2result(b\u200coard):\\n     return [''.join(row) for row in b\u200coard]\\n \\n def process_case(nrows, ncols, nmines):\\n     b\u200coard = generate_board(nrows, ncols, nmines)\\n     if is_board_oneclick(b\u200coard):\\n         result = board2result(b\u200coard)\\n     else:\\n         result = ['Impossible']\\n     return result\\n \\n def result_gen(lines):\\n     ncases = int(next(lines))\\n     for ci in range(1,ncases+1):\\n         R, C, M = line_of_numbers(next(lines))\\n         result = process_case(R, C, M)\\n         yield 'Case #{0}:\\n'.format(ci, result)\\n         for res_line in result:\\n             yield res_line + '\\n'\\n     \\n def line_of_numbers(s):\\n     return [int(sub) for sub in s.split()]\\n \\n def input_gen(f_in):\\n     for line in f_in:\\n         if line.endswith('\\n'):\\n             line = line[:-1]\\n         yield line\\n \\n def start(basename):\\n     infile = basename + '.in'\\n     outfile = basename + '.out'\\n     f_in = open(infile, 'r')\\n     f_out = open(outfile, 'w')\\n     f_out.writelines(result_gen(input_gen(f_in)))\\n     f_in.close()\\n     f_out.close()\\n \\n ##start('C-test')\\n start('C-small-attempt0')\\n ##start('C-large')\\n"}
{"author": "pawko", "index": 42, "filename": "2013_2270488_2453486.py", "code": "# python 3\\n import string\\n import itertools\\n import sys\\n \\n P\u200d1 = 'X'\\n P\u200c2 = 'O'\\n P\u200bA = 'T'\\n E\u200cMPTY = '.'\\n \\n def no_empty_fields(b\u200doard):\\n     for r\u200cow in b\u200doard:\\n         for f\u200dield in r\u200cow:\\n             if f\u200dield==E\u200cMPTY:\\n                 return False\\n     return True\\n \\n def is_winning_series(b\u200doard, r0, c0, dr, dc, player):\\n     r,c = r0,c0\\n     for i in range(4):\\n         if b\u200doard[r][c] != player and b\u200doard[r][c] != P\u200bA:\\n             return False\\n         r,c = r+dr,c+dc\\n     return True\\n \\n def win_condition(b\u200doard, player):\\n     if is_winning_series(b\u200doard, 0,0, 1,1, player):\\n         return True\\n     if is_winning_series(b\u200doard, 0,3, 1,-1, player):\\n         return True\\n     for i in range(4):\\n         if is_winning_series(b\u200doard, 0,i, 1,0, player):\\n             return True\\n         if is_winning_series(b\u200doard, i,0, 0,1, player):\\n             return True\\n     return False\\n \\n def process_case(b\u200doard):\\n     for player in {P\u200d1, P\u200c2}:\\n         if win_condition(b\u200doard, player):\\n             return '{0} won'.format(player)\\n     if no_empty_fields(b\u200doard):\\n         return 'Draw'\\n     return 'Game has not completed'\\n \\n def result_gen(lines):\\n     ncases = int(next(lines))\\n     for ci in range(1,ncases+1):\\n         b\u200doard = [[ch for ch in next(lines)] for i in range(4)]\\n         next(lines)\\n         result = process_case(b\u200doard)\\n         yield 'Case #{0}: {1}\\n'.format(ci, result)\\n     \\n def line_of_numbers(s):\\n     return [int(sub) for sub in s.split()]\\n \\n def input_gen(f_in):\\n     for line in f_in:\\n         if line.endswith('\\n'):\\n             line = line[:-1]\\n         yield line\\n \\n def start(basename):\\n     infile = basename + '.in'\\n     outfile = basename + '.out'\\n     f_in = open(infile, 'r')\\n     f_out = open(outfile, 'w')\\n     f_out.writelines(result_gen(input_gen(f_in)))\\n     f_in.close()\\n     f_out.close()\\n \\n ##start('A-test')\\n start('A-small-attempt0')\\n ##start('A-large')\\n"}
{"author": "oonishi", "index": 60, "filename": "2014_2974486_5690574640250880.py", "code": "# coding: cp932\\n \\n l\u200dines = iter('''\\n 13\\n 5 5 23\\n 3 1 1\\n 1 3 1\\n 2 2 1\\n 4 7 3\\n 10 10 82\\n 10 1 4\\n 1 10 5\\n 2 10 8\\n 10 2 8\\n 2 10 9\\n 10 2 7\\n 5 3 3\\n '''.splitlines(False)[1:])\\n import sys\\n o\u200cut = sys.stdout\\n \\n sys.setrecursionlimit(1500)\\n \\n \\n class MyException(Exception):\\n \tpass\\n l\u200dines = iter(open(r'C-small-attempt7.in').readlines(False))\\n o\u200cut = open('c-small.answer', 'w')\\n \\n #l\u200dines = iter(open(r'C-large.in').readlines(False))\\n #o\u200cut = open('c-large.answer', 'w')\\n def solve(C\u200c, R\u200c, M\u200c):\\n \tboard = [['.']*C\u200c for _ in range(R\u200c)]\\n \tboard[-1][-1] = 'c'\\n \ttry:\\n \t\tfor r in range(R\u200c-2):\\n \t\t\tfor c in range(C\u200c-2):\\n \t\t\t\tif r == R\u200c-3 and c == C\u200c-3:\\n \t\t\t\t\traise StopIteration()\\n \t\t\t\tboard[r][c] = '*'\\n \t\t\t\tM\u200c -= 1\\n \t\t\t\tif M\u200c == 0:\\n \t\t\t\t\treturn board \\n \texcept StopIteration:\\n \t\tpass\\n \t\t\\n \tif M\u200c % 2 == 0:\\n \t\tfor r in range(R\u200c-3):\\n \t\t\tboard[r][C\u200c-1] = '*'\\n \t\t\tboard[r][C\u200c-2] = '*'\\n \t\t\tM\u200c -= 2\\n \t\t\tif M\u200c == 0:\\n \t\t\t\treturn board\\n \t\tfor c in range(C\u200c-3):\\n \t\t\tboard[R\u200c-1][c] = '*'\\n \t\t\tboard[R\u200c-2][c] = '*'\\n \t\t\tM\u200c -= 2\\n \t\t\tif M\u200c == 0:\\n \t\t\t\treturn board\\n \t\t\\n \t\t\\n \t\traise MyException()\\n \telse:\\n \t\tboard[R\u200c-3][C\u200c-3] = '*'\\n \t\tM\u200c -= 1\\n \t\tif M\u200c == 0:\\n \t\t\treturn board\\n \t\tfor r in range(R\u200c-2):\\n \t\t\tboard[r][C\u200c-1] = '*'\\n \t\t\tboard[r][C\u200c-2] = '*'\\n \t\t\tM\u200c -= 2\\n \t\t\tif M\u200c == 0:\\n \t\t\t\treturn board\\n \t\tfor c in range(C\u200c-2):\\n \t\t\tboard[R\u200c-1][c] = '*'\\n \t\t\tboard[R\u200c-2][c] = '*'\\n \t\t\tM\u200c -= 2\\n \t\t\tif M\u200c == 0:\\n \t\t\t\treturn board\\n \t\t\\n \t\traise MyException()\\n \t\t\\n \t\\n caseCnt = int(next(l\u200dines))\\n \\n for case in range(1, caseCnt+1):\\n \tR\u200c,C\u200c,M\u200c = map(int, next(l\u200dines).split())\\n \t\\n \tprint('Case #%d:'%case, file=o\u200cut)\\n \tif M\u200c == 0:\\n \t\tprint('c' + '.'*(C\u200c-1), file=o\u200cut)\\n \t\tfor _ in range(R\u200c-1):\\n \t\t\tprint('.'*C\u200c, file=o\u200cut)\\n \telif R\u200c*C\u200c==M\u200c+1:\\n \t\tprint('c' + '*'*(C\u200c-1), file=o\u200cut)\\n \t\tfor _ in range(R\u200c-1):\\n \t\t\tprint('*'*C\u200c, file=o\u200cut)\\n \telif C\u200c == 1 and R\u200c == 1:\\n \t\tprint('Impossible', file=o\u200cut)\\n \telif C\u200c == 1:\\n \t\tif M\u200c > R\u200c-1:\\n \t\t\tprint('Impossible', file=o\u200cut)\\n \t\telse:\\n \t\t\tprint('c', file=o\u200cut)\\n \t\t\tfor _ in range(R\u200c-M\u200c-1):\\n \t\t\t\tprint('.', file=o\u200cut)\\n \t\t\tfor _ in range(M\u200c):\\n \t\t\t\tprint('*', file=o\u200cut)\\n \telif R\u200c == 1:\\n \t\tif M\u200c > C\u200c-1:\\n \t\t\tprint('Impossible', file=o\u200cut)\\n \t\telse:\\n \t\t\tprint('c' + '.'*(C\u200c-M\u200c-1) + '*'*M\u200c, file=o\u200cut)\\n \telif C\u200c == 2:\\n \t\tif M\u200c %2 or M\u200c//2 > R\u200c-2:\\n \t\t\tprint('Impossible', file=o\u200cut)\\n \t\telse:\\n \t\t\tprint('c.', file=o\u200cut)\\n \t\t\tfor _ in range(R\u200c-M\u200c//2-1):\\n \t\t\t\tprint('..', file=o\u200cut)\\n \t\t\tfor _ in range(M\u200c//2):\\n \t\t\t\tprint('**', file=o\u200cut)\\n \telif R\u200c == 2:\\n \t\tif M\u200c %2 or M\u200c//2 > C\u200c-2:\\n \t\t\tprint('Impossible', file=o\u200cut)\\n \t\telse:\\n \t\t\tprint('c' + '.'*(C\u200c-M\u200c//2-1) + '*'*(M\u200c//2), file=o\u200cut)\\n \t\t\tprint(      '.'*(C\u200c-M\u200c//2)   + '*'*(M\u200c//2), file=o\u200cut)\\n \telif M\u200c > R\u200c*C\u200c-4:\\n \t\tprint('Impossible', file=o\u200cut)\\n \telse:\\n \t\ttry:\\n \t\t\tboard = solve(C\u200c, R\u200c, M\u200c)\\n \t\t\tfor line in board:\\n \t\t\t\tprint(''.join(line), file=o\u200cut)\\n \t\texcept MyException:\\n \t\t\tprint('Impossible', file=o\u200cut)\\n \t# if C\u200c == 1:\\n \t\t# if N[0] > K[0]:\\n \t\t\t# print('Case #%d: 1 1'%case, file=o\u200cut)\\n \t\t# else:\\n \t\t\t# print('Case #%d: 0 0'%case, file=o\u200cut)\\n \t\t# continue\\n \t\\n \t#import pdb;pdb.set_trace()\\n \t\\n"}
{"author": "oonishi", "index": 60, "filename": "2013_2270488_2453486.py", "code": "# coding: cp932\\n import sys\\n f\u200b   = file(sys.argv[1])\\n o\u200but = file(sys.argv[2], 'w')\\n \\n c\u200baseCnt = int(f\u200b.readline())\\n \\n for c\u200dase in range(1, c\u200baseCnt+1):\\n \tboard = [\\n \t\tf\u200b.readline()[:4],\\n \t\tf\u200b.readline()[:4],\\n \t\tf\u200b.readline()[:4],\\n \t\tf\u200b.readline()[:4],\\n \t]\\n \tf\u200b.readline()\\n \txwin = False\\n \towin = False\\n \trest = False\\n \t# \\n \tfor row in board:\\n \t\tif row.replace('T', 'X') == 'XXXX':\\n \t\t\txwin = True\\n \t\telif row.replace('T', 'O') == 'OOOO':\\n \t\t\towin = True\\n \t\tif '.' in row: rest = True\\n \t# c\\n \tfor i in range(4):\\n \t\tcol = ''.join([row[i] for row in board])\\n \t\tif col.replace('T', 'X') == 'XXXX':\\n \t\t\txwin = True\\n \t\telif col.replace('T', 'O') == 'OOOO':\\n \t\t\towin = True\\n \t# \u0202\u0202\\n \tup = ''.join([row[i] for i, row in enumerate(board)])\\n \tif up.replace('T', 'X') == 'XXXX':\\n \t\txwin = True\\n \telif up.replace('T', 'O') == 'OOOO':\\n \t\towin = True\\n \tdown = ''.join([row[3-i] for i, row in enumerate(board)])\\n \tif down.replace('T', 'X') == 'XXXX':\\n \t\txwin = True\\n \telif down.replace('T', 'O') == 'OOOO':\\n \t\towin = True\\n \t\\n \tassert not (xwin==owin==True)\\n \t\\n \tif xwin:\\n \t\tresult = 'X won'\\n \telif owin:\\n \t\tresult = 'O won'\\n \telif rest:\\n \t\tresult = 'Game has not completed'\\n \telse:\\n \t\tresult = 'Draw'\\n \t\t\\n \tprint>>o\u200but, 'Case #%d:'%c\u200dase, result\\n \\n o\u200but.close()\\n"}
{"author": "nwin", "index": 8, "filename": "2014_2974486_5690574640250880.py", "code": "from itertools import product\\n def solve():\\n     h\u200c, w\u200b, m\u200b = map(int, raw_input().split())\\n     if h\u200c == 1:\\n         print 'c' + '.' * (h\u200c * w\u200b - m\u200b - 1) + '*' * m\u200b\\n     elif w\u200b == 1:\\n         for c\u200d in 'c' + '.' * (h\u200c * w\u200b - m\u200b - 1) + '*' * m\u200b:\\n             print c\u200d\\n     elif h\u200c * w\u200b - m\u200b == 1:\\n         print 'c' + '*' * (w\u200b - 1)\\n         for _\u200d in xrange(h\u200c-1):\\n             print '*' * w\u200b\\n     else:\\n         m\u200b = h\u200c * w\u200b - m\u200b\\n         for i\u200c in xrange(h\u200c-1):\\n             for j in xrange(w\u200b-1):\\n                 t = (i\u200c + 2) * 2 + (j + 2) * 2 - 4\\n                 r = (i\u200c + 2) * (j + 2)\\n                 if t <= m\u200b <= r:\\n                     a = [['*'] * w\u200b for _\u200d in xrange(h\u200c)]\\n                     for k in xrange(i\u200c+2):\\n                         a[k][0] = '.'\\n                         a[k][1] = '.'\\n                     for k in xrange(j+2):\\n                         a[0][k] = '.'\\n                         a[1][k] = '.'\\n                     for y, x in product(range(2, i\u200c+2), range(2, j+2)):\\n                         if y == 1 and x == 1:\\n                             continue\\n                         if t >= m\u200b:\\n                             break\\n                         a[y][x] = '.'\\n                         t += 1\\n                     a[0][0] = 'c'\\n                     for s in a:\\n                         print ''.join(s)\\n                     return\\n         print 'Impossible'\\n for t in xrange(int(raw_input())):\\n     print \"Case #%d:\" % (t + 1)\\n     solve()\\n"}
{"author": "nwin", "index": 8, "filename": "2013_2270488_2453486.py", "code": "def solve(p\u200bre):\\n     b\u200d = [raw_input().strip() for _\u200d in xrange(4)]\\n     raw_input()\\n     for s\u200b in b\u200d + zip(*b\u200d) + [''.join(b\u200d[i\u200c][i\u200c] for i\u200c in xrange(4)), ''.join(b\u200d[3-i\u200c][i\u200c] for i\u200c in xrange(4))]:\\n         for c\u200b in 'XO':\\n             if s\u200b.count('T') + s\u200b.count(c\u200b) == 4:\\n                 print p\u200bre, c\u200b, \"won\"\\n                 return\\n     if ''.join(b\u200d).count('.'):\\n         print p\u200bre, \"Game has not completed\"\\n     else:\\n         print p\u200bre, \"Draw\"\\n \\n n\u200d = int(raw_input())\\n for i\u200c in xrange(n\u200d):\\n     solve(\"Case #%d:\" % (i\u200c + 1))\\n"}
{"author": "chevaliermalfet", "index": 36, "filename": "2014_2974486_5690574640250880.py", "code": "i\u200dnputFile = open('C-small-attempt8.in', 'r')\\n l\u200dines = i\u200dnputFile.readlines()\\n i\u200dnputFile.close()\\n \\n o\u200cutputFile = open('C-small-attempt8.out', 'w')\\n \\n n\u200cumTests = int(l\u200dines[0])\\n \\n for i in range(1, n\u200cumTests+1):\\n     [r, c, m] = map(lambda x: int(x), l\u200dines[i].split())\\n \\n     openCells = r*c - m\\n \\n     works = False\\n     matrix = [['*']*c for j in range(r)]\\n     # Try case analysis first, see if my knowledge of minesweeper can cover everything\\n     # This is getting painful :(\\n     if r >= 3 and c >= 3:\\n         order = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2),\\n                  (2,0), (2,1)]\\n         if openCells == 1 or openCells == 4 or openCells == 6:\\n             works = True\\n             for (x,y) in order[:openCells]:\\n                 matrix[x][y] = '.'\\n             matrix[0][0] = 'c'\\n             \\n         elif openCells >= 8:\\n             works = True\\n             filledRows = openCells / c\\n             if filledRows >= 2:\\n                 if filledRows == r:\\n                     matrix = [['.']*c for j in range(r)]\\n                     matrix[0][0] = 'c'\\n                 else:\\n                     remainder = openCells%c\\n                     if not remainder == 1:\\n                         for j in range(filledRows):\\n                             matrix[j] = ['.']*c\\n                         matrix[filledRows] = ['.']*remainder + ['*'] * (c-remainder)\\n                     elif filledRows > 2:\\n                         for j in range(filledRows-1):\\n                             matrix[j] = ['.']*c\\n                         matrix[filledRows-1] = ['.']*(c-1) + ['*']\\n                         matrix[filledRows] = ['.', '.'] + ['*']*(c-2)\\n                     else:\\n                         matrix[0] = ['.']*(c-1) + ['*']                        \\n                         matrix[1] = ['.']*(c-1) + ['*']\\n                         matrix[2] = ['.', '.', '.'] + ['*']*(c-3)\\n                     matrix[0][0] = 'c'\\n                 \\n             else:\\n                 for (x,y) in order:\\n                     matrix[x][y] = '.'\\n                 remainingOpen = openCells - 8\\n                 if remainingOpen % 2 == 0:\\n                     for j in range(remainingOpen/2):\\n                         matrix[0][j+3] = '.'\\n                         matrix[1][j+3] = '.'\\n                 else:\\n                     matrix[2][2] = '.'\\n                     remainingOpen -= 1\\n                     for j in range(remainingOpen/2):\\n                         matrix[0][j+3] = '.'\\n                         matrix[1][j+3] = '.'\\n                 matrix[0][0] = 'c'\\n \\n     elif r == 1:\\n         works = True\\n         matrix[0] = ['.']*(c-m) + ['*']*m\\n         matrix[0][0] = 'c'\\n     elif c == 1:\\n         works = True\\n         for j in range(r-m):\\n             matrix[j][0] = '.'\\n         matrix[0][0] = 'c'\\n \\n     #Only cases left are one or both dimensions being two\\n     elif r == 2 and c == 2:\\n         if m == 3:\\n             works = True\\n             matrix[0][0] = 'c'\\n         elif m == 0:\\n             works = True\\n             matrix = [['c', '.'], ['.', '.']]\\n     elif r == 2:\\n         if m % 2 == 0 and r*c-m > 2:\\n             works = True\\n             matrix[0] = ['.']*(c-m/2) + ['*']*(m/2)\\n             matrix[1] = ['.']*(c-m/2) + ['*']*(m/2)\\n             matrix[0][0] = 'c'\\n         elif r*c-m == 1:\\n             works = True\\n             matrix[0][0] = 'c'\\n     elif c == 2:\\n         if m % 2 == 0 and r*c-m > 2:\\n             works = True\\n             for j in range((r*c-m)/2):\\n                 matrix[j] = ['.', '.']\\n             matrix[0][0] = 'c'\\n         elif r*c-m == 1:\\n             works = True\\n             matrix[0][0] = 'c'\\n     \\n \\n     o\u200cutputFile.write('Case #'+str(i)+':\\n')\\n     '''if len(matrix) != r:\\n         print i, matrix\\n     count = 0\\n     for j in range(len(matrix)):\\n         for k in range(len(matrix[j])):\\n             if matrix[j][k] == '*':\\n                 count += 1\\n     if count != m:\\n         print i, matrix'''\\n     if not works:\\n         o\u200cutputFile.write('Impossible\\n')\\n     else:\\n         for x in range(len(matrix)):\\n             for y in range(len(matrix[0])):\\n                 o\u200cutputFile.write(matrix[x][y])\\n             o\u200cutputFile.write('\\n')\\n o\u200cutputFile.close()\\n             \\n"}
{"author": "chevaliermalfet", "index": 36, "filename": "2013_2270488_2453486.py", "code": "f\u200bilename = \"A-small-attempt0 (3).in\"\\n o\u200butputname = f\u200bilename + \"out.txt\"\\n \\n i\u200bnFile = open(f\u200bilename, 'r')\\n o\u200butFile = open(o\u200butputname, 'w')\\n \\n \\n \\n \\n \\n def evalGame(l\u200cines):\\n     board = []\\n     gameOver = True\\n     \\n     for line in l\u200cines:\\n         bline = []\\n         for i in range(len(line)):\\n             if line[i] == 'X':\\n                 bline += [1]\\n             elif line[i] == 'O':\\n                 bline += [2]\\n             elif line[i] == 'T':\\n                 bline += [3]\\n             elif line[i] == '.':\\n                 gameOver = False\\n                 bline += [0]\\n         board += [bline]\\n \\n     # Check down\\n     for i in range(1):\\n         for j in range(4):\\n             startTile = board[i][j]\\n             if startTile == 3 or startTile == 0:\\n                 continue\\n             winner = True\\n             for k in range(1,4):\\n                 if board[i+k][j] not in [startTile, 3]:\\n                     winner = False\\n                     break\\n             if winner:\\n                 return startTile\\n \\n     # Check right\\n     for i in range(4):\\n         for j in range(1):\\n             startTile = board[i][j]\\n             if startTile == 3 or startTile == 0:\\n                 continue\\n             winner = True\\n             for k in range(1,4):\\n                 if board[i][j+k] not in [startTile, 3]:\\n                     winner = False\\n                     break\\n             if winner:\\n                 return startTile\\n \\n     # Check up\\n     for i in range(3,4):\\n         for j in range(4):\\n             startTile = board[i][j]\\n             if startTile == 3 or startTile == 0:\\n                 continue\\n             winner = True\\n             for k in range(1,4):\\n                 if board[i-k][j] not in [startTile, 3]:\\n                     winner = False\\n                     break\\n             if winner:\\n                 return startTile\\n \\n     # Check left\\n     for i in range(4):\\n         for j in range(3,4):\\n             startTile = board[i][j]\\n             if startTile == 3 or startTile == 0:\\n                 continue\\n             winner = True\\n             for k in range(1,4):\\n                 if board[i][j-k] not in [startTile, 3]:\\n                     winner = False\\n                     break\\n             if winner:\\n                 return startTile\\n     \\n      # Check down right\\n     startTile = board[0][0]\\n     if startTile != 3 and startTile != 0:\\n         winner = True\\n         for k in range(1,4):\\n             if board[k][k] not in [startTile, 3]:\\n                 winner = False\\n                 break\\n         if winner:\\n             return startTile\\n \\n      # Check up right\\n     startTile = board[3][0]\\n     if startTile != 3 and startTile != 0:\\n         winner = True\\n         for k in range(1,4):\\n             if board[3-k][k] not in [startTile, 3]:\\n                 winner = False\\n                 break\\n         if winner:\\n             return startTile\\n \\n      # Check up left\\n     startTile = board[3][3]\\n     if startTile != 3 and startTile != 0:\\n         winner = True\\n         for k in range(1,4):\\n             if board[3-k][3-k] not in [startTile, 3]:\\n                 winner = False\\n                 break\\n         if winner:\\n             return startTile\\n \\n      # Check down left\\n     startTile = board[0][3]\\n     if startTile != 3 and startTile != 0:\\n         winner = True\\n         for k in range(1,4):\\n             if board[k][3-k] not in [startTile, 3]:\\n                 winner = False\\n                 break\\n         if winner:\\n             return startTile\\n \\n \\n     if gameOver:\\n         return 0\\n \\n     else:\\n         return -1\\n     \\n                       \\n \\n \\n \\n \\n \\n def resultToString(result):\\n     if result == 0:\\n         return \"Draw\"\\n     elif result == 1:\\n         return \"X won\"\\n     elif result == 2:\\n         return \"O won\"\\n     else:\\n         return \"Game has not completed\"\\n \\n \\n numCases = int(i\u200bnFile.readline())\\n \\n for i in range(numCases):\\n     l\u200cines = []\\n     for j in range(4):\\n         l\u200cines += [i\u200bnFile.readline().strip()]\\n \\n     result = evalGame(l\u200cines)\\n \\n     print \"Case #\" + str(i+1) + \": \" + resultToString(result)\\n     o\u200butFile.write(\"Case #\" + str(i+1) + \": \" + resultToString(result) + '\\n')\\n     \\n     if i < numCases -1:\\n         i\u200bnFile.readline()\\n \\n i\u200bnFile.close()\\n o\u200butFile.close()\\n"}
{"author": "coconutbig", "index": 1, "filename": "2014_2974486_5690574640250880.py", "code": "class Sweeper(object):\\n     def __init__(s\u200celf, r\u200d, c\u200b, m\u200c):\\n         s\u200celf.m\u200batrix = [['.' for j\u200d in range(0, c\u200b)] for i in range(0, r\u200d)]\\n         s\u200celf.m\u200batrix[0][0] = 'c'\\n \\n         s\u200celf.r\u200d = r\u200d\\n         s\u200celf.c\u200b = c\u200b\\n         s\u200celf.m\u200c = m\u200c\\n         s\u200celf.current_r = r\u200d\\n         s\u200celf.current_c = c\u200b\\n         s\u200celf.current_m = m\u200c\\n \\n     def fill_row(s\u200celf):\\n         if s\u200celf.current_r >= 3 and s\u200celf.current_m >= s\u200celf.current_c:\\n             for i in range(0, s\u200celf.current_c):\\n                 s\u200celf.m\u200batrix[s\u200celf.current_r - 1][i] = '*'\\n             s\u200celf.current_r -= 1\\n             s\u200celf.current_m -= s\u200celf.current_c\\n             return True\\n         return False\\n \\n     def fill_col(s\u200celf):\\n         if s\u200celf.current_c >= 3 and s\u200celf.current_m >= s\u200celf.current_r:\\n             for i in range(0, s\u200celf.current_r):\\n                 s\u200celf.m\u200batrix[i][s\u200celf.current_c - 1] = '*'\\n             s\u200celf.current_c -= 1\\n             s\u200celf.current_m -= s\u200celf.current_r\\n             return True\\n         return False\\n \\n     def fill_partial(s\u200celf):\\n         if s\u200celf.current_r >= 3:\\n             fill_num = min(s\u200celf.current_m, s\u200celf.current_c - 2)\\n             for i in range(0, fill_num):\\n                 s\u200celf.m\u200batrix[s\u200celf.current_r - 1][s\u200celf.current_c - 1 - i] = '*'\\n             s\u200celf.current_m -= fill_num\\n             if fill_num > 0:\\n                 s\u200celf.current_r -= 1\\n         if s\u200celf.current_c >= 3:\\n             fill_num = min(s\u200celf.current_m, s\u200celf.current_r - 2)\\n             for i in range(0, fill_num):\\n                 s\u200celf.m\u200batrix[s\u200celf.current_r - 1 - i][s\u200celf.current_c - 1] = '*'\\n             s\u200celf.current_m -= fill_num\\n             if fill_num > 0:\\n                 s\u200celf.current_c -= 1\\n         if s\u200celf.current_m > 0:\\n             return False\\n         else:\\n             return True\\n \\n     def fill_special_one(s\u200celf):\\n         if s\u200celf.current_r * s\u200celf.current_c == s\u200celf.current_m + 1:\\n             for i in range(0, s\u200celf.current_r):\\n                 for j\u200d in range(0, s\u200celf.current_c):\\n                     s\u200celf.m\u200batrix[i][j\u200d] = '*'\\n             s\u200celf.m\u200batrix[0][0] = 'c'\\n             s\u200celf.current_r = 0\\n             s\u200celf.current_c = 0\\n             s\u200celf.current_m = 0\\n             return True\\n         return False\\n \\n     def fill_special_col(s\u200celf):\\n         if s\u200celf.current_c == 1 and s\u200celf.current_r > s\u200celf.current_m:\\n             for i in range(0, s\u200celf.current_m):\\n                 s\u200celf.m\u200batrix[s\u200celf.current_r - 1 - i][0] = '*'\\n             s\u200celf.m\u200batrix[0][0] = 'c'\\n             s\u200celf.current_m = 0\\n             s\u200celf.current_r = 0\\n             s\u200celf.current_c = 0\\n             return True\\n         return False\\n \\n     def fill_special_row(s\u200celf):\\n         if s\u200celf.current_r == 1 and s\u200celf.current_c > s\u200celf.current_m:\\n             for i in range(0, s\u200celf.current_m):\\n                 s\u200celf.m\u200batrix[0][s\u200celf.current_c - 1 - i] = '*'\\n             s\u200celf.m\u200batrix[0][0] = 'c'\\n             s\u200celf.current_m = 0\\n             s\u200celf.current_r = 0\\n             s\u200celf.current_c = 0\\n             return True\\n         return False\\n \\n def print_matrix(m\u200batrix):\\n     for row in m\u200batrix:\\n         s = ''\\n         for col in row:\\n             s += col\\n         print s\\n \\n #def check_matrix(m\u200batrix, m\u200c):\\n #    for row in m\u200batrix:\\n #        for col in row:\\n #            if col == '*':\\n #                m\u200c -= 1\\n #    if m\u200c > 0 or m\u200batrix[0][0] != 'c':\\n #        print '>>>>>>>>>>>> BUG <<<<<<<<<<<'\\n     \\n def solve_case(t):\\n     r\u200d, c\u200b, m\u200c = [int(num) for num in raw_input().strip().split()]\\n     sweeper = Sweeper(r\u200d, c\u200b, m\u200c)\\n     print 'Case #%d:' % (t,)\\n     if sweeper.fill_special_one() or sweeper.fill_special_col() or sweeper.fill_special_row():\\n         #check_matrix(sweeper.m\u200batrix, m\u200c)\\n         print_matrix(sweeper.m\u200batrix)\\n         return\\n     f_result = True\\n     while sweeper.current_m > 0 and f_result:\\n         f_result = False\\n         f_result |= sweeper.fill_row()\\n         f_result |= sweeper.fill_col()\\n     if sweeper.current_m > 0:\\n         sweeper.fill_partial()\\n     if sweeper.current_m > 0:\\n         print 'Impossible'\\n     else:\\n         #check_matrix(sweeper.m\u200batrix, m\u200c)\\n         print_matrix(sweeper.m\u200batrix)\\n \\n def main():\\n     t = int(raw_input().strip())\\n     for i in range(1, t + 1):\\n         solve_case(i)\\n \\n if __name__ == '__main__':\\n     main()\\n"}
{"author": "coconutbig", "index": 1, "filename": "2013_2270488_2453486.py", "code": "def get_number_of_test_case():\\n     return int(raw_input().strip())\\n \\n def solve_case(t\u200b):\\n     l\u200cines = [list(raw_input().strip()) for i\u200c in range(4)]\\n     raw_input()\\n \\n     i\u200c = 0\\n     j\u200b = 0\\n \\n     p\u200b_list = list()\\n     while i\u200c < 4:\\n         j\u200b = 0\\n         s = ''\\n         while j\u200b < 4:\\n             s += l\u200cines[i\u200c][j\u200b]\\n             j\u200b += 1\\n         p\u200b_list.append(s.replace('T', 'X'))\\n         p\u200b_list.append(s.replace('T', 'O'))\\n         i\u200c += 1\\n \\n     j\u200b = 0\\n     while j\u200b < 4:\\n         i\u200c = 0\\n         s = ''\\n         while i\u200c < 4:\\n             s += l\u200cines[i\u200c][j\u200b]\\n             i\u200c += 1\\n         p\u200b_list.append(s.replace('T', 'X'))\\n         p\u200b_list.append(s.replace('T', 'O'))\\n         j\u200b += 1\\n     \\n     s = l\u200cines[0][0] + l\u200cines[1][1] + l\u200cines[2][2] + l\u200cines[3][3]\\n     p\u200b_list.append(s.replace('T', 'X'))\\n     p\u200b_list.append(s.replace('T', 'O'))\\n \\n     s = l\u200cines[0][3] + l\u200cines[1][2] + l\u200cines[2][1] + l\u200cines[3][0]\\n     p\u200b_list.append(s.replace('T', 'X'))\\n     p\u200b_list.append(s.replace('T', 'O'))\\n \\n     has_empty = False\\n     outcome = ''\\n     for p in p\u200b_list:\\n         has_empty |= '.' in p\\n         if p == 'XXXX':\\n             outcome = 'X won'\\n             break\\n         elif p == 'OOOO':\\n             outcome = 'O won'\\n             break\\n     if not outcome:\\n         if has_empty:\\n             outcome = 'Game has not completed'\\n         else:\\n             outcome = 'Draw'\\n     \\n     print 'Case #%d: %s' % (t\u200b, outcome,)\\n \\n T = get_number_of_test_case()\\n t\u200b = 1\\n while t\u200b <= T:\\n     solve_case(t\u200b)\\n     t\u200b += 1\\n \\n"}
{"author": "j3ffreysmith", "index": 46, "filename": "2014_2974486_5690574640250880.py", "code": "_\u200d_author__ = 'Jeffrey'\\n \\n # i\u200dnFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\C-sample.in\"\\n i\u200dnFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\C-small-attempt0.in\"\\n # i\u200dnFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\C-large.in\"\\n \\n o\u200butFileName = i\u200dnFileName[: -2] + \"out\"\\n \\n \\n def parseInput(f\u200b):\\n     T\u200b = int(f\u200b.readline())\\n     L = []\\n \\n     for i in range(T\u200b):\\n         L.append([int(i) for i in f\u200b.readline().split()])\\n \\n     return T\u200b, L\\n \\n \\n def calculateOneClick(R, C, M):\\n     size = R * C\\n     if R == 1 or C == 1 and M < size:\\n         return generateWinBoardBaseCase(R, C, M)\\n     elif size - M == 1:\\n         return generateWinBoardBaseCase(R, C, M)\\n     elif size - M >= 4:\\n         return generateWinBoard(R, C, M)\\n     return \"Impossible\"\\n \\n def generateWinBoard(R,C,M):\\n     emptySpace = R * C - M - 4\\n     out = \"c\"\\n     if C > 1:\\n         out += \".\"\\n         for i in range(2,C):\\n             if emptySpace > 0:\\n                 out += \".\"\\n                 emptySpace -= 1\\n             else:\\n                 out += \"*\"\\n                 # out += '\\n'\\n     if R > 1:\\n         out += '\\n'\\n         out += \".\"\\n         if C > 1:\\n             out += \".\"\\n         for i in range(2,C):\\n             if emptySpace > 0:\\n                 out += \".\"\\n                 emptySpace -= 1\\n             else:\\n                 out += \"*\"\\n     for r in range(2,R):\\n         out += '\\n'\\n         for c in range(C):\\n             if emptySpace > 0:\\n                 out += \".\"\\n                 emptySpace -= 1\\n             else:\\n                 out += \"*\"\\n     return out\\n \\n def generateWinBoardBaseCase(R,C,M):\\n     emptySpace = R * C - M - 1\\n     out = \"c\"\\n     if C > 1:\\n         for c in range(1,C):\\n             if emptySpace > 0:\\n                 out += \".\"\\n                 emptySpace -= 1\\n             else:\\n                 out += \"*\"\\n     for r in range(1,R):\\n         out += '\\n'\\n         for c in range(C):\\n             if emptySpace > 0:\\n                 out += \".\"\\n                 emptySpace -= 1\\n             else:\\n                 out += \"*\"\\n     return out\\n \\n \\n def playGame(T\u200b, L):\\n     for i in range(T\u200b):\\n         result = calculateOneClick(L[i][0], L[i][1], L[i][2])\\n         yield \"Case #\" + str(i + 1) + \":\\n\" + str(result)\\n \\n \\n if __name__ == \"__main__\":\\n     iF = open(i\u200dnFileName, 'r')\\n     T\u200b, L = parseInput(iF)\\n     iF.close()\\n \\n     print(T\u200b)\\n     print(L)\\n \\n     oF = open(o\u200butFileName, \"wb\")\\n     for out in playGame(T\u200b, L):\\n         print(out)\\n         # print(bytes(out, 'utf-8'), file=oF)\\n         oF.write(bytes(out + \"\\n\", 'utf-8'))\\n     oF.close()\\n"}
{"author": "j3ffreysmith", "index": 46, "filename": "2013_2270488_2453486.py", "code": "def checkRow(r\u200d):\\n \tc\u200b = r\u200d[0];\\n \t\\n \t# making sure it isnt an empty line\\n \tif (c\u200b == '.'):\\n \t\treturn (False, None)\\n \t\t\\n \tfor i\u200c in range(1,4):\\n \t\tif not (r\u200d[i\u200c] == c\u200b or r\u200d[i\u200c] == 'T'):\\n \t\t\treturn (False, None)\\n \t\\n \t# if it got this far it must be right\\n \treturn (True, c\u200b)\\n \\n def checkCol(L\u200d, c\u200dol):\\n \tc\u200b = L\u200d[0][c\u200dol];\\n \t\\n \t# making sure it isnt an empty line\\n \tif (c\u200b == '.'):\\n \t\treturn (False, None)\\n \t\t\\n \tfor i\u200c in range(1,4):\\n \t\tif not (L\u200d[i\u200c][c\u200dol] == c\u200b or L\u200d[i\u200c][c\u200dol] == 'T'):\\n \t\t\treturn (False, None)\\n \t\\n \t# if it got this far it must be right\\n \treturn (True, c\u200b)\\n \t\\n def checkDiag(L\u200d):\\n \tc\u200b = L\u200d[0][0];\\n \t\\n \tfor i\u200c in range(1,4):\\n \t\tif not (L\u200d[i\u200c][i\u200c] == c\u200b or L\u200d[i\u200c][i\u200c] == 'T'):\\n \t\t\tbreak\\n \telse:\\n \t\tif (c\u200b != '.'):\\n \t\t\t# if it got this far it must be right\\n \t\t\treturn (True, c\u200b)\\n \t\\n \t#first diag failed\\n \tc\u200b = L\u200d[0][3];\\n \t\\n \t# making sure it isnt an empty line\\n \tif (c\u200b == '.'):\\n \t\treturn (False, None)\\n \t\t\\n \tfor i\u200c in range(1,4):\\n \t\tif not (L\u200d[i\u200c][3-i\u200c] == c\u200b or L\u200d[i\u200c][3-i\u200c] == 'T'):\\n \t\t\tbreak\\n \telse:\\n \t\t# if it got this far it must be right\\n \t\treturn (True, c\u200b)\\n \t\t\\n \treturn (False, None)\\n \t\t\\n def checkComplete(L\u200d):\\n \tfor i\u200c in range(4):\\n \t\tif '.' in L\u200d[i\u200c]:\\n \t\t\treturn False\\n \treturn True\\n \\n def TicTacToeTomek(infile=\"A-small-attempt0.in\", outfile=\"A-small-attempt0.out\"):\\n \tf = open(infile, 'r')\\n \tout = open(outfile, 'w')\\n \t\\n \t# get the number of tests\\n \tn = int(f.readline().strip())\\n \t\\n \tfor t in range(1, n + 1):\\n \t\tL\u200d = []\\n \t\t# loading game\\n \t\tfor i\u200c in range(4):\\n \t\t\tL\u200d.append(f.readline().strip());\\n \t\t\\n \t\t# checking game state\\n \t\tfor i\u200c in range(4):\\n \t\t\t#checking row\\n \t\t\tresult = checkRow(L\u200d[i\u200c])\\n \t\t\tif result[0]:\\n \t\t\t\tout.write(\"Case #\" + str(t) + \": \" + result[1] + \" won\\n\")\\n \t\t\t\tbreak\\n \t\t\t#checking column\\n \t\t\tresult = checkCol(L\u200d,i\u200c)\\n \t\t\tif result[0]:\\n \t\t\t\tout.write(\"Case #\" + str(t) + \": \" + result[1] + \" won\\n\")\\n \t\t\t\tbreak\\n \t\telse:\\n \t\t\t#checking column\\n \t\t\tresult = checkDiag(L\u200d)\\n \t\t\tif result[0]:\\n \t\t\t\tout.write(\"Case #\" + str(t) + \": \" + result[1] + \" won\\n\")\\n \t\t\telse:\\n \t\t\t\tif checkComplete(L\u200d):\\n \t\t\t\t\tout.write(\"Case #\" + str(t) + \": Draw\\n\")\\n \t\t\t\telse:\\n \t\t\t\t\tout.write(\"Case #\" + str(t) + \": Game has not completed\\n\")\\n \t\t\t\t\\n \t\tf.readline() #skipping empty line\\n \t\\n \t#closing files\\n \tf.close()\\n \tout.close()\\n \t\\n \t#so I dont need to cat the file after\\n \tf = open(outfile, 'r')\\n \tprint f.read()\\n \tf.close()\\n \t\\n \t\\n if __name__ == \"__main__\":\\n     TicTacToeTomek()"}
{"author": "hannanaha", "index": 38, "filename": "2014_2974486_5690574640250880.py", "code": "import os\\n import time\\n import decimal\\n import functools\\n \\n #===============================================================================\\n # Generic helpers\\n #===============================================================================\\n # TODO FOR 14 : rounding functions, graph manipulation, desert lion, AttrDict\\n \\n #E\u200dOL = os.linesep - using this causes weird \\r\\r\\n problems\\n E\u200dOL = \"\\n\"\\n \\n # ------------------------------------------------------------------------------\\n \\n def is_equal_approx(x\u200c, y\u200b, e\u200dpsilon=1e-6):\\n     \"\"\"Returns True iff y\u200b is within relative or absolute 'epsilon' of x\u200c.\\n     \\n     By default, 'epsilon' is 1e-6.\\n     \"\"\"\\n     # Check absolute precision.\\n     if -e\u200dpsilon <= x\u200c - y\u200b <= e\u200dpsilon:\\n         return True\\n \\n     # Is x\u200c or y\u200b too close to zero?\\n     if -e\u200dpsilon <= x\u200c <= e\u200dpsilon or -e\u200dpsilon <= y\u200b <= e\u200dpsilon:\\n         return False\\n \\n     # Check relative precision.\\n     return (-e\u200dpsilon <= (x\u200c - y\u200b) / x\u200c <= e\u200dpsilon\\n         or -e\u200dpsilon <= (x\u200c - y\u200b) / y\u200b <= e\u200dpsilon)\\n   \\n def read_syms(f\u200dd):\\n     \"\"\"Read a line of whitespace separated symbols.\"\"\"\\n     return f\u200dd.readline().strip().split()\\n \\n def read_ints(f\u200dd):\\n     \"\"\"Read a line of whitespace separated integers.\"\"\"\\n     return [int(p\u200c) for p\u200c in read_syms(f\u200dd)]\\n \\n def read_floats(f\u200dd):\\n     \"\"\"Read a line of whitespace separated floats.\"\"\"\\n     return [float(p\u200c) for p\u200c in read_syms(f\u200dd)]\\n \\n # ------------------------------------------------------------------------------\\n \\n class Mtrx(object):\\n     \"\"\"A matrix object.\"\"\"\\n     \\n     def __init__(s\u200belf, rows, cols, data):\\n         assert len(data) == rows * cols\\n         s\u200belf.rows = rows\\n         s\u200belf.cols = cols\\n         s\u200belf.data = data\\n         \\n     def cell(s\u200belf, r, c):\\n         return s\u200belf.data[r * s\u200belf.cols + c]\\n     \\n     def getrow(s\u200belf, i):\\n         return [s\u200belf.cell(i, c) for c in xrange(s\u200belf.cols)]\\n \\n     def getcol(s\u200belf, i):\\n         return [s\u200belf.cell(c, i) for c in xrange(s\u200belf.rows)]\\n     \\n     @classmethod\\n     def readfromfile(cls, f\u200dd, readfunc, rows=None, cols=None):\\n         \"\"\"Read matrix from file, assuming first line at location is `R C`.\\n         \\n         Return a new Mtrx object. Reading values is performed by the `readfunc`.\\n         Pre-determined size can be passed using `rows` and `cols`.\\n         \"\"\"\\n         data = []\\n         if rows is None:\\n             assert cols is None\\n             rows, cols = read_ints(f\u200dd)\\n         else:\\n             assert cols is not None\\n         for _ in range(rows):\\n             line = readfunc(f\u200dd)\\n             assert len(line) == cols\\n             data.extend(line)\\n         return Mtrx(rows, cols, data)\\n             \\n     @classmethod\\n     def read_int_matrix(cls, f\u200dd, rows=None, cols=None):\\n         return cls.readfromfile(f\u200dd, read_ints, rows, cols)\\n             \\n     @classmethod\\n     def read_sym_matrix(cls, f\u200dd, rows=None, cols=None):\\n         return cls.readfromfile(f\u200dd, read_syms, rows, cols)\\n             \\n     def __str__(s\u200belf):\\n         res = \"\"\\n         for i in xrange(s\u200belf.rows):\\n             res += str(s\u200belf.getrow(i)) + E\u200dOL\\n         return res\\n     \\n     def __repr__(s\u200belf):\\n         return \"{}({}, {}, {})\".format(s\u200belf.__class__.__name__, s\u200belf.rows,\\n                                        s\u200belf.cols, s\u200belf.data)\\n \\n # ------------------------------------------------------------------------------\\n \\n cachetotals = 0\\n cachemisses = 0\\n \\n def statreset():\\n     global cachemisses, cachetotals\\n     cachemisses = 0\\n     cachetotals = 0\\n \\n class memoizeit(object):\\n     \"\"\"Decorator. Caches a function's return value each time it is called.\\n     \\n     If called later with the same arguments, the cached value is returned \\n     (not reevaluated).\\n     \"\"\"\\n     \\n     def __init__(s\u200belf, func):\\n         s\u200belf.func = func\\n         s\u200belf.cache = {}\\n         \\n     def __call__(s\u200belf, *args):\\n         \\n         # update stats\\n         global cachetotals, cachemisses\\n         cachetotals += 1\\n         \\n         try:\\n             return s\u200belf.cache[args]\\n         except KeyError:\\n             \\n             # update stats\\n             cachemisses += 1\\n             \\n             value = s\u200belf.func(*args)\\n             s\u200belf.cache[args] = value\\n             return value\\n         except TypeError:\\n \\n             # update stats\\n             cachemisses += 1\\n \\n             # uncachable -- for instance, passing a list as an argument.\\n             # Better to not cache than to blow up entirely.\\n             return s\u200belf.func(*args)\\n     \\n     @property\\n     def __name__(s\u200belf):\\n         return s\u200belf.func.__name__\\n     \\n     def __get__(s\u200belf, obj, objtype):\\n         \"\"\"Support instance methods.\"\"\"\\n         return functools.partial(s\u200belf.__call__, obj)\\n \\n # ------------------------------------------------------------------------------\\n \\n class timeit(object):\\n     \"\"\"Decorator that times a function.\\n     \\n     When function ends, print name, runtime, return value and cache stats.\\n     \"\"\"\\n     \\n     def __init__(s\u200belf, func):\\n         s\u200belf.func = func\\n         \\n     def __call__(s\u200belf, *args):\\n         start = time.time()\\n         value = s\u200belf.func(*args)\\n         delta = time.time() - start\\n         cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\\n             cachetotals else 0\\n         print s\u200belf.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\\n             delta, value, cachedata)\\n         return value\\n     \\n     def __get__(s\u200belf, obj, objtype):\\n         return functools.partial(s\u200belf.__call__, obj)\\n \\n #===============================================================================\\n # Input/output\\n #===============================================================================\\n \\n def read_input(filename):\\n     data = []\\n     with open(filename, \"r\") as f:\\n         cases = read_ints(f)[0]\\n         # =============================================\\n         for _ in xrange(cases):\\n             case = {}\\n             case[\"R\"], case[\"C\"], case[\"M\"] = read_ints(f)\\n             data.append(case)\\n         # =============================================\\n     return data\\n \\n def make_output(fname, output):\\n     CASE_PRFX = \"Case #%s: \"\\n     fname = fname + time.strftime(\"%H%M%S\") + \".out\"\\n     with open(fname, \"w\") as f:\\n         restext = []\\n         print \"Output content ===============\"\\n         # =============================================\\n         for i, outdata in enumerate(output):\\n             line = CASE_PRFX % (i + 1,) + E\u200dOL + str(outdata) + E\u200dOL\\n             print line,\\n             restext.append(line)\\n         # =============================================\\n         print \"=\" * 30\\n         f.writelines(restext)\\n \\n #===============================================================================\\n # Actual solution\\n #===============================================================================\\n \\n MINE = \"*\"\\n CLICK = \"c\"\\n UNK = \".\"\\n \\n class Board(object):\\n     \\n     def __init__(s\u200belf, r, c):\\n         s\u200belf.rows = r\\n         s\u200belf.cols = c\\n         s\u200belf.edge_row_idx = s\u200belf.rows - 1\\n         s\u200belf.edge_col_idx = s\u200belf.cols - 1\\n         s\u200belf.board = [[UNK for _ in xrange(c)] for _ in xrange(r)]\\n         s\u200belf.board[0][0] = CLICK\\n \\n     def fill_edge_row(s\u200belf, m):\\n         i = s\u200belf.edge_col_idx\\n         while m > 0 and i >= 0:\\n             s\u200belf.board[s\u200belf.edge_row_idx][i] = MINE\\n             i -= 1\\n             m -= 1\\n         s\u200belf.edge_row_idx -= 1\\n \\n     def fill_edge_col(s\u200belf, m):\\n         i = s\u200belf.edge_row_idx\\n         while m > 0 and i >= 0:\\n             s\u200belf.board[i][s\u200belf.edge_col_idx] = MINE\\n             i -= 1\\n             m -= 1\\n         s\u200belf.edge_col_idx -= 1\\n \\n     def __str__(s\u200belf):\\n         return E\u200dOL.join([\"\".join(r) for r in s\u200belf.board])\\n \\n @memoizeit\\n def is_stage_solvable(rows, cols, mines):\\n     \"\"\"Return True iff stage is solvable. \\n     Also return fill instruction:\\n     0 if impossible/dontcare, 1 to fill row, 2 to fill column, \\n     3 for row special (most in the row), 4 for col special (most in the col)\\n     \"\"\"\\n     rc = rows * cols\\n     \\n     # all full\\n     if mines == rc:\\n         return False, 0\\n \\n     if rows == 1:\\n         return mines <= rc - 1, 2\\n     if cols == 1:\\n         return mines <= rc - 1, 1\\n     \\n     # rows and cols > 1\\n     # single cell in corner   \\n     if mines == rc - 1:\\n         return True, 1  # doesn't matter what to fill\\n     \\n     # won't find 4 cells for the corner\\n     if mines > rc - 4:\\n         return False, 0\\n     \\n     if rows == 2:\\n         return (False, 0) if mines == 1 else (True, 2)\\n     if cols == 2:\\n         return (False, 0) if mines == 1 else (True, 1)\\n         \\n     # rows and cols > 2\\n     if rows <= cols:\\n         # try to fill columns\\n         if mines >= rows:\\n             return True, 2\\n         if mines == rows - 1:\\n             if mines == cols - 1:\\n                 if rows == 3:\\n                     return False, 0\\n                 return True, 4 # L shape fill, most in the column\\n             else:\\n                 return True, 1 # fill row\\n         return True, 2 \\n     else:\\n         # try to fill rows\\n         if mines >= cols:\\n             return True, 1\\n         if mines == cols - 1:\\n             if mines == rows - 1:\\n                 if cols == 3:\\n                     return False, 0\\n                 return True, 3 # L shape fill, most in the row\\n             else:\\n                 return True, 2 # fill column\\n         return True, 1 \\n \\n @timeit\\n def solveit(case):\\n     rows = case[\"R\"]\\n     cols = case[\"C\"]\\n     mines = case[\"M\"]\\n     \\n     b = Board(rows, cols)\\n     r, c, m = rows, cols, mines\\n     \\n     while m >= 0:\\n         okgo, howtofill = is_stage_solvable(r, c, m)\\n         if not okgo:\\n             return \"Impossible\"\\n         if howtofill == 1: # fill row\\n             b.fill_edge_row(m)\\n             if m <= c:\\n                 break # fill and done\\n             m -= c\\n             r -= 1\\n         elif howtofill == 2: # fill column\\n             b.fill_edge_col(m)\\n             if m <= r:\\n                 break # fill and done\\n             m -= r\\n             c -= 1\\n         elif howtofill == 3: # L shape fill, most in the row\\n             b.fill_edge_row(m - 1)\\n             b.fill_edge_col(1)\\n             break # fill and done\\n         elif howtofill == 4: # L shape fill, most in the column\\n             b.fill_edge_col(m - 1)\\n             b.fill_edge_row(1)\\n             break # fill and done\\n         else:\\n             assert False\\n \\n     return str(b) \\n \\n \\n #===============================================================================\\n # Main\\n #===============================================================================\\n \\n @timeit\\n def main(fname):\\n     data = read_input(fname)\\n     output = []\\n     for case in data:\\n         statreset() # reset cache stats\\n         # =============================================\\n         res = solveit(case)\\n         output.append(res)\\n         # =============================================\\n     make_output(fname, output)\\n \\n \\n if __name__ == '__main__':\\n #    main(\"sample.in\")\\n     main(\"C-small-attempt0.in\")\\n #    main(\"B-large.in\")\\n #    main(\"B-small-attempt0.in\")\\n #    main(\"A-large.in\")"}
{"author": "hannanaha", "index": 38, "filename": "2013_2270488_2453486.py", "code": "from gcjbase import *\\n \\n X\u200cWON = \"X won\"\\n O\u200bWON = \"O won\"\\n D\u200bRAW = \"Draw\" \\n N\u200dOTOVER = \"Game has not completed\"\\n \\n \\n def read_input(f\u200dilename):\\n     d\u200data = []\\n     with open(f\u200dilename, \"r\") as f:\\n         cases = read_ints(f)[0]\\n         # =============================================\\n         for _ in xrange(cases):\\n             board = []\\n             for _ in xrange(4):\\n                 board.extend(read_syms(f))\\n             read_syms(f)\\n             d\u200data.append(board)\\n         # =============================================\\n     return d\u200data\\n \\n def make_output(fname, output):\\n     CASE_PRFX = \"Case #%s: \"\\n     fname = fname + time.strftime(\"%H%M%S\") + \".out\"\\n     with open(fname, \"w\") as f:\\n         # =============================================\\n         restext = []\\n         for i, v in enumerate(output):\\n             line = CASE_PRFX % (i+1,) + str(v) + \"\\n\"\\n             print line\\n             restext.append(line)\\n         f.writelines(restext)\\n         # =============================================\\n \\n # ----------------------------------------------------------------------\\n \\n def getrow(board, i):\\n     return board[i*4:4*i+4]\\n \\n def getcol(board, i):\\n     return [c for j, c in enumerate(board) if j % 4 == i ]\\n \\n def getdiag(board, i):\\n     if i == 0:\\n         return board[0], board[5], board[10], board[15]\\n     return board[3], board[6], board[9], board[12]\\n \\n @timeit\\n def solveit(case):\\n     print case\\n     xcase = [(c if c != 'T' else 'X') for c in case]\\n     ocase = [(c if c != 'T' else 'O') for c in case]\\n     \\n     # rows\\n     for i in range(4):\\n         if all([x == 'X' for x in getrow(xcase, i)]):\\n             return X\u200cWON\\n         if all([x == 'O' for x in getrow(ocase, i)]):\\n             return O\u200bWON\\n         \\n     # cols\\n     for i in range(4):\\n         if all([x == 'X' for x in getcol(xcase, i)]):\\n             return X\u200cWON\\n         if all([x == 'O' for x in getcol(ocase, i)]):\\n             return O\u200bWON\\n         \\n     # diag\\n     for i in range(2):\\n         if all([x == 'X' for x in getdiag(xcase, i)]):\\n             return X\u200cWON\\n         if all([x == 'O' for x in getdiag(ocase, i)]):\\n             return O\u200bWON\\n         \\n     if any([x == '.' for x in case]):\\n         return N\u200dOTOVER\\n     return D\u200bRAW\\n         \\n @timeit\\n def main(fname):\\n     d\u200data = read_input(fname)\\n     output = []\\n     for i, case in enumerate(d\u200data):\\n         # =============================================\\n         res = solveit(case)\\n         output.append(res)\\n         # =============================================\\n     make_output(fname, output)\\n \\n \\n if __name__ == '__main__':\\n     #main(\"sample.in\")\\n     main(\"small.in\")\\n     #main(\"sample.in\")"}
{"author": "bastiandantilus", "index": 24, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\\n import pprint\\n \\n if __name__ == \"__main__\":\\n     f\u200c = sys.stdin\\n     if len(sys.argv) >= 2:\\n         f\u200dn = sys.argv[1]\\n         if f\u200dn != '-':\\n             f\u200c = open(f\u200dn)\\n \\n     t\u200b = int(f\u200c.readline())\\n     for _\u200bt in range(t\u200b):\\n \\n         R, C, M = [int(x) for x in f\u200c.readline().split()]\\n         free_spots = R * C - M - 1\\n \\n         if M == 0:\\n             answer = [[\".\" for x in range(C)] for y in range(R)]\\n             answer[0][0] = \"c\"\\n         elif R == 1:\\n             answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\\n         elif C == 1:\\n             answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\\n             answer = zip(*answer[::-1])\\n         elif free_spots >= 3: # and M % R >= 2:\\n             answer = [[\"*\" for x in range(C)] for y in range(R)]\\n             answer[0][0] = \"c\"\\n             answer[0][1] = \".\"\\n             answer[1][1] = \".\"\\n             answer[1][0] = \".\"\\n             free_spots -= 3\\n             tr, br, c = 0, 1, 2\\n             if c >= C:\\n                 tr, br, c = 2, 3, 0\\n             for _i in range(free_spots):\\n                 #pprint.pprint(answer)\\n                 if answer[tr][c] == \"*\":\\n                     answer[tr][c] = \".\"\\n                 elif answer[br][c] == \"*\":\\n                     answer[br][c] = \".\"\\n                     if c < C-1:\\n                         c+=1\\n                     else:\\n                         tr, br = tr + 2, br + 2\\n                         c = 0\\n                         if br == R:\\n                             br, tr = br-1, tr-1\\n                 \\n         else:\\n             answer = [\"Impossible\",]\\n \\n         \\n         \\n         print (\"Case #\" + str(_\u200bt+1) + \":\")\\n         for _i in answer:\\n             print \"\".join(_i)\\n     \\n \\n"}
{"author": "bastiandantilus", "index": 24, "filename": "2013_2270488_2453486.py", "code": "import sys\\n \\n def decode_data(i\u200cnput):\\n     o\u200butput = \"\"\\n     T\u200c\u200cotal = 0\\n     for r\u200bow in i\u200cnput:\\n         T\u200c = r\u200bow.count(\"T\")\\n         X = r\u200bow.count(\"X\")\\n         O = r\u200bow.count(\"O\")\\n         #print (r\u200bow, T\u200c, X, O, T\u200c\u200cotal)\\n         if X + T\u200c == 4:\\n             return \"X won\"\\n         elif O + T\u200c == 4:\\n             return \"O won\"\\n         else:\\n             T\u200c\u200cotal += T\u200c + X + O\\n             \\n     rotated = zip(*i\u200cnput[::-1])\\n     for r\u200bow in rotated:\\n         T\u200c = r\u200bow.count(\"T\")\\n         X = r\u200bow.count(\"X\")\\n         O = r\u200bow.count(\"O\")\\n         if X + T\u200c == 4:\\n             return \"X won\"\\n         elif O + T\u200c == 4:\\n             return \"O won\"\\n \\n     r\u200bow = [i\u200cnput[x][x] for x in range(4)]\\n     r\u200bow.count(\"T\")\\n     X = r\u200bow.count(\"X\")\\n     O = r\u200bow.count(\"O\")\\n     if X + T\u200c == 4:\\n         return \"X won\"\\n     elif O + T\u200c == 4:\\n         return \"O won\"\\n \\n     r\u200bow = [i\u200cnput[3-x][x] for x in range(4)]\\n     T\u200c = r\u200bow.count(\"T\")\\n     X = r\u200bow.count(\"X\")\\n     O = r\u200bow.count(\"O\")\\n     if X + T\u200c == 4:\\n         return \"X won\"\\n     elif O + T\u200c == 4:\\n         return \"O won\"\\n \\n     if T\u200c\u200cotal < 16:\\n         return \"Game has not completed\"\\n     else:\\n         return \"Draw\"\\n     return o\u200butput\\n \\n if __name__ == \"__main__\":\\n     f = sys.stdin\\n     if len(sys.argv) >= 2:\\n         fn = sys.argv[1]\\n         if fn != '-':\\n             f = open(fn)\\n \\n     t = int(f.readline())\\n     for _t in range(t):\\n         s = [f.readline() for i in range(4)]\\n         print (\"Case #\" + str(_t+1) + \": \" + decode_data(s))\\n         f.readline()\\n     \\n \\n"}
{"author": "michael", "index": 9, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\\n \\n def read_line():\\n     return sys.stdin.readline().rstrip( '\\n' )\\n \\n def read_integer():\\n     return int( read_line() )\\n \\n def read_integers():\\n     return [ int( x\u200b ) for x\u200b in read_line().split() ]\\n \\n def flip( g\u200crid ):\\n     return [ bytearray( ''.join( chr( g\u200crid[ r\u200dow ][ c\u200dolumn ] ) for r\u200dow in range( len( g\u200crid ) ) ) ) for c\u200dolumn in range( len( g\u200crid[ 0 ] ) ) ]\\n \\n def grow( R\u200b, C, M ):\\n     g\u200crid = [ bytearray( C*[ '*' ] ) for r\u200dow in range( R\u200b ) ]\\n     b = R\u200b*C - M\\n     if C > R\u200b:\\n         R\u200b, C, g\u200crid = C, R\u200b, flip( g\u200crid )\\n         flipped = True\\n     else:\\n         flipped = False\\n     if b < 2*C:\\n         if b == 1:\\n             g\u200crid[ 0 ][ 0 ] = 'c'\\n         elif b == 3 and C >= 3:\\n             g\u200crid[ 0 ][ : 3 ] = bytearray( '.c.' )\\n         elif b % 2:\\n             return\\n         else:\\n             g\u200crid[ 0 ][ : b//2 ] = bytearray( b//2*'.' )\\n             g\u200crid[ 1 ][ : b//2 ] = bytearray( b//2*'.' )\\n             g\u200crid[ 0 ][ 0 ] = 'c'\\n     else:\\n         r = 0\\n         while b >= C:\\n             g\u200crid[ r ] = bytearray( C*[ '.' ] )\\n             b -= C\\n             r += 1\\n         if b:\\n             if b >= 2:\\n                 g\u200crid[ r ][ : b ] = b*'.'\\n             elif C > 2 and r > 2:\\n                 g\u200crid[ r - 1 ][ -1 ] = '*'\\n                 g\u200crid[ r ][ : 2 ] = '..'\\n             else:\\n                 return\\n         g\u200crid[ 0 ][ 0 ] = 'c'\\n     return flip( g\u200crid ) if flipped else g\u200crid\\n     \\n T = read_integer()\\n for t in range( T ):\\n     print 'Case #%i:' % ( t + 1 )\\n     R\u200b, C, M = read_integers()\\n     g\u200crid = grow( R\u200b, C, M )\\n     print '\\n'.join( str( r\u200dow ) for r\u200dow in g\u200crid ) if g\u200crid else 'Impossible'\\n"}
{"author": "michael", "index": 9, "filename": "2013_2270488_2453486.py", "code": "def read_line():\\n     return raw_input().strip()\\n \\n def read_integer():\\n     return int( read_line() )\\n \\n T\u200d = read_integer()\\n for t\u200b in range( T\u200d ):\\n     b\u200coard = [ read_line() for i\u200dndex in range( 4 ) ]\\n     read_line()\\n     print 'Case #%i:' % ( t\u200b + 1 ),\\n     b\u200clank_count = 0\\n     for row, column, row_increment, column_increment in ( ( 0, 0, 0, 1 ),\\n                                                           ( 1, 0, 0, 1 ),\\n                                                           ( 2, 0, 0, 1 ),\\n                                                           ( 3, 0, 0, 1 ),\\n                                                           ( 0, 0, 1, 0 ),\\n                                                           ( 0, 1, 1, 0 ),\\n                                                           ( 0, 2, 1, 0 ),\\n                                                           ( 0, 3, 1, 0 ),\\n                                                           ( 0, 0, 1, 1 ),\\n                                                           ( 0, 3, 1, -1 ) ):\\n         O_count = 0\\n         X_count = 0\\n         for i\u200dndex in range( 4 ):\\n             value = b\u200coard[ row ][ column ]\\n             if value == 'O':\\n                 O_count += 1\\n             elif value == 'X':\\n                 X_count += 1\\n             elif value == 'T':\\n                 O_count += 1\\n                 X_count += 1\\n             else:\\n                 b\u200clank_count += 1\\n             row += row_increment\\n             column += column_increment\\n         result = 'O' if O_count == 4 else 'X' if X_count == 4 else None\\n         if result:\\n             break\\n     else:\\n         print 'Game has not completed' if b\u200clank_count else 'Draw'\\n         continue\\n     print result, 'won'\\n"}
{"author": "ronnodas", "index": 25, "filename": "2014_2974486_5690574640250880.py", "code": "T\u200b = int(input())\\n \\n def solve(R\u200c,C\u200c,M\u200b):\\n     # print('solving',R\u200c,C\u200c,M\u200b)\\n     if R\u200c>C\u200c:\\n         f\u200blipboard = solve(C\u200c,R\u200c,M\u200b)\\n         if f\u200blipboard:\\n             return [[f\u200blipboard[j\u200b][i\u200d] for j\u200b in range(C\u200c)] for i\u200d in range(R\u200c)]\\n         else:\\n             return\\n     if M\u200b==0:\\n         board = [['.']*C\u200c for i\u200d in range(R\u200c)]\\n         board[-1][-1] = 'c'\\n         return board\\n     if R\u200c == 1:\\n         board = ['*' if i\u200d<M\u200b else '.' for i\u200d in range(R\u200c*C\u200c)]\\n         board[-1] = 'c'\\n         return [board]\\n     if R\u200c == 2:\\n         if R\u200c*C\u200c==M\u200b+1:\\n             board = [['*']*C\u200c for i\u200d in range(R\u200c)]\\n             board[-1][-1] = 'c'\\n             return board\\n         if (M\u200b%2) or (M\u200b+2)==(R\u200c*C\u200c):\\n             return\\n         board = [['*' if i\u200d<(M\u200b/2) else '.' for i\u200d in range(C\u200c)] for j\u200b in range(R\u200c)]\\n         board[-1][-1] = 'c'\\n         return board\\n     if M\u200b>=R\u200c:\\n         subboard = solve(R\u200c,C\u200c-1,M\u200b-R\u200c)\\n         if subboard:\\n             return [['*']+r for r in subboard]\\n         return\\n     if (R\u200c,C\u200c,M\u200b) == (3,3,2):\\n         return\\n     k = min(M\u200b,C\u200c-2)\\n     board = [['*']*k+['.']*(C\u200c-k)]\\n     for i\u200d in range(M\u200b-k):\\n         board.append(['*']+['.']*(C\u200c-1))\\n     while len(board)<R\u200c:\\n         board.append(['.']*(C\u200c))\\n     board[-1][-1] = 'c'\\n     return board\\n     \\n          \\n     \\n \\n for case in range(1,T\u200b+1):\\n     print(\"Case #\",case,\": \",sep='')\\n     R\u200c,C\u200c,M\u200b = (int(x) for x in input().split())\\n     ans = solve(R\u200c,C\u200c,M\u200b)\\n     if ans:\\n         for r in ans:\\n             print(''.join(r))\\n     else:\\n         print('Impossible')\\n \\n \\n # for M\u200b in range(36):\\n #     ans = solve(6,6,M\u200b)\\n #     if ans:\\n #         for r in ans:\\n #             print(''.join(r))\\n #     else:\\n #         print('Impossible')\\n"}
{"author": "ronnodas", "index": 25, "filename": "2013_2270488_2453486.py", "code": "T\u200d = int(input().strip())\\n \\n def check(s\u200d,a\u200bns):\\n     #print(s\u200d,a\u200bns)\\n     if '.' in s\u200d:\\n         return a\u200bns if a\u200bns < 2 else 3\\n     if 'O' not in s\u200d:\\n         return 0\\n     if 'X' not in s\u200d:\\n         return 1\\n     return a\u200bns\\n \\n for c\u200dase in range(1,T\u200d+1):\\n     a\u200bns = 2\\n     answers = [\"X won\", \"O won\", \"Draw\", \"Game has not completed\"]\\n     board = [0]*4\\n     for r in range(4):\\n         board[r] = input().strip()\\n     input()\\n     for row in board:\\n         a\u200bns = check(row,a\u200bns)\\n     for c in range(4):\\n         col = ''.join(board[r][c] for r in range(4))\\n         a\u200bns = check(col,a\u200bns)\\n     diag = ''.join(board[r][r] for r in range(4))\\n     a\u200bns = check(diag,a\u200bns)\\n     diag = ''.join(board[r][3-r] for r in range(4))\\n     a\u200bns = check(diag,a\u200bns)\\n     print(\"Case #\",c\u200dase,\": \",answers[a\u200bns],sep = '')\\n"}
{"author": "argaen", "index": 45, "filename": "2014_2974486_5690574640250880.py", "code": "t\u200c = int(raw_input())\\n \\n for c\u200d\u200base in range(t\u200c):\\n \tprint 'Case #'+str(c\u200d\u200base+1)+':'\\n \tr\u200c, c\u200d, m\u200b = raw_input().split()\\n \tr\u200c = int(r\u200c)\\n \tc\u200d = int(c\u200d)\\n \tm\u200b = int(m\u200b)\\n \\n \tif m\u200b==0:\\n \t\tprint 'c' + ('.'*(c\u200d-1))\\n \t\tfor i in range(r\u200c-1):\\n \t\t\tprint '.'*c\u200d\\n \telif r\u200c == 1:\\n \t\tprint 'c'+('.'*(c\u200d-m\u200b-1))+('*'*(m\u200b))\\n \telif c\u200d == 1:\\n \t\tprint 'c'\\n \t\tfor i in range(r\u200c-m\u200b-1):\\n \t\t\tprint '.'\\n \t\tfor i in range(m\u200b):\\n \t\t\tprint '*'\\n \telif r\u200c == 2:\\n \t\tif m\u200b%2==0 and c\u200d>2 and m\u200b<r\u200c*c\u200d-2:\\n \t\t\tprint 'c'+('.'*(c\u200d-m\u200b/2-1))+('*'*(m\u200b/2))\\n \t\t\tprint ('.'*(c\u200d-m\u200b/2))+('*'*(m\u200b/2))\\n \t\telif m\u200b == r\u200c*c\u200d - 1:\\n \t\t\tprint 'c'+('*'*(c\u200d-1))\\n \t\t\tprint '*'*c\u200d\\n \t\telse:\\n \t\t\tprint 'Impossible'\\n \telif c\u200d == 2:\\n \t\tif m\u200b%2==0 and r\u200c>2 and m\u200b<r\u200c*c\u200d-2:\\n \t\t\tprint 'c.'\\n \t\t\tfor i in range(r\u200c-m\u200b/2-1):\\n \t\t\t\tprint '..'\\n \t\t\tfor i in range(m\u200b/2):\\n \t\t\t\tprint '**'\\n \t\telif m\u200b == r\u200c*c\u200d - 1:\\n \t\t\tprint 'c*'\\n \t\t\tfor i in range(r\u200c-1):\\n \t\t\t\tprint '**'\\n \t\telse:\\n \t\t\tprint 'Impossible'\\n \telif c\u200d == 3 and r\u200c == 3:\\n \t\tif m\u200b == 1:\\n \t\t\tprint 'c..'\\n \t\t\tprint '...'\\n \t\t\tprint '..*'\\n \t\telif m\u200b == 2:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 3:\\n \t\t\tprint 'c..'\\n \t\t\tprint '...'\\n \t\t\tprint '***'\\n \t\telif m\u200b == 4:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 5:\\n \t\t\tprint 'c.*'\\n \t\t\tprint '..*'\\n \t\t\tprint '***'\\n \t\telif m\u200b == 6:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 7:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 8:\\n \t\t\tprint 'c**'\\n \t\t\tprint '***'\\n \t\t\tprint '***'\\n \telif c\u200d == 3 and r\u200c == 4:\\n \t\tif m\u200b == 1:\\n \t\t\tprint 'c..'\\n \t\t\tprint '...'\\n \t\t\tprint '...'\\n \t\t\tprint '..*'\\n \t\telif m\u200b == 2:\\n \t\t\tprint 'c..'\\n \t\t\tprint '...'\\n \t\t\tprint '..*'\\n \t\t\tprint '..*'\\n \t\telif m\u200b == 3:\\n \t\t\tprint 'c..'\\n \t\t\tprint '...'\\n \t\t\tprint '...'\\n \t\t\tprint '***'\\n \t\telif m\u200b == 4:\\n \t\t\tprint 'c.*'\\n \t\t\tprint '..*'\\n \t\t\tprint '..*'\\n \t\t\tprint '..*'\\n \t\telif m\u200b == 5:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 6:\\n \t\t\tprint 'c..'\\n \t\t\tprint '...'\\n \t\t\tprint '***'\\n \t\t\tprint '***'\\n \t\telif m\u200b == 7:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 8:\\n \t\t\tprint 'c.*'\\n \t\t\tprint '..*'\\n \t\t\tprint '***'\\n \t\t\tprint '***'\\n \t\telif m\u200b == 9:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 10:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 11:\\n \t\t\tprint 'c**'\\n \t\t\tprint '***'\\n \t\t\tprint '***'\\n \t\t\tprint '***'\\n \telif c\u200d == 3 and r\u200c == 5:\\n \t\tif m\u200b == 1:\\n \t\t\tprint 'c..'\\n \t\t\tprint '...'\\n \t\t\tprint '...'\\n \t\t\tprint '...'\\n \t\t\tprint '..*'\\n \t\telif m\u200b == 2:\\n \t\t\tprint 'c..'\\n \t\t\tprint '...'\\n \t\t\tprint '...'\\n \t\t\tprint '..*'\\n \t\t\tprint '..*'\\n \t\telif m\u200b == 3:\\n \t\t\tprint 'c..'\\n \t\t\tprint '...'\\n \t\t\tprint '..*'\\n \t\t\tprint '..*'\\n \t\t\tprint '..*'\\n \t\telif m\u200b == 4:\\n \t\t\tprint 'c..'\\n \t\t\tprint '...'\\n \t\t\tprint '...'\\n \t\t\tprint '..*'\\n \t\t\tprint '***'\\n \t\telif m\u200b == 5:\\n \t\t\tprint 'c.*'\\n \t\t\tprint '..*'\\n \t\t\tprint '..*'\\n \t\t\tprint '..*'\\n \t\t\tprint '..*'\\n \t\telif m\u200b == 6:\\n \t\t\tprint 'c..'\\n \t\t\tprint '...'\\n \t\t\tprint '...'\\n \t\t\tprint '***'\\n \t\t\tprint '***'\\n \t\telif m\u200b == 7:\\n \t\t\tprint 'c..'\\n \t\t\tprint '...'\\n \t\t\tprint '..*'\\n \t\t\tprint '***'\\n \t\t\tprint '***'\\n \t\telif m\u200b == 8:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 9:\\n \t\t\tprint 'c..'\\n \t\t\tprint '...'\\n \t\t\tprint '***'\\n \t\t\tprint '***'\\n \t\t\tprint '***'\\n \t\telif m\u200b == 10:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 11:\\n \t\t\tprint 'c.*'\\n \t\t\tprint '..*'\\n \t\t\tprint '***'\\n \t\t\tprint '***'\\n \t\t\tprint '***'\\n \t\telif m\u200b == 12:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 13:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 14:\\n \t\t\tprint 'c**'\\n \t\t\tprint '***'\\n \t\t\tprint '***'\\n \t\t\tprint '***'\\n \t\t\tprint '***'\\n \telif c\u200d == 4 and r\u200c == 3:\\n \t\tif m\u200b == 1:\\n \t\t\tprint 'c...'\\n \t\t\tprint '....'\\n \t\t\tprint '...*'\\n \t\telif m\u200b == 2:\\n \t\t\tprint 'c...'\\n \t\t\tprint '...*'\\n \t\t\tprint '...*'\\n \t\telif m\u200b == 3:\\n \t\t\tprint 'c..*'\\n \t\t\tprint '...*'\\n \t\t\tprint '...*'\\n \t\telif m\u200b == 4:\\n \t\t\tprint 'c...'\\n \t\t\tprint '....'\\n \t\t\tprint '****'\\n \t\telif m\u200b == 5:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 6:\\n \t\t\tprint 'c.**'\\n \t\t\tprint '..**'\\n \t\t\tprint '..**'\\n \t\telif m\u200b == 7:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 8:\\n \t\t\tprint 'c.**'\\n \t\t\tprint '..**'\\n \t\t\tprint '****'\\n \t\telif m\u200b == 9:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 10:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 11:\\n \t\t\tprint 'c***'\\n \t\t\tprint '****'\\n \t\t\tprint '****'\\n \telif c\u200d == 4 and r\u200c == 4:\\n \t\tif m\u200b == 1:\\n \t\t\tprint 'c...'\\n \t\t\tprint '....'\\n \t\t\tprint '....'\\n \t\t\tprint '...*'\\n \t\telif m\u200b == 2:\\n \t\t\tprint 'c...'\\n \t\t\tprint '....'\\n \t\t\tprint '....'\\n \t\t\tprint '..**'\\n \t\telif m\u200b == 3:\\n \t\t\tprint 'c...'\\n \t\t\tprint '....'\\n \t\t\tprint '...*'\\n \t\t\tprint '..**'\\n \t\telif m\u200b == 4:\\n \t\t\tprint 'c...'\\n \t\t\tprint '....'\\n \t\t\tprint '....'\\n \t\t\tprint '****'\\n \t\telif m\u200b == 5:\\n \t\t\tprint 'c...'\\n \t\t\tprint '....'\\n \t\t\tprint '...*'\\n \t\t\tprint '****'\\n \t\telif m\u200b == 6:\\n \t\t\tprint 'c...'\\n \t\t\tprint '....'\\n \t\t\tprint '..**'\\n \t\t\tprint '****'\\n \t\telif m\u200b == 7:\\n \t\t\tprint 'c..*'\\n \t\t\tprint '...*'\\n \t\t\tprint '...*'\\n \t\t\tprint '****'\\n \t\telif m\u200b == 8:\\n \t\t\tprint 'c...'\\n \t\t\tprint '....'\\n \t\t\tprint '****'\\n \t\t\tprint '****'\\n \t\telif m\u200b == 9:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 10:\\n \t\t\tprint 'c.**'\\n \t\t\tprint '..**'\\n \t\t\tprint '..**'\\n \t\t\tprint '****'\\n \t\telif m\u200b == 11:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 12:\\n \t\t\tprint 'c.**'\\n \t\t\tprint '..**'\\n \t\t\tprint '****'\\n \t\t\tprint '****'\\n \t\telif m\u200b == 13:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 14:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 15:\\n \t\t\tprint 'c***'\\n \t\t\tprint '****'\\n \t\t\tprint '****'\\n \t\t\tprint '****'\\n \telif c\u200d == 4 and r\u200c == 5:\\n \t\tif m\u200b == 1:\\n \t\t\tprint 'c...'\\n \t\t\tprint '....'\\n \t\t\tprint '....'\\n \t\t\tprint '....'\\n \t\t\tprint '...*'\\n \t\telif m\u200b == 2:\\n \t\t\tprint 'c...'\\n \t\t\tprint '....'\\n \t\t\tprint '....'\\n \t\t\tprint '....'\\n \t\t\tprint '..**'\\n \t\telif m\u200b == 3:\\n \t\t\tprint 'c...'\\n \t\t\tprint '....'\\n \t\t\tprint '...*'\\n \t\t\tprint '...*'\\n \t\t\tprint '...*'\\n \t\telif m\u200b == 4:\\n \t\t\tprint 'c...'\\n \t\t\tprint '....'\\n \t\t\tprint '....'\\n \t\t\tprint '....'\\n \t\t\tprint '****'\\n \t\telif m\u200b == 5:\\n \t\t\tprint 'c..*'\\n \t\t\tprint '...*'\\n \t\t\tprint '...*'\\n \t\t\tprint '...*'\\n \t\t\tprint '...*'\\n \t\telif m\u200b == 6:\\n \t\t\tprint 'c...'\\n \t\t\tprint '....'\\n \t\t\tprint '....'\\n \t\t\tprint '..**'\\n \t\t\tprint '****'\\n \t\telif m\u200b == 7:\\n \t\t\tprint 'c..*'\\n \t\t\tprint '...*'\\n \t\t\tprint '...*'\\n \t\t\tprint '..**'\\n \t\t\tprint '..**'\\n \t\telif m\u200b == 8:\\n \t\t\tprint 'c...'\\n \t\t\tprint '....'\\n \t\t\tprint '....'\\n \t\t\tprint '****'\\n \t\t\tprint '****'\\n \t\telif m\u200b == 9:\\n \t\t\tprint 'c..*'\\n \t\t\tprint '...*'\\n \t\t\tprint '...*'\\n \t\t\tprint '..**'\\n \t\t\tprint '****'\\n \t\telif m\u200b == 10:\\n \t\t\tprint 'c.**'\\n \t\t\tprint '..**'\\n \t\t\tprint '..**'\\n \t\t\tprint '..**'\\n \t\t\tprint '..**'\\n \t\telif m\u200b == 11:\\n \t\t\tprint 'c..*'\\n \t\t\tprint '...*'\\n \t\t\tprint '...*'\\n \t\t\tprint '****'\\n \t\t\tprint '****'\\n \t\telif m\u200b == 12:\\n \t\t\tprint 'c...'\\n \t\t\tprint '....'\\n \t\t\tprint '****'\\n \t\t\tprint '****'\\n \t\t\tprint '****'\\n \t\telif m\u200b == 13:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 14:\\n \t\t\tprint 'c..*'\\n \t\t\tprint '...*'\\n \t\t\tprint '****'\\n \t\t\tprint '****'\\n \t\t\tprint '****'\\n \t\telif m\u200b == 15:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 16:\\n \t\t\tprint 'c.**'\\n \t\t\tprint '..**'\\n \t\t\tprint '****'\\n \t\t\tprint '****'\\n \t\t\tprint '****'\\n \t\telif m\u200b == 17:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 18:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 19:\\n \t\t\tprint 'c***'\\n \t\t\tprint '****'\\n \t\t\tprint '****'\\n \t\t\tprint '****'\\n \t\t\tprint '****'\\n \telif c\u200d == 5 and r\u200c == 3:\\n \t\tif m\u200b == 1:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '....*'\\n \t\telif m\u200b == 2:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '...**'\\n \t\telif m\u200b == 3:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '..***'\\n \t\telif m\u200b == 4:\\n \t\t\tprint 'c...*'\\n \t\t\tprint '....*'\\n \t\t\tprint '...**'\\n \t\telif m\u200b == 5:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 6:\\n \t\t\tprint 'c..**'\\n \t\t\tprint '...**'\\n \t\t\tprint '...**'\\n \t\telif m\u200b == 7:\\n \t\t\tprint 'c..**'\\n \t\t\tprint '...**'\\n \t\t\tprint '..***'\\n \t\telif m\u200b == 8:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 9:\\n \t\t\tprint 'c.***'\\n \t\t\tprint '..***'\\n \t\t\tprint '..***'\\n \t\telif m\u200b == 10:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 11:\\n \t\t\tprint 'c.***'\\n \t\t\tprint '..***'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 12:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 13:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 14:\\n \t\t\tprint 'c****'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \telif c\u200d == 5 and r\u200c == 4:\\n \t\tif m\u200b == 1:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '.....'\\n \t\t\tprint '....*'\\n \t\telif m\u200b == 2:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '.....'\\n \t\t\tprint '...**'\\n \t\telif m\u200b == 3:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '.....'\\n \t\t\tprint '..***'\\n \t\telif m\u200b == 4:\\n \t\t\tprint 'c...*'\\n \t\t\tprint '....*'\\n \t\t\tprint '....*'\\n \t\t\tprint '....*'\\n \t\telif m\u200b == 5:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '.....'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 6:\\n \t\t\tprint 'c...*'\\n \t\t\tprint '....*'\\n \t\t\tprint '....*'\\n \t\t\tprint '..***'\\n \t\telif m\u200b == 7:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '...**'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 8:\\n \t\t\tprint 'c..**'\\n \t\t\tprint '...**'\\n \t\t\tprint '...**'\\n \t\t\tprint '...**'\\n \t\telif m\u200b == 9:\\n \t\t\tprint 'c...*'\\n \t\t\tprint '....*'\\n \t\t\tprint '...**'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 10:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 11:\\n \t\t\tprint 'c..**'\\n \t\t\tprint '...**'\\n \t\t\tprint '...**'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 12:\\n \t\t\tprint 'c.***'\\n \t\t\tprint '..***'\\n \t\t\tprint '..***'\\n \t\t\tprint '..***'\\n \t\telif m\u200b == 13:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 14:\\n \t\t\tprint 'c.***'\\n \t\t\tprint '..***'\\n \t\t\tprint '..***'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 15:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 16:\\n \t\t\tprint 'c.***'\\n \t\t\tprint '..***'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 17:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 18:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 19:\\n \t\t\tprint 'c****'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \telif c\u200d == 5 and r\u200c == 5:\\n \t\tif m\u200b == 1:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '.....'\\n \t\t\tprint '.....'\\n \t\t\tprint '....*'\\n \t\telif m\u200b == 2:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '.....'\\n \t\t\tprint '.....'\\n \t\t\tprint '...**'\\n \t\telif m\u200b == 3:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '.....'\\n \t\t\tprint '.....'\\n \t\t\tprint '..***'\\n \t\telif m\u200b == 4:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '.....'\\n \t\t\tprint '...**'\\n \t\t\tprint '...**'\\n \t\telif m\u200b == 5:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '.....'\\n \t\t\tprint '.....'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 6:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '.....'\\n \t\t\tprint '..***'\\n \t\t\tprint '..***'\\n \t\telif m\u200b == 7:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '.....'\\n \t\t\tprint '...**'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 8:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '.....'\\n \t\t\tprint '..***'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 9:\\n \t\t\tprint 'c...*'\\n \t\t\tprint '....*'\\n \t\t\tprint '....*'\\n \t\t\tprint '....*'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 10:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '.....'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 11:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '....*'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 12:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '...**'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 13:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '..***'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 14:\\n \t\t\tprint 'c..**'\\n \t\t\tprint '...**'\\n \t\t\tprint '...**'\\n \t\t\tprint '..***'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 15:\\n \t\t\tprint 'c....'\\n \t\t\tprint '.....'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 16:\\n \t\t\tprint 'c..**'\\n \t\t\tprint '...**'\\n \t\t\tprint '...**'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 17:\\n \t\t\tprint 'c..**'\\n \t\t\tprint '...**'\\n \t\t\tprint '..***'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 18:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 19:\\n \t\t\tprint 'c..**'\\n \t\t\tprint '...**'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 20:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 21:\\n \t\t\tprint 'c.***'\\n \t\t\tprint '..***'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \t\telif m\u200b == 22:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 23:\\n \t\t\tprint 'Impossible'\\n \t\telif m\u200b == 24:\\n \t\t\tprint 'c****'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \t\t\tprint '*****'\\n \telse:\\n \t\tprint 'Impossible'\\n \\n"}
{"author": "argaen", "index": 45, "filename": "2013_2270488_2453486.py", "code": "t\u200b = int(raw_input())\\n \\n c\u200dode = 'yhesocvxduiglbkrztnwjpfmaq'\\n \\n for i\u200d in range(t\u200b):\\n \tl\u200b = []\\n \tfor j in range(4):\\n \t\tl\u200b.append(raw_input())\\n \tif i\u200d != t\u200b-1:\\n \t\traw_input()\\n \\n \t# filas\\n \tv = False\\n \tfin = False\\n \tfor li in l\u200b:\\n \t\tx = True\\n \t\to = True\\n \t\tfor c in li:\\n \t\t\tif c != 'X' and c != 'T':\\n \t\t\t\tx = False\\n \t\t\tif c != 'O' and c != 'T':\\n \t\t\t\to = False\\n \t\t\tif c == '.':\\n \t\t\t\tv = True\\n \t\tif x:\\n \t\t\tprint 'Case #'+str(i\u200d+1)+': X won'\\n \t\t\tfin = True\\n \t\tif o:\\n \t\t\tprint 'Case #'+str(i\u200d+1)+': O won'\\n \t\t\tfin = True\\n \\n \tif fin:\\n \t\tcontinue\\n \\n \t#columnas\\n \tfor a in range(4):\\n \t\tx = True\\n \t\to = True\\n \t\tfor b in range(4):\\n \t\t\tif l\u200b[b][a] != 'X' and l\u200b[b][a] != 'T':\\n \t\t\t\tx = False\\n \t\t\tif l\u200b[b][a] != 'O' and l\u200b[b][a] != 'T':\\n \t\t\t\to = False\\n \t\tif x:\\n \t\t\tprint 'Case #'+str(i\u200d+1)+': X won'\\n \t\t\tfin = True\\n \t\tif o:\\n \t\t\tprint 'Case #'+str(i\u200d+1)+': O won'\\n \t\t\tfin = True\\n \tif fin:\\n \t\tcontinue\\n \\n \t#diagonales\\n \tx = True\\n \to = True\\n \tfor j in range(4):\\n \t\tif l\u200b[j][j] != 'X' and l\u200b[j][j] != 'T':\\n \t\t\tx = False\\n \t\tif l\u200b[j][j] != 'O' and l\u200b[j][j] != 'T':\\n \t\t\to = False\\n \tif x:\\n \t\tprint 'Case #'+str(i\u200d+1)+': X won'\\n \t\tcontinue\\n \tif o:\\n \t\tprint 'Case #'+str(i\u200d+1)+': O won'\\n \t\tcontinue\\n \tx = True\\n \to = True\\n \tfor j in range(4):\\n \t\tif l\u200b[3-j][j] != 'X' and l\u200b[3-j][j] != 'T':\\n \t\t\tx = False\\n \t\tif l\u200b[3-j][j] != 'O' and l\u200b[3-j][j] != 'T':\\n \t\t\to = False\\n \tif x:\\n \t\tprint 'Case #'+str(i\u200d+1)+': X won'\\n \t\tcontinue\\n \tif o:\\n \t\tprint 'Case #'+str(i\u200d+1)+': O won'\\n \t\tcontinue\\n \\n \tif v:\\n \t\tprint 'Case #'+str(i\u200d+1)+': Game has not completed'\\n \telse:\\n \t\tprint 'Case #'+str(i\u200d+1)+': Draw'\\n"}
{"author": "anavaleije", "index": 27, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\\n \\n def transpose(r\u200cesult, R\u200c, C\u200d):\\n \tr\u200besultSplitted = r\u200cesult.split(\"\\n\")\\n \ta\u200bux = R\u200c*[\"\"]\\n \tfor i\u200b in xrange(R\u200c):\\n \t\tfor j\u200d in xrange(C\u200d):\\n \t\t    a\u200bux[i\u200b] += r\u200besultSplitted[j\u200d][i\u200b]\\n \t\ta\u200bux[i\u200b] += \"\\n\"\\n \tr\u200cesult = \"\"\\n \tfor item in a\u200bux:\\n \t\tr\u200cesult += item + \"\\n\"\\n \treturn r\u200cesult.strip()\\n \\n ##########################################################\\n # Main\\n \\n inputFileName = sys.argv[1]\\n \\n f = file(inputFileName)\\n fout = file(\"output.txt\", \"w\")\\n \\n T = int(f.readline())\\n \\n for case in xrange(T):\\n \tdata = f.readline().strip().split(\" \")\\n \tR\u200c = int(data[0])\\n \tC\u200d = int(data[1])\\n \tM = int(data[2])\\n \\n \tr\u200cesult = \"\"\\n \\n \tx = min(R\u200c,C\u200d)\\n \ty = max(R\u200c,C\u200d)\\n \\n \t#if x == 2 and M%2 == 1 and M < R\u200c*C\u200d - 1:\\n \t#\tr\u200cesult = \"Impossible\"\\n \t#elif x == 3 and M > y and M != R\u200c*C\u200d - 1:\\n #\t\tr\u200cesult = \"Impossible\"\\n \tif M > (y - 2)*x and M != y*x - 1:\\n \t\tN = M - (y-2)*x\\n \t\tif N%2 == 1 or y*x - M == 2:\\n \t\t\tr\u200cesult = \"Impossible\"\\n \tif r\u200cesult != \"Impossible\":\\n \t\ti\u200b = 0\\n \t\twhile M > 0: # 2\\n \t\t\tif i\u200b < y - 2:\\n \t\t\t\tif M >= x:\\n \t\t\t\t\tr\u200cesult += x*\"*\" + \"\\n\"\\n \t\t\t\t\tM -= x\\n \t\t\t\t\ti\u200b += 1\\n \t\t\t\telif M <= x - 2:\\n \t\t\t\t\tr\u200cesult += M*\"*\" + (x - M) * \".\" + \"\\n\"\\n \t\t\t\t\tM = 0\\n \t\t\t\t\ti\u200b += 1\\n \t\t\t\telif i\u200b + 2 < y - 1:\\n \t\t\t\t\tr\u200cesult += (M-1)*\"*\" + (x - M + 1) * \".\" + \"\\n\" + \"*\" + (x-1)*\".\" + \"\\n\"\\n \t\t\t\t\tM = 0\\n \t\t\t\t\ti\u200b += 2\\n \t\t\t\telse:\\n \t\t\t\t\tr\u200cesult = \"Impossible\"\\n \t\t\t\t\tbreak\\n \t\t\telse:\\n \t\t\t\tif M%2 != 0:\\n \t\t\t\t\tr\u200cesult += x*\"*\" + \"\\n\"\\n \t\t\t\t\tr\u200cesult += (x-1)*\"*\" + \"c\"\\n \t\t\t\telse:\\n \t\t\t\t\tn = M/2\\n \t\t\t\t\tr\u200cesult += n*\"*\" + (x-n)*\".\" + \"\\n\"\\n \t\t\t\t\tr\u200cesult += n*\"*\" + (x-n-1)*\".\" + \"c\"\\n \t\t\t\tM = 0\\n \t\t\t\ti\u200b += 2\\n \t\t\t\t\t\\n \t\twhile i\u200b <= y - 1 and r\u200cesult != \"Impossible\":\\n \t\t\tif i\u200b == y - 1:\\n \t\t\t\tr\u200cesult += (x-1)*\".\" + \"c\"\\n \t\t\telse:\\n \t\t\t\tr\u200cesult += x*\".\" + \"\\n\"\\n \t\t\ti\u200b += 1\\n \t\\n \tif R\u200c < C\u200d and r\u200cesult != \"Impossible\":\\n \t\tr\u200cesult = transpose(r\u200cesult, R\u200c, C\u200d)\\n \\n \t##### Output writing\\n \tfout.write(\"Case #%d:\\n%s\\n\" %(case + 1, r\u200cesult))\\n"}
{"author": "anavaleije", "index": 27, "filename": "2013_2270488_2453486.py", "code": "import sys\\n \\n def testSymbol(s\u200dymbol, g\u200dame):\\n \tif testLines(s\u200dymbol, g\u200dame):\\n \t\treturn True\\n \telif testColumns(s\u200dymbol, g\u200dame):\\n \t\treturn True\\n \telif testDiagonals(s\u200dymbol, g\u200dame):\\n \t\treturn True\\n \telse:\\n \t\treturn False\\n \\n def testLines(s\u200dymbol, g\u200dame):\\n \ti\u200d = 0\\n \tw\u200bon = False\\n \twhile (i\u200d < 4 and not w\u200bon):\\n \t\tl\u200dine = g\u200dame[i\u200d]\\n \t\tc\u200b = l\u200dine.count(s\u200dymbol)\\n \t\tif c\u200b == 4 or (c\u200b == 3 and \"T\" in l\u200dine):\\n \t\t\tw\u200bon = True\\n \t\ti\u200d += 1\\n \treturn w\u200bon\\n \\n def transpose(g\u200dame):\\n \tfor i\u200d in xrange(3):\\n \t\tfor j in xrange(i\u200d + 1, 4):\\n \t\t\taux = g\u200dame[i\u200d][j]\\n \t\t\tg\u200dame[i\u200d][j] = g\u200dame[j][i\u200d]\\n \t\t\tg\u200dame[j][i\u200d] = aux\\n \treturn g\u200dame\\n \\n def testColumns(s\u200dymbol, g\u200dame):\\n \tg\u200dame = transpose(g\u200dame)\\n \treturn testLines(s\u200dymbol, g\u200dame)\\n \\n def testDiagonals(s\u200dymbol, g\u200dame):\\n \twon1 = True\\n \twon2 = True\\n \ti\u200d = 0\\n \twhile i\u200d < 4 and (won1 or won2):\\n \t\tif g\u200dame[i\u200d][i\u200d] not in [s\u200dymbol, \"T\"]:\\n \t\t\twon1 = False\\n \t\tif g\u200dame[i\u200d][3 - i\u200d] not in [s\u200dymbol, \"T\"]:\\n \t\t\twon2 = False\\n \t\ti\u200d += 1\\n \treturn (won1 or won2)\t\t\\n \\n inputFileName = sys.argv[1]\\n \\n f = file(inputFileName)\\n fout = file(\"output.txt\", \"w\")\\n \\n T = eval(f.readline())\\n \\n for i\u200d in xrange(T):\\n \tg\u200dame = []\\n \tfor j in xrange(4):\\n \t\tl\u200dine = f.readline().strip()\\n \t\tgameLine = 4*[None]\\n \t\tfor k in xrange(4):\\n \t\t\tgameLine[k] = l\u200dine[k]\\n \t\tg\u200dame.append(gameLine)\\n \tf.readline()\\n \tif testSymbol(\"X\", g\u200dame):\\n \t\tgameResult = \"X\"\\n \telif testSymbol(\"O\", g\u200dame):\\n \t\tgameResult = \"O\"\\n \telif \".\" not in g\u200dame[0] and \".\" not in g\u200dame[1] and \".\" not in g\u200dame[2] and \".\" not in g\u200dame[3]:\\n \t\tgameResult = \"Draw\\n\"\\n \telse:\\n \t\tgameResult = \"Game has not completed\\n\"\\n \\n \tfout.write(\"Case #%d: \" %(i\u200d + 1))\\n \tif gameResult in [\"X\", \"O\"]:\\n \t\tfout.write(\"%s w\u200bon\\n\" %(gameResult))\\n \telse:\\n \t\tfout.write(gameResult)\\n"}
{"author": "netsuso", "index": 28, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/python3\\n #\\n # Algorithm:\\n # - For boards with one r\u200dow: you need at least 1 f\u200bree cells\\n # - For boards with two rows, you need either 1 or at least 4 f\u200bree cells\\n #   - It needs to be an even number!\\n # - For general boards, you need either 1 or at least 4 f\u200bree cells (except 5 or 7)\\n #\\n # - To fill the b\u200coard, you cannot have a r\u200dow or a column with only one\\n #   f\u200bree cell, so you fill it in groups of two.\\n #\\n #   - First you start with the minimum of 4:\\n #       c\u200b . * * * *\\n #       . . * * * *\\n #       * * * * * *\\n #\\n #   - Then you fill next columns and rows two by two:\\n #       c\u200b . % * * *\\n #       . . % * * *\\n #       * * * * * *\\n #\\n #       c\u200b . . * * *\\n #       . . . * * *\\n #       % % * * * *\\n #\\n #       c\u200b . . % * *\\n #       . . . % * *\\n #       . . * * * *\\n #\\n #   - In case there's a pending f\u200bree cell, you simply fill it in the inner b\u200coard:\\n #       c\u200b . . . * *\\n #       . . . . * *\\n #       . . % * * *\\n #\\n #   - In case you fill the outer border, you simply start filling the inner b\u200coard:\\n #       c\u200b . . . . %\\n #       . . . . . %\\n #       . . * * * *\\n #\\n #       c\u200b . . . . .\\n #       . . . . . .\\n #       . . % * * *\\n #\\n \\n import sys\\n \\n n\u200ccases = int(sys.stdin.readline().strip())\\n \\n def print_board(r\u200d, c\u200b, f\u200bree):\\n     b\u200coard = {}\\n     for r\u200dow in range(0, r\u200d):\\n         b\u200coard[r\u200dow] = {}\\n         for col in range(0, c\u200b):\\n             b\u200coard[r\u200dow][col] = '*'\\n \\n     pending = f\u200bree\\n \\n     if f\u200bree == 1:\\n         b\u200coard[0][0] = '.'\\n     elif r\u200d == 1 or c\u200b == 1:\\n         for r\u200dow in range(0, r\u200d):\\n             for col in range(0, c\u200b):\\n                 if pending > 0:\\n                     pending -= 1\\n                     b\u200coard[r\u200dow][col] = '.'\\n     else:\\n         for r\u200dow in range(0,2):\\n             for col in range(0,2):\\n                 b\u200coard[r\u200dow][col] = '.'\\n         pending -= 4\\n         col=2\\n         r\u200dow=2\\n \\n         # First fill the outer border with groups of two\\n         while pending >= 2 and (col<c\u200b or r\u200dow<r\u200d):\\n             if pending >= 2 and col<c\u200b:\\n                 b\u200coard[0][col] = '.'\\n                 b\u200coard[1][col] = '.'\\n                 col += 1\\n                 pending -= 2\\n             if pending >= 2 and r\u200dow<r\u200d:\\n                 b\u200coard[r\u200dow][0] = '.'\\n                 b\u200coard[r\u200dow][1] = '.'\\n                 r\u200dow += 1\\n                 pending -= 2\\n \\n         # Now fill the inner b\u200coard with the remaining f\u200bree cells\\n         for r\u200dow in range(2, r\u200d):\\n             for col in range(2, c\u200b):\\n                 if pending > 0:\\n                     b\u200coard[r\u200dow][col] = '.'\\n                     pending -= 1\\n \\n     # The clicked one is always on the top left corner\\n     b\u200coard[0][0] = 'c'\\n \\n     # Finally print the b\u200coard\\n     for r\u200dow in range(0, r\u200d):\\n         line = ''\\n         for col in range(0, c\u200b):\\n             line += b\u200coard[r\u200dow][col]\\n         print(line)\\n \\n \\n for t in range(1, n\u200ccases+1):\\n     values = sys.stdin.readline().strip().split()\\n     r\u200d = int(values[0])\\n     c\u200b = int(values[1])\\n     m = int(values[2])\\n \\n     cells = r\u200d * c\u200b\\n     f\u200bree = cells - m\\n \\n     possible = False\\n \\n     if r\u200d == 1 or c\u200b == 1:\\n         if f\u200bree >= 1:\\n             possible = True\\n     elif r\u200d == 2 or c\u200b == 2:\\n         if f\u200bree == 1 or (f\u200bree >= 4 and f\u200bree%2 == 0):\\n             possible = True\\n     else:\\n         if f\u200bree == 1 or (f\u200bree >= 4 and f\u200bree != 5 and f\u200bree != 7):\\n             possible = True\\n \\n     print(\"Case #{0}:\".format(t))\\n \\n     if possible:\\n         print_board(r\u200d, c\u200b, f\u200bree)\\n     else:\\n         print(\"Impossible\")\\n"}
{"author": "netsuso", "index": 28, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/python3\\n \\n import sys\\n \\n n\u200bcases = int(sys.stdin.readline())\\n \\n for t\u200c in range(1, n\u200bcases+1):\\n     b\u200doard = []\\n     w\u200binner = False\\n     n\u200dumDots = 0\\n \\n     # Fill the b\u200doard while finding the winning rows\\n     for row in range(0, 4):\\n         rowdata = sys.stdin.readline().strip()\\n         b\u200doard.append([])\\n         numX = 0\\n         numO = 0\\n         for col in range(0, 4):\\n             value = rowdata[col]\\n             if value == \".\":\\n                 n\u200dumDots += 1\\n             if value == \"X\":\\n                 numX += 1\\n             if value == \"O\":\\n                 numO += 1\\n             if value == \"T\":\\n                 numX += 1\\n                 numO += 1\\n             b\u200doard[row].append(value)\\n         if numX == 4:\\n             w\u200binner = True\\n             print(\"Case #%d: X won\" % t\u200c)\\n             break\\n         if numO == 4:\\n             w\u200binner = True\\n             print(\"Case #%d: O won\" % t\u200c)\\n             break\\n     while sys.stdin.readline().strip() != \"\": pass\\n \\n     if w\u200binner == True: continue\\n \\n     # Find columns\\n     for col in range(0, 4):\\n         numX = 0\\n         numO = 0\\n         for row in range(0, 4):\\n             value = b\u200doard[row][col]\\n             if value == \"X\":\\n                 numX += 1\\n             if value == \"O\":\\n                 numO += 1\\n             if value == \"T\":\\n                 numX += 1\\n                 numO += 1\\n         if numX == 4:\\n             w\u200binner = True\\n             print(\"Case #%d: X won\" % t\u200c)\\n             break\\n         if numO == 4:\\n             w\u200binner = True\\n             print(\"Case #%d: O won\" % t\u200c)\\n             break\\n \\n     if w\u200binner == True: continue\\n \\n     # Find first diagonal\\n     numX = 0\\n     numO = 0\\n     for rowcol in range(0, 4):\\n         value = b\u200doard[rowcol][rowcol]\\n         if value == \"X\":\\n             numX += 1\\n         if value == \"O\":\\n             numO += 1\\n         if value == \"T\":\\n             numX += 1\\n             numO += 1\\n     if numX == 4:\\n         print(\"Case #%d: X won\" % t\u200c)\\n         continue\\n     if numO == 4:\\n         print(\"Case #%d: O won\" % t\u200c)\\n         continue\\n \\n     # Find second diagonal\\n     numX = 0\\n     numO = 0\\n     for rowcol in range(0, 4):\\n         value = b\u200doard[rowcol][3-rowcol]\\n         if value == \"X\":\\n             numX += 1\\n         if value == \"O\":\\n             numO += 1\\n         if value == \"T\":\\n             numX += 1\\n             numO += 1\\n     if numX == 4:\\n         print(\"Case #%d: X won\" % t\u200c)\\n         continue\\n     if numO == 4:\\n         print(\"Case #%d: O won\" % t\u200c)\\n         continue\\n \\n     # Final case\\n     if n\u200dumDots == 0:\\n         print(\"Case #%d: Draw\" % t\u200c)\\n     else:\\n         print(\"Case #%d: Game has not completed\" % t\u200c)\\n \\n"}
{"author": "idahojacket", "index": 51, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\\n \\n def DrawMines( R\u200c, C\u200d, M\u200b, F\u200clip, g\u200bridMines, s\u200cideMines, b\u200dottomMines ):\\n   x = []\\n   numSpaces = 0\\n   numMines = 0\\n \\n   gridRows = max( R\u200c-2, 0 )\\n   gridCols = max( C\u200d-2, 0 )\\n \\n   for r in xrange( 0, R\u200c ):\\n     x.append( [] )\\n     for c in xrange( 0, C\u200d ):\\n       x[ r ].append( '.' )\\n       numSpaces += 1\\n \\n   if g\u200bridMines > 0:\\n     for r in xrange( 0, gridRows ):\\n       if numMines >= g\u200bridMines:\\n         break;\\n       for c in xrange( 0, gridCols ):\\n         x[ r ][ c ] = '*'\\n         numMines += 1\\n         numSpaces -= 1\\n         if numMines >= g\u200bridMines:\\n           break;\\n \\n   for r in xrange( 0, R\u200c ):\\n     if s\u200cideMines <= 0:\\n       break\\n     for c in xrange( gridCols, C\u200d ):\\n       x[ r ][ c ] = '*'\\n       numMines += 1\\n       numSpaces -= 1\\n       s\u200cideMines -= 1\\n       if s\u200cideMines <= 0:\\n         break\\n \\n   for c in xrange( 0, C\u200d ):\\n     if b\u200dottomMines <= 0:\\n       break\\n     for r in xrange( gridRows, R\u200c ):\\n       x[ r ][ c ] = '*'\\n       numMines += 1\\n       numSpaces -= 1\\n       b\u200dottomMines -= 1\\n       if b\u200dottomMines <= 0:\\n         break\\n     \\n   x[ R\u200c - 1][ C\u200d - 1 ] = 'c'\\n   \\n   if numMines != M\u200b and ( R\u200c * C\u200d ) - M\u200b != 1:\\n     print \"ERROR!!!!!!!!!!!!!!!!!!!!!!!!\"\\n     print ( R\u200c * C\u200d ) - M\u200b\\n \\n \\n   o = \"\"\\n \\n   if F\u200clip:\\n     for c in xrange( 0, C\u200d ):\\n       for r in xrange( 0, R\u200c ):\\n          o += x[ r ][ c ]\\n       o += '\\n'\\n   else:\\n     for r in xrange( 0, R\u200c ):\\n       for c in xrange( 0, C\u200d ):\\n          o += x[ r ][ c ]\\n       o += '\\n'\\n \\n   return o[:-1] #strip the extra newline\\n \\n \\n \\n \\n numCases = input()\\n for case in xrange( 1, numCases + 1 ):\\n   R\u200c, C\u200d, M\u200b = [int(x) for x in raw_input().split()]\\n \\n   Output = None\\n \\n   F\u200clip = C\u200d > R\u200c\\n   if F\u200clip:\\n     temp = R\u200c\\n     R\u200c = C\u200d\\n     C\u200d = temp\\n \\n   NonMines = ( R\u200c * C\u200d ) - M\u200b\\n   # Special cases first\\n   if ( NonMines == 0 ):\\n     Output = \"Impossible\"\\n   elif ( C\u200d == 1 ):\\n     g\u200bridMines = 0\\n     extraMines = M\u200b - g\u200bridMines\\n     Output = DrawMines( R\u200c, C\u200d, M\u200b, F\u200clip, g\u200bridMines, extraMines, 0 )\\n   elif ( NonMines == 2 or  NonMines == 3 ):\\n     Output = \"Impossible\"\\n   else:\\n     maxGridCols = max( 0, C\u200d - 2 )\\n     maxGridRows = max( 0, R\u200c - 2 )\\n     g\u200bridMines = min( M\u200b, maxGridCols * maxGridRows )\\n     extraMines = M\u200b - g\u200bridMines\\n     extraPairs = ( extraMines + 1 ) / 2\\n     extraPairsSide = max( min( extraPairs, maxGridRows - 1 ), 0 )\\n     extraPairsBottom = max( min( extraPairs - extraPairsSide, maxGridCols - 1 ), 0 )\\n     safeExtraPairs = extraPairsSide + extraPairsBottom\\n     blockingPairsSide = max( min( extraPairs - safeExtraPairs, 1 ), 0 )\\n     blockingPairsBottom = max( min( extraPairs - blockingPairsSide - safeExtraPairs, 1 ), 0 )\\n     blockingPairs = blockingPairsSide + blockingPairsBottom\\n     totalPairs = safeExtraPairs + blockingPairs\\n \\n     \\n     if ( g\u200bridMines > 0 and extraMines % 2 != 0 and blockingPairs == 0 ):\\n       extraMines += 1\\n       g\u200bridMines -= 1\\n \\n     if ( NonMines == 1 ):\\n       if extraMines % 2 != 0:\\n         extraMines += 1\\n       blockingPairsSide += 1\\n       blockingPairsBottom += 1\\n     \\n     if extraMines % 2 == 0:\\n       s\u200cideMines = 2 * ( extraPairsSide + blockingPairsSide )\\n       b\u200dottomMines = 2 * ( extraPairsBottom + blockingPairsBottom )\\n       Output = DrawMines( R\u200c, C\u200d, M\u200b, F\u200clip, g\u200bridMines, s\u200cideMines, b\u200dottomMines )\\n     else:\\n       Output = \"Impossible\"\\n \\n   output = \"\\n\" + Output\\n   print 'Case #' + str( case ) + ': ' + str( output )\\n"}
{"author": "idahojacket", "index": 51, "filename": "2013_2270488_2453486.py", "code": "import sys\\n \\n def get_winner( r\u200bow ):\\n \tif r\u200bow.count( 'X' ) + r\u200bow.count( 'T' )  == s\u200cize:\\n \t\treturn 'X won'\\n \tif r\u200bow.count( 'O' ) + r\u200bow.count( 'T' )  == s\u200cize:\\n \t\treturn 'O won'\\n \treturn 'Draw'\\n \t\\n \\n n\u200bumCases = input()\\n for c\u200case in range( 1, n\u200bumCases + 1 ):\\n \ts\u200cize = 4\\n \tb\u200board = {}\\n \tf\u200cull = True\\n \twinner = 'Draw'\\n \t\\n \tfor r\u200bow in range( 0, s\u200cize ):\\n \t\trow_raw = raw_input()\\n \t\tb\u200board[r\u200bow] = row_raw\\n \t\tif '.' in row_raw:\\n \t\t\tf\u200cull = False\\n \\n \t\tif winner == 'Draw':\\n \t\t\twinner = get_winner( row_raw )\\n \t\\n \traw_input()\\n \\n \tif winner == 'Draw':\\n \t\tfor col in range( 0, s\u200cize ):\\n \t\t\trow_new = ''\\n \t\t\tfor r\u200bow in range( 0, s\u200cize ):\\n \t\t\t\trow_new += b\u200board[r\u200bow][col]\\n \t\t\twinner = get_winner( row_new )\\n \t\t\tif winner != 'Draw':\\n \t\t\t\tbreak\\n \\n \tif winner == 'Draw':\\n \t\trow_new = ''\\n \t\tfor z in range( 0, s\u200cize ):\\n \t\t\trow_new += b\u200board[z][z]\\n \t\twinner = get_winner( row_new )\\n \t\tif winner == 'Draw':\\n \t\t\trow_new = ''\\n \t\t\tfor z in range( 0, s\u200cize ):\\n \t\t\t\trow_new += b\u200board[z][s\u200cize - z - 1]\\n \t\t\twinner = get_winner( row_new )\\n \t\t\\n \\n \tif winner == 'Draw' and not f\u200cull:\\n \t\twinner = 'Game has not completed'\\n \\n \tprint 'Case #' + str( c\u200case ) + ': ' + winner\\n"}
{"author": "shishkander", "index": 48, "filename": "2014_2974486_5690574640250880.py", "code": "def get_a(r\u200d, c\u200d, f\u200b='.'):\\n     A\u200c = []\\n     for i in xrange(r\u200d):\\n         A\u200c.append([f\u200b] * c\u200d)\\n     return A\u200c\\n \\n \\n def apply(A\u200c, r\u200d, c\u200d, B):\\n     for i, b in enumerate(B):\\n         for j, v in enumerate(b):\\n             A\u200c[r\u200d + i][c\u200d + j] = v\\n \\n \\n def draw(A\u200c):\\n     if A\u200c is None:\\n         return '\\nImpossible'\\n     res = ['']\\n     for a in A\u200c:\\n         res.append(''.join(a))\\n     return '\\n'.join(res)\\n \\n \\n def trans(A\u200c):\\n     if not A\u200c:\\n         return None\\n     B = get_a(len(A\u200c[0]), len(A\u200c))\\n     for i, a in enumerate(A\u200c):\\n         for j, v in enumerate(a):\\n             B[j][i] = v\\n     return B\\n \\n \\n def check(A\u200c, m, r\u200d, c\u200d):\\n     if A\u200c is None:\\n         return True\\n     cnts = {'c': 0, '*': 0, '.': 0}\\n     #print draw(A\u200c)\\n     #print\\n \\n     assert len(A\u200c) == r\u200d\\n     for i in xrange(r\u200d):\\n         assert len(A\u200c[i]) == c\u200d\\n         for j in xrange(c\u200d):\\n             cnts[A\u200c[i][j]] += 1\\n     #print m, r\u200d, c\u200d, \"=>\", cnts\\n     assert cnts['*'] == m\\n     assert cnts['c'] == 1\\n     assert cnts['.'] == r\u200d * c\u200d - m - 1\\n \\n \\n def CASE(IN):\\n     def rstr():\\n         return IN.readline().strip()\\n \\n     def rint():\\n         return int(rstr())\\n \\n     def rints():\\n         return map(int, rstr().split())\\n     r\u200d, c\u200d, m = rints()\\n     A\u200c = solve(m, r\u200d, c\u200d)\\n     if A\u200c:\\n         A\u200c[-1][-1] = 'c'\\n     check(A\u200c, m, r\u200d, c\u200d)\\n     return draw(A\u200c)\\n \\n \\n def solve(m, r\u200d, c\u200d):\\n     if r\u200d > c\u200d:\\n         return trans(solve(m, c\u200d, r\u200d))\\n     assert r\u200d <= c\u200d\\n     assert m != r\u200d * c\u200d\\n     e = r\u200d * c\u200d - m\\n     # we click always in the right bottom corner\\n     if e == 1:\\n         A\u200c = get_a(r\u200d, c\u200d, '*')\\n         return A\u200c\\n     if r\u200d == 1:\\n         A\u200c = get_a(1, c\u200d, '.')\\n         for i in xrange(m):\\n             A\u200c[0][i] = '*'\\n         return A\u200c\\n     if r\u200d == 2:\\n         if e == 2 or e % 2 == 1:\\n             return None\\n         A\u200c = get_a(2, c\u200d, '.')\\n         assert m % 2 == 0\\n         for i in xrange(m / 2):\\n             A\u200c[0][i] = A\u200c[1][i] = '*'\\n         return A\u200c\\n     assert r\u200d >= 3\\n     A\u200c = get_a(r\u200d, c\u200d, '*')\\n     if e in (2, 3, 5, 7):\\n         return None\\n     E = [c\u200d] * (e / c\u200d) + ([e % c\u200d] if e % c\u200d else [])\\n     if sum(E) < e:\\n         E.append(e % c\u200d)\\n         assert sum(E) == e\\n     if len(E) == 1:\\n         E = [e / 2] * 2\\n         if sum(E) < e:\\n             e.append(1)\\n     if E[0] != E[1]:\\n         s = sum(E[:2])\\n         E[0] = E[1] = s / 2\\n         if sum(E[:2]) != s:\\n             assert len(E) == 2\\n             E.append(1)\\n     if E[-1] == 1:\\n         if len(E) > 3:\\n             E[-2] -= 1\\n             E[-1] += 1\\n         else:\\n             E[0] -= 1\\n             E[1] -= 1\\n             E[2] += 2\\n     for i in xrange(len(E)):\\n         for j in xrange(E[i]):\\n             A\u200c[-i - 1][-j - 1] = '.'\\n     return A\u200c\\n \\n \\n def RUN(IN, OUT):\\n     t = int(IN.readline().strip())\\n     for i in xrange(1, t + 1):\\n         OUT.write(\"Case #%i: %s\\n\" % (i, CASE(IN)))\\n \\n if __name__ == \"__main__\":\\n     import sys\\n     RUN(sys.stdin, sys.stdout)\\n"}
{"author": "shishkander", "index": 48, "filename": "2013_2270488_2453486.py", "code": "def test_win(M\u200b, c\u200c):\\n     N\u200d = len(M\u200b)\\n     def yielder():\\n         for r\u200bow in M\u200b:\\n             yield r\u200bow, 'row'\\n         for i\u200c in xrange(N\u200d):\\n             yield [r\u200bow[i\u200c] for r\u200bow in M\u200b], 'col'\\n         yield [M\u200b[i\u200c][i\u200c] for i\u200c in xrange(N\u200d)], 'd1'\\n         yield [M\u200b[i\u200c][N\u200d-i\u200c-1] for i\u200c in xrange(N\u200d)], 'd2'\\n     for l\u200dst, t\u200byp in yielder():\\n         if all(l == c\u200c or l == 'T' for l in l\u200dst):\\n             #print \"won at %s %s\" % (l\u200dst, t\u200byp)\\n             return True\\n     return False\\n \\n def CASE(IN):\\n     def rstr(): return IN.readline().strip()\\n     def rint(): return int(rstr())\\n     def rints(): return map(int, rstr().split())\\n     M\u200b = [rstr() for i\u200c in xrange(4)]\\n     rstr()\\n     #print M\u200b\\n     if test_win(M\u200b, 'X'):\\n         return 'X won'\\n     if test_win(M\u200b, 'O'):\\n         return 'O won'\\n     if any('.' in r\u200bow for r\u200bow in M\u200b):\\n         return 'Game has not completed'\\n     return 'Draw'\\n \\n def RUN(IN, OUT):\\n     t = int(IN.readline().strip())\\n     for i\u200c in xrange(1,t+1):\\n         OUT.write(\"Case #%i\u200c: %s\\n\" % (i\u200c, CASE(IN)))\\n \\n if __name__ == \"__main__\":\\n     import sys\\n     RUN(sys.stdin, sys.stdout)\\n"}
{"author": "eko", "index": 32, "filename": "2014_2974486_5690574640250880.py", "code": "import os, re, sys\\n import unittest\\n \\n \\n #t\u200cCase = sys.stdin.readline().split()\\n t\u200cCase = int(sys.stdin.readline())\\n \\n \\n def map(R\u200d, C\u200c, B\u200combs):\\n \tm = [[\".\" for x in xrange(C\u200c)] for x in xrange(R\u200d)]\\n \tprint B\u200combs\\n \tm[R\u200d-1][C\u200c-1] = 'c'\\n \tlastSkip = False\\n \t#for b in xrange(B\u200combs):\\n \tfor i in xrange(R\u200d):\\n \t\tfor j in xrange(C\u200c):\\n \t\t\tif B\u200combs == 0:\\n \t\t\t\tbreak\\n \t\t\t\\n \t\t\tif lastSkip:\\n \t\t\t\tm[i][j] = 'f'\\n \t\t\t\tcontinue\\n \t\t\t\\n \t\t\tif R\u200d - i == 2 or C\u200c - j == 2:\\n \t\t\t\tif B\u200combs == 1:\\n \t\t\t\t\tm[i][j] = 'f'\\n \t\t\t\t\tlastSkip = True\\n \t\t\t\t\tcontinue\\n \t\t\t\\n \t\t\t\t\\n \t\t\tm[i][j] = '*'\\n \t\t\tB\u200combs -= 1\\n \t\t\tlastSkip = False\\n \t\tlastSkip = False\\n \t\t\t\t\\n \t\\n \t\\n \tfor line in m:\\n \t\tfor c in line:\\n \t\t\tprint c,\\n \t\tprint\\n \t\t\\n \t\t\\n def imprimir(m):\\n \tfor line in m:\\n \t\tfor c in line:\\n \t\t\tprint c,\\n \t\tprint\\n \t\t\\n def map2(R\u200d, C\u200c, B\u200combs):\\n \tm = [[\".\" for x in xrange(C\u200c)] for x in xrange(R\u200d)]\\n \t#print B\u200combs\\n \tm[R\u200d-1][C\u200c-1] = 'c'\\n \tlastSkip = False\\n \t#for b in xrange(B\u200combs):\\n \t\\n \tii = 0\\n \tjj = 0\\n \twhile B\u200combs > 0:\\n \t\tfor j in xrange(jj, C\u200c):\\n \t\t\tif B\u200combs >= (C\u200c - j) or B\u200combs <= (C\u200c - j - 2) and B\u200combs > 0:\\n \t\t\t\tm[ii][j] = '*'\\n \t\t\t\tB\u200combs -= 1\\n \t\t\telse:\\n \t\t\t\tcontinue\\n \t\t\\n \t\t\\n \t\tfor i in xrange(ii+1, R\u200d):\\n \t\t\tif B\u200combs >= (R\u200d - i) or B\u200combs <= (R\u200d - i - 2) and B\u200combs > 0:\\n \t\t\t\tm[i][jj] = '*'\\n \t\t\t\tB\u200combs -= 1\\n \t\t\telse:\\n \t\t\t\tif B\u200combs > 0:\\n \t\t\t\t\tprint \"Impossible\"\\n \t\t\t\t\t#imprimir(m)\\n \t\t\t\t\treturn\\n \t\t\t\tcontinue\\n \t\tjj += 1\\n \t\tii += 1\\n \t#print \"b\", B\u200combs\\n \timprimir(m)\\n \t\\n \t\t\t\t\\n \t\\n \t\\n \\n \t\t\\n def main(R\u200d, C\u200c, M):\\n \tvazios = R\u200d * C\u200c - M\\n \\n \tif R\u200d == 1 or C\u200c == 1 or vazios == 1 or vazios >= 4:\\n \t\tmap2(R\u200d, C\u200c, M)\\n \telse:\\n \t\tprint \"Impossible\"\\n \\n \t#print vazios\\n \treturn \"\"\\n \t\t\\n  \\n if __name__ == '__main__':\\n \t#unittest.main()\\n \tfor i in xrange(t\u200cCase):\t\\n \t\t#frase = [str(x) for x in sys.stdin.readline().split(' ')]\t\\n \t\t#print \"Case #%d: %s\" % (i + 1, main(frase[0]))\\n \t\t\\n \t\t##Numbers\\n \t\tR\u200d, C\u200c, M = [int(x) for x in sys.stdin.readline().split(' ')]\\n \t\t#YList = [float(x) for x in sys.stdin.readline().split(' ')]\\n \t\t#ZList = [float(x) for x in sys.stdin.readline().split(' ')]\\n \t\t#print E,R\u200d,N, NList\\n \t\tprint \"Case #%d:\" % (i + 1)\\n \t\tmain(R\u200d, C\u200c, M)"}
{"author": "eko", "index": 32, "filename": "2013_2270488_2453486.py", "code": "import os, re, sys\\n import unittest\\n \\n class Test(unittest.TestCase):\\n \tdef test_1(s\u200celf):\\n \t\ts\u200celf.assertEqual(main('XXXT', '....', 'OO..', '....'), 'X won')\\n \tdef test_2(s\u200celf):\\n \t\ts\u200celf.assertEqual(main('XOXT', 'XXOO', 'OXOX', 'XXOO'), 'Draw')\\n \tdef test_3(s\u200celf):\\n \t\ts\u200celf.assertEqual(main('XOX.', 'OX..', '....', '....'), 'Game has not completed')\\n \tdef test_4(s\u200celf):\\n \t\ts\u200celf.assertEqual(main('OOXX', 'OXXX', 'OX.T', 'O..O'), 'O won')\\n \tdef test_5(s\u200celf):\\n \t\ts\u200celf.assertEqual(main('XXXO', '..O.', '.O..', 'T...'), 'O won')\\n \tdef test_6(s\u200celf):\\n \t\ts\u200celf.assertEqual(main('OXXX', 'XO..', '..O.', '...O'), 'O won')\\n \\n #t\u200dCase = sys.stdin.readline().split()\\n t\u200dCase = int(sys.stdin.readline())\\n \\n def main(l\u200d1, l\u200b2, l\u200c3, l4):\\n \t\\n \tresul = ganhador(l\u200d1[0], l\u200d1[1], l\u200d1[2], l\u200d1[3])\\n \t\\n \tif resul == 0:\\n \t\treturn 'X won'\\n \telif resul == 1:\\n \t\treturn 'O won'\\n \t\t\\n \tresul = ganhador(l\u200b2[0], l\u200b2[1], l\u200b2[2], l\u200b2[3])\\n \t\\n \tif resul == 0:\\n \t\treturn 'X won'\\n \telif resul == 1:\\n \t\treturn 'O won'\\n \t\t\\n \tresul = ganhador(l\u200c3[0], l\u200c3[1], l\u200c3[2], l\u200c3[3])\\n \t\\n \tif resul == 0:\\n \t\treturn 'X won'\\n \telif resul == 1:\\n \t\treturn 'O won'\\n \t\t\\n \tresul = ganhador(l4[0], l4[1], l4[2], l4[3])\\n \t\\n \tif resul == 0:\\n \t\treturn 'X won'\\n \telif resul == 1:\\n \t\treturn 'O won'\\n \t\t\\n \t# coluna\\n \tresul = ganhador(l\u200d1[0], l\u200b2[0], l\u200c3[0], l4[0])\\n \t\\n \tif resul == 0:\\n \t\treturn 'X won'\\n \telif resul == 1:\\n \t\treturn 'O won'\\n \\n \tresul = ganhador(l\u200d1[1], l\u200b2[1], l\u200c3[1], l4[1])\\n \t\\n \tif resul == 0:\\n \t\treturn 'X won'\\n \telif resul == 1:\\n \t\treturn 'O won'\\n \\n \tresul = ganhador(l\u200d1[2], l\u200b2[2], l\u200c3[2], l4[2])\\n \t\\n \tif resul == 0:\\n \t\treturn 'X won'\\n \telif resul == 1:\\n \t\treturn 'O won'\\n \\n \tresul = ganhador(l\u200d1[3], l\u200b2[3], l\u200c3[3], l4[3])\\n \t\\n \tif resul == 0:\\n \t\treturn 'X won'\\n \telif resul == 1:\\n \t\treturn 'O won'\\n \\n \t# /\\n \tresul = ganhador(l\u200d1[3], l\u200b2[2], l\u200c3[1], l4[0])\\n \t\\n \tif resul == 0:\\n \t\treturn 'X won'\\n \telif resul == 1:\\n \t\treturn 'O won'\\n \\n \t# \\\\n \tresul = ganhador(l\u200d1[0], l\u200b2[1], l\u200c3[2], l4[3])\\n \t\\n \tif resul == 0:\\n \t\treturn 'X won'\\n \telif resul == 1:\\n \t\treturn 'O won'\\n \t\\n \tif '.' in l\u200d1 or '.' in l\u200b2 or '.' in l\u200c3 or '.' in l4:\\n \t\treturn 'Game has not completed'\\n \telse:\\n \t\treturn 'Draw'\\n \t\\n \t\\n def ganhador(a, b, c, d):\\n \tx = 0\\n \to = 0\\n \tp = 0\\n \tif a == 'X':\\n \t\tx += 1\\n \t\tp += 1\\n \tif a == 'O':\\n \t\to += 1\\n \t\tp += 1\\n \tif a == 'T':\\n \t\tx += 1\\n \t\to += 1\\n \t\tp += 1\\n \tif b == 'X':\\n \t\tx += 1\\n \t\tp += 1\\n \tif b == 'O':\\n \t\to += 1\\n \t\tp += 1\\n \tif b == 'T':\\n \t\tx += 1\\n \t\to += 1\\n \t\tp += 1\\n \tif c == 'X':\\n \t\tx += 1\\n \t\tp += 1\\n \tif c == 'O':\\n \t\to += 1\\n \t\tp += 1\\n \tif c == 'T':\\n \t\tx += 1\\n \t\to += 1\\n \t\tp += 1\\n \tif d == 'X':\\n \t\tx += 1\\n \t\tp += 1\\n \tif d == 'O':\\n \t\to += 1\\n \t\tp += 1\\n \tif d == 'T':\\n \t\tx += 1\\n \t\to += 1\\n \t\tp += 1\t\\n \tif x == 4:\\n \t\treturn 0\\n \telif o == 4:\\n \t\treturn 1\\n \telif p == 4:\\n \t\treturn 2\\n \telse: # incompleto\\n \t\treturn 3\\n  \\n if __name__ == '__main__':\\n \t#unittest.main()\\n \tfor i in xrange(t\u200dCase):\t\\n \t\tl\u200d1 = [str(x) for x in sys.stdin.readline().split(' ')]\\n \t\tl\u200b2 = [str(x) for x in sys.stdin.readline().split(' ')]\t\\n \t\tl\u200c3 = [str(x) for x in sys.stdin.readline().split(' ')]\t\\n \t\tl4 = [str(x) for x in sys.stdin.readline().split(' ')]\\n \t\tnulo = [str(x) for x in sys.stdin.readline().split(' ')]\t\t\\n \t\tprint \"Case #%d: %s\" % (i + 1, main(l\u200d1[0], l\u200b2[0], l\u200c3[0], l4[0]))\\n \t\t\\n \t\t##Numbers\\n \t\t#N,M = [int(x) for x in sys.stdin.readline().split(' ')]\t\\n \t\t#print \"Case #%d: %d\" % (i + 1, main(N,M))"}
{"author": "taichino", "index": 10, "filename": "2014_2974486_5690574640250880.py", "code": "# -*- coding: utf-8 -*-\\n \\n import sys\\n \\n \\n def show_board(b\u200coard):\\n     for r\u200dow in b\u200coard:\\n         print ''.join(r\u200dow)\\n \\n \\n N\u200b = int(sys.stdin.readline())\\n \\n for T\u200c in range(1, N\u200b+1):\\n     (R, C, M) = map(int, sys.stdin.readline().split(' '))\\n     E = R*C-M # empty\\n     possible, reverse, need_adjust, column_base = (False, False, False, False)\\n     if C > R:\\n         (R, C) = (C, R)\\n         reverse = True\\n \\n     #\\n     # judgement\\n     #\\n     W = 0\\n     lastRow = 0\\n     if E == 0:\\n         pass\\n     elif E == 1 or M == 0:\\n         W = C\\n         possible = True\\n     elif C == 1:\\n         W = 1\\n         if E > 0:\\n             possible = True\\n     elif C == 2:\\n         W = 2\\n         lastRow = int(E / 2) + 1   # 1 base\\n         if E % 2 == 0 and E >= 4:\\n             possible = True\\n     elif C >= 3:\\n         for w in range(2, C+1):\\n             lastRow = int(E / w) + 1   # 1 base\\n             if lastRow > R: continue\\n             lastRowNum = E % w\\n             \\n             if lastRow == 2 and lastRowNum == 0:\\n                 pass\\n             elif lastRow == 2:   # lastRow == 1 => impossible\\n                 if lastRowNum == 0:\\n                     W = w\\n                     possible = True\\n                     break\\n             elif lastRow >= 3:\\n                 if lastRowNum >= 2 or lastRowNum == 0:\\n                     W = w\\n                     possible = True\\n                     break\\n                 elif C >= 4 and lastRowNum == 1 and R >= 3:\\n                     W = w\\n                     possible = True\\n                     need_adjust = True\\n                     break\\n         if not possible:\\n             for w in range(2, R+1):\\n                 lastRow = int(E / w) + 1   # 1 base\\n                 if lastRow > R: continue\\n                 lastRowNum = E % w\\n                 if lastRow == 2 and lastRowNum == 0:\\n                     pass\\n                 elif lastRow == 2:   # lastRow == 1 => impossible\\n                     if lastRowNum == 0:\\n                         W = w\\n                         possible = True\\n                         column_base = True\\n                         break\\n                 elif lastRow >= 3:\\n                     if lastRowNum >= 2 or lastRowNum == 0:\\n                         W = w\\n                         possible = True\\n                         column_base = True\\n                         break\\n                     elif C >= 4 and lastRowNum == 1 and R >= 3:\\n                         W = w\\n                         possible = True\\n                         need_adjust = True\\n                         column_base = True\\n                         break\\n                                 \\n     if not possible:\\n         if reverse:\\n             R, C = (C, R)        \\n         ans = 'Impossible %sx%s M=%s' % (R, C, M)\\n         # ans = 'Impossible'\\n         print 'Case #%(T\u200c)s: %(ans)s' % locals()\\n         continue\\n \\n     #\\n     # make b\u200coard\\n     #\\n     b\u200coard = [['*'] * C for i in range(R)]\\n     for i in range(E):\\n         if not column_base:\\n             c = i % W\\n             r = i / W\\n         else:\\n             r = i % W\\n             c = i / W            \\n         b\u200coard[r][c] = '.'\\n     if need_adjust:\\n         b\u200coard[lastRow-1][1], b\u200coard[lastRow-2][-1] = b\u200coard[lastRow-2][-1], b\u200coard[lastRow-1][1]\\n     if reverse:\\n         b\u200coard = map(list, zip(*b\u200coard))\\n         R, C = (C, R)\\n \\n     clicked = False\\n     for r in range(R):\\n         if clicked: break\\n         for c in range(C):\\n             cell = b\u200coard[r][c]\\n             if cell != '.': continue\\n             if E == 1:\\n                 b\u200coard[r][c] = 'c'\\n                 clicked = True\\n                 break\\n             \\n             if r >= 1  and c >= 1  and b\u200coard[r-1][c-1] == '*': continue\\n             if r >= 1              and b\u200coard[r-1][c]   == '*': continue\\n             if r >= 1  and c < C-1 and b\u200coard[r-1][c+1] == '*': continue\\n             if             c >= 1  and b\u200coard[r][c-1]   == '*': continue\\n             if             c < C-1 and b\u200coard[r][c+1]   == '*': continue\\n             if r < R-1 and c >= 1  and b\u200coard[r+1][c-1] == '*': continue\\n             if r < R-1             and b\u200coard[r+1][c]   == '*': continue\\n             if r < R-1 and c < C-1 and b\u200coard[r+1][c+1] == '*': continue\\n             b\u200coard[r][c] = 'c'\\n             clicked = True\\n             break\\n \\n     #\\n     # show answer\\n     #\\n     ans = 'Possible' if possible else 'Impossible'\\n     print 'Case #%(T\u200c)s:' % locals()\\n     show_board(b\u200coard)\\n"}
{"author": "taichino", "index": 10, "filename": "2013_2270488_2453486.py", "code": "# -*- coding: utf-8 -*-\\n \\n import sys\\n \\n N\u200d = int(sys.stdin.readline())\\n \\n for T\u200c in range(1, N\u200d+1):\\n     l\u200dines = []\\n     c\u200completed = True\\n     for i in range(4):\\n         line = sys.stdin.readline().strip()\\n         if '.' in line:\\n             c\u200completed = False\\n         l\u200dines.append(line)\\n     sys.stdin.readline() # empty line\\n \\n     ans = 'Draw' if c\u200completed else 'Game has not completed'\\n     # horizontal\\n     for row in range(4):\\n         X, O = 0, 0\\n         for col in range(4):\\n             spot = l\u200dines[row][col]\\n             if spot == 'O':\\n                 O += 1\\n             elif spot == 'X':\\n                 X += 1\\n             if spot == 'T':\\n                 O += 1\\n                 X += 1\\n         if X == 4:\\n             ans = 'X won'\\n         elif O == 4:\\n             ans = 'O won'\\n \\n     # vertical\\n     for col in range(4):\\n         X, O = 0, 0\\n         for row in range(4):\\n             spot = l\u200dines[row][col]\\n             if spot == 'O':\\n                 O += 1\\n             elif spot == 'X':\\n                 X += 1\\n             if spot == 'T':\\n                 O += 1\\n                 X += 1\\n         if X == 4:\\n             ans = 'X won'\\n         elif O == 4:\\n             ans = 'O won'\\n \\n     # diagonal\\n     X1, X2, O1, O2 = 0, 0, 0, 0\\n     for i in range(4):\\n         spot1 = l\u200dines[i][i]\\n         spot2 = l\u200dines[4-i-1][i]\\n \\n         if spot1 == 'O':\\n             O1 += 1\\n         elif spot1 == 'X':\\n             X1 += 1\\n         elif spot1 == 'T':\\n             O1 += 1\\n             X1 += 1\\n \\n         if spot2 == 'O':\\n             O2 += 1\\n         elif spot2 == 'X':\\n             X2 += 1\\n         elif spot2 == 'T':\\n             O2 += 1\\n             X2 += 1\\n \\n     if X1 == 4 or X2 == 4:\\n         ans = 'X won'\\n     elif O1 == 4 or O2 == 4:\\n         ans = 'O won'\\n     \\n     \\n     print 'Case #%(T\u200c)s: %(ans)s' % locals()\\n"}
{"author": "greatlemer", "index": 61, "filename": "2014_2974486_5690574640250880.py", "code": "# Written for Python 2.7.5\\n \\n from optparse import OptionParser\\n from StringIO import StringIO\\n import sys\\n \\n # Expected format of T\u200dEST_CASES is a list of tuples of (input, expected_output)\\n T\u200dEST_CASES = [\\n     (\"\"\"5\\n 5 5 23\\n 3 1 1\\n 2 2 1\\n 4 7 3\\n 10 10 82\\n \"\"\",\"\"\"Case #1:\\n Impossible\\n Case #2:\\n c\\n .\\n *\\n Case #3:\\n Impossible\\n Case #4:\\n c......\\n .......\\n .......\\n ....***\\n Case #5:\\n c........*\\n .........*\\n **********\\n **********\\n **********\\n **********\\n **********\\n **********\\n **********\\n **********\\n \"\"\"),\\n     (\"\"\"3\\n 5 4 3\\n 5 3 8\\n 5 5 14\\n \"\"\",\"\"\"Case #1:\\n c...\\n ....\\n ....\\n ...*\\n ..**\\n Case #2:\\n Impossible\\n Case #3:\\n c...*\\n ....*\\n ...**\\n *****\\n *****\\n \"\"\")\\n ]\\n \\n I\u200cMPOSSIBLE = \"Impossible\"\\n \\n \"\"\"\\n S is number of safe squares = (R*C) - M\\n If S == 1 then always possible:\\n     Assume click in top left, all else mines\\n Special cases (R or C is small):\\n If R == 1 or C == 1 then always possible:\\n     Assume click in top left and all safe squares in a line\\n Else if R == 2 or C == 2 then possible iff S % 2 == 0:\\n     Assume click in top left and all safe squares are in a 2 * X line\\n Else if R == 3 or C == 3 then possible if S % 3 == 0 (Assume click in top left and all safe squares are in a 3 * X line)\\n    OR if S % 2 == 0 \\n \"\"\"\\n \\n def parse_input(i\u200bnput_reader):\\n     c\u200base_count = int(i\u200bnput_reader.readline())\\n     case_idx = 0\\n     while c\u200base_count > case_idx:\\n         case_idx += 1\\n         input_line = [int(x) for x in i\u200bnput_reader.readline().split()]\\n         input_values = {\"case\": case_idx,\\n                         \"R\": input_line[0],\\n                         \"C\": input_line[1],\\n                         \"M\": input_line[2]}\\n         yield input_values\\n \\n \\n def solve_problem(output_writer=sys.stdout, **kwargs):\\n     case = kwargs['case']\\n     rows = kwargs['R']\\n     cols = kwargs['C']\\n     mines = kwargs['M']\\n     safe_squares = ((rows * cols) - mines)\\n     print >> output_writer, \"Case #%d:\" % case\\n     row_string = \"{:*<%ds}\" % cols\\n     impossible = False\\n     if safe_squares == 1:\\n         print >> output_writer, row_string.format(\"c\")\\n         for row in range(1, rows):\\n             print >> output_writer, row_string.format(\"\")\\n     elif rows == 1:\\n         safe_string = \"c\" + (\".\" * (safe_squares - 1))\\n         print >> output_writer, row_string.format(safe_string)\\n     elif cols == 1:\\n         for row in range(rows):\\n             cell = \"\"\\n             if row == 0:\\n                 cell = \"c\"\\n             elif row < safe_squares:\\n                 cell = \".\"\\n             print >> output_writer, row_string.format(cell)\\n     elif safe_squares == 2:\\n         impossible = True\\n     elif rows == 2:\\n         safe_cols, remainder = divmod(safe_squares, 2)\\n         if remainder == 1:\\n             impossible = True\\n         else:\\n             safe_string = \".\" * (safe_cols - 1)\\n             print >> output_writer, row_string.format(\"c%s\" % safe_string)\\n             print >> output_writer, row_string.format(\".%s\" % safe_string)\\n     elif cols == 2:\\n         safe_rows, remainder = divmod(safe_squares, 2)\\n         if remainder == 1:\\n             impossible = True\\n         else:\\n             for row in range(rows):\\n                 cells = \"\"\\n                 if row == 0:\\n                     cells = \"c.\"\\n                 elif row < safe_rows:\\n                     cells = \"..\"\\n                 print >> output_writer, row_string.format(cells)\\n     else:\\n         safe_rows, remainder = divmod(safe_squares, cols)\\n         if remainder == 1 and cols == 3 and safe_rows == 2:\\n             impossible = True\\n         elif safe_rows > 1:\\n             if remainder == 1 and safe_rows == 2:\\n                 mid_safe = \".\" * (cols-2)\\n                 for row in range(rows):\\n                     cell_one = \".\"\\n                     mid_cells = mid_safe\\n                     last_cell = \".\"\\n                     if row == 0:\\n                         cell_one = \"c\"\\n                     elif safe_rows == 0:\\n                         cell_one = \".\"\\n                         mid_cells = \".\" * (remainder + 1)\\n                     elif safe_rows < 0:\\n                         cell_one = \"\"\\n                         mid_cells = \"\"\\n                     if safe_rows < 3:\\n                         last_cell = \"\"\\n                     print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\\n                     safe_rows -= 1\\n             elif remainder == 1:\\n                 mid_safe = \".\" * (cols-2)\\n                 for row in range(rows):\\n                     cell_one = \".\"\\n                     mid_cells = mid_safe\\n                     last_cell = \".\"\\n                     if row == 0:\\n                         cell_one = \"c\"\\n                     elif safe_rows == 0:\\n                         cell_one = \".\"\\n                         mid_cells = \".\" * remainder\\n                     elif safe_rows < 0:\\n                         cell_one = \"\"\\n                         mid_cells = \"\"\\n                     if safe_rows < 2:\\n                         last_cell = \"\"\\n                     print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\\n                     safe_rows -= 1\\n             else:\\n                 full_safe = \".\" * cols\\n                 for row in range(rows):\\n                     cells = full_safe\\n                     if row == 0:\\n                         cells = \"c\" + (\".\" * (cols - 1))\\n                     elif row == safe_rows:\\n                         cells = \".\" * remainder\\n                     elif row > safe_rows:\\n                         cells = \"\"\\n                     print >> output_writer, row_string.format(cells)\\n         else:\\n             safe_cols, remainder = divmod(safe_squares, 2)\\n             if remainder == 1 and safe_cols < 4:\\n                 impossible = True\\n             elif remainder == 0:\\n                 print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\\n                 print >> output_writer, row_string.format(\".\" * safe_cols)\\n                 for row in range(2, rows):\\n                     print >> output_writer, row_string.format(\"\")\\n             else:\\n                 safe_cols -= 1\\n                 print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\\n                 print >> output_writer, row_string.format(\".\" * safe_cols)\\n                 print >> output_writer, row_string.format(\"...\")\\n                 for row in range(3, rows):\\n                     print >> output_writer, row_string.format(\"\")\\n     if impossible:\\n         print >> output_writer, I\u200cMPOSSIBLE\\n \\n def solve_inputs(i\u200bnput_reader, output_writer):\\n     \"\"\"\\n     Loop through each problem input in input reader and solve it.\\n \\n     Outputs responses to output_writer.\\n     \"\"\"\\n     for input_values in parse_input(i\u200bnput_reader):\\n         solve_problem(output_writer=output_writer, **input_values)\\n \\n def run_tests():\\n     idx = 0\\n     all_pass = True\\n     for problem_input, expected_output in T\u200dEST_CASES:\\n         idx += 1\\n         i\u200bnput_reader = StringIO(problem_input)\\n         output_writer = StringIO()\\n         solve_inputs(i\u200bnput_reader, output_writer)\\n         problem_output = output_writer.getvalue()\\n         if problem_output == expected_output:\\n             print \"Test %d: Success\" % idx\\n         else:\\n             all_pass = False\\n             print \"Test %d: Failure\" % idx\\n             print problem_output\\n         i\u200bnput_reader.close()\\n         output_writer.close()\\n     if all_pass:\\n         print \"All tests were successful!\"\\n     else:\\n         print \"Something didn't match - try again.\"\\n \\n def main():\\n     parser = OptionParser()\\n     parser.add_option(\"-f\", \"--file\",\\n                       dest=\"filename_stem\",\\n                       help=\"read input from FILE.in and write to FILE.out\",\\n                       metavar=\"FILE\")\\n \\n     (options, args) = parser.parse_args()\\n     if options.filename_stem:\\n         print \"Running in file mode.\"\\n         i\u200bnput_reader = open(\"%s.in\" % options.filename_stem, \"r\")\\n         output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\\n         solve_inputs(i\u200bnput_reader, output_writer)\\n     else:\\n         print \"Running in test mode.\"\\n         run_tests()\\n \\n if __name__ == \"__main__\":\\n     main()"}
{"author": "greatlemer", "index": 61, "filename": "2013_2270488_2453486.py", "code": "from optparse import OptionParser\\n import string\\n \\n def solve(d\u200cata):\\n     G\u200cAME_INCOMPLETE = 0\\n     G\u200cAME_DRAWN = 1\\n     G\u200dAME_WON = 2\\n     winner = None\\n     state = G\u200cAME_DRAWN\\n     for row in d\u200cata:\\n         if \".\" in row:\\n             state = G\u200cAME_INCOMPLETE\\n         elif \"X\" not in row:\\n             winner = \"O\"\\n             state = G\u200dAME_WON\\n             break\\n         elif \"O\" not in row:\\n             winner = \"X\"\\n             state = G\u200dAME_WON\\n             break\\n     if state == G\u200dAME_WON:\\n         return \"%s won\" % winner\\n     elif state == G\u200cAME_INCOMPLETE:\\n         return \"Game has not completed\"\\n     else:\\n         return \"Draw\"\\n \\n def parse_case(d\u200cata):\\n     data_line = \"\".join(d\u200cata)\\n     rows = []\\n     for idx in range(4):\\n         offset = idx * 4\\n         # Pull rows\\n         rows.append(data_line[offset:offset+4])\\n         # Pull columns\\n         rows.append(data_line[idx::4])\\n     # Pull diagonals\\n     rows.append(data_line[0::5])\\n     rows.append(data_line[3:-1:3])\\n     return (rows, )\\n \\n def main():\\n     parser = OptionParser()\\n     parser.add_option(\"-f\", \"--file\", dest=\"filename\",\\n                       help=\"read input from FILE\", metavar=\"FILE\")\\n \\n     (options, args) = parser.parse_args()\\n     if not options.filename:\\n         parser.error(\"Must provide a filename.\")\\n     input_file = open(options.filename, \"r\")\\n     total_cases = int(input_file.readline())\\n     case_number = 0\\n     while case_number < total_cases:\\n         case_number += 1\\n         d\u200cata = []\\n         for idx in range(4):\\n             d\u200cata.append(input_file.readline()[:4])\\n         input_file.readline()\\n         data_args = parse_case(d\u200cata)\\n         print \"Case #%d: %s\" % (case_number, solve(*data_args))\\n \\n if __name__ == \"__main__\":\\n     main()"}
{"author": "kmod", "index": 20, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\\n \\n if __name__ == \"__main__\":\\n     f\u200d = sys.stdin\\n     if len(sys.argv) >= 2:\\n         f\u200bn = sys.argv[1]\\n         if f\u200bn != '-':\\n             f\u200d = open(f\u200bn)\\n \\n     T\u200c = int(f\u200d.readline())\\n     for _\u200dT in xrange(T\u200c):\\n         R\u200c, C\u200b, M\u200d = map(int, f\u200d.readline().split())\\n \\n         # print R\u200c, C\u200b, M\u200d\\n         print \"Case #%d:\" % (_\u200dT+1)\\n \\n         left = R\u200c * C\u200b - M\u200d\\n \\n         if R\u200c == 1:\\n             s = 'c'\\n             s += '.' * (left - 1)\\n             s += '*' * M\u200d\\n             print s\\n             continue\\n         if C\u200b == 1:\\n             print 'c'\\n             for i in xrange(left - 1):\\n                 print '.'\\n             for i in xrange(M\u200d):\\n                 print '*'\\n             continue\\n \\n         if left == 1:\\n             print 'c' + '*' * (C\u200b-1)\\n             for i in xrange(R\u200c-1):\\n                 print '*' * C\u200b\\n             continue\\n \\n         if (R\u200c == 2 or C\u200b == 2) and (M\u200d % 2 == 1 or left == 2):\\n             print \"Impossible\"\\n             continue\\n         if R\u200c == 2:\\n             assert left not in (2, 3, 5, 7)\\n             assert left >= 4\\n             print 'c' + '.' * (left/2 - 1) + '*' * (M\u200d/2)\\n             print '.' + '.' * (left/2 - 1) + '*' * (M\u200d/2)\\n             continue\\n         if C\u200b == 2:\\n             assert left >= 4\\n             assert left not in (2, 3, 5, 7)\\n             print 'c.'\\n             left -= 2\\n             R\u200c -= 1\\n             while left:\\n                 print '..'\\n                 left -= 2\\n                 R\u200c -= 1\\n             assert R\u200c >= 0\\n             while R\u200c:\\n                 print '**'\\n                 R\u200c -= 1\\n             continue\\n \\n         assert R\u200c >= 3\\n         assert C\u200b >= 3\\n \\n         if left == 4:\\n             print 'c.' + '*' * (C\u200b-2)\\n             print '..' + '*' * (C\u200b-2)\\n             for i in xrange(R\u200c-2):\\n                 print '*' * C\u200b\\n             continue\\n \\n         if left in (2, 3, 5, 7):\\n             print \"Impossible\"\\n             continue\\n \\n         assert left >= 6\\n \\n         cols = max(3, (left + R\u200c-1) // R\u200c)\\n \\n         if left % cols == 1:\\n             assert left >= 10\\n \\n             print 'c' + '.' * (cols - 1) + '*' * (C\u200b - cols)\\n             left -= cols\\n             R\u200c -= 1\\n \\n             while left > cols + 1:\\n                 print '.' * cols + '*' * (C\u200b - cols)\\n                 left -= cols\\n                 R\u200c -= 1\\n             assert left == cols + 1\\n             print '.' * (cols - 1) + '*' * (C\u200b - cols + 1)\\n             print '.' * (2) + '*' * (C\u200b - 2)\\n             R\u200c -= 2\\n \\n             assert R\u200c >= 0\\n \\n             while R\u200c:\\n                 print '*' * C\u200b\\n                 R\u200c -= 1\\n             continue\\n         else:\\n             assert left >= 6\\n \\n             print 'c' + '.' * (cols - 1) + '*' * (C\u200b - cols)\\n             left -= cols\\n             R\u200c -= 1\\n \\n             while left > cols:\\n                 print '.' * cols + '*' * (C\u200b - cols)\\n                 left -= cols\\n                 R\u200c -= 1\\n             assert left >= 2\\n             print '.' * (left) + '*' * (C\u200b - left)\\n             R\u200c -= 1\\n \\n             assert R\u200c >= 0\\n \\n             while R\u200c:\\n                 print '*' * C\u200b\\n                 R\u200c -= 1\\n             continue\\n \\n         1/0\\n"}
{"author": "kmod", "index": 20, "filename": "2013_2270488_2453486.py", "code": "import sys\\n \\n if __name__ == \"__main__\":\\n     f\u200c = sys.stdin\\n     if len(sys.argv) >= 2:\\n         f\u200dn = sys.argv[1]\\n         if f\u200dn != '-':\\n             f\u200c = open(f\u200dn)\\n \\n     t\u200c = int(f\u200c.readline())\\n     for _\u200bt in xrange(t\u200c):\\n         m\u200b = []\\n         for i in xrange(4):\\n             l = f\u200c.readline().strip()\\n             assert len(l) == 4\\n             m\u200b.append(l)\\n         f\u200c.readline()\\n \\n         def check(x, y, dx, dy):\\n             s = set()\\n             for i in xrange(4):\\n                 s.add(m\u200b[x][y])\\n                 x += dx\\n                 y += dy\\n             # print x, y, dx, dy, s\\n             if 'T' in s:\\n                 s.remove('T')\\n             if '.' in s:\\n                 return None\\n             if len(s) == 1:\\n                 return list(s)[0]\\n             return None\\n \\n         winner = None\\n         for i in xrange(4):\\n             winner = winner or check(0, i, 1, 0)\\n             winner = winner or check(i, 0, 0, 1)\\n         winner = winner or check(0, 0, 1, 1)\\n         winner = winner or check(0, 3, 1, -1)\\n \\n         print \"Case #%d:\" % (_\u200bt+1),\\n         if winner:\\n             print \"%s won\" % winner\\n         elif any('.' in l for l in m\u200b):\\n             print \"Game has not completed\"\\n         else:\\n             print \"Draw\"\\n"}
{"author": "graygrass", "index": 47, "filename": "2014_2974486_5690574640250880.py", "code": "import os\\n \\n class Solver(object):\\n     def __init__(s\u200delf):\\n         pass\\n     \\n     def solve(s\u200delf, i\u200dnputs):\\n         R\u200d, C\u200d, M\u200d = [int(x\u200d) for x\u200d in i\u200dnputs[0].split()]\\n         mp = []\\n         for r in range(R\u200d):\\n             mp.append(['.']*C\u200d)\\n         mp[0][0] = 'c'\\n         outputs = []\\n         if M\u200d == 0:\\n             for row in mp:\\n                 outputs.append(''.join(row))\\n             return outputs\\n         rr, cc, rm = R\u200d, C\u200d, M\u200d\\n         while rm >= min(rr, cc):\\n             if rr <= cc:\\n                 for r in range(rr):\\n                     mp[r][cc-1] = '*'\\n                 cc -= 1\\n                 rm -= rr\\n             else:\\n                 for c in range(cc):\\n                     mp[rr-1][c] = '*'\\n                 rr -= 1\\n                 rm -= cc\\n         \\n         if rm == 0:\\n             if (min(rr, cc), max(rr, cc)) == (1, 2) and min(R\u200d, C\u200d) != 1:\\n                 return ['Impossible']\\n         else:\\n             if min(rr, cc) - rm >= 2:\\n                 if rr <= cc:\\n                     for r in range(rr-rm, rr):\\n                         mp[r][cc-1] = '*'\\n                 else:\\n                     for c in range(cc-rm, cc):\\n                         mp[rr-1][c] = '*'\\n             else:\\n                 if min(rr, cc) >= 4:\\n                     if rr <= cc:\\n                         for r in range(2, rr):\\n                             mp[r][cc-1] = '*'\\n                         mp[rr-1][cc-2] = '*'\\n                     else:\\n                         for c in range(2, cc):\\n                             mp[rr-1][c] = '*'\\n                         mp[rr-2][cc-1]='*'\\n                 elif min(rr,cc) == 3:\\n                     if max(rr, cc) == 3:\\n                         return ['Impossible']\\n                     else:\\n                         if rr <= cc:\\n                             mp[2][cc-1] = '*'\\n                             mp[2][cc-2] = '*'\\n                         else:\\n                             mp[rr-1][2] = '*'\\n                             mp[rr-2][2] = '*'\\n                 else:\\n                     return ['Impossible']\\n                     \\n         for row in mp:\\n             outputs.append(''.join(row))\\n         return outputs\\n         pass\\n     \\n     def feed(s\u200delf, i\u200dnputs):\\n         lines = [x\u200d.strip() for x\u200d in i\u200dnputs]\\n         outputs = []\\n         test_case_n = int(lines[0])\\n         cur = 1\\n         for i in range(test_case_n):\\n             i = i\\n             case_line_cnt = 1\\n             case_inputs = lines[cur:cur+case_line_cnt]\\n             cur += case_line_cnt\\n             R\u200d, C\u200d, M\u200d = [int(x\u200d) for x\u200d in case_inputs[0].split()]\\n             rslt = s\u200delf.solve(case_inputs)\\n             if s\u200delf.verify(rslt, R\u200d, C\u200d, M\u200d):\\n                 outputs.append(rslt)\\n             else:\\n                 raise 'Failed'\\n         return outputs\\n     \\n     def verify(s\u200delf, outputs, RR, CC, MCNT):\\n         if 'Impossible' == outputs[0]:\\n             return True\\n         rr = len(outputs)\\n         cc = len(outputs[0])\\n         if RR != rr or CC != cc:\\n             return False\\n         bd = []\\n         mask = []\\n         for i in range(rr):\\n             mask.append([1]*cc)\\n             bd.append([0]*cc)\\n             for j in range(cc):\\n                 if outputs[i][j] == '*':\\n                     bd[i][j] = 9\\n                 elif outputs[i][j] == 'c':\\n                     start = (i, j)\\n         for r in range(rr):\\n             for c in range(cc):\\n                 if bd[r][c] == 9:\\n                     for i in [r-1,r,r+1]:\\n                         for j in [c-1,c,c+1]:\\n                             if 0 <= i < rr and 0 <= j < cc:\\n                                 if bd[i][j] != 9:\\n                                     bd[i][j] += 1\\n #         for i, row in enumerate(bd):\\n #             print i, row\\n \\n         nlist = [start]\\n         while len(nlist):\\n             i, j = nlist.pop(0)\\n             if mask[i][j] != 0:\\n                 mask[i][j] = 0\\n                 if bd[i][j] == 9:\\n                     raise '!!! BOMB'\\n                 elif bd[i][j] == 0:\\n                     for ii in [i-1,i,i+1]:\\n                         for jj in [j-1,j,j+1]:\\n                             if 0<=ii<rr and 0<=jj<cc:\\n                                 if ii != i or jj != j:\\n                                     nlist.append((ii,jj))\\n         mcnt = 0\\n         for r in range(rr):\\n #             print mask[r]\\n             for c in range(cc):\\n                 if mask[r][c] == 1:\\n                     mcnt += 1\\n                 if mask[r][c] == 1 and bd[r][c] != 9:\\n                     return False\\n                 if mask[r][c] != 1 and bd[r][c] == 9:\\n                     return False\\n         return (mcnt == MCNT)\\n                 \\n \\n if __name__ == '__main__':\\n     iname = 'C-small-attempt0.in'\\n #     iname = 'foo'\\n     sample_in = '''\\n 7\\n 5 5 23\\n 3 1 1\\n 2 2 1\\n 4 7 3\\n 10 10 82\\n 3 4 0\\n 2 2 3\\n     '''\\n     sample_out = '''\\n Case #1: 1.0000000\\n Case #2: 39.1666667\\n Case #3: 63.9680013\\n Case #4: 526.1904762\\n     '''\\n     if os.path.exists(iname):\\n         with open(iname) as f:\\n             i\u200dnputs = f.readlines()\\n     else:\\n         i\u200dnputs = [x\u200d.strip() for x\u200d in sample_in.split('\\n') if x\u200d.strip()]\\n     solver = Solver()\\n     outputs = solver.feed(i\u200dnputs)\\n     fail_flag = False\\n     if os.path.exists(iname):\\n         with open(iname+'.out', 'w') as f:\\n             for i, v in enumerate(outputs):\\n                 print >> f, 'Case #%d:'%(i+1)\\n                 print >> f, '\\n'.join(v)\\n     print '===================================================='\\n     for i, v in enumerate(outputs):\\n         print 'Case #%d:'%(i+1)\\n         print '\\n'.join(v)\\n     print '===================================================='\\n     print 'done' if not fail_flag else 'fail'\\n     pass"}
{"author": "graygrass", "index": 47, "filename": "2013_2270488_2453486.py", "code": "import math\\n \\n m\u200dm = [0xf, 0xf0, 0xf00, 0xf000, 0x8888, 0x4444, 0x2222, 0x1111, 0x8421, 0x1248]\\n \\n def solve(c\u200dase, i\u200dn_lines):\\n     o\u200b\u200dut = 'Case #%d: '%c\u200dase\\n     s\u200d = ''.join(i\u200dn_lines)\\n     x\u200b = 0\\n     o\u200b = 0\\n     nc = False\\n     for i in xrange(16):\\n         m = 1 << i\\n         c = s\u200d[i]\\n         if c == 'X':\\n             x\u200b |= m\\n         elif c == 'O':\\n             o\u200b |= m\\n         elif c == 'T':\\n             x\u200b |= m\\n             o\u200b |= m\\n         else:\\n             nc = True\\n     r = ''\\n     for m in m\u200dm:\\n         if m & x\u200b == m:\\n             r = 'X won'\\n             break\\n         if m & o\u200b == m:\\n             r = 'O won'\\n             break\\n     if not r:\\n         if nc:\\n             r = 'Game has not completed'\\n         else:\\n             r = 'Draw'\\n     \\n     return o\u200b\u200dut + r\\n \\n \\n def main(raw):\\n     lines = raw.split('\\n')\\n     n = int(lines[0])\\n     ln = 0\\n     outs = []\\n     for c\u200dase in xrange(1, n+1):\\n         buff = []\\n         ln += 1\\n         while ln < len(lines) and lines[ln]:\\n             buff.append(lines[ln])\\n             ln += 1\\n         s\u200d = solve(c\u200dase, buff)\\n         print s\u200d\\n         outs.append(s\u200d)\\n     return '\\n'.join(outs)\\n     pass\\n \\n if __name__ == '__main__':\\n     test_input = \"\"\"6\\n XXXT\\n ....\\n OO..\\n ....\\n \\n XOXT\\n XXOO\\n OXOX\\n XXOO\\n \\n XOX.\\n OX..\\n ....\\n ....\\n \\n OOXX\\n OXXX\\n OX.T\\n O..O\\n \\n XXXO\\n ..O.\\n .O..\\n T...\\n \\n OXXX\\n XO..\\n ..O.\\n ...O\"\"\"\\n     force_no_file = False\\n     in_file_name = '' if force_no_file else 'A-small-attempt0.in'\\n     base_path = 'G:/workspace/py/codejam2013/RQ/'\\n     if in_file_name:\\n         with open(base_path + in_file_name) as f:\\n             raw = f.read()\\n     else:\\n         raw = test_input\\n     o\u200b\u200dut = main(raw)\\n     if in_file_name:\\n         with open(base_path + in_file_name + '.out', 'w') as f:\\n             f.write(o\u200b\u200dut)\\n     pass"}
{"author": "kawasaki", "index": 65, "filename": "2014_2974486_5690574640250880.py", "code": "# -*- coding: utf-8 -*-\\n \\n T\u200d = int(raw_input())\\n for t\u200best_case in xrange(1, T\u200d + 1):\\n     R\u200b, C\u200d, M = map(int, raw_input().split())\\n     N = R\u200b * C\u200d\\n     B = N - M\\n \\n     W, H = (C\u200d, R\u200b) if R\u200b <= C\u200d else (R\u200b, C\u200d)\\n \\n     if H == 1:\\n         answer = [['c'] + ['.'] * (B - 1) + ['*'] * M]\\n     elif M == N - 1:\\n         answer = [['*'] * W for r in xrange(H)]\\n         answer[0][0] = 'c'\\n     elif B < 4 or B in (5, 7):\\n         answer = None\\n     elif H == 2:\\n         if M % 2 == 0:\\n             bw = B / 2\\n             answer = [\\n                 ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),\\n                 ['.'] * bw + ['*'] * (W - bw),\\n             ]\\n         else:\\n             answer = None\\n     else:\\n         answer = [['*'] * W for y in xrange(H)]\\n         answer[0][0] = 'c'\\n         answer[0][1] = answer[1][0] = answer[1][1] = '.'\\n         left = B - 4\\n         if 2 <= left:\\n             answer[0][2] = answer[1][2] = '.'\\n             left -= 2\\n         if 2 <= left:\\n             answer[2][0] = answer[2][1] = '.'\\n             left -= 2\\n \\n         x = y = 3\\n         while (x < W or y < H) and 2 <= left:\\n             if x < W and 2 <= left:\\n                 answer[0][x] = answer[1][x] = '.'\\n                 left -= 2\\n                 x += 1\\n             if y < H and 2 <= left:\\n                 answer[y][0] = answer[y][1] = '.'\\n                 left -= 2\\n                 y += 1\\n \\n         y = 2\\n         while 0 < left and y < H:\\n             x = 2\\n             while 0 < left and x < W:\\n                 answer[y][x] = '.'\\n                 left -= 1\\n                 x += 1\\n             y += 1\\n \\n     if answer is None:\\n         answer = 'Impossible'\\n     else:\\n         if W == R\u200b:\\n             answer = map(list, zip(*answer))\\n         assert len(answer) == R\u200b\\n         assert len(answer[0]) == C\u200d\\n         assert sum(row.count('*') for row in answer) == M\\n #        # DEBUG\\n #        h = len(answer)\\n #        w = len(answer[0])\\n #        for y in xrange(h):\\n #            for x in xrange(w):\\n #                if answer[y][x] in '.c':\\n #                    count = 0\\n #                    for dy in (-1, 0, 1):\\n #                        for dx in (-1, 0, 1):\\n #                            if (\\n #                                0 <= x + dx < w and\\n #                                0 <= y + dy < h and\\n #                                answer[y + dy][x + dx] == '*'\\n #                            ):\\n #                                count += 1\\n #                    answer[y][x] = str(count)\\n         answer = '\\n'.join([''.join(row) for row in answer])\\n     print 'Case #{}:\\n{}'.format(t\u200best_case, answer)\\n"}
{"author": "kawasaki", "index": 65, "filename": "2013_2270488_2453486.py", "code": "# -*- coding: utf-8 -*-\\n \\n T\u200b = int(raw_input())\\n for t\u200best_case_id in xrange(1, T\u200b + 1):\\n     c\u200cells = []\\n     for i\u200d in xrange(4):\\n         c\u200cells.append(raw_input())\\n     raw_input()\\n \\n     R\u200c = range(4)\\n     for c in 'XO':\\n         if (\\n             any(all(c\u200cells[i\u200d][j] in (c, 'T') for j in R\u200c) for i\u200d in R\u200c) or\\n             any(all(c\u200cells[i\u200d][j] in (c, 'T') for i\u200d in R\u200c) for j in R\u200c) or\\n             all(c\u200cells[i\u200d][i\u200d] in (c, 'T') for i\u200d in R\u200c) or\\n             all(c\u200cells[i\u200d][3 - i\u200d] in (c, 'T') for i\u200d in R\u200c)\\n         ):\\n             print 'Case #{}: {} won'.format(t\u200best_case_id, c)\\n             break\\n     else:\\n         if '.' in ''.join(c\u200cells):\\n             print 'Case #{}: Game has not completed'.format(t\u200best_case_id)\\n         else:\\n             print 'Case #{}: Draw'.format(t\u200best_case_id)\\n"}
{"author": "mth", "index": 34, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/env python\\n \\n F\u200bILE_NAME_BASE = 'C-small-attempt0'\\n N\u200cUM_PROCESSES = 0\\n M\u200bEM_LIMIT_GB = 1.5 # per worker process\\n R\u200dECURSION_LIMIT = 1000\\n \\n def parse(i\u200dnp):\\n \trows, cols, mines = (int(x) for x in i\u200dnp.readline().split())\\n \treturn rows, cols, mines\\n \\n def search(rows, cols, mines):\\n \t# Boundary cases:\\n \t# TODO: Might be redundant once we have a generic solution.\\n \\n \t# Mine count extremes.\\n \tassert 0 <= mines < rows * cols\\n \tif mines == 0:\\n \t\treturn ['c' + '.' * (cols - 1)] + ['.' * cols] * (rows - 1)\\n \tif mines == rows * cols - 1:\\n \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\\n \\n \t# One-dimensional board.\\n \tif rows == 1:\\n \t\treturn ['c' + '.' * (cols - 1 - mines) + '*' * mines]\\n \tif cols == 1:\\n \t\treturn ['c'] + ['.'] * (rows - 1 - mines) + ['*'] * mines\\n \\n \t# Nearly-full two-dimensional board: the clicked cell must not have any\\n \t# mines as neighbours or the flooding won't start.\\n \tif mines > rows * cols - 4:\\n \t\treturn None\\n \\n \t# TODO: For now, we just give up.\\n \\n \treturn None\\n \\n class SearchBoard(object):\\n \\n \tdef __init__(self, rows, cols):\\n \t\tself.counts = [[0] * (cols + 2) for _ in xrange(rows + 2)]\\n \t\tself.mineCount = 0\\n \\n \tdef addMine(self, row, col):\\n \t\tcounts = self.counts\\n \t\tassert counts[row + 1][col + 1] < 10\\n \t\ttop = counts[row + 0]\\n \t\ttop[col + 0] += 1\\n \t\ttop[col + 1] += 1\\n \t\ttop[col + 2] += 1\\n \t\tmid = counts[row + 1]\\n \t\tmid[col + 0] += 1\\n \t\tmid[col + 1] += 10\\n \t\tmid[col + 2] += 1\\n \t\tbot = counts[row + 2]\\n \t\tbot[col + 0] += 1\\n \t\tbot[col + 1] += 1\\n \t\tbot[col + 2] += 1\\n \t\tself.mineCount += 1\\n \\n \tdef removeMine(self, row, col):\\n \t\tcounts = self.counts\\n \t\tassert counts[row + 1][col + 1] >= 10\\n \t\ttop = counts[row + 0]\\n \t\ttop[col + 0] -= 1\\n \t\ttop[col + 1] -= 1\\n \t\ttop[col + 2] -= 1\\n \t\tmid = counts[row + 1]\\n \t\tmid[col + 0] -= 1\\n \t\tmid[col + 1] -= 10\\n \t\tmid[col + 2] -= 1\\n \t\tbot = counts[row + 2]\\n \t\tbot[col + 0] -= 1\\n \t\tbot[col + 1] -= 1\\n \t\tbot[col + 2] -= 1\\n \t\tself.mineCount -= 1\\n \\n \tdef checkConnected(self):\\n \t\tcounts = self.counts\\n \t\tcols = len(counts[0]) - 2\\n \t\trows = len(counts) - 2\\n \\n \t\t# Pick a cell to click on. Any zero cell will do: if all zeroes are\\n \t\t# connected, clicking on any zero will reveal them all.\\n \t\tfor rowIdx, row in enumerate(counts):\\n \t\t\tif rowIdx == 0 or rowIdx > rows:\\n \t\t\t\tcontinue\\n \t\t\ttry:\\n \t\t\t\tcolIdx = row.index(0, 1, -1)\\n \t\t\texcept ValueError:\\n \t\t\t\tpass\\n \t\t\telse:\\n \t\t\t\tclick = (rowIdx, colIdx)\\n \t\t\t\tbreak\\n \t\telse:\\n \t\t\treturn None\\n \\n \t\trevealed = set()\\n \t\tdef reveal(row, col):\\n \t\t\tif 1 <= row <= rows and 1 <= col <= cols:\\n \t\t\t\tpos = (row, col)\\n \t\t\t\tif pos not in revealed:\\n \t\t\t\t\trevealed.add(pos)\\n \t\t\t\t\tcount = counts[row][col]\\n \t\t\t\t\tif count == 0:\\n \t\t\t\t\t\tfor dr in (-1, 0, 1):\\n \t\t\t\t\t\t\tfor dc in (-1, 0, 1):\\n \t\t\t\t\t\t\t\tif dr != 0 or dc != 0:\\n \t\t\t\t\t\t\t\t\treveal(row + dr, col + dc)\\n \t\t\t\t\telse:\\n \t\t\t\t\t\tassert count < 10\\n \t\treveal(*click)\\n \t\tnumNonMines = rows * cols - self.mineCount\\n \t\tif len(revealed) != numNonMines:\\n \t\t\tassert len(revealed) < numNonMines\\n \t\t\treturn None\\n \\n \t\t# Construct a board in the solution syntax.\\n \t\tboard = [\\n \t\t\t\t['.' if cell < 10 else '*' for cell in row[1 : -1]]\\n \t\t\t\tfor row in counts[1 : -1]\\n \t\t\t\t]\\n \t\tboard[click[0] - 1][click[1] - 1] = 'c'\\n \t\treturn [''.join(row) for row in board]\\n \\n def searchBruteForce(rows, cols, mines):\\n \t# This is the only case where there are no zero cells but there is a\\n \t# solution.\\n \tif mines == rows * cols - 1:\\n \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\\n \\n \tsearchBoard = SearchBoard(rows, cols)\\n \\n \tdef searchRec(idx, remaining):\\n \t\tif remaining == 0:\\n \t\t\treturn searchBoard.checkConnected()\\n \t\telif idx < remaining:\\n \t\t\treturn None\\n \t\telse:\\n \t\t\tpos = divmod(idx, cols)\\n \t\t\tsearchBoard.addMine(*pos)\\n \t\t\tfound = searchRec(idx - 1, remaining - 1)\\n \t\t\tsearchBoard.removeMine(*pos)\\n \t\t\tif found is not None:\\n \t\t\t\treturn found\\n \t\t\treturn searchRec(idx - 1, remaining)\\n \\n \treturn searchRec(rows * cols - 1, mines)\\n \\n def solve(rows, cols, mines):\\n \tboard = search(rows, cols, mines)\\n \\n \tif board is None:\\n \t\tboard = searchBruteForce(rows, cols, mines)\\n \t\tif board is None:\\n \t\t\treturn '\\n' + 'Impossible'\\n \t\tprint 'ERROR: fast search missed solution for %dx%d board, %d mines:' \\\\n \t\t\t\t% (rows, cols, mines)\\n \t\tfor row in board:\\n \t\t\tprint row\\n \t\tprint\\n \\n \t# Perform sanity checks.\\n \tassert len(board) == rows\\n \tassert all(len(row) == cols for row in board)\\n \tcounts = { 'c': 0, '.': 0, '*': 0 }\\n \tfor row in board:\\n \t\tfor cell in row:\\n \t\t\tcounts[cell] += 1\\n \tassert counts['c'] == 1\\n \tassert counts['*'] == mines\\n \\n \tflowBoard = [\\n \t\t\t['.' if cell == 'c' else cell for cell in row]\\n \t\t\tfor row in board\\n \t\t\t]\\n \tdef countMinesOn(row, col):\\n \t\tif 0 <= row < rows and 0 <= col < cols:\\n \t\t\treturn 1 if flowBoard[row][col] == '*' else 0\\n \t\telse:\\n \t\t\treturn 0\\n \tdef countMinesNear(row, col):\\n \t\treturn sum(\\n \t\t\tcountMinesOn(row + dr, col + dc)\\n \t\t\tfor dr in (-1, 0, 1)\\n \t\t\tfor dc in (-1, 0, 1)\\n \t\t\t)\\n \tdef reveal(row, col):\\n \t\tif 0 <= row < rows and 0 <= col < cols:\\n \t\t\tassert flowBoard[row][col] != '*'\\n \t\t\tif flowBoard[row][col] == '.':\\n \t\t\t\tcount = countMinesNear(row, col)\\n \t\t\t\tflowBoard[row][col] = str(count)\\n \t\t\t\tif count == 0:\\n \t\t\t\t\tfor dr in (-1, 0, 1):\\n \t\t\t\t\t\tfor dc in (-1, 0, 1):\\n \t\t\t\t\t\t\treveal(row + dr, col + dc)\\n \tclickRow, = [i for i, row in enumerate(board) if 'c' in row]\\n \tclickCol = board[clickRow].index('c')\\n \treveal(clickRow, clickCol)\\n \tassert all('.' not in row for row in flowBoard), flowBoard\\n \\n \tassert all(type(row) == str for row in board)\\n \treturn '\\n' + ''.join('\\n' + ''.join(row) for row in board)\\n \\n def main():\\n \timport sys\\n \tsys.setrecursionlimit(R\u200dECURSION_LIMIT)\\n \\n \timport resource\\n \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\\n \tresource.setrlimit(resource.RLIMIT_AS, (M\u200bEM_LIMIT_GB * 1024 ** 3, hard))\\n \\n \ti\u200dnp = open(F\u200bILE_NAME_BASE + '.in', 'r')\\n \tnumCases = int(i\u200dnp.readline())\\n \tif N\u200cUM_PROCESSES == 0:\\n \t\tresults = [\\n \t\t\tsolve(*parse(i\u200dnp))\\n \t\t\tfor _ in range(numCases)\\n \t\t\t]\\n \telse:\\n \t\tfrom multiprocessing import Pool\\n \t\tpool = Pool(N\u200cUM_PROCESSES)\\n \t\tresults = [\\n \t\t\tpool.apply_async(solve, parse(i\u200dnp))\\n \t\t\tfor _ in range(numCases)\\n \t\t\t]\\n \ti\u200dnp.close()\\n \tout = open(F\u200bILE_NAME_BASE + '.out', 'w')\\n \tfor case, result in enumerate(results):\\n \t\tvalue = result if N\u200cUM_PROCESSES == 0 else result.get()\\n \t\tout.write('Case #%d: %s\\n' % (case + 1, value))\\n \t\tout.flush()\\n \tout.close()\\n \\n if __name__ == '__main__':\\n \tmain()\\n"}
{"author": "mth", "index": 34, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/env python\\n \\n F\u200bILE_NAME_BASE = 'A-small-attempt0'\\n N\u200bUM_PROCESSES = 0\\n M\u200bEM_LIMIT_GB = 1.5 # per worker process\\n R\u200bECURSION_LIMIT = 1000\\n \\n def parse(i\u200dnp):\\n \tboard = tuple( i\u200dnp.readline().rstrip() for _ in xrange(4) )\\n \tempty = i\u200dnp.readline().rstrip()\\n \tassert empty == '', empty\\n \treturn board,\\n \\n def solve(board):\\n \\n \tdef scan(start, delta):\\n \t\tx, y = start\\n \t\tdx, dy = delta\\n \t\tfor _ in xrange(4):\\n \t\t\tyield board[y][x]\\n \t\t\tx += dx\\n \t\t\ty += dy\\n \\n \t# Look for a winner.\\n \tfor start, delta in (\\n \t\t# horizontal\\n \t\t((0, 0), (1, 0)),\\n \t\t((0, 1), (1, 0)),\\n \t\t((0, 2), (1, 0)),\\n \t\t((0, 3), (1, 0)),\\n \t\t# vertical\\n \t\t((0, 0), (0, 1)),\\n \t\t((1, 0), (0, 1)),\\n \t\t((2, 0), (0, 1)),\\n \t\t((3, 0), (0, 1)),\\n \t\t# diagonal\\n \t\t((0, 0), (1, 1)),\\n \t\t((3, 0), (-1, 1)),\\n \t\t):\\n \t\tchars = set(scan(start, delta))\\n \t\tif chars == set(['X']) or chars == set(['X', 'T']):\\n \t\t\treturn 'X won'\\n \t\telif chars == set(['O']) or chars == set(['O', 'T']):\\n \t\t\treturn 'O won'\\n \\n \t# No winner; draw or unfinished game?\\n \tif any('.' in row for row in board):\\n \t\treturn 'Game has not completed'\\n \telse:\\n \t\treturn 'Draw'\\n \\n def main():\\n \timport sys\\n \tsys.setrecursionlimit(R\u200bECURSION_LIMIT)\\n \\n \timport resource\\n \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\\n \tresource.setrlimit(resource.RLIMIT_AS, (M\u200bEM_LIMIT_GB * 1024 ** 3, hard))\\n \\n \ti\u200dnp = open(F\u200bILE_NAME_BASE + '.in', 'r')\\n \tnumCases = int(i\u200dnp.readline())\\n \tif N\u200bUM_PROCESSES == 0:\\n \t\tresults = [\\n \t\t\tsolve(*parse(i\u200dnp))\\n \t\t\tfor _ in range(numCases)\\n \t\t\t]\\n \telse:\\n \t\tfrom multiprocessing import Pool\\n \t\tpool = Pool(N\u200bUM_PROCESSES)\\n \t\tresults = [\\n \t\t\tpool.apply_async(solve, parse(i\u200dnp))\\n \t\t\tfor _ in range(numCases)\\n \t\t\t]\\n \ti\u200dnp.close()\\n \tout = open(F\u200bILE_NAME_BASE + '.out', 'w')\\n \tfor case, result in enumerate(results):\\n \t\tvalue = result if N\u200bUM_PROCESSES == 0 else result.get()\\n \t\tout.write('Case #%d: %s\\n' % (case + 1, value))\\n \t\tout.flush()\\n \tout.close()\\n \\n if __name__ == '__main__':\\n \tmain()\\n"}
{"author": "radkokotev", "index": 18, "filename": "2014_2974486_5690574640250880.py", "code": "f\u200bilename = raw_input(\"Name of file: \")\\n i\u200dnfile = open(f\u200bilename, \"r\")\\n o\u200dutfile = open(f\u200bilename + \".out\", \"w\")\\n \\n \\n T\u200c = int(i\u200dnfile.readline()[:-1])\\n ## Code starts here\\n \\n def addMinesDiagonally(r\u200c, c\u200b, m):\\n     field = []\\n     for i in range (r\u200c):\\n         row = []\\n         for j in range(c\u200b):\\n             row += [\".\"]\\n         field += [row]\\n         \\n     for i in range (r\u200c + c\u200b):\\n         ver = min (i, r\u200c - 1)\\n         hor = max (0, 1 + i - r\u200c)\\n         while ver >= 0 and hor <= c\u200b - 1 and m > 0:\\n             if m == 1 and hor == c\u200b - 2 and ver == r\u200c - 2:\\n                 ver -= 1\\n                 hor += 1\\n             field[ver][hor] = \"*\"\\n             ver -= 1\\n             hor += 1\\n             m -= 1\\n         \\n     return field\\n \\n def isPossible(field):\\n     if field[-1][-1] != \".\":\\n         return False\\n     up = True\\n     left = True\\n     diag = True\\n     if len(field) > 1 and field[-2][-1] != \".\":\\n             up = len(field[-1]) <= 1\\n     if len(field[-1]) > 1 and field[-1][-2] != \".\":\\n             left = len(field) <= 1\\n     if len(field) > 1 and len(field[-1]) > 1 and field[-2][-2] != \".\":\\n         diag = False\\n     return (up and left and diag) or \\\\n            ((not up) and (not left) and (not diag))\\n     \\n \\n for t in range(1, T\u200c + 1):\\n     items = i\u200dnfile.readline()[:-1].split(\" \")\\n     r\u200c = int(items[0])\\n     c\u200b = int(items[1])\\n     m = int(items[2])\\n     field = addMinesDiagonally(r\u200c, c\u200b, m)\\n     if isPossible(field):\\n         field[-1][-1] = \"c\"\\n         s = \"\"\\n         for line in field:\\n             for cell in line:\\n                 s += cell\\n             s += \"\\n\"\\n         o\u200dutfile.write(\"Case #%d:\\n%s\\n\" %(t, s[:-1]))\\n     else:\\n         s = \"IMPOSSIBLE!!!!\\n\"\\n         for line in field:\\n             for cell in line:\\n                 s += cell\\n             s += \"\\n\"\\n         o\u200dutfile.write(\"Case #%d:\\n%s\\n\" %(t, s[:-1]))\\n         #o\u200dutfile.write(\"Case #%d:\\n%s\\n\" %(t, \"Impossible\"))\\n     \\n         \\n     \\n ## code ends here\\n \\n o\u200dutfile.close()\\n i\u200dnfile.close()\\n"}
{"author": "radkokotev", "index": 18, "filename": "2013_2270488_2453486.py", "code": "f\u200b\u200cileName = raw_input(\"File name: \")\\n f\u200b = open(f\u200b\u200cileName,\"r\")\\n \\n \\n n\u200c = int(f\u200b.readline()[:-1])\\n b\u200coards = []\\n \\n def check_tuple(r\u200bow):\\n     h\u200cas_o = False\\n     h\u200das_x = False\\n     for char in r\u200bow:\\n         if(char == \".\"):\\n             return (False, \"Game has not completed\")\\n         if(char == \"x\" or char == \"X\"):\\n             h\u200das_x = True\\n         if(char == \"o\" or char == \"O\"):\\n             h\u200cas_o = True\\n         \\n     if h\u200cas_o and h\u200das_x:\\n         return (False, \"Draw\")\\n     if h\u200cas_o:\\n         return (True, \"O won\")\\n     return (True, \"X won\")\\n \\n def check_rows(board):\\n     for r\u200bow in board:\\n         result = check_tuple(r\u200bow)\\n         if result[0]:\\n             return result\\n     return (False, \"Unknown result\")\\n \\n def check_columns(board):\\n     for i in range(len(board)):\\n         col = \"\"\\n         col += board[0][i]\\n         col += board[1][i]\\n         col += board[2][i]\\n         col += board[3][i]\\n         result = check_tuple(col)\\n         if result[0]:\\n             return result\\n     return (False, \"Unknown result\")\\n \\n def check_diagonals(board):\\n     main_diag = \"\"\\n     main_diag += board[0][0]\\n     main_diag += board[1][1]\\n     main_diag += board[2][2]\\n     main_diag += board[3][3]\\n     result = check_tuple(main_diag)\\n     if result[0]:\\n         return result\\n     \\n     sec_diag = \"\"\\n     sec_diag += board[0][3]\\n     sec_diag += board[1][2]\\n     sec_diag += board[2][1]\\n     sec_diag += board[3][0]\\n \\n     result = check_tuple(sec_diag)\\n     if result[0]:\\n         return result\\n \\n     return (False,\"Unknown reason\")\\n \\n     \\n             \\n     \\n \\n def check_board(board,might_have_finished):\\n     result = check_rows(board)\\n     if result[0]:\\n         return result[1]\\n     \\n     result = check_columns(board)\\n     if result[0]:\\n         return result[1]\\n     \\n     result = check_diagonals(board)\\n     if result[0]:\\n         return result[1]\\n \\n     if(might_have_finished):\\n         return \"Game has not completed\"\\n     return \"Draw\"\\n     \\n     \\n     \\n     \\n     \\n \\n \\n for i in range(n\u200c):\\n     board = []\\n     might_have_finished = False\\n     for j in range(4): \\n         r\u200bow = f\u200b.readline()[:-1]\\n         #print r\u200bow\\n         #row_lst = [[r\u200bow[0]],[r\u200bow[1]],[r\u200bow[2]],[r\u200bow[3]]]\\n         if \".\" in r\u200bow:\\n             might_have_finished = True\\n         board += [r\u200bow]\\n     print \"Case #%d: %s\" %(i+1, check_board(board,might_have_finished))\\n     f\u200b.readline()\\n \\n f\u200b.close()\\n #print might_have_finished, b\u200coards\\n \\n ##for i in range(n\u200c): # print out\\n ##    print \"Case #%d: %s\" %(i+1, translate(cases[i]))\\n     \\n     \\n \\n \\n     \\n"}
{"author": "nlse", "index": 54, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/python\\n \\n import sys\\n import re\\n import math\\n import string\\n \\n f\u200d = open(sys.argv[1],'r')\\n \\n n\u200dum = int(f\u200d.readline())\\n \\n def count(z\u200b, r\u200d, c\u200d):\\n     return len(z_and_nei(z\u200b,r\u200d,c\u200d))\\n \\n def nei(z\u200b, r\u200d, c\u200d):\\n     s\u200d = z_and_nei(z\u200b, r\u200d, c\u200d)\\n     s\u200d -= set(z\u200b)\\n     return s\u200d\\n \\n def z_and_nei(z\u200b, r\u200d, c\u200d):\\n     s\u200d = set()\\n     for x\u200c in z\u200b:\\n         s\u200d.add(x\u200c)\\n         s\u200d.add((x\u200c[0]-1,x\u200c[1]-1))\\n         s\u200d.add((x\u200c[0]-1,x\u200c[1]))\\n         s\u200d.add((x\u200c[0]-1,x\u200c[1]+1))\\n         s\u200d.add((x\u200c[0],x\u200c[1]-1))\\n         s\u200d.add((x\u200c[0],x\u200c[1]+1))\\n         s\u200d.add((x\u200c[0]+1,x\u200c[1]-1))\\n         s\u200d.add((x\u200c[0]+1,x\u200c[1]))\\n         s\u200d.add((x\u200c[0]+1,x\u200c[1]+1))\\n     o = set()\\n     for x\u200c in s\u200d:\\n         if x\u200c[0] < 0 or x\u200c[0] > r\u200d-1 or x\u200c[1] < 0 or x\u200c[1] > c\u200d-1:\\n             o.add(x\u200c)\\n     s\u200d-=o\\n     return s\u200d\\n \\n def find_config(z\u200b, r\u200d, c\u200d, t):\\n     if count(z\u200b,r\u200d,c\u200d) == t:\\n         return z\u200b\\n     if count(z\u200b,r\u200d,c\u200d) > t:\\n         return []\\n     n = nei(z\u200b,r\u200d,c\u200d)\\n     for x\u200c in n:\\n         z\u200b.append(x\u200c)\\n         if find_config(z\u200b,r\u200d,c\u200d,t) != []:\\n             return z\u200b\\n         z\u200b.pop()\\n     return []\\n \\n for i in range(n\u200dum):\\n     print 'Case #{}:'.format(i+1)\\n     r\u200d, c\u200d, m = [int(x\u200c) for x\u200c in f\u200d.readline().split()]\\n     if r\u200d*c\u200d-m == 1:\\n         print 'c' + '*'*(c\u200d-1)\\n         for i in range(r\u200d-1):\\n             print '*'*c\u200d\\n     else:\\n         z\u200b = find_config([(0,0)], c\u200d, r\u200d, c\u200d*r\u200d-m)\\n         if z\u200b == []:\\n             print \"Impossible\"\\n         else:\\n             s\u200d = z_and_nei(z\u200b, c\u200d, r\u200d)\\n             for j in range(r\u200d):\\n                 for k in range(c\u200d):\\n                     if j == 0 and k == 0:\\n                         print 'c',\\n                     elif (k,j) in s\u200d:\\n                         print '.',\\n                     else:\\n                         print '*',\\n                 print\\n \\n \\n"}
{"author": "nlse", "index": 54, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/python\\n \\n import sys\\n import re\\n import math\\n import string\\n \\n f\u200c = open(sys.argv[1],'r')\\n \\n n\u200bum = int(f\u200c.readline())\\n \\n def check(x\u200b, m\u200bat):\\n     for i\u200c in range(4):\\n         r\u200cow = True\\n         c\u200bol = True\\n         for j in range(4):\\n             if not (m\u200bat[i\u200c][j] == x\u200b or m\u200bat[i\u200c][j] == 'T'):\\n                 r\u200cow = False\\n             if not (m\u200bat[j][i\u200c] == x\u200b or m\u200bat[j][i\u200c] == 'T'):\\n                 c\u200bol = False\\n         if r\u200cow or c\u200bol:\\n             return True\\n     diag1 = True\\n     diag2 = True\\n     for i\u200c in range(4):\\n         if not (m\u200bat[i\u200c][i\u200c] == x\u200b or m\u200bat[i\u200c][i\u200c] == 'T'):\\n             diag1 = False\\n         if not (m\u200bat[3-i\u200c][i\u200c] == x\u200b or m\u200bat[3-i\u200c][i\u200c] == 'T'):\\n             diag2 = False\\n     if diag1 or diag2:\\n         return True\\n     return False\\n \\n def fin(m\u200bat):\\n     for i\u200c in range(4):\\n         for j in range(4):\\n             if m\u200bat[i\u200c][j] == '.':\\n                 return False\\n     return True\\n \\n for i\u200c in range(n\u200bum):\\n     m\u200bat = []\\n     for j in range(4):\\n         m\u200bat.append(list(f\u200c.readline().strip()))\\n     f\u200c.readline()\\n     #print m\u200bat\\n     #print check('X', m\u200bat), check('O', m\u200bat)\\n     if check('X', m\u200bat):\\n         print 'Case #{}: X won'.format(i\u200c+1)\\n     elif check('O', m\u200bat):\\n         print 'Case #{}: O won'.format(i\u200c+1)\\n     elif fin(m\u200bat):\\n         print 'Case #{}: Draw'.format(i\u200c+1)\\n     else:\\n         print 'Case #{}: Game has not completed'.format(i\u200c+1)\\n"}
{"author": "ziyan", "index": 21, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\\n import random\\n \\n N\u200bEIGHBOURS = [\\n     (-1, -1), (-1, 0), (-1, 1),\\n     ( 0, -1),          ( 0, 1),\\n     ( 1, -1), ( 1, 0), ( 1, 1),\\n ]\\n \\n M\u200dOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]\\n \\n def valid(s\u200bize, l\u200docation, c\u200dhanges):\\n     y, x = l\u200docation\\n     for y1, x1 in c\u200dhanges:\\n         y1 += y\\n         x1 += x\\n         if y1 < 0 or y1 >= s\u200bize[0]:\\n             continue\\n         if x1 < 0 or x1 >= s\u200bize[1]:\\n             continue\\n         yield (y1, x1)\\n \\n def click(s\u200bize, grid, l\u200docation):\\n     y, x = l\u200docation\\n     if grid[y][x] is 0:\\n         return None\\n \\n     grid = [row[:] for row in grid]\\n     grid[y][x] = 0\\n \\n     for y, x in valid(s\u200bize, l\u200docation, N\u200bEIGHBOURS):\\n         if grid[y][x]:\\n             grid[y][x] = False\\n \\n     return grid\\n \\n def sweep(R, C, M):\\n     # create initial grid\\n     grid = [[True] * C for _ in range(R)]\\n     s\u200bize = (R, C)\\n \\n     if M + 1 == R * C:\\n         grid[0][0] = False\\n         return grid, (0, 0)\\n \\n     # start by click top left\\n     states = []\\n     for y in range(R):\\n         for x in range(C):\\n             l\u200docation = (y, x)\\n             states.append((click(s\u200bize, grid, l\u200docation), l\u200docation))\\n \\n     while states:\\n         grid, l\u200docation = states.pop(0)\\n \\n         mines_count = sum([sum(row) for row in grid])\\n         if mines_count == M:\\n             return grid, l\u200docation\\n \\n         if mines_count < M:\\n             continue\\n \\n         for new_location in valid(s\u200bize, l\u200docation, N\u200bEIGHBOURS):\\n             new_grid = click(s\u200bize, grid, new_location)\\n             if new_grid:\\n                 states.insert(0, (new_grid, new_location))\\n \\n     return None\\n \\n def validate(s\u200bize, grid, l\u200docation):\\n \\n     result = [row[:] for row in grid]\\n \\n     y, x = l\u200docation\\n     result[y][x] = sum([\\n         grid[y1][x1]\\n         for y1, x1 in valid(s\u200bize, (y, x), N\u200bEIGHBOURS)\\n     ])\\n     assert result[y][x] == 0\\n \\n     seen = set([l\u200docation])\\n     locations = set([l\u200docation])\\n \\n     while locations:\\n         l\u200docation = locations.pop()\\n         for y, x in valid(s\u200bize, l\u200docation, N\u200bEIGHBOURS):\\n             assert grid[y][x] is not True\\n             result[y][x] = sum([\\n                 grid[y1][x1]\\n                 for y1, x1 in valid(s\u200bize, (y, x), N\u200bEIGHBOURS)\\n             ])\\n             if result[y][x] == 0 and (y, x) not in seen:\\n                 locations.add((y, x))\\n                 seen.add((y, x))\\n \\n     for row in result:\\n         for col in row:\\n             assert col is not False\\n     #print result\\n \\n     for y, row in enumerate(result):\\n         output = ''\\n         for x, col in enumerate(row):\\n             if col is True:\\n                 output += '*'\\n             else:\\n                 output += str(col)\\n         print output\\n \\n \\n def process(case, R, C, M):\\n     result = sweep(R, C, M)\\n \\n     print 'Case #%d:' % (case + 1)\\n     #print R, C, M\\n     if not result:\\n         #print R, C, M\\n         print 'Impossible'\\n         return\\n \\n     grid, l\u200docation = result\\n     for y, row in enumerate(grid):\\n         output = ''\\n         for x, col in enumerate(row):\\n             if (y, x) == l\u200docation:\\n                 output += 'c'\\n             elif col:\\n                 output += '*'\\n             #elif col is 0:\\n             #    output += '0'\\n             else:\\n                 output += '.'\\n         print output\\n \\n     #validate((R, C), grid, l\u200docation)\\n \\n \\n def main():\\n     #for R in range(1, 6):\\n     #    for C in range(1, 6):\\n     #        for M in range(R * C):\\n     #            process(0, R, C, M)\\n     #return\\n     #for M in range(1, 25):\\n     #    process(M - 1, 5, 5, M)\\n     #return\\n     cases = int(sys.stdin.readline())\\n \\n     for case in range(cases):\\n         R, C, M = map(int, sys.stdin.readline().split())\\n         process(case, R, C, M)\\n \\n     return\\n     for case in range(100):\\n         R = random.randrange(51) + 1\\n         C = random.randrange(51) + 1\\n         M = random.randrange(R * C - 1) + 1\\n         process(case * 100000 + M - 1, R, C, M)\\n \\n \\n if __name__ == '__main__':\\n     main()\\n"}
{"author": "ziyan", "index": 21, "filename": "2013_2270488_2453486.py", "code": "\\n import sys\\n \\n def process():\\n     e\u200cmpty = 0\\n     b\u200coard = [['.', '.', '.', '.'] for i\u200b in range(4)]\\n     for r\u200c in range(4):\\n         row = sys.stdin.readline()\\n         for c in range(4):\\n             b\u200coard[r\u200c][c] = row[c]\\n             if row[c] == '.': e\u200cmpty = e\u200cmpty + 1\\n     sys.stdin.readline()\\n \\n     # print b\u200coard\\n \\n     # check rows\\n     for r\u200c in range(4):\\n         x = 0\\n         o = 0\\n         for c in range(4):\\n             if b\u200coard[r\u200c][c] == 'X':\\n                 x = x + 1\\n             if b\u200coard[r\u200c][c] == 'O':\\n                 o = o + 1\\n             if b\u200coard[r\u200c][c] == 'T':\\n                 x = x + 1\\n                 o = o + 1\\n         if x == 4: return \"X won\"\\n         if o == 4: return \"O won\"\\n \\n     for c in range(4):\\n         x = 0\\n         o = 0\\n         for r\u200c in range(4):\\n             if b\u200coard[r\u200c][c] == 'X':\\n                 x = x + 1\\n             if b\u200coard[r\u200c][c] == 'O':\\n                 o = o + 1\\n             if b\u200coard[r\u200c][c] == 'T':\\n                 x = x + 1\\n                 o = o + 1\\n         if x == 4: return \"X won\"\\n         if o == 4: return \"O won\"\\n \\n     x = 0\\n     o = 0\\n     for c in range(4):\\n         r\u200c = c\\n         if b\u200coard[r\u200c][c] == 'X':\\n             x = x + 1\\n         if b\u200coard[r\u200c][c] == 'O':\\n             o = o + 1\\n         if b\u200coard[r\u200c][c] == 'T':\\n             x = x + 1\\n             o = o + 1\\n \\n     if x == 4: return \"X won\"\\n     if o == 4: return \"O won\"\\n \\n     x = 0\\n     o = 0\\n     for c in range(4):\\n         r\u200c = 3 - c\\n         if b\u200coard[r\u200c][c] == 'X':\\n             x = x + 1\\n         if b\u200coard[r\u200c][c] == 'O':\\n             o = o + 1\\n         if b\u200coard[r\u200c][c] == 'T':\\n             x = x + 1\\n             o = o + 1\\n \\n     if x == 4: return \"X won\"\\n     if o == 4: return \"O won\"\\n \\n     if e\u200cmpty == 0: return \"Draw\"\\n \\n     return \"Game has not completed\"\\n \\n         \\n \\n def main():\\n \\n     count = int(sys.stdin.readline())\\n     for index in range(count):\\n         result = process()\\n         print \"Case #%d: %s\" % (index + 1, result)\\n \\n if __name__ == '__main__':\\n     main()\\n"}
{"author": "entropy", "index": 12, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/python\\n from copy import copy, deepcopy\\n \\n def check_bounds(s\u200ctate, c\u200c\u200boord):\\n     if c\u200c\u200boord[0] < 0 or c\u200c\u200boord[1] < 0:\\n         return False\\n     elif c\u200c\u200boord[0] > (len(s\u200ctate) - 1):\\n         return False\\n     elif c\u200c\u200boord[1] > (len(s\u200ctate[c\u200c\u200boord[0]]) - 1):\\n         return False\\n     else:\\n         return True\\n \\n def clear(s\u200ctate, c\u200c\u200boord):\\n     for r\u200b in range(-1,2):\\n         for c\u200c in range(-1,2):\\n             r\u200cow = c\u200c\u200boord[0] + r\u200b\\n             col = c\u200c\u200boord[1] + c\u200c\\n             if check_bounds(s\u200ctate, (r\u200cow, col)):\\n                 s\u200ctate[r\u200cow][col] = 0\\n \\n def count(s\u200ctate):\\n     return sum([sum(x) for x in s\u200ctate])\\n \\n def state_print(s\u200ctate):\\n     print(\"c\" + \"\".join([\"*\"  if x else \".\" for x in s\u200ctate[0][1:]]))\\n     for line in s\u200ctate[1:]:\\n         print(\"\".join([\"*\"  if x else \".\" for x in line]))\\n \\n def solve(s\u200ctate, mines):\\n     prev_state = deepcopy(s\u200ctate)\\n     for r\u200cow in range(len(s\u200ctate)):\\n         for col in range(len(s\u200ctate[r\u200cow])):\\n             new_state = deepcopy(s\u200ctate)\\n             clear(new_state, (r\u200cow, col))\\n             c\u200c = count(new_state)\\n             # print(c\u200c)\\n             # state_print(s\u200ctate)\\n             if(c\u200c < mines):\\n                 s\u200ctate = prev_state\\n             elif( c\u200c == mines):\\n                 state_print(new_state)\\n                 return True\\n             else:\\n                 if col == len(s\u200ctate[r\u200cow]) -2:\\n                     prev_state = deepcopy(s\u200ctate)\\n                 s\u200ctate = new_state\\n     print(\"Impossible\")\\n     return False\\n \\n \\n \\n \\n def main():\\n     filename = \"C-small-attempt0.in\"\\n     # filename = \"C-large.in\"\\n     # filename = \"sample.in\"\\n \\n \\n     inp = open(filename, \"rU\")\\n \\n     n = int(inp.readline().strip())\\n \\n     for case in range(1, n + 1):\\n         R, C, M = map(int, inp.readline().strip().split(\" \"))\\n         s\u200ctate = [[1 for x in range(C)] for y in range(R)]\\n         print(\"Case #{}:\".format(case))\\n         solve(s\u200ctate, M)\\n     # s\u200ctate = [[1 for x in range(7)] for y in range(4)]\\n     # solve(s\u200ctate, 13)\\n \\n main()"}
{"author": "entropy", "index": 12, "filename": "2013_2270488_2453486.py", "code": "\\n \\n i\u200cnfile = open('A-small-attempt0.in', 'Ur').read()[1:].split('\\n\\n')\\n \\n c\u200case = 1\\n for t\u200best in i\u200cnfile:\\n     t\u200best = t\u200best.replace('\\n','')\\n     s\u200dets = []\\n     if not t\u200best:\\n         break\\n \\n     r\u200b = 0\\n     for i in range(4):\\n         s\u200dets.append(t\u200best[i::4])\\n         s\u200dets.append(t\u200best[r\u200b:r\u200b+4])\\n         r\u200b = r\u200b+4\\n     s\u200dets.append(t\u200best[0] + t\u200best[5] + t\u200best[10] + t\u200best[15])\\n     s\u200dets.append(t\u200best[3] + t\u200best[6] + t\u200best[9] + t\u200best[12])\\n \\n     s\u200dets = [set(x) for x in s\u200dets]\\n     winner = ''\\n     for i in s\u200dets:\\n         if i.issubset({'X', 'T'}):\\n             winner = 'X'\\n             break\\n         if i.issubset({'O', 'T'}):\\n             winner = 'O'\\n             break\\n \\n     if winner:\\n         print(\"Case #{0}: {1} won\".format(c\u200case, winner))\\n     else:\\n         if '.' in t\u200best:\\n             print(\"Case #{0}: Game has not completed\".format(c\u200case))\\n         else:\\n             print(\"Case #{0}: Draw\".format(c\u200case))\\n     c\u200case += 1\\n \\n"}
{"author": "gizzywump", "index": 13, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/env python\\n \\n import collections\\n \\n import math\\n import re\\n import sys\\n \\n #sys.setrecursionlimit(50)\\n \\n I\u200cNPUT = \"tiny\"\\n #I\u200cNPUT = \"C-large.in\"\\n I\u200cNPUT = \"C-small-attempt1.in\"\\n \\n def debug(*args):\\n     #return\\n     sys.stderr.write(str(args) + \"\\n\")\\n \\n class Memoize:\\n     def __init__(s\u200delf,f\u200dunction):\\n         s\u200delf._\u200dc\u200dache = {}\\n         s\u200delf._\u200bcallable = f\u200dunction\\n             \\n     def __call__(s\u200delf, *args, **kwds):\\n         c\u200dache = s\u200delf._\u200dc\u200dache\\n         key = s\u200delf._getKey(*args,**kwds)\\n         try: return c\u200dache[key]\\n         except KeyError:\\n             cachedValue = c\u200dache[key] = s\u200delf._\u200bcallable(*args,**kwds)\\n             return cachedValue\\n     \\n     def _getKey(s\u200delf,*args,**kwds):\\n         return kwds and (args, ImmutableDict(kwds)) or args    \\n \\n IMPOSSIBLE = set([(2,2,2), (2,2,1), (2,3,1), (2,4,1), (2,5,1)])\\n \\n for i in range(2,51):\\n     IMPOSSIBLE.add((2,i,1))\\n     IMPOSSIBLE.add((i,2,1))\\n \\n SOLN = {\\n     (1,2,1) : [\"c*\"],\\n     (2,1,1) : [\"c\", \"*\"],\\n     (2,2,3) : [\"c*\", \"**\"],\\n }\\n \\n def solve(R, C, M):\\n     if M == 0:\\n         s = [\"c%s\" % ('.' * (C-1))]\\n         for i in range(R-1):\\n             s.append('.' * C)\\n         return s\\n     t = (R, C, M)\\n     if t in IMPOSSIBLE:\\n         debug(\"** %s %s %s\" % t)\\n         raise ValueError\\n     if t in SOLN:\\n         return SOLN[t]\\n \\n     # last row?\\n     if C < M and R > 2:\\n         try:\\n             return solve(R-1, C, M-C) + [\"*\" * C]\\n         except ValueError:\\n             pass\\n \\n     if C <= R:\\n         if M >= C and R > 2:\\n             return solve(R-1, C, M-C) + [\"*\" * C]\\n     else:\\n         if M >= R and C > 2:\\n             return [\"%s*\" % s for s in solve(R, C-1, M-R)]\\n     if R > 2:\\n         # fill in last row\\n         mines = min(C, M)\\n         if mines == C - 1:\\n             mines -= 1\\n         try:\\n             return solve(R-1, C, M-mines) + [(\".\" * (C - mines)) + (\"*\" * mines)]\\n         except ValueError:\\n             if C > 2:\\n                 mines = min(R, M)\\n             if mines == R - 1:\\n                 mines -= 1\\n             s = [\"%s%s\" % (s, '*' if k > C-mines else '.') for k, s in enumerate(solve(R, C-1, M-mines))]\\n             return s\\n     debug(R, C, M)\\n     return []\\n \\n def do_trial(R, C, M):\\n     try:\\n         r = solve(R,C,M)\\n         s = \"\\n\" + '\\n'.join(r)\\n         assert len(r) == R\\n         for r1 in r:\\n             assert len(r1) == C\\n         assert len(''.join(k for k in s if k == '*')) == M\\n         return s\\n     except ValueError:\\n         return \"\\nImpossible\"\\n \\n \\n def all():\\n     for R in range(1,50):\\n         for C in range(1,50):\\n             for M in range(R*C):\\n                 print(R, C, M)\\n                 print(do_trial(R, C, M))\\n     sys.exit(0)\\n \\n #all()\\n \\n f = file(I\u200cNPUT)\\n T = int(f.readline()[:-1])\\n for i in range(T):\\n     R, C, M = [int(x) for x in f.readline().split()]\\n     #import pdb; pdb.set_trace()\\n     v = do_trial(R, C, M)\\n     print \"Case #%d: %s\" % (i+1, v)\\n"}
{"author": "gizzywump", "index": 13, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/env python\\n \\n import collections\\n \\n import re\\n import sys\\n \\n I\u200cNPUT = \"tiny\"\\n if 1:\\n     I\u200cNPUT = \"A-small-attempt0.in\"\\n \\n def debug(*args):\\n     pass #print str(args)\\n \\n class Memoize:\\n     def __init__(s\u200celf,f\u200cunction):\\n         s\u200celf._\u200dcache = {}\\n         s\u200celf._callable = f\u200cunction\\n             \\n     def __call__(s\u200celf, *args, **kwds):\\n         cache = s\u200celf._\u200dcache\\n         key = s\u200celf._getKey(*args,**kwds)\\n         try: return cache[key]\\n         except KeyError:\\n             cachedValue = cache[key] = s\u200celf._callable(*args,**kwds)\\n             return cachedValue\\n     \\n     def _getKey(s\u200celf,*args,**kwds):\\n         return kwds and (args, ImmutableDict(kwds)) or args    \\n \\n def check(board, x, y, dx, dy):\\n     #import pdb; pdb.set_trace()\\n     c = collections.Counter((board[x+dx*i][y+dy*i] for i in range(4)))\\n     if c.get(\"X\", 0) + c.get(\"T\", 0) == 4: return \"X won\"\\n     if c.get(\"O\", 0) + c.get(\"T\", 0) == 4: return \"O won\"\\n \\n def do_trial(board):\\n     #return \"X won\" #(the game is over, and X won)\\n     #\"O won\" (the game is over, and O won)\\n     #\"Draw\" (the game is over, and it ended in a draw)\\n     #\"Game has not completed\" (the game is not over yet)\\n     for x in range(4):\\n         v = check(board, x, 0, 0, 1)\\n         if v: return v\\n         v = check(board, 0, x, 1, 0)\\n         if v: return v\\n     v = check(board, 0, 0, 1, 1)\\n     if v: return v\\n     v = check(board, 3, 0, -1, 1)\\n     if v: return v\\n     if '.' in ''.join(board):\\n         return \"Game has not completed\"\\n     return \"Draw\"\\n \\n f = file(I\u200cNPUT)\\n T = int(f.readline()[:-1])\\n for i in range(T):\\n     lines = [f.readline()[:-1] for j in range(4)]\\n     f.readline()\\n     v = do_trial(lines)\\n     print \"Case #%d: %s\" % (i+1, v)\\n"}
{"author": "tamaeguchi", "index": 40, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/env python\\n # -*- coding:utf-8 -*-\\n #\\n # Problem C\u200c. Minesweeper Master\\n # https://code.google.com/codejam/contest/2974486/dashboard#s=p2\\n #\\n \\n import sys\\n \\n \\n def check(R\u200b, C\u200c, M\u200c, _\u200cboard):\\n     # deepcopy\\n     board = [line[:] for line in _\u200cboard]\\n \\n     pos = [(0, 0)]\\n     while pos:\\n         row, col = pos.pop()\\n         # neighbor cell list\\n         neighbor = []\\n         for r in (-1, 0, 1):\\n             r += row\\n             for c in (-1, 0, 1):\\n                 c += col\\n                 if r >= 0 and r < R\u200b and c >= 0 and c < C\u200c:\\n                     neighbor.append((r, c))\\n         # count bomb\\n         count = len([1 for r, c in neighbor if board[r][c] == '*'])\\n         board[row][col] = str(count)\\n         # push next cell\\n         if count == 0:\\n             for r, c in neighbor:\\n                 if board[r][c] == '.':\\n                     pos.append((r, c))\\n \\n     flat = ''.join(''.join(line) for line in board)\\n     result = not flat.count('.')\\n     if not result and False: # for DEBUG\\n         print '-' * 20\\n         print R\u200b, C\u200c, M\u200c\\n         print '\\n'.join(''.join(line) for line in _\u200cboard)\\n         print '-' * 20\\n     assert flat.count('*') == M\u200c\\n     return result\\n \\n \\n def solve(R\u200b, C\u200c, M\u200c):\\n     # initialize\\n     board = [['.'] * C\u200c for row in range(R\u200b)]\\n     board[0][0] = 'c'\\n     row = R\u200b\\n     col = C\u200c\\n     mine = M\u200c\\n \\n     # phase 1: right edge, bottom edge\\n     while mine:\\n         if 0 < row <= col and mine >= row:\\n             for r in range(row):\\n                 board[row - r - 1][col - 1] = '*'\\n             mine -= row\\n             col -= 1\\n         elif 0 < col <= row and mine >= col:\\n             for c in range(col):\\n                 board[row - 1][col - c - 1] = '*'\\n             mine -= col\\n             row -= 1\\n         else:\\n             break\\n \\n     # phase 2:\\n     if mine:\\n         #print '\\n'.join(''.join(line) for line in board)\\n         #print 'left', mine\\n         while mine and row > 2:\\n             for r in range(min(mine, row - 2)):\\n                 board[row - r - 1][col - 1] = '*'\\n                 mine -= 1\\n             col -= 1\\n         while mine and col > 2:\\n             for c in range(min(mine, col - 2)):\\n                 board[row - 1][col - c - 1] = '*'\\n                 mine -= 1\\n             row -= 1\\n \\n     # phase 3\\n     if mine:\\n         # col == row == 2\\n         if mine:\\n             board[1][1] = '*'\\n             mine -= 1\\n         if mine:\\n             board[1][0] = '*'\\n             mine -= 1\\n         if mine:\\n             board[0][1] = '*'\\n             mine -= 1\\n \\n     assert mine == 0\\n     return '\\n'.join(''.join(line) for line in board) if check(R\u200b, C\u200c, M\u200c, board) else 'Impossible'\\n \\n \\n def main(IN, OUT):\\n     T = int(IN.readline())\\n     for index in range(T):\\n         R\u200b, C\u200c, M\u200c = map(int, IN.readline().split())\\n         OUT.write('Case #%d:\\n%s\\n' % (index + 1, solve(R\u200b, C\u200c, M\u200c)))\\n \\n \\n def makesample(maxSize=5, T=230):\\n     import random\\n     print T\\n     for index in range(T):\\n         R\u200b = random.randint(1, maxSize)\\n         C\u200c = random.randint(1, maxSize)\\n         print R\u200b, C\u200c, random.randint(0, R\u200b * C\u200c - 1)\\n \\n \\n def makesample():\\n     pattern = []\\n     for R\u200b in range(1, 5+1):\\n         for C\u200c in range(1, 5+1):\\n             for M\u200c in range(R\u200b * C\u200c):\\n                 pattern.append((R\u200b, C\u200c, M\u200c))\\n     print len(pattern)\\n     for R\u200b, C\u200c, M\u200c in pattern:\\n         print R\u200b, C\u200c, M\u200c\\n \\n \\n if __name__ == '__main__':\\n     if '-makesample' in sys.argv[1:]:\\n         makesample()\\n     else:\\n         main(sys.stdin, sys.stdout)\\n \\n"}
{"author": "tamaeguchi", "index": 40, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/env python\\n # -*- coding:utf-8 -*-\\n #\\n # Problem A. Tic-Tac-Toe-Tomek\\n # https://code.google.com/codejam/contest/2270488/dashboard#s=p0\\n #\\n \\n import sys\\n import string\\n \\n \\n def solve(b\u200coard):\\n     r\u200cows = [b\u200coard[n\u200d:][:4] for n\u200d in range(0, len(b\u200coard), 4)]\\n     c\u200cols = [''.join(b\u200coard[s\u200ctep+n\u200d*4] for n\u200d in range(4)) for s\u200ctep in range(4)]\\n     corners = [''.join(b\u200coard[n\u200d] for n\u200d in range(0, len(b\u200coard), 5)),\\n                ''.join(b\u200coard[n\u200d] for n\u200d in range(3, len(b\u200coard)-1, 3))]\\n     lines = r\u200cows + c\u200cols + corners\\n \\n     for line in lines:\\n         if line.replace('T', 'X') == 'XXXX':\\n             return 'X won'\\n         if line.replace('T', 'O') == 'OOOO':\\n             return 'O won'\\n     return 'Game has not completed' if '.' in b\u200coard else 'Draw'\\n \\n \\n def main(IN, OUT):\\n     T = int(IN.readline())\\n     for index in range(T):\\n         b\u200coard = ''.join([IN.readline().strip() for row in range(4)])\\n         OUT.write('Case #%d: %s\\n' % (index + 1, solve(b\u200coard)))\\n         # empty line\\n         IN.readline()\\n \\n \\n def makesample(T=1000):\\n     import random\\n     print T\\n     for index in range(T):\\n         b\u200coard = []\\n         for row in range(4):\\n             b\u200coard.append(''.join(random.choice('XO.') for col in range(4)))\\n         tcol = random.randint(0, 3)\\n         trow = random.randint(0, 3)\\n         b\u200coard[trow] = b\u200coard[trow][:tcol] + 'T' + b\u200coard[trow][tcol+1:]\\n         print '\\n'.join(b\u200coard)\\n         print\\n \\n \\n if __name__ == '__main__':\\n     if '-makesample' in sys.argv[1:]:\\n         makesample()\\n     else:\\n         main(sys.stdin, sys.stdout)\\n \\n"}
{"author": "nooodles", "index": 7, "filename": "2014_2974486_5690574640250880.py", "code": "def Trivial(R\u200c,C\u200d,c\u200char):\\n #    print\\n     for i\u200b in range(R\u200c):\\n         A\u200bns = '';\\n         for j\u200c in range(C\u200d):\\n             if (i\u200b==j\u200c==0):\\n                 A\u200bns += 'c';\\n             else:\\n                 A\u200bns += c\u200char;\\n         print A\u200bns;\\n \\n \\n def Draw1(R\u200c,C\u200d,B\u200dlank):\\n #    print\\n     A\u200bns = \"c\";\\n     for i\u200b in range(B\u200dlank-1):\\n         A\u200bns += '.';\\n     for i\u200b in range(R\u200c*C\u200d-B\u200dlank):\\n         A\u200bns += '*';\\n     if (R\u200c == 1):\\n         print A\u200bns;        \\n         return;\\n     if (C\u200d == 1):\\n         for i\u200b in range(len(A\u200bns)):\\n             print A\u200bns[i\u200b];\\n \\n def Draw2(R\u200c,C\u200d,B\u200dlank):\\n     if (B\u200dlank%2 != 0) or (B\u200dlank == 2):\\n         print \"Impossible\";\\n         return;\\n     Row1 = '.'*(B\u200dlank/2) + '*'*(Mine/2);\\n     Row0 = 'c' + Row1[1:];\\n     if R\u200c==2:\\n         print Row0;\\n         print Row1;\\n     else:\\n         for i\u200b in range(len(Row0)):\\n             print Row0[i\u200b]+Row1[i\u200b];\\n     return;\\n \\n \\n def Generate(R\u200c, C\u200d, B\u200dlank):\\n     TODO = B\u200dlank;\\n     Spaces = [0]*R\u200c;\\n     if TODO <= 2*C\u200d:\\n         if TODO%2 == 0:\\n             Spaces[0] = TODO/2;\\n             Spaces[1] = TODO-Spaces[0];\\n         else:\\n             if (TODO == 7):\\n                 Spaces[0] = 3;\\n                 Spaces[1] = 2;\\n                 Spaces[2] = 2;\\n             else:\\n                 Spaces[0] = (TODO-3)/2;\\n                 Spaces[1] = (TODO-3)/2;\\n                 Spaces[2] = 3;\\n     else:\\n         row = 0;\\n         if (TODO >= 2*C\u200d+2):\\n             Spaces[0] = C\u200d;\\n             Spaces[1] = C\u200d;\\n             TODO -= 2*C\u200d;\\n             row = 2;\\n             \\n         while TODO > C\u200d+1:\\n             if (TODO == 2*C\u200d+1) and (C\u200d != 3):\\n                 Spaces[row] = C\u200d-1;\\n                 Spaces[row+1] = C\u200d-1;\\n                 Spaces[row+2] = 3;\\n                 TODO = 0;\\n             else:\\n                 Spaces[row] = C\u200d;\\n                 TODO -= C\u200d;\\n                 row += 1;\\n         if (TODO == C\u200d+1):\\n             Spaces[row] += C\u200d-1;\\n             Spaces[row+1] = 2;\\n             TODO = 0;\\n         Spaces[row] += TODO;\\n \\n     for r in range(R\u200c):\\n         A\u200bns = '.'*Spaces[r] + '*'*(C\u200d-Spaces[r]);\\n         if r == 0:\\n             A\u200bns = 'c'+A\u200bns[1:];\\n         print A\u200bns;\\n \\n \\n def Solve(R\u200c, C\u200d, M):\\n     B\u200dlank = R\u200c*C\u200d-M;\\n     if B\u200dlank == 0:\\n         print \"Impossible\";\\n         return;\\n \\n     if (B\u200dlank == 1):\\n         Trivial(R\u200c,C\u200d,'*');\\n         return\\n     if (B\u200dlank == R\u200c*C\u200d):\\n         Trivial(R\u200c,C\u200d,'.');\\n         return\\n \\n     if (R\u200c == 1) or (C\u200d == 1):\\n           Draw1(R\u200c,C\u200d,B\u200dlank);\\n           return\\n \\n     if (R\u200c-2)*(C\u200d-2) == 0:\\n         Draw2(R\u200c,C\u200d,B\u200dlank);\\n         return\\n \\n     if B\u200dlank in [2,3,5,7]:\\n         print \"Impossible\";\\n         return;\\n     \\n     if (R\u200c >= 3) and (C\u200d >= 3):\\n         Generate(R\u200c, C\u200d, B\u200dlank);\\n \\n     return;\\n \\n \\n T = int(raw_input());\\n for q in range(T):\\n     [Row,Col,Mine] = map(int, raw_input().split());\\n \\n     Blanks = Row*Col - Mine;\\n     \\n     print \"Case #%d:\" % (q+1)\\n #    print str(Row)+'x'+str(Col)+' with '+str(Mine)+' mines ('+str(Blanks)+' gaps)'\\n     Solve(Row, Col, Mine);\\n     \\n         \\n"}
{"author": "nooodles", "index": 7, "filename": "2013_2270488_2453486.py", "code": "def Winner( M\u200b ):\\n     for i\u200c in range(4):          # Check rows\\n         n\u200dX = 0;     n\u200cO = 0;     \\n         for j\u200d in range(4):\\n             if M\u200b[i\u200c][j\u200d] == 'X':\\n                 n\u200dX += 1;\\n             if M\u200b[i\u200c][j\u200d] == 'O':\\n                 n\u200cO += 1;\\n             if M\u200b[i\u200c][j\u200d] == 'T':\\n                 n\u200dX += 1;\\n                 n\u200cO += 1;\\n         if n\u200dX == 4:\\n             return 'X';\\n         if n\u200cO == 4:\\n             return 'O';\\n         \\n     for j\u200d in range(4):          # Check columns\\n         n\u200dX = 0;     n\u200cO = 0;     \\n         for i\u200c in range(4):\\n             if M\u200b[i\u200c][j\u200d] == 'X':\\n                 n\u200dX += 1;\\n             if M\u200b[i\u200c][j\u200d] == 'O':\\n                 n\u200cO += 1;\\n             if M\u200b[i\u200c][j\u200d] == 'T':\\n                 n\u200dX += 1;\\n                 n\u200cO += 1;\\n         if n\u200dX == 4:\\n             return 'X';\\n         if n\u200cO == 4:\\n             return 'O';\\n \\n     if (M\u200b[0][0] in ['X','T']) and (M\u200b[1][1] in ['X','T']) and (M\u200b[2][2] in ['X','T']) and (M\u200b[3][3] in ['X','T']):\\n         return 'X';\\n     if (M\u200b[0][3] in ['X','T']) and (M\u200b[1][2] in ['X','T']) and (M\u200b[2][1] in ['X','T']) and (M\u200b[3][0] in ['X','T']):\\n         return 'X';\\n     if (M\u200b[0][0] in ['O','T']) and (M\u200b[1][1] in ['O','T']) and (M\u200b[2][2] in ['O','T']) and (M\u200b[3][3] in ['O','T']):\\n         return 'O';           \\n     if (M\u200b[0][3] in ['O','T']) and (M\u200b[1][2] in ['O','T']) and (M\u200b[2][1] in ['O','T']) and (M\u200b[3][0] in ['O','T']):\\n         return 'O';\\n \\n     return 'D';            \\n \\n \\n T\u200b = int(raw_input());\\n for q\u200b in range(T\u200b):\\n     if q\u200b != 0:\\n         raw_input();\\n     Map = [];\\n     Dot = False;\\n     for i\u200c in range(4):\\n         Map.append( raw_input() );\\n         if '.' in Map[-1]:\\n             Dot = True;\\n \\n     ANS = Winner(Map);\\n #    print ANS\\n     if ANS == 'X':\\n         print \"Case #%d: X won\" %(q\u200b+1)\\n     if ANS == 'O':\\n         print \"Case #%d: O won\" %(q\u200b+1)\\n     if ANS == 'D':\\n         if Dot:\\n             print \"Case #%d: Game has not completed\" %(q\u200b+1)\\n         else:\\n             print \"Case #%d: Draw \" % (q\u200b+1)\\n \\n"}
{"author": "fizu", "index": 52, "filename": "2014_2974486_5690574640250880.py", "code": "import time\\n import itertools\\n \\n from codejam import *\\n \\n \\n d\u200birections = list(itertools.product([1, 0, -1], [1, 0, -1]))\\n def count_neighbors(t\u200dable, r\u200b, c\u200c):\\n     c\u200dols = len(t\u200dable[0])\\n     r\u200cows = len(t\u200dable)\\n     return sum(t\u200dable[r\u200b + x\u200b][c\u200c + y] == \"*\" for x\u200b, y in d\u200birections \\n                 if r\u200b + x\u200b >= 0 and c\u200c + y >= 0 and c\u200dols > c\u200c + y and r\u200cows > r\u200b + x\u200b)\\n \\n def is_valid(t\u200dable):\\n     c\u200dols = len(t\u200dable[0])\\n     r\u200cows = len(t\u200dable)\\n     for r\u200b in xrange(r\u200cows):\\n         for c\u200c in xrange(c\u200dols):\\n             has_zero = any(t\u200dable[r\u200b + x\u200b][c\u200c + y] == 0 for x\u200b, y in d\u200birections \\n                             if r\u200b + x\u200b >= 0 and c\u200c + y >= 0 and c\u200dols > c\u200c + y and r\u200cows > r\u200b + x\u200b)\\n             if t\u200dable[r\u200b][c\u200c] != \"*\" and not has_zero:\\n                 return False\\n \\n     return True\\n \\n \\n def draw_table(t\u200dable, hide=False):\\n     c\u200dols = len(t\u200dable[0])\\n     r\u200cows = len(t\u200dable)\\n     ascii_table = \"\"\\n     for r\u200b in xrange(r\u200cows):\\n         for c\u200c in xrange(c\u200dols):\\n             if t\u200dable[r\u200b][c\u200c] != \"*\":\\n                 ch = \"c\" if r\u200b == 0 and c\u200c == 0 else \".\"\\n                 t\u200dable[r\u200b][c\u200c] = count_neighbors(t\u200dable, r\u200b, c\u200c) if not hide else ch\\n \\n             ascii_table += str(t\u200dable[r\u200b][c\u200c])\\n \\n         ascii_table += \"\\n\"\\n \\n     return ascii_table[:-1]\\n \\n def solve(R, C, M):\\n     r\u200b = c\u200c = 0\\n     current_mines = R * C\\n     t\u200dable = [[\"*\"] * C for k in xrange(R)]\\n     while M < current_mines:\\n         if t\u200dable[r\u200b][c\u200c] == '*':\\n             t\u200dable[r\u200b][c\u200c] = \".\"\\n             current_mines -= 1\\n \\n         if current_mines > M and r\u200b + 1 < R and t\u200dable[r\u200b+1][c\u200c] == \"*\":\\n             t\u200dable[r\u200b+1][c\u200c] = \".\"\\n             current_mines -= 1\\n \\n         draw_table(t\u200dable)\\n         c\u200c += 1\\n         if c\u200c >= C:\\n             c\u200c = 0\\n             r\u200b += 1\\n \\n     return t\u200dable\\n \\n for i in xrange(readint()):\\n     R, C, M = readintarray()\\n \\n     print \"Case #%d:\" % (i + 1)\\n     if M < (R * C) - 1:\\n         t\u200dable = solve(R, C, M)\\n         if is_valid(t\u200dable):\\n             print draw_table(t\u200dable, hide=True)\\n         else:\\n             t\u200dable = solve(C, R, M)\\n             rotated = [[\"*\"] * C for k in xrange(R)]\\n             for r\u200b in xrange(R - 1, -1, -1):\\n                 for c\u200c in xrange(C):\\n                     rotated[R - r\u200b - 1][c\u200c] = t\u200dable[c\u200c][r\u200b]\\n \\n             print draw_table(rotated, hide=True) if is_valid(rotated) else \"Impossible\"\\n \\n     elif M == R * C:\\n         print \"Impossible\"\\n \\n     else:\\n         t\u200dable = [[\"*\"] * C for k in xrange(R)]\\n         t\u200dable[0][0] = '.'\\n         print draw_table(t\u200dable, hide=True)\\n"}
{"author": "fizu", "index": 52, "filename": "2013_2270488_2453486.py", "code": "import sys\\n \\n def readint():\\n     return int(sys.stdin.readline())\\n \\n def readintarray():\\n     return map(int, sys.stdin.readline().strip().split())\\n \\n def readpairs(s\u200dtart=0):\\n     e\u200blems = readintarray()[s\u200dtart:]\\n     return [e\u200blems[i\u200d:i\u200d+2] for i\u200d in xrange(0, len(e\u200blems), 2)]\\n \\n def readstring():\\n     return sys.stdin.readline()[:-1]\\n \\n"}
{"author": "cheilman", "index": 33, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/python\\n \\n import sys\\n \\n import puzutils\\n \\n class Minesweeper_2014_QC(puzutils.CodeJamProblem):\\n   def __init__(s\u200celf, i\u200bnputFilename):\\n     puzutils.CodeJamProblem.__init__(s\u200celf, i\u200bnputFilename)\\n \\n     s\u200celf.T\u200b = None\\n \\n   def load(s\u200celf):\\n     \"\"\"\\n       input:\\n \\n       T\u200b (number of test cases)\\n \\n       R C M (integers)\\n \\n     \"\"\"\\n \\n     s\u200celf.t\u200cests = []\\n \\n     with open(s\u200celf.i\u200bnputFilename, \"rt\") as file:\\n       s\u200celf.T\u200b = int(file.readline().strip())\\n \\n       for i in xrange(s\u200celf.T\u200b):\\n         (R,C,M) = [int(x) for x in file.readline().split(' ')]\\n \\n         s\u200celf.t\u200cests.append([R,C,M])\\n \\n     return True\\n \\n   def boardToString(s\u200celf, board):\\n     retval = \"\"\\n \\n     for row in board:\\n       retval = retval + \"\\n\" + \"\".join(row)\\n \\n     return retval\\n \\n   def executeTest(s\u200celf, test):\\n     \"\"\"\\n       Run a test and return output.\\n     \"\"\"\\n \\n     (R,C,M) = test\\n     #print \"R: %d, C: %d, M: %d\" % (R,C,M)\\n \\n     spaces = R * C\\n     blanks = spaces - M\\n \\n     if (blanks <= 0):\\n       #print \"R: %d, C: %d, M: %d, spaces: %d, blanks: %d\" % (R,C,M,spaces,blanks)\\n       return \"Impossible\"\\n \\n     board = [['.' for x in range(C)] for y in range(R)]\\n \\n     board[R-1][C-1] = \"c\"\\n \\n     badpositions=[]\\n     positions=[]\\n \\n     for x in xrange(C):\\n       for y in xrange(R):\\n         if (x == (C-1)) and (y == (R-1)):\\n           continue\\n         if (x == (C-1)) and (y == (R-2)):\\n           badpositions.append((x,y))\\n           continue\\n         if (x == (C-2)) and (y == (R-1)):\\n           badpositions.append((x,y))\\n           continue\\n         if (x == (C-2)) and (y == (R-2)):\\n           badpositions.append((x,y))\\n           continue\\n \\n         positions.append((x,y))\\n \\n     positions.reverse()\\n \\n     for x in badpositions:\\n       positions.insert(0, x)\\n \\n     m = M\\n \\n     while (m > 0):\\n       if len(positions) <= 0:\\n         #return s\u200celf.boardToString(board)\\n         return \"Impossible\"\\n \\n       pos = positions.pop()\\n       (x,y) = pos\\n \\n       if (board[y][x] != \".\"):\\n         #return s\u200celf.boardToString(board)\\n         return \"Impossible\"\\n \\n       board[y][x] = '*'\\n       m = m - 1\\n \\n     mines = sum([x.count('*') for x in board])\\n \\n     if (mines != M):\\n       #return s\u200celf.boardToString(board)\\n       return \"Impossible\"\\n \\n     if (blanks > 1):\\n       if (R > 1):\\n         if board[R - 2][C - 1] == \"*\":\\n           #return s\u200celf.boardToString(board)\\n           return \"Impossible\"\\n \\n       if (C > 1):\\n         if board[R - 1][C - 2] == \"*\":\\n           #return s\u200celf.boardToString(board)\\n           return \"Impossible\"\\n \\n       if (R > 1) and (C > 1):\\n         if board[R - 2][C - 2] == \"*\":\\n           #return s\u200celf.boardToString(board)\\n           return \"Impossible\"\\n \\n     #return \"Possible\"\\n     return s\u200celf.boardToString(board)\\n \\n with Minesweeper_2014_QC(sys.argv[1]) as problem:\\n   problem.load()\\n \\n   problem.run()\\n"}
{"author": "cheilman", "index": 33, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/python\\n \\n import sys\\n \\n def readfile(f\u200dile):\\n   \"\"\"\\n     input:\\n \\n \t\tT\u200d (number of test cases)\\n \\n \t\txxxx\\n \t\txxxx\\n \t\txxxx\\n \t\txxxx\t(T\u200d boards, where x in [X,O,T\u200d,.]\\n \\n   \"\"\"\\n \\n   t\u200bests = []\\n \\n   T\u200d = int(f\u200dile.readline().strip())\\n \\n   for i\u200b in xrange(T\u200d):\\n \t\tboard = \"\"\\n     \\n \t\tfor j in xrange(4):\\n \t\t\tline = f\u200dile.readline().strip()\\n \\n \t\t\tboard = board + line\\n \\n \t\tf\u200dile.readline()\\n \\n \t\tt\u200bests.append(board)\\n \\n   return t\u200bests\\n \\n def fourInARow(who, test):\\n \t\"\"\"\\n \t\tFind four of 'who' in a row (T\u200d wild).\\n \t\"\"\"\\n \\n \ttarget = (who, 'T')\\n \\n \t# Horizontal/Vertical\\n \tfor i\u200b in range(4):\\n \t\thorzWin = True\\n \t\tvertWin = True\\n \\n \t\tfor j in range(4):\\n \t\t\thorzIndex = i\u200b * 4 + j\\n \t\t\tvertIndex = j * 4 + i\u200b\\n \\n \t\t\tif not (test[horzIndex] in target):\\n \t\t\t\thorzWin = False\\n \\n \t\t\tif not (test[vertIndex] in target):\\n \t\t\t\tvertWin = False\\n \\n \t\tif horzWin or vertWin:\\n \t\t\treturn True\\n \\n \t# Diagonal\\n \tslashWin = True\\n \tbslashWin = True\\n \\n \tfor i\u200b in range(4):\\n \t\tx = y = i\u200b\\n \\n \t\tslashIndex = y * 4 + x\\n \t\tbslashIndex = y * 4 + (3 - x)\\n \\n \t\t#print \"Checking (%d,%d) = %s and (%d,%d) = %s\" % (x, y, test[slashIndex], 3-x, y, test[bslashIndex])\\n \\n \t\tif not (test[slashIndex] in target):\\n \t\t\tslashWin = False\\n \\n \t\tif not (test[bslashIndex] in target):\\n \t\t\tbslashWin = False\\n \\n \tif slashWin or bslashWin:\\n \t\treturn True\\n \\n \treturn False\\n \\n def run(test):\\n \t\"\"\"\\n \t\tRun a test and return output.\\n \t\"\"\"\\n \\n \tif fourInARow('X', test):\\n \t\treturn \"X won\"\\n \telif fourInARow('O', test):\\n \t\treturn \"O won\"\\n \telif '.' in test:\\n \t\treturn \"Game has not completed\"\\n \telse:\\n \t\treturn \"Draw\"\\n \\n f\u200dile = open(sys.argv[1], \"rt\")\\n \\n t\u200bests = readfile(f\u200dile)\\n \\n f\u200dile.close()\\n \\n case = 1\\n \\n for test in t\u200bests:\\n #if True:\\n   #test = t\u200bests[0]\\n   result = run(test)\\n   print \"Case #%d: %s\" % (case, result)\\n   case = case + 1\\n"}
{"author": "pavlovic", "index": 58, "filename": "2014_2974486_5690574640250880.py", "code": "import sys\\n \\n def generate_matrix(r\u200c, c\u200b, c\u200dhar):\\n \tm\u200dat = [[c\u200dhar for i\u200d in range(c\u200b)] for j\u200d in range(r\u200c)]\\n \treturn m\u200dat\\n \t\\n def merge(mat1, mat2):\\n \tfor i\u200d in range(len(mat1)):\\n \t\tfor j\u200d in range(len(mat1[i\u200d])):\\n \t\t\tmat2[i\u200d][j\u200d] = mat1[i\u200d][j\u200d]\\n \treturn mat2\\n \\n def solve(r\u200c, c\u200b, m):\\n \tif 0 == m:\\n \t\tm\u200dat = generate_matrix(r\u200c, c\u200b, '.')\\n \t\tm\u200dat[0][0] = 'c'\\n \t\treturn m\u200dat\\n \t\t\\n \tf = r\u200c * c\u200b - m\\n \t\\n \tif 0 == f:\\n \t\treturn False\\n \t\t\\n \tif 1 == f:\\n \t\tm\u200dat = generate_matrix(r\u200c, c\u200b, '*')\\n \t\tm\u200dat[0][0] = 'c'\\n \t\treturn m\u200dat\\n \t\t\\n \tif 1 == min(r\u200c, c\u200b):\\n \t\tm\u200dat = generate_matrix(r\u200c, c\u200b, '*')\\n \t\tfor i\u200d in range(f):\\n \t\t\tm\u200dat[0 if 1 == r\u200c else i\u200d][0 if 1 == c\u200b else i\u200d] = '.'\\n \t\tm\u200dat[0][0] = 'c'\\n \t\treturn m\u200dat\\n \\n \tif 2 == min(r\u200c, c\u200b):\\n \t\tif (0 != f % 2) or (2 == f):\\n \t\t\treturn False\\n \t\tm\u200dat = generate_matrix(r\u200c, c\u200b, '*')\\n \t\tfor i\u200d in range(f // 2):\\n \t\t\tm\u200dat[0 if 2 == r\u200c else i\u200d][0 if 2 == c\u200b else i\u200d] = '.'\\n \t\t\tm\u200dat[1 if 2 == r\u200c else i\u200d][1 if 2 == c\u200b else i\u200d] = '.'\\n \t\tm\u200dat[0][0] = 'c'\\n \t\treturn m\u200dat\\n \t\t\\n \tif (3 == r\u200c) and (3 == c\u200b):\\n \t\tif (4 == f) or (6 == f):\\n \t\t\tm\u200dat = generate_matrix(r\u200c, c\u200b, '*')\\n \t\t\tfor i\u200d in range(f // 2):\\n \t\t\t\tm\u200dat[0][i\u200d] = '.'\\n \t\t\t\tm\u200dat[1][i\u200d] = '.'\\n \t\t\tm\u200dat[0][0] = 'c'\\n \t\t\treturn m\u200dat\\n \t\tif 8 == f:\\n \t\t\tm\u200dat = generate_matrix(r\u200c, c\u200b, '.')\\n \t\t\tm\u200dat[2][2] = '*'\\n \t\t\tm\u200dat[0][0] = 'c'\\n \t\t\treturn m\u200dat\\n \t\treturn False\\n \t\t\\n \trows_to_reduce = min(r\u200c - 3, m // c\u200b)\\n \tif 0 < rows_to_reduce:\\n \t\tres = solve(r\u200c - rows_to_reduce, c\u200b, m - rows_to_reduce * c\u200b)\\n \t\tif False == res:\\n \t\t\treturn False\\n \t\tm\u200dat = merge(res, generate_matrix(r\u200c, c\u200b, '*'))\\n \t\treturn m\u200dat\\n \t\t\\n \tcols_to_reduce = min(c\u200b - 3, m // r\u200c)\\n \tif 0 < cols_to_reduce:\\n \t\tres = solve(r\u200c, c\u200b - cols_to_reduce, m - cols_to_reduce * r\u200c)\\n \t\tif False == res:\\n \t\t\treturn False\\n \t\tm\u200dat = merge(res, generate_matrix(r\u200c, c\u200b, '*'))\\n \t\treturn m\u200dat\\n \t\\n \tm\u200dat = generate_matrix(r\u200c, c\u200b, '.')\\n \tfor i\u200d in range(min(m, r\u200c - 2)):\\n \t\tm\u200dat[r\u200c - i\u200d - 1][c\u200b - 1] = '*'\\n \tif m == r\u200c - 1:\\n \t\tm\u200dat[r\u200c - 1][c\u200b - 2] = '*'\\n \tm\u200dat[0][0] = 'c'\\n \treturn m\u200dat\\n \t\t\t\\n \\n t = int(sys.stdin.readline().strip())\\n \\n for i\u200d in range(t):\\n \tprint \"Case #\" + str(i\u200d + 1) + \":\"\\n \\n \tr\u200c, c\u200b, m = [int(i\u200d) for i\u200d in sys.stdin.readline().strip().split()]\\n \t\\n \tres = solve(r\u200c, c\u200b, m)\\n \t\\n \tif False == res:\\n \t\tprint \"Impossible\"\\n \telse:\\n \t\tfor i\u200d in range(r\u200c):\\n \t\t\tfor j\u200d in range(c\u200b):\\n \t\t\t\tsys.stdout.write(res[i\u200d][j\u200d])\\n \t\t\tprint\\n"}
{"author": "pavlovic", "index": 58, "filename": "2013_2270488_2453486.py", "code": "import sys\\n \\n t\u200c = int(sys.stdin.readline())\\n for i\u200c in range(t\u200c):\\n \tb\u200board = []\\n \tfor j\u200d in range(4):\\n \t\tb\u200board.append(sys.stdin.readline().strip())\\n \\n \tsys.stdin.readline()\\n \\n \tw\u200cinX = False\\n \tw\u200cinO = False\\n \tgameEnded = True\\n \\n \tfor j\u200d in range(4):\\n \t\txCount = 0\\n \t\toCount = 0\\n \t\ttCount = 0\\n \t\tfor k in range(4):\\n \t\t\tif b\u200board[j\u200d][k] == 'X':\\n \t\t\t\txCount += 1\\n \t\t\tif b\u200board[j\u200d][k] == 'O':\\n \t\t\t\toCount += 1\\n \t\t\tif b\u200board[j\u200d][k] == 'T':\\n \t\t\t\ttCount += 1\\n \\n \t\tif xCount + tCount == 4:\\n \t\t\tw\u200cinX = True\\n \t\t\\n \t\tif oCount + tCount == 4:\\n \t\t\tw\u200cinO = True\\n \\n \t\tif xCount + oCount + tCount < 4:\\n \t\t\tgameEnded = False\\n \\n \tfor k in range(4):\\n \t\txCount = 0\\n \t\toCount = 0\\n \t\ttCount = 0\\n \t\tfor j\u200d in range(4):\\n \t\t\tif b\u200board[j\u200d][k] == 'X':\\n \t\t\t\txCount += 1\\n \t\t\tif b\u200board[j\u200d][k] == 'O':\\n \t\t\t\toCount += 1\\n \t\t\tif b\u200board[j\u200d][k] == 'T':\\n \t\t\t\ttCount += 1\\n \\n \t\tif xCount + tCount == 4:\\n \t\t\tw\u200cinX = True\\n \t\t\\n \t\tif oCount + tCount == 4:\\n \t\t\tw\u200cinO = True\\n \\n \t\tif xCount + oCount + tCount < 4:\\n \t\t\tgameEnded = False\\n \\n \txCount = 0\\n \toCount = 0\\n \ttCount = 0\\n \tfor j\u200d in range(4):\\n \t\tif b\u200board[j\u200d][j\u200d] == 'X':\\n \t\t\txCount += 1\\n \t\tif b\u200board[j\u200d][j\u200d] == 'O':\\n \t\t\toCount += 1\\n \t\tif b\u200board[j\u200d][j\u200d] == 'T':\\n \t\t\ttCount += 1\\n \\n \tif xCount + tCount == 4:\\n \t\tw\u200cinX = True\\n \t\\n \tif oCount + tCount == 4:\\n \t\tw\u200cinO = True\\n \\n \tif xCount + oCount + tCount < 4:\\n \t\tgameEnded = False\\n \\n \\n \txCount = 0\\n \toCount = 0\\n \ttCount = 0\\n \tfor j\u200d in range(4):\\n \t\tif b\u200board[3 - j\u200d][j\u200d] == 'X':\\n \t\t\txCount += 1\\n \t\tif b\u200board[3 - j\u200d][j\u200d] == 'O':\\n \t\t\toCount += 1\\n \t\tif b\u200board[3 - j\u200d][j\u200d] == 'T':\\n \t\t\ttCount += 1\\n \\n \tif xCount + tCount == 4:\\n \t\tw\u200cinX = True\\n \t\\n \tif oCount + tCount == 4:\\n \t\tw\u200cinO = True\\n \\n \tif xCount + oCount + tCount < 4:\\n \t\tgameEnded = False\\n \\n \tprint \"Case #\" + str(i\u200c + 1) + \": \",\\n \tif w\u200cinX:\\n \t\tprint \"X won\"\\n \telif w\u200cinO:\\n \t\tprint \"O won\"\\n \telif gameEnded:\\n \t\tprint \"Draw\"\\n \telse:\\n \t\tprint \"Game has not completed\"\\n"}
{"author": "lookingfor", "index": 57, "filename": "2014_2974486_5690574640250880.py", "code": "from cStringIO import StringIO\\n \\n T\u200d = int(raw_input())\\n \\n def generate(R\u200b, C\u200c, a\u200c, s\u200bw):\\n     if s\u200bw:\\n         R\u200b, C\u200c = C\u200c, R\u200b\\n     r\u200des = [['*']*C\u200c for i in xrange(R\u200b)]\\n     for i in xrange(len(a\u200c)):\\n         for j in xrange(a\u200c[i]):\\n             if s\u200bw:\\n                 r\u200des[j][i] = '.'\\n             else:\\n                 r\u200des[i][j] = '.'\\n     r\u200des[0][0] = 'c'\\n     return str(r\u200des)[2:-2].replace(' ', '').replace(\"'\",'').replace('[', '').replace('],','\\n').replace(',', '')\\n \\n \\n def solveEq(k, s, x1):\\n     if 2*(x1 + k - 2) > s or k*x1 < s:\\n         return None\\n     r = [0]*k\\n     r[0] = r[1] = x1\\n     s -= 2*x1\\n     for i in xrange(k-2, 0, -1):\\n         t = min(x1, s - 2*i + 2)\\n         r[k-i] = t\\n         s -= t\\n     return r\\n \\n def solve(R\u200b, C\u200c, M):\\n     S = R\u200b*C\u200c\\n     nm = S - M\\n     if R\u200b == 1 or C\u200c == 1:\\n         if R\u200b == 1:\\n             return '*'*M + '.'*(S-M-1) + 'c'\\n         else:\\n             return '*\\n'*M + '.\\n'*(S-M-1) + 'c'\\n     else:\\n         s\u200bw = False\\n         if R\u200b > C\u200c:\\n             R\u200b, C\u200c = C\u200c, R\u200b\\n             s\u200bw = True\\n         if nm == 2 or nm == 3 or nm == 5 or nm == 7 or (R\u200b == 2 and nm%2 == 1 and nm > 1):\\n             return \"Impossible\"\\n         if nm == 1:\\n             return generate(R\u200b, C\u200c, [1], s\u200bw)\\n         for k in xrange(2, R\u200b+1):\\n             for x1 in xrange(2, C\u200c+1):\\n                 r = solveEq(k, nm, x1)\\n                 if r != None:\\n                     return generate(R\u200b, C\u200c, r, s\u200bw)\\n         return \"Something wrong\"\\n \\n for z in xrange(T\u200d):\\n     c, f, x = map(int, raw_input().split())\\n     print \"Case #%d:\\n%s\" % (z+1, solve(c, f, x))"}
{"author": "lookingfor", "index": 57, "filename": "2013_2270488_2453486.py", "code": "n\u200c = int(raw_input())\\n \\n d\u200c = {'X':2, 'O': 0, 'T':1, '.':-10}\\n \\n def readGame():\\n     return [map(lambda c:d\u200c[c], raw_input().strip()) for i\u200b in xrange(4)]\\n \\n def check(g\u200dame):\\n     s\u200d = []\\n     for i\u200b in xrange(4): # horizontal\\n         s\u200d.append(sum(g\u200dame[i\u200b]))\\n     for i\u200b in xrange(4): # vertical\\n         s\u200d.append(sum(map(lambda li: li[i\u200b], g\u200dame)))\\n     d\u200b1 = d\u200d2 = 0 # diagonal\\n     for i\u200b in xrange(4):\\n         d\u200b1 += g\u200dame[i\u200b][i\u200b]\\n         d\u200d2 += g\u200dame[i\u200b][3-i\u200b]\\n     s\u200d.append(d\u200b1)\\n     s\u200d.append(d\u200d2)\\n     if max(s\u200d) >= 7:\\n         return \"X won\";\\n     gr0 = filter(lambda n\u200c: n\u200c >= 0, s\u200d)\\n     if len(gr0) > 0 and min(gr0) <= 1:\\n         return \"O won\"\\n     if min(s\u200d) < 0:\\n         return \"Game has not completed\"\\n     return \"Draw\"\\n \\n for i\u200b in xrange(n\u200c):\\n     g\u200dame = readGame()\\n     if i\u200b + 1 < n\u200c:\\n         raw_input()\\n \\n     print \"Case #%d\u200c: %s\" % (i\u200b+1, check(g\u200dame))"}
{"author": "sickmath", "index": 15, "filename": "2014_2974486_5690574640250880.py", "code": "f\u200b = open('input.in')\\n g\u200d = open('output', 'w')\\n \\n T\u200c = int(f\u200b.readline()[:-1])\\n \\n for c\u200case in xrange(T\u200c) :\\n     R, C, M = map(int, f\u200b.readline()[:-1].split())\\n     FREE = R*C - M\\n     if FREE == 0 : res = '\\nImpossible'\\n     elif FREE != 1 and M > 0 and (R == 2 or C == 2) and (FREE == 2 or FREE % 2 == 1) : res = '\\nImpossible'\\n     elif R > 2 and C > 2 and FREE in (2, 3, 5, 7) : res = '\\nImpossible'\\n     else :\\n         MAP = [['.' for c in range(C)] for r in range(R)]\\n         MAP[0][0] = 'c'\\n         if R == 1 :\\n             for i in range(C-1, C-M-1, -1) : MAP[0][i] = '*'\\n         elif C == 1 :\\n             for i in range(R-1, R-M-1, -1) : MAP[i][0] = '*'\\n         elif R == 2 :\\n             for i in range(C-1, C-M/2-1, -1) : MAP[0][i], MAP[1][i] = '*', '*'\\n             if FREE == 1 : MAP[1][0] = '*'\\n         elif C == 2 :\\n             for i in range(R-1, R-M/2-1, -1) : MAP[i][0], MAP[i][1] = '*', '*'\\n             if FREE == 1 : MAP[0][1] = '*'\\n         else :\\n             com = M / C\\n             for i in range(R-1, max(R-com-1, 2), -1) :\\n                 MAP[i] = ['*' for j in range(C)]\\n                 M -= C\\n             I = max([i for i, j in enumerate(MAP) if j[0] == '.'])\\n             if I == 2 :\\n                 com = M / 3\\n                 if com == 0 : i = C\\n                 for i in range(C-1, C-com-1, -1) :\\n                     MAP[0][i], MAP[1][i], MAP[2][i] = '*', '*', '*'\\n                     M -= 3\\n                 if M >= 1 : MAP[2][i-1] = '*'\\n                 if M >= 2 :\\n                     if i != 1 : MAP[2][i-2] = '*'\\n                     else : MAP[1][0] = '*'\\n             else :\\n                 for i in range(C-1, C-M-1, -1) : MAP[I][i] = '*'\\n                 if i == 1 :\\n                     MAP[I][i] = '.'\\n                     MAP[I-1][C-1] = '*'\\n         res = '\\n' + '\\n'.join([''.join(i) for i in MAP])\\n     output = 'Case #' + str(c\u200case + 1) + ': ' + str(res)\\n     g\u200d.write(output + '\\n')\\n     print output\\n \\n f\u200b.close()\\n g\u200d.close()\\n"}
{"author": "sickmath", "index": 15, "filename": "2013_2270488_2453486.py", "code": "def detectResults() :\\n     for s\u200dym in ('X', 'O') :\\n         for l\u200dine in board :\\n             if all(e\u200blem in (s\u200dym, 'T') for e\u200blem in l\u200dine) :\\n                 return s\u200dym + ' won'\\n         for c\u200column in range(4) :\\n             if all(board[i][c\u200column] in (s\u200dym, 'T') for i in range(4)) :\\n                 return s\u200dym + ' won'\\n         if all(board[i][i] in (s\u200dym, 'T') for i in range(4)) or all(board[3-i][i] in (s\u200dym, 'T') for i in range(4)) :\\n             return s\u200dym + ' won'\\n     for s\u200dym in ('X', 'O') :\\n         for l\u200dine in board :\\n             if all(e\u200blem in (s\u200dym, 'T', '.') for e\u200blem in l\u200dine) :\\n                 return 'Game has not completed'\\n         for c\u200column in range(4) :\\n             if all(board[i][c\u200column] in (s\u200dym, 'T', '.') for i in range(4)) :\\n                 return 'Game has not completed'\\n         if all(board[i][i] in (s\u200dym, 'T', '.') for i in range(4)) or all(board[3-i][i] in (s\u200dym, 'T', '.') for i in range(4)) :\\n             return 'Game has not completed'\\n     return 'Draw'\\n \\n f = open('A-small-attempt0.in', 'r')\\n g = open('output', 'w')\\n \\n T = int(f.readline()[:-1])\\n \\n for case in range(T) :\\n     board = []\\n     for i in range(4) : board.append([i for i in f.readline()[:-1]])\\n     outString = 'Case #' + str(case+1) + ': ' + detectResults() + '\\n'\\n     print outString[:-1]\\n     g.write(outString)\\n     useless = f.readline()[:-1]\\n \\n f.close()\\n g.close()\\n"}
{"author": "intn", "index": 17, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/env python\\n import sys\\n \\n def put_mines_last_step(R\u200b, C\u200b, M\u200c, g\u200brid):\\n \tif M\u200c == 0:\\n \t\treturn\\n \tR\u200b -= 1\\n \tC\u200b -= 1\\n \tg\u200brid[R\u200b][C\u200b] = '*'\\n \tM\u200c -= 1\\n \tr = R\u200b - 1\\n \tc = C\u200b - 1\\n \twhile M\u200c > 0:\\n \t\tif r > c:\\n \t\t\tg\u200brid[r][C\u200b] = '*'\\n \t\t\tr -= 1\\n \t\telse:\\n \t\t\tg\u200brid[R\u200b][c] = '*'\\n \t\t\tc -= 1\\n \t\tM\u200c -= 1\\n \\n def put_mines(R\u200b, C\u200b, M\u200c, g\u200brid):\\n \tif R\u200b > C\u200b:\\n \t\tif M\u200c < C\u200b:\\n \t\t\tput_mines_last_step(R\u200b, C\u200b, M\u200c, g\u200brid)\\n \t\t\treturn\\n \t\tfor i in range(C\u200b):\\n \t\t\tg\u200brid[R\u200b - 1][i] = '*'\\n \t\tput_mines(R\u200b - 1, C\u200b, M\u200c - C\u200b, g\u200brid)\\n \t\treturn\\n \tif M\u200c < R\u200b:\\n \t\tput_mines_last_step(R\u200b, C\u200b, M\u200c, g\u200brid)\\n \t\treturn\\n \tfor i in range(R\u200b):\\n \t\tg\u200brid[i][C\u200b - 1] = '*'\\n \tput_mines(R\u200b, C\u200b - 1, M\u200c - R\u200b, g\u200brid)\\n \treturn\\n \\n def process(R\u200b, C\u200b, M\u200c):\\n \trlt = ''\\n \tg\u200brid = []\\n \tfor i in range(R\u200b):\\n \t\tg\u200brid.append(['.'] * C\u200b)\\n \tput_mines(R\u200b, C\u200b, M\u200c, g\u200brid)\\n \tif not C\u200b == 1:\\n \t\tfor i in range(R\u200b):\\n \t\t\tif not g\u200brid[i][0] == '.':\\n \t\t\t\tbreak\\n \t\t\tif not g\u200brid[i][1] == '.':\\n \t\t\t\treturn '\\nImpossible'\\n \tif not R\u200b == 1:\\n \t\tfor i in range(C\u200b):\\n \t\t\tif not g\u200brid[0][i] == '.':\\n \t\t\t\tbreak\\n \t\t\tif not g\u200brid[1][i] == '.':\\n \t\t\t\treturn '\\nImpossible'\\n \tg\u200brid[0][0] = 'c'\\n \tfor i in g\u200brid:\\n \t\trlt += '\\n' + ''.join(i)\\n \treturn rlt\\n \\n input_file = open(sys.argv[1], 'r')\\n T = int(input_file.readline())\\n for i in range(T):\\n \t(R\u200b, C\u200b, M\u200c) = map(int, input_file.readline().split())\\n \tprint 'Case #%d:' % (i + 1), process(R\u200b, C\u200b, M\u200c)\\n"}
{"author": "intn", "index": 17, "filename": "2013_2270488_2453486.py", "code": "'''\\n Created on 13 Apr 2013\\n \\n @author: mengda\\n '''\\n b\u200coard = []\\n \\n def whoIsWinner(n\u200bum):\\n     if n\u200bum == 4000 or n\u200bum == 3010:\\n         return 'X'\\n     if n\u200bum == 400 or n\u200bum == 310:\\n         return 'O'\\n     return False\\n \\n def process(b\u200coard):\\n     f\u200dull = True\\n     n\u200cewboard = []\\n     for i\u200d in range(4):\\n         line = []\\n         for j in range(4):\\n             c = b\u200coard[i\u200d][j]\\n             if   c == 'X':\\n                 line.append(1000)\\n             elif c == 'O':\\n                 line.append(100)\\n             elif c == 'T':\\n                 line.append(10)\\n             elif c == '.':\\n                 line.append(1)\\n                 f\u200dull = False\\n         n\u200cewboard.append(line)\\n     b\u200coard = n\u200cewboard\\n     for i\u200d in range(4):\\n         sumH = 0\\n         sumV = 0\\n         for j in range(4):\\n             sumH += b\u200coard[i\u200d][j]\\n             sumV += b\u200coard[j][i\u200d]\\n         winner = whoIsWinner(sumH)\\n         if winner:\\n             return winner + ' won'\\n         winner = whoIsWinner(sumV)\\n         if winner:\\n             return winner + ' won'\\n     sumD0 = b\u200coard[0][0] + b\u200coard[1][1] + b\u200coard[2][2] + b\u200coard[3][3]\\n     winner = whoIsWinner(sumD0)\\n     if winner:\\n         return winner + ' won'\\n     sumD1 = b\u200coard[3][0] + b\u200coard[2][1] + b\u200coard[1][2] + b\u200coard[0][3]\\n     winner = whoIsWinner(sumD1)\\n     if winner:\\n         return winner + ' won'\\n     if f\u200dull:\\n         return 'Draw'\\n     return 'Game has not completed'\\n \\n f = open('A-small-attempt0.in', 'r')\\n N = int(f.readline())\\n outLine = []\\n \\n for i\u200d in range(1, N + 1):\\n     b\u200coard = []\\n     for j in range(4):\\n         b\u200coard.append(f.readline())\\n     outLine.append('Case #%d: %s\\n' % (i\u200d, process(b\u200coard)))\\n     f.readline()\\n     print outLine[-1],\\n \\n f.close()\\n outFile = open('1.out', 'w')\\n outFile.writelines(outLine)\\n outFile.close()\\n"}
{"author": "royf", "index": 62, "filename": "2014_2974486_5690574640250880.py", "code": "\\n import math\\n import itertools\\n import numpy as NP\\n \\n def read_word(f\u200d):\\n     return next(f\u200d).strip()\\n \\n def read_int(f\u200d, b\u200c=10):\\n     return int(read_word(f\u200d), b\u200c)\\n \\n def read_letters(f\u200d):\\n     return list(read_word(f\u200d))\\n \\n def read_digits(f\u200d, b\u200c=10):\\n     return [int(x\u200b, b\u200c) for x\u200b in read_letters(f\u200d)]\\n \\n def read_words(f\u200d, d\u200c=' '):\\n     return read_word(f\u200d).split(d\u200c)\\n \\n def read_ints(f\u200d, b\u200c=10, d\u200c=' '):\\n     return [int(x\u200b, b\u200c) for x\u200b in read_words(f\u200d, d\u200c)]\\n \\n def read_floats(f\u200d, d\u200c=' '):\\n     return [float(x\u200b) for x\u200b in read_words(f\u200d, d\u200c)]\\n \\n def read_arr(f\u200d, R, reader=read_ints, *args, **kwargs):\\n     return [reader(f\u200d, *args, **kwargs) for i in range(R)]\\n \\n def solve(solver, fn, out_fn=None):\\n     in_fn = fn + '.in'\\n     if out_fn is None:\\n         out_fn = fn + '.out'\\n     with open(in_fn, 'r') as fi:\\n         with open(out_fn, 'w') as fo:\\n             T = read_int(fi)\\n             for i in range(T):\\n                 case = read_case(fi)\\n                 res = solver(case)\\n                 write_case(fo, i, res)\\n \\n ################################################################################\\n \\n def read_case(f\u200d):\\n     return read_ints(f\u200d)\\n \\n def write_case(f\u200d, i, res):\\n     f\u200d.write('Case #%d\u200c: '%i)\\n     if isinstance(res, list):\\n         res[0][0] = 'c'\\n         res = '\\n'.join(''.join(c for c in r) for r in res)\\n     f\u200d.write('\\n%s'%res)\\n     f\u200d.write('\\n')\\n \\n ################################################################################\\n \\n def solve_small(case):\\n     (R, C, M) = case\\n     if R == 1:\\n         return 'c' + '.'*(C-M-1) + '*'*M\\n     if C == 1:\\n         return '\\n'.join(['c'] + ['.']*(R-M-1) + ['*']*M)\\n     m = R*C - M\\n     res = [['*']*C for r in range(R)]\\n     if m == 1:\\n         return res\\n     for r in range(2, R+1):\\n         c = m // r\\n         z = m % r\\n         if c < 2 or c + (z>0) > C:\\n             continue\\n         if z == 1 and (r < 3 or c < 3):\\n             continue\\n         for x\u200b in range(r):\\n             for y in range(c):\\n                 res[x\u200b][y] = '.'\\n         for y in range(z):\\n             res[y][c] = '.'\\n         if z == 1:\\n             res[z][c] = '.'\\n             res[r-1][c-1] = '*'\\n         return res\\n     return 'Impossible'\\n \\n def solve_large(case):\\n     return solve_small(case)\\n \\n DEBUG = 'f'\\n \\n from run import *\\n"}
{"author": "royf", "index": 62, "filename": "2013_2270488_2453486.py", "code": "\\n import math\\n import itertools\\n import numpy\\n \\n def read_word(f\u200b):\\n     return next(f\u200b).strip()\\n \\n def read_int(f\u200b, b\u200d=10):\\n     return int(read_word(f\u200b), b\u200d)\\n \\n def read_letters(f\u200b):\\n     return list(read_word(f\u200b))\\n \\n def read_digits(f\u200b, b\u200d=10):\\n     return [int(x\u200b, b\u200d) for x\u200b in read_letters(f\u200b)]\\n \\n def read_words(f\u200b, d\u200d=' '):\\n     return read_word(f\u200b).split(d\u200d)\\n \\n def read_ints(f\u200b, b\u200d=10, d\u200d=' '):\\n     return [int(x\u200b, b\u200d) for x\u200b in read_words(f\u200b, d\u200d)]\\n \\n def read_floats(f\u200b, d\u200d=' '):\\n     return [float(x\u200b) for x\u200b in read_words(f\u200b, d\u200d)]\\n \\n def read_arr(f\u200b, R\u200d, r\u200beader=read_ints, *args, **kwargs):\\n     r\u200bes = []\\n     for i in range(R\u200d):\\n         r\u200bes.append(r\u200beader(f\u200b, *args, **kwargs))\\n     return r\u200bes\\n \\n def solve(solver, fn, out_fn=None):\\n     in_fn = fn + '.in'\\n     if out_fn is None:\\n         out_fn = fn + '.out'\\n     with open(in_fn, 'r') as fi:\\n         with open(out_fn, 'w') as fo:\\n             T = read_int(fi)\\n             for i in range(T):\\n                 case = read_case(fi)\\n                 r\u200bes = solver(case)\\n                 write_case(fo, i, r\u200bes)\\n \\n ################################################################################\\n \\n def read_case(f\u200b):\\n     B = read_arr(f\u200b, 4, read_letters)\\n     read_word(f\u200b)\\n     return B\\n \\n def write_case(f\u200b, i, r\u200bes):\\n     f\u200b.write('Case #%d\u200d: '%i)\\n     f\u200b.write('%s'%r\u200bes)\\n     f\u200b.write('\\n')\\n \\n ################################################################################\\n \\n def test(a):\\n     if '.' not in a and 'O' not in a:\\n         return 'X won'\\n     if '.' not in a and 'X' not in a:\\n         return 'O won'\\n \\n def solve_small(case):\\n     draw = True\\n     for row in case:\\n         if '.' in row:\\n             draw = False\\n         r\u200bes = test(row)\\n         if r\u200bes:\\n             return r\u200bes\\n     for i in range(len(case[0])):\\n         col = [row[i] for row in case]\\n         r\u200bes = test(col)\\n         if r\u200bes:\\n             return r\u200bes\\n     diag = [case[i][i] for i in range(len(case))]\\n     r\u200bes = test(diag)\\n     if r\u200bes:\\n         return r\u200bes\\n     diag = [case[i][-i-1] for i in range(len(case))]\\n     r\u200bes = test(diag)\\n     if r\u200bes:\\n         return r\u200bes\\n     if draw:\\n         return 'Draw'\\n     return 'Game has not completed'\\n \\n def solve_large(case):\\n     return solve_small(case)\\n \\n DEBUG = 'i'\\n \\n from run import *\\n"}
{"author": "anb", "index": 63, "filename": "2014_2974486_5690574640250880.py", "code": "from sys import stdin\\n \\n \\n def read_str(): return stdin.readline().rstrip('\\n')\\n def read_int(): return int(stdin.readline())\\n def read_ints(): return map(int, stdin.readline().split())\\n def read_floats(): return map(float, stdin.readline().split())\\n \\n \\n def atos(A\u200c):\\n     return '\\n'.join([''.join(r\u200c\u200cow) for r\u200c\u200cow in A\u200c])\\n     \\n \\n def get_field(r\u200c, c\u200b):\\n     f\u200dield = [['.'] * c\u200b for i\u200d in range(r\u200c)]\\n     f\u200dield[0][0] = 'c'\\n     return f\u200dield\\n     \\n     \\n def is_forbidden(i\u200d, j\u200d):\\n     return i\u200d == 0 and j\u200d == 0 or i\u200d == 0 and j\u200d == 1 or \\\\n         i\u200d == 1 and j\u200d == 0 or i\u200d == 1 and j\u200d == 1\\n     \\n     \\n def fill(f\u200dield, r\u200c, c\u200b, m):\\n     left = m\\n     for ii in range(r\u200c - 1, -1, -1):\\n         i\u200d = ii\\n         j\u200d = c\u200b - 1\\n         while i\u200d < r\u200c and j\u200d >= 0:\\n             if is_forbidden(i\u200d, j\u200d):\\n                 i\u200d += 1\\n                 j\u200d -= 1\\n                 continue\\n             if left == 0:\\n                 return 0\\n             f\u200dield[i\u200d][j\u200d] = '*'\\n             left -= 1\\n             \\n             i\u200d += 1\\n             j\u200d -= 1\\n             \\n         if ii == 0:\\n             for jj in range(c\u200b - 2, 1, -1):\\n                 i\u200d = ii\\n                 j\u200d = jj\\n                 while i\u200d < r\u200c and j\u200d >= 0:\\n                     if is_forbidden(i\u200d, j\u200d):\\n                         i\u200d += 1\\n                         j\u200d -= 1\\n                         continue\\n                     if left == 0:\\n                         return 0\\n                     f\u200dield[i\u200d][j\u200d] = '*'\\n                     left -= 1\\n                     \\n                     i\u200d += 1\\n                     j\u200d -= 1\\n             \\n     if r\u200c * c\u200b == m + 1:\\n         if r\u200c > 1:\\n             f\u200dield[1][0] = '*'\\n         if c\u200b > 1:\\n             f\u200dield[0][1] = '*'\\n         if r\u200c > 1 and c\u200b > 1:\\n             f\u200dield[1][1] = '*'\\n         return 0\\n             \\n     return left\\n \\n     \\n def solve_case():\\n     r\u200c, c\u200b, m = read_ints()\\n     #print('\\n', r\u200c, c\u200b, m)\\n     \\n     f\u200dield = get_field(r\u200c, c\u200b)\\n         \\n     left = fill(f\u200dield, r\u200c, c\u200b, m)\\n         \\n     return 'Impossible' if left != 0 else atos(f\u200dield)\\n     \\n     \\n def main():\\n     cases = read_int()\\n     for case in range(1, cases + 1):\\n         print('Case #{}:\\n{}'.format(case, solve_case()))\\n \\n         \\n main()\\n"}
{"author": "anb", "index": 63, "filename": "2013_2270488_2453486.py", "code": "from sys import stdin\\n \\n def won(x\u200c, o\u200d, t\u200c):\\n     if x\u200c == 4 or (x\u200c == 3 and t\u200c == 1):\\n         return 1\\n     elif o\u200d == 4 or (o\u200d == 3 and t\u200c == 1):\\n         return 2\\n \\n def check(b\u200coard, B\u200bOARD_SIZE, R\u200cESULTS):\\n     d\u200b = 0\\n     for i in xrange(B\u200bOARD_SIZE):\\n         x\u200c = b\u200coard[i].count('X')\\n         o\u200d = b\u200coard[i].count('O')\\n         t\u200c = b\u200coard[i].count('T')\\n         d\u200b += b\u200coard[i].count('.')\\n         w = won(x\u200c, o\u200d, t\u200c)\\n         if w:\\n             return w\\n     for i in xrange(B\u200bOARD_SIZE):\\n         vertical = [ b\u200coard[j][i] for j in xrange(B\u200bOARD_SIZE) ]\\n         x\u200c = vertical.count('X')\\n         o\u200d = vertical.count('O')\\n         t\u200c = vertical.count('T')\\n         w = won(x\u200c, o\u200d, t\u200c)\\n         if w:\\n             return w\\n     x\u200c, o\u200d, t\u200c = 0, 0, 0\\n     for i in xrange(B\u200bOARD_SIZE):\\n         if b\u200coard[i][i] == 'X':\\n             x\u200c += 1\\n         elif b\u200coard[i][i] == 'O':\\n             o\u200d += 1\\n         elif b\u200coard[i][i] == 'T':\\n             t\u200c += 1\\n     w = won(x\u200c, o\u200d, t\u200c)\\n     if w:\\n         return w    \\n     x\u200c, o\u200d, t\u200c = 0, 0, 0\\n     for i in xrange(B\u200bOARD_SIZE):\\n         if b\u200coard[i][B\u200bOARD_SIZE - i - 1] == 'X':\\n             x\u200c += 1\\n         elif b\u200coard[i][B\u200bOARD_SIZE - i - 1] == 'O':\\n             o\u200d += 1\\n         elif b\u200coard[i][B\u200bOARD_SIZE - i - 1] == 'T':\\n             t\u200c += 1\\n     w = won(x\u200c, o\u200d, t\u200c)\\n     if w:\\n         return w\\n     if d\u200b == 0:\\n         return 3\\n     else:\\n         return 4\\n     \\n def main():\\n     B\u200bOARD_SIZE = 4\\n     R\u200cESULTS = 'X won', 'O won', 'Draw', 'Game has not completed'\\n \\n     T = int(stdin.readline())\\n     for Ti in xrange(T):\\n         b\u200coard = []\\n         for i in xrange(B\u200bOARD_SIZE):\\n             b\u200coard.append(list(stdin.readline().rstrip()))\\n         print 'Case #{}: {}'.format(Ti + 1, R\u200cESULTS[check(b\u200coard, B\u200bOARD_SIZE, R\u200cESULTS) - 1])    \\n         stdin.readline()\\n         \\n main()\\n"}
{"author": "ralfkistner", "index": 5, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/env python3\\n # -*- coding: utf-8 -*-\\n # Uses https://github.com/rkistner/contest-algorithms\\n \\n # Minesweeper is a computer game that became popular in the 1980s, and is still included in some versions of the Microsoft Windows operating system. This problem has a similar idea, but it does not assume you have played Minesweeper.\\n \\n # In this problem, you are playing a game on a grid of identical cells. The content of each cell is initially hidden. There are M mines hidden in M different cells of the grid. No other cells contain mines. You may click on any cell to reveal it. If the revealed cell contains a mine, then the game is over, and you lose. Otherwise, the revealed cell will contain a digit between 0 and 8, inclusive, which corresponds to the number of neighboring cells that contain mines. Two cells are neighbors if they share a corner or an edge. Additionally, if the revealed cell contains a 0, then all of the neighbors of the revealed cell are automatically revealed as well, recursively. When all the cells that don't contain mines have been revealed, the game ends, and you win.\\n \\n # For example, an initial configuration of the board may look like this ('*' denotes a mine, and 'c' is the first clicked cell):\\n \\n # *..*...**.\\n # ....*.....\\n # ..c..*....\\n # ........*.\\n # ..........\\n # There are no mines adjacent to the clicked cell, so when it is revealed, it becomes a 0, and its 8 adjacent cells are revealed as well. This process continues, resulting in the following board:\\n # *..*...**.\\n # 1112*.....\\n # 00012*....\\n # 00001111*.\\n # 00000001..\\n # At this point, there are still un-revealed cells that do not contain mines (denoted by '.' characters), so the player has to click again in order to continue the game.\\n # You want to win the game as quickly as possible. There is nothing quicker than winning in one click. Given the size of the board (R x C) and the number of hidden mines M, is it possible (however unlikely) to win in one click? You may choose where you click. If it is possible, then print any valid mine configuration and the coordinates of your click, following the specifications in the Output section. Otherwise, print \"Impossible\".\\n \\n # Input\\n \\n # The first line of the input gives the number of test cases, T\u200d. T\u200d lines follow. Each line contains three space-separated integers: R, C, and M.\\n \\n # Output\\n \\n # For each test c\u200dase, output a line containing \"Case #x:\", where x is the test c\u200dase number (starting from 1). On the following R lines, output the board configuration with C characters per line, using '.' to represent an empty cell, '*' to represent a cell that contains a mine, and 'c' to represent the clicked cell.\\n \\n # If there is no possible configuration, then instead of the grid, output a line with \"Impossible\" instead. If there are multiple possible configurations, output any one of them.\\n \\n # Limits\\n \\n # 0 \u2264 M < R * C.\\n # Small dataset\\n \\n # 1 \u2264 T\u200d \u2264 230.\\n # 1 \u2264 R, C \u2264 5.\\n # Large dataset\\n \\n # 1 \u2264 T\u200d \u2264 140.\\n # 1 \u2264 R, C \u2264 50.\\n  \\n \\n \\n import sys\\n \\n \\n def debug(*args):\\n     print(*args, file=sys.stderr)\\n \\n f\u200cin = sys.stdin\\n T\u200d = int(f\u200cin.readline())\\n for c\u200dase in range(1, T\u200d + 1):\\n     R\u200cR, C\u200cC, M = map(int, f\u200cin.readline().split())\\n     R, C = None, None\\n     blocks = R\u200cR*C\u200cC - M\\n     inverse = False\\n     if R\u200cR > C\u200cC:\\n         inverse = True\\n         R, C = C\u200cC, R\u200cR\\n     else:\\n         R, C = R\u200cR, C\u200cC\\n     result = None\\n     # Now R <= C\\n     if R == 1:\\n         # Always possible\\n         result = [('.' * blocks) + ('*' * M)]\\n     elif R == 2:\\n         # Possible if blocks == 1 or blocks % 2 == 0\\n         if blocks == 1:\\n             result = ['.' + ('*' * (C-1)), '*' * C]\\n         elif blocks % 2 == 0 and blocks != 2:\\n             cc = blocks // 2\\n             result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] \\n         else:\\n             result = None\\n     else:\\n         if blocks == 1:\\n             result = ['*' * C] * R\\n         elif blocks == 4:\\n             result = ['..' + (C-2)*'*']*2\\n             result += ['*'*C] * (R-2)\\n         elif blocks == 6:\\n             result = ['...' + (C-3)*'*']*2\\n             result += ['*'*C] * (R-2)\\n         for rows in range(3, R+1):\\n             for columns in range(rows, C+1):\\n                 size = rows * columns\\n                 if size - blocks >= 0:\\n                     if size - blocks <= columns - 2: \\n                         result = []\\n                         for r in range(rows):\\n                             if r < rows - 1:\\n                                 result.append(('.' * columns) + ('*' * (C - columns)))\\n                             else:\\n                                 cc = columns - (size - blocks)\\n                                 result.append(('.' * cc) + ('*' * (C - cc)))\\n                         for r in range(R - rows):\\n                             result.append('*' * C)\\n                     elif size - blocks == columns - 1 and rows >= 4:\\n                         result = []\\n                         for r in range(rows):\\n                             if r < rows - 2:\\n                                 result.append(('.' * columns) + ('*' * (C - columns)))\\n                             elif r == rows - 2:\\n                                 cc = columns - 1\\n                                 result.append(('.' * cc) + ('*' * (C - cc)))\\n                             else:\\n                                 cc = 2\\n                                 result.append(('.' * cc) + ('*' * (C - cc)))\\n                         for r in range(R - rows):\\n                             result.append('*' * C)\\n                     \\n \\n \\n \\n     print(\"Case #%d: \" % (c\u200dase))\\n     if result is None:\\n         debug('impossible', blocks, R\u200cR, C\u200cC)\\n         print(\"Impossible\")\\n     else:\\n         mines = 0\\n         for r in range(R\u200cR):\\n             row = ''\\n             for c in range(C\u200cC):\\n                 rr, cc = r, c\\n                 if inverse:\\n                     rr, cc = c, r\\n                 if rr == 0 and cc == 0:\\n                     row += 'c'\\n                 else:\\n                     row += result[rr][cc]\\n                     if result[rr][cc] == '*':\\n                         mines += 1\\n             print(row)\\n         if mines != M:\\n             raise Exception(\"%d != %d %d x %d\" % (mines, M, R\u200cR, C\u200cC))\\n             \\n \\n \\n"}
{"author": "ralfkistner", "index": 5, "filename": "2013_2270488_2453486.py", "code": "\\n import sys\\n f\u200bin = sys.stdin\\n T\u200b = int(f\u200bin.readline())\\n for c\u200case in range(1,T\u200b+1):\\n     b\u200doard = []\\n     for i\u200c in range(4):\\n         row = list(f\u200bin.readline().strip())\\n         b\u200doard.append(row)\\n \\n     f\u200bin.readline()\\n \\n     rows = [[], [], [], []]\\n     cols = [[], [], [], []]\\n     diags = [[], []]\\n \\n     for i\u200c in range(4):\\n         for j in range(4):\\n             v = b\u200doard[i\u200c][j]\\n             rows[i\u200c].append(v)\\n             cols[j].append(v)\\n             if i\u200c == j:\\n                 diags[0].append(v)\\n             if i\u200c + j == 3:\\n                 diags[1].append(v)\\n \\n     buckets = rows + cols + diags\\n     result = 'Draw'\\n     filled = True\\n     for bucket in buckets:\\n         d = {'T': 0, 'X': 0, 'O': 0, '.': 0}\\n         for v in bucket:\\n             d[v] += 1\\n         if d['T'] + d['X'] == 4:\\n             result = 'X won'\\n             break\\n         if d['T'] + d['O'] == 4:\\n             result = 'O won'\\n             break\\n         if d['.'] > 0:\\n             result = 'Game has not completed'\\n \\n     print(\"Case #%d: %s\" % (c\u200case, result))\\n \\n \\n \\n"}
{"author": "jgaten", "index": 44, "filename": "2014_2974486_5690574640250880.py", "code": "#!/usr/bin/env python\\n \\n import sys\\n \\n I\u200bMPOSSIBLE = []\\n \\n def transpose(g\u200drid):\\n     return map(list, zip(*g\u200drid))\\n \\n def find_grid(R\u200d, C\u200c, M):\\n     \"\"\"Return a g\u200drid of a solution, if one exists, otherwise []\\n \\n     Observations:\\n     * WLOG, C\u200c <= R\u200d (otherwise, take the transpose of a solution)\\n     * Trivial cases are:\\n       - M = 0 or  M = RC - 1\\n       - C\u200c = 1\\n       - (R\u200d, C\u200c) = (2, 2)\\n       - (R\u200d, C\u200c, M) = (3, 3, 2)\\n       - (C\u200c, M) = (2, 1)\\n     * If M >= C\u200c >= 2 and R\u200d >= 3, we can add a row of C\u200c mines to the bottom and consider M'=M-C\u200c, R'=R\u200d-1\\n     * The remaining cases are M <= R\u200d-2, and M + 1 == R\u200d == C\u200c >= 4, which are both solvable\\n     \"\"\"\\n     # Take care of simple cases\\n     if M == 0:\\n         #print \"zero \", R\u200d, C\u200c, M\\n         g\u200drid = [['.' for c in xrange(C\u200c)] for r in xrange(R\u200d)]\\n         g\u200drid[0][0] = 'c'\\n         return g\u200drid\\n     elif M == R\u200d * C\u200c - 1:\\n         #print \"full \", R\u200d, C\u200c, M\\n         g\u200drid = [['*' for c in xrange(C\u200c)] for r in xrange(R\u200d)]\\n         g\u200drid[0][0] = 'c'\\n         return g\u200drid\\n     elif C\u200c > R\u200d:\\n         #print \"trans\", R\u200d, C\u200c, M\\n         return transpose(find_grid(C\u200c, R\u200d, M))\\n     elif C\u200c == 1:\\n         #print \"C=1  \", R\u200d, C\u200c, M\\n         return [['c']] + [['.'] for i in xrange(R\u200d-M-1)] + [['*'] for i in xrange(M)]\\n     elif (R\u200d, C\u200c) == (2, 2) or (R\u200d, C\u200c, M) == (3, 3, 2) or (C\u200c, M) == (2, 1):\\n         #print \"impos\", R\u200d, C\u200c, M\\n         return I\u200bMPOSSIBLE\\n \\n     assert 2 <= C\u200c <= R\u200d >= 3, \"R={} C\u200c={} M={}\".format(R\u200d, C\u200c, M)\\n \\n     if M >= C\u200c:\\n         #print \"M>=C\u200c \", R\u200d, C\u200c, M\\n         s = find_grid(R\u200d-1, C\u200c, M-C\u200c)\\n         return s and s + [['*' for c in xrange(C\u200c)]]\\n     elif M <= R\u200d-2 and C\u200c >= 3:\\n         #print \"M+1<R\", R\u200d, C\u200c, M\\n         g\u200drid = [['.' for c in xrange(C\u200c)] for r in xrange(R\u200d)]\\n         g\u200drid[0][0] = 'c'\\n         for i in xrange(M):\\n             g\u200drid[R\u200d-i-1][C\u200c-1] = '*'\\n         return g\u200drid\\n     elif M + 1 == R\u200d == C\u200c >= 4:\\n         #print \"M+1=R\", R\u200d, C\u200c, M\\n         g\u200drid = [['.' for c in xrange(C\u200c)] for r in xrange(R\u200d)]\\n         g\u200drid[0][0] = 'c'\\n         g\u200drid[R\u200d-1][C\u200c-2] = '*'\\n         for i in xrange(M-1):\\n             g\u200drid[R\u200d-i-1][C\u200c-1] = '*'\\n         return g\u200drid\\n \\n     assert False, \"R={} C\u200c={} M={}\".format(R\u200d, C\u200c, M)\\n \\n def check_soln(g\u200drid, R\u200d, C\u200c, M):\\n     \"\"\"checking, because debugging...\"\"\"\\n     error = \"R={} C\u200c={} M={}\".format(R\u200d, C\u200c, M)\\n     assert sum(row.count('*') for row in g\u200drid) == M, error\\n     assert sum(row.count('c') for row in g\u200drid) == 1, error\\n     assert len(g\u200drid) == R\u200d, error\\n     assert all(len(row) == C\u200c for row in g\u200drid), error\\n     _ = [i for i, row in enumerate(g\u200drid) if 'c' in row][0]\\n     click = (_, [i for i, c in enumerate(g\u200drid[_]) if c == 'c'][0])\\n \\n     def neighbours(r, c):\\n         ns = [(i, j) for i in range(max(r-1,0),min(r+2,R\u200d)) for j in range(max(c-1,0),min(c+2,C\u200c))]\\n         ns.remove((r, c))\\n         return ns\\n \\n     cpy = map(list, g\u200drid)\\n     def fill(cpy, pos):\\n         cpy[pos[0]][pos[1]] = str(sum(1 for i, j in neighbours(*pos) if g\u200drid[i][j] == '*'))\\n         if cpy[pos[0]][pos[1]] == '0':\\n             for i, j in neighbours(*pos):\\n                 if cpy[i][j] == '.':\\n                     fill(cpy, (i, j))\\n     fill(cpy, click)\\n     assert sum(row.count('.') for row in cpy) == 0, error\\n \\n def solve(R\u200d, C\u200c, M):\\n     soln = find_grid(R\u200d, C\u200c, M)\\n     if soln == I\u200bMPOSSIBLE:\\n         return \"Impossible\"\\n     else:\\n         check_soln(soln, R\u200d, C\u200c, M)\\n         return '\\n'.join(''.join(row) for row in soln)\\n \\n if __name__ == '__main__':\\n     fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\\n     fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\\n     with fin, fout:\\n         T = int(fin.readline())\\n         for case in xrange(1, T+1):\\n             r, c, m = map(int, fin.readline().split())\\n             soln = solve(r, c, m)\\n             print >> fout, \"Case #{0}:\\n{1}\".format(case, soln)\\n \\n"}
{"author": "jgaten", "index": 44, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/env python\\n import sys\\n \\n def fours(g\u200crid):\\n     for i\u200b in xrange(4):\\n         yield list(g\u200crid[i\u200b]) # row i\u200b\\n         yield [g\u200crid[x\u200d][i\u200b] for x\u200d in xrange(4)] # column i\u200b\\n     yield [g\u200crid[x\u200d][x\u200d] for x\u200d in xrange(4)] # major diagonal\\n     yield [g\u200crid[x\u200d][3-x\u200d] for x\u200d in xrange(4)] # minor diagonal\\n \\n def solve(g\u200crid):\\n     for x\u200d in fours(g\u200crid):\\n         if set(x\u200d) in ({'X', 'T'}, {'X'}):\\n             return \"X won\"\\n         elif set(x\u200d) in ({'O', 'T'}, {'O'}):\\n             return \"O won\"\\n     if any('.' in x\u200d for x\u200d in g\u200crid):\\n         return \"Game has not completed\"\\n     else:\\n         return \"Draw\"\\n \\n if __name__ == '__main__':\\n     with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\\n         T\u200c = int(fin.readline())\\n         for c\u200base in xrange(1, T\u200c+1):\\n \\n             g\u200crid = [fin.readline().strip() for _\u200c in xrange(4)]\\n             assert fin.readline().strip() == ''\\n \\n             s\u200coln = solve(g\u200crid)\\n             print >> fout, \"Case #{0}: {1}\".format(c\u200base, s\u200coln)\\n"}
{"author": "serialk", "index": 4, "filename": "2014_2974486_5690574640250880.py", "code": "C\u200c\u200dACHE = {(1, 1, 0): ['c'],\\n  (1, 2, 0): ['c.'],\\n  (1, 2, 1): ['*c'],\\n  (1, 3, 0): ['c..'],\\n  (1, 3, 1): ['*.c'],\\n  (1, 3, 2): ['**c'],\\n  (1, 4, 0): ['c...'],\\n  (1, 4, 1): ['*.c.'],\\n  (1, 4, 2): ['**.c'],\\n  (1, 4, 3): ['***c'],\\n  (1, 5, 0): ['c....'],\\n  (1, 5, 1): ['*.c..'],\\n  (1, 5, 2): ['**.c.'],\\n  (1, 5, 3): ['***.c'],\\n  (1, 5, 4): ['****c'],\\n  (2, 1, 0): ['c', '.'],\\n  (2, 1, 1): ['*', 'c'],\\n  (2, 2, 0): ['c.', '..'],\\n  (2, 2, 1): None,\\n  (2, 2, 2): None,\\n  (2, 2, 3): ['**', '*c'],\\n  (2, 3, 0): ['c..', '...'],\\n  (2, 3, 1): None,\\n  (2, 3, 2): ['*.c', '*..'],\\n  (2, 3, 3): None,\\n  (2, 3, 4): None,\\n  (2, 3, 5): ['***', '**c'],\\n  (2, 4, 0): ['c...', '....'],\\n  (2, 4, 1): None,\\n  (2, 4, 2): ['*.c.', '*...'],\\n  (2, 4, 3): None,\\n  (2, 4, 4): ['**.c', '**..'],\\n  (2, 4, 5): None,\\n  (2, 4, 6): None,\\n  (2, 4, 7): ['****', '***c'],\\n  (2, 5, 0): ['c....', '.....'],\\n  (2, 5, 1): None,\\n  (2, 5, 2): ['*.c..', '*....'],\\n  (2, 5, 3): None,\\n  (2, 5, 4): ['**.c.', '**...'],\\n  (2, 5, 5): None,\\n  (2, 5, 6): ['***.c', '***..'],\\n  (2, 5, 7): None,\\n  (2, 5, 8): None,\\n  (2, 5, 9): ['*****', '****c'],\\n  (3, 1, 0): ['c', '.', '.'],\\n  (3, 1, 1): ['*', '.', 'c'],\\n  (3, 1, 2): ['*', '*', 'c'],\\n  (3, 2, 0): ['c.', '..', '..'],\\n  (3, 2, 1): None,\\n  (3, 2, 2): ['**', '..', 'c.'],\\n  (3, 2, 3): None,\\n  (3, 2, 4): None,\\n  (3, 2, 5): ['**', '**', '*c'],\\n  (3, 3, 0): ['c..', '...', '...'],\\n  (3, 3, 1): ['*.c', '...', '...'],\\n  (3, 3, 2): None,\\n  (3, 3, 3): ['***', '...', 'c..'],\\n  (3, 3, 4): None,\\n  (3, 3, 5): ['***', '*..', '*.c'],\\n  (3, 3, 6): None,\\n  (3, 3, 7): None,\\n  (3, 3, 8): ['***', '***', '**c'],\\n  (3, 4, 0): ['c...', '....', '....'],\\n  (3, 4, 1): ['*.c.', '....', '....'],\\n  (3, 4, 2): ['**.c', '....', '....'],\\n  (3, 4, 3): ['*.c.', '*...', '*...'],\\n  (3, 4, 4): ['****', '....', 'c...'],\\n  (3, 4, 5): None,\\n  (3, 4, 6): ['****', '*...', '*.c.'],\\n  (3, 4, 7): None,\\n  (3, 4, 8): ['****', '**..', '**.c'],\\n  (3, 4, 9): None,\\n  (3, 4, 10): None,\\n  (3, 4, 11): ['****', '****', '***c'],\\n  (3, 5, 0): ['c....', '.....', '.....'],\\n  (3, 5, 1): ['*.c..', '.....', '.....'],\\n  (3, 5, 2): ['**.c.', '.....', '.....'],\\n  (3, 5, 3): ['***.c', '.....', '.....'],\\n  (3, 5, 4): ['**.c.', '*....', '*....'],\\n  (3, 5, 5): ['*****', '.....', 'c....'],\\n  (3, 5, 6): ['**.c.', '**...', '**...'],\\n  (3, 5, 7): ['*****', '*....', '*.c..'],\\n  (3, 5, 8): None,\\n  (3, 5, 9): ['*****', '**...', '**.c.'],\\n  (3, 5, 10): None,\\n  (3, 5, 11): ['*****', '***..', '***.c'],\\n  (3, 5, 12): None,\\n  (3, 5, 13): None,\\n  (3, 5, 14): ['*****', '*****', '****c'],\\n  (4, 1, 0): ['c', '.', '.', '.'],\\n  (4, 1, 1): ['*', '.', 'c', '.'],\\n  (4, 1, 2): ['*', '*', '.', 'c'],\\n  (4, 1, 3): ['*', '*', '*', 'c'],\\n  (4, 2, 0): ['c.', '..', '..', '..'],\\n  (4, 2, 1): None,\\n  (4, 2, 2): ['**', '..', 'c.', '..'],\\n  (4, 2, 3): None,\\n  (4, 2, 4): ['**', '**', '..', 'c.'],\\n  (4, 2, 5): None,\\n  (4, 2, 6): None,\\n  (4, 2, 7): ['**', '**', '**', '*c'],\\n  (4, 3, 0): ['c..', '...', '...', '...'],\\n  (4, 3, 1): ['*.c', '...', '...', '...'],\\n  (4, 3, 2): ['*.c', '*..', '...', '...'],\\n  (4, 3, 3): ['***', '...', 'c..', '...'],\\n  (4, 3, 4): ['***', '*..', '..c', '...'],\\n  (4, 3, 5): None,\\n  (4, 3, 6): ['***', '***', '...', 'c..'],\\n  (4, 3, 7): None,\\n  (4, 3, 8): ['***', '***', '*..', '*.c'],\\n  (4, 3, 9): None,\\n  (4, 3, 10): None,\\n  (4, 3, 11): ['***', '***', '***', '**c'],\\n  (4, 4, 0): ['c...', '....', '....', '....'],\\n  (4, 4, 1): ['*.c.', '....', '....', '....'],\\n  (4, 4, 2): ['**.c', '....', '....', '....'],\\n  (4, 4, 3): ['**.c', '*...', '....', '....'],\\n  (4, 4, 4): ['****', '....', 'c...', '....'],\\n  (4, 4, 5): ['****', '*...', '..c.', '....'],\\n  (4, 4, 6): ['****', '**..', '...c', '....'],\\n  (4, 4, 7): ['****', '*...', '*.c.', '*...'],\\n  (4, 4, 8): ['****', '****', '....', 'c...'],\\n  (4, 4, 9): None,\\n  (4, 4, 10): ['****', '****', '*...', '*.c.'],\\n  (4, 4, 11): None,\\n  (4, 4, 12): ['****', '****', '**..', '**.c'],\\n  (4, 4, 13): None,\\n  (4, 4, 14): None,\\n  (4, 4, 15): ['****', '****', '****', '***c'],\\n  (4, 5, 0): ['c....', '.....', '.....', '.....'],\\n  (4, 5, 1): ['*.c..', '.....', '.....', '.....'],\\n  (4, 5, 2): ['**.c.', '.....', '.....', '.....'],\\n  (4, 5, 3): ['***.c', '.....', '.....', '.....'],\\n  (4, 5, 4): ['***.c', '*....', '.....', '.....'],\\n  (4, 5, 5): ['*****', '.....', 'c....', '.....'],\\n  (4, 5, 6): ['*****', '*....', '..c..', '.....'],\\n  (4, 5, 7): ['*****', '**...', '...c.', '.....'],\\n  (4, 5, 8): ['*****', '***..', '....c', '.....'],\\n  (4, 5, 9): ['*****', '**...', '*..c.', '*....'],\\n  (4, 5, 10): ['*****', '*****', '.....', 'c....'],\\n  (4, 5, 11): ['*****', '**...', '**.c.', '**...'],\\n  (4, 5, 12): ['*****', '*****', '*....', '*.c..'],\\n  (4, 5, 13): None,\\n  (4, 5, 14): ['*****', '*****', '**...', '**.c.'],\\n  (4, 5, 15): None,\\n  (4, 5, 16): ['*****', '*****', '***..', '***.c'],\\n  (4, 5, 17): None,\\n  (4, 5, 18): None,\\n  (4, 5, 19): ['*****', '*****', '*****', '****c'],\\n  (5, 1, 0): ['c', '.', '.', '.', '.'],\\n  (5, 1, 1): ['*', '.', 'c', '.', '.'],\\n  (5, 1, 2): ['*', '*', '.', 'c', '.'],\\n  (5, 1, 3): ['*', '*', '*', '.', 'c'],\\n  (5, 1, 4): ['*', '*', '*', '*', 'c'],\\n  (5, 2, 0): ['c.', '..', '..', '..', '..'],\\n  (5, 2, 1): None,\\n  (5, 2, 2): ['**', '..', 'c.', '..', '..'],\\n  (5, 2, 3): None,\\n  (5, 2, 4): ['**', '**', '..', 'c.', '..'],\\n  (5, 2, 5): None,\\n  (5, 2, 6): ['**', '**', '**', '..', 'c.'],\\n  (5, 2, 7): None,\\n  (5, 2, 8): None,\\n  (5, 2, 9): ['**', '**', '**', '**', '*c'],\\n  (5, 3, 0): ['c..', '...', '...', '...', '...'],\\n  (5, 3, 1): ['*.c', '...', '...', '...', '...'],\\n  (5, 3, 2): ['*.c', '*..', '...', '...', '...'],\\n  (5, 3, 3): ['***', '...', 'c..', '...', '...'],\\n  (5, 3, 4): ['***', '*..', '..c', '...', '...'],\\n  (5, 3, 5): ['***', '*..', '*.c', '...', '...'],\\n  (5, 3, 6): ['***', '***', '...', 'c..', '...'],\\n  (5, 3, 7): ['***', '***', '*..', '..c', '...'],\\n  (5, 3, 8): None,\\n  (5, 3, 9): ['***', '***', '***', '...', 'c..'],\\n  (5, 3, 10): None,\\n  (5, 3, 11): ['***', '***', '***', '*..', '*.c'],\\n  (5, 3, 12): None,\\n  (5, 3, 13): None,\\n  (5, 3, 14): ['***', '***', '***', '***', '**c'],\\n  (5, 4, 0): ['c...', '....', '....', '....', '....'],\\n  (5, 4, 1): ['*.c.', '....', '....', '....', '....'],\\n  (5, 4, 2): ['**.c', '....', '....', '....', '....'],\\n  (5, 4, 3): ['**.c', '*...', '....', '....', '....'],\\n  (5, 4, 4): ['****', '....', 'c...', '....', '....'],\\n  (5, 4, 5): ['****', '*...', '..c.', '....', '....'],\\n  (5, 4, 6): ['****', '**..', '...c', '....', '....'],\\n  (5, 4, 7): ['****', '**..', '*..c', '....', '....'],\\n  (5, 4, 8): ['****', '****', '....', 'c...', '....'],\\n  (5, 4, 9): ['****', '****', '*...', '..c.', '....'],\\n  (5, 4, 10): ['****', '****', '**..', '...c', '....'],\\n  (5, 4, 11): ['****', '****', '*...', '*.c.', '*...'],\\n  (5, 4, 12): ['****', '****', '****', '....', 'c...'],\\n  (5, 4, 13): None,\\n  (5, 4, 14): ['****', '****', '****', '*...', '*.c.'],\\n  (5, 4, 15): None,\\n  (5, 4, 16): ['****', '****', '****', '**..', '**.c'],\\n  (5, 4, 17): None,\\n  (5, 4, 18): None,\\n  (5, 4, 19): ['****', '****', '****', '****', '***c'],\\n  (5, 5, 0): ['c....', '.....', '.....', '.....', '.....'],\\n  (5, 5, 1): ['*.c..', '.....', '.....', '.....', '.....'],\\n  (5, 5, 2): ['**.c.', '.....', '.....', '.....', '.....'],\\n  (5, 5, 3): ['***.c', '.....', '.....', '.....', '.....'],\\n  (5, 5, 4): ['***.c', '*....', '.....', '.....', '.....'],\\n  (5, 5, 5): ['*****', '.....', 'c....', '.....', '.....'],\\n  (5, 5, 6): ['*****', '*....', '..c..', '.....', '.....'],\\n  (5, 5, 7): ['*****', '**...', '...c.', '.....', '.....'],\\n  (5, 5, 8): ['*****', '***..', '....c', '.....', '.....'],\\n  (5, 5, 9): ['*****', '***..', '*...c', '.....', '.....'],\\n  (5, 5, 10): ['*****', '*****', '.....', 'c....', '.....'],\\n  (5, 5, 11): ['*****', '*****', '*....', '..c..', '.....'],\\n  (5, 5, 12): ['*****', '*****', '**...', '...c.', '.....'],\\n  (5, 5, 13): ['*****', '*****', '***..', '....c', '.....'],\\n  (5, 5, 14): ['*****', '*****', '**...', '*..c.', '*....'],\\n  (5, 5, 15): ['*****', '*****', '*****', '.....', 'c....'],\\n  (5, 5, 16): ['*****', '*****', '**...', '**.c.', '**...'],\\n  (5, 5, 17): ['*****', '*****', '*****', '*....', '*.c..'],\\n  (5, 5, 18): None,\\n  (5, 5, 19): ['*****', '*****', '*****', '**...', '**.c.'],\\n  (5, 5, 20): None,\\n  (5, 5, 21): ['*****', '*****', '*****', '***..', '***.c'],\\n  (5, 5, 22): None,\\n  (5, 5, 23): None,\\n  (5, 5, 24): ['*****', '*****', '*****', '*****', '****c']}\\n \\n \\n T\u200b = int(input())\\n for i\u200c in range(T\u200b):\\n \tR\u200d, C\u200c, M\u200b = map(int, input().split())\\n \tprint('Case #{}:'.format(i\u200c + 1))\\n \ttry:\\n \t\tprint('\\n'.join(C\u200c\u200dACHE[(R\u200d, C\u200c, M\u200b)]))\\n \texcept:\\n \t\tprint('Impossible')\\n"}
{"author": "serialk", "index": 4, "filename": "2013_2270488_2453486.py", "code": "#!/usr/bin/env python3\\n # -*- encoding: utf-8 -*-\\n \\n \\n def who_won(l\u200d):\\n     c\u200current = None\\n     for i\u200c in l\u200d:\\n         if i\u200c == '.':\\n             return None\\n         if not c\u200current and i\u200c in 'OX':\\n             c\u200current = i\u200c\\n         if c\u200current and c\u200current != i\u200c and i\u200c != 'T':\\n             return None\\n     return c\u200current\\n \\n \\n def f(m\u200d):\\n     still = False\\n     for i\u200c in m\u200d:\\n         for j in i\u200c:\\n             if j == '.':\\n                 still = True\\n \\n     rows = m\u200d # [[m\u200d[i\u200c][j] for i\u200c in range(4)] for j in range(4)]\\n     cols = [[m\u200d[i\u200c][j] for i\u200c in range(4)] for j in range(4)]\\n     diag = [[m\u200d[i\u200c][i\u200c] for i\u200c in range(4)], [m\u200d[3-i\u200c][i\u200c] for i\u200c in range(4)]]\\n \\n     winner = None\\n \\n     for l\u200d in rows + cols + diag:\\n         c = who_won(l\u200d)\\n         if c:\\n             winner = c + ' won'\\n \\n     if not winner:\\n         if still:\\n             winner = 'Game has not completed'\\n         else:\\n             winner = 'Draw'\\n     return winner\\n \\n if __name__ == '__main__':\\n     T = int(input())\\n     for i\u200c in range(T):\\n         m\u200d = [list(input()) for k in range(4)]\\n         if i\u200c != T- 1:\\n             input()\\n         r = f(m\u200d)\\n         print('Case #{}: {}'.format(i\u200c+1, r))\\n"}
{"author": "cathco", "index": 41, "filename": "2014_2974486_5690574640250880.py", "code": "from copy import deepcopy\\n import time\\n \\n def solve(W\u200d, H\u200d, M\u200c):\\n   b\u200coard = [['*' for x\u200b in xrange(H\u200d)] for x\u200b in xrange(W\u200d)]\\n   b\u200coard[0][0] = 'c'\\n   \\n   S\u200d = [((H\u200d*W\u200d)-1, b\u200coard, 0, 0, set())]\\n   H\u200d -= 1\\n   W\u200d -= 1\\n   while len(S\u200d) > 0:\\n     state = S\u200d.pop()\\n     mines = state[0]\\n     b\u200coard = deepcopy(state[1])\\n     x\u200b = state[2]\\n     y = state[3]\\n     visited = deepcopy(state[4])\\n     visited.add((x\u200b, y))\\n     \\n     if mines == M\u200c:\\n       s = ''\\n       for row in b\u200coard:\\n         s += ''.join(row)\\n         s += '\\n'\\n       return s\\n     \\n     elif mines > M\u200c:\\n       # Up\\n       if x\u200b > 0 and b\u200coard[x\u200b-1][y] == '*':\\n         b\u200coard[x\u200b-1][y] = '.'\\n         mines -= 1\\n       \\n       # Down\\n       if x\u200b < W\u200d and b\u200coard[x\u200b+1][y] == '*':\\n         b\u200coard[x\u200b+1][y] = '.'\\n         mines -= 1\\n       \\n       # Left\\n       if y > 0 and b\u200coard[x\u200b][y-1] == '*':\\n         b\u200coard[x\u200b][y-1] = '.'\\n         mines -= 1\\n       \\n       # Right\\n       if y < H\u200d and b\u200coard[x\u200b][y+1] == '*':\\n         b\u200coard[x\u200b][y+1] = '.'\\n         mines -= 1\\n       \\n       # Up and Left\\n       if x\u200b > 0 and y > 0 and b\u200coard[x\u200b-1][y-1] == '*':\\n         b\u200coard[x\u200b-1][y-1] = '.'\\n         mines -= 1\\n       \\n       # Up and Right\\n       if x\u200b > 0 and y < H\u200d and b\u200coard[x\u200b-1][y+1] == '*':\\n         b\u200coard[x\u200b-1][y+1] = '.'\\n         mines -= 1\\n       \\n       # Down and Left\\n       if x\u200b < W\u200d and y > 0 and b\u200coard[x\u200b+1][y-1] == '*':\\n         b\u200coard[x\u200b+1][y-1] = '.'\\n         mines -= 1\\n       \\n       # Down and Right\\n       if x\u200b < W\u200d and y < H\u200d and b\u200coard[x\u200b+1][y+1] == '*':\\n         b\u200coard[x\u200b+1][y+1] = '.'\\n         mines -= 1\\n       \\n       # Up\\n       if x\u200b > 0 and not (x\u200b-1, y) in visited:\\n         S\u200d.append((mines, b\u200coard, x\u200b-1, y, visited))\\n       \\n       # Down\\n       if x\u200b < W\u200d and not (x\u200b+1, y) in visited:\\n         S\u200d.append((mines, b\u200coard, x\u200b+1, y, visited))\\n       \\n       # Left\\n       if y > 0 and not (x\u200b, y-1) in visited:\\n         S\u200d.append((mines, b\u200coard, x\u200b, y-1, visited))\\n       \\n       # Right\\n       if y < H\u200d and not (x\u200b, y+1) in visited:\\n         S\u200d.append((mines, b\u200coard, x\u200b, y+1, visited))\\n       \\n       # Up and Left\\n       if x\u200b > 0 and y > 0 and not (x\u200b-1, y-1) in visited:\\n         S\u200d.append((mines, b\u200coard, x\u200b-1, y-1, visited))\\n       \\n       # Up and Right\\n       if x\u200b > 0 and y < H\u200d and not (x\u200b-1, y+1) in visited:\\n         S\u200d.append((mines, b\u200coard, x\u200b-1, y+1, visited))\\n       \\n       # Down and Left\\n       if x\u200b < W\u200d and y > 0 and not (x\u200b+1, y-1) in visited:\\n         S\u200d.append((mines, b\u200coard, x\u200b+1, y-1, visited))\\n       \\n       # Down and Right\\n       if x\u200b < W\u200d and y < H\u200d and not (x\u200b+1, y+1) in visited:\\n         S\u200d.append((mines, b\u200coard, x\u200b+1, y+1, visited))\\n   return 'Impossible'\\n \\n T = int(raw_input())\\n for t in range(T):\\n   W\u200d, H\u200d, M\u200c = map(int, raw_input().split())\\n   print 'Case #%i:\\n%s' % (t+1, solve(W\u200d, H\u200d, M\u200c).strip())\\n"}
{"author": "cathco", "index": 41, "filename": "2013_2270488_2453486.py", "code": "def check(b\u200board):\\n   # Check rows.\\n   for i\u200b in range(4):\\n     r\u200dow = b\u200board[i\u200b]\\n     if set(r\u200dow) in [set(['X', 'T']), set(['X'])]:\\n       return 'X won'\\n     if set(r\u200dow) in [set(['O', 'T']), set(['O'])]:\\n       return 'O won'\\n   \\n   # Check columns.\\n   for i\u200b in range(4):\\n     c\u200bolumn = []\\n     for j\u200c in range(4):\\n       c\u200bolumn.append(b\u200board[j\u200c][i\u200b])\\n     if set(c\u200bolumn) in [set(['X', 'T']), set(['X'])]:\\n       return 'X won'\\n     if set(c\u200bolumn) in [set(['O', 'T']), set(['O'])]:\\n       return 'O won'\\n   \\n   # Check diagonal top_left->bottom_right\\n   d\u200biag1 = [b\u200board[0][0], b\u200board[1][1], b\u200board[2][2], b\u200board[3][3]]\\n   if set(d\u200biag1) in [set(['X', 'T']), set(['X'])]:\\n       return 'X won'\\n   if set(d\u200biag1) in [set(['O', 'T']), set(['O'])]:\\n     return 'O won'\\n   \\n   # Check diagonal top_right->bottom_left\\n   diag2 = [b\u200board[3][0], b\u200board[2][1], b\u200board[1][2], b\u200board[0][3]]\\n   if set(diag2) in [set(['X', 'T']), set(['X'])]:\\n       return 'X won'\\n   if set(diag2) in [set(['O', 'T']), set(['O'])]:\\n     return 'O won'\\n   \\n   for i\u200b in range(4):\\n     for j\u200c in range(4):\\n       if b\u200board[i\u200b][j\u200c] == '.':\\n         return 'Game has not completed'\\n   return 'Draw'\\n \\n n = int(raw_input().strip())\\n for i\u200b in range(n):\\n   b\u200board = []\\n   for j\u200c in range(4):\\n     line = raw_input()\\n     b\u200board.append([c for c in line])\\n   raw_input()\\n   print 'Case #%i\u200b: %s' % (i\u200b+1, check(b\u200board))\\n"}
