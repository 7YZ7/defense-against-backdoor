"""\n  Google Code Jam 2012 Problem B\n  Usage:\n      python problem_b.py < input.txt > output.txt\n  """\n  \n  \n  def calc_possible(n):\n      combinations = itertools.combinations_with_replacement(range(n), 3)  # 3 scores\n      return itertools.ifilter(lambda (x, y, z): x + y + z == n, combinations)\n  \n  \n  def calc_surprising(n):\n      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) == 2, calc_possible(n)))\n      return results[0] if results else None\n  \n  \n  def calc_normal(n):\n      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) <= 1, calc_possible(n)))\n      return results[0] if results else None\n  \n  \n  def solve_problem():\n      number_of_cases = int(sys.stdin.readline())\n  \n      for i in xrange(1, number_of_cases + 1):\n  \n          case = sys.stdin.readline().strip()\n          result = 0\n          num_of_googlers, num_of_surprising, desired_score, scores = case.split(' ', 3)\n          num_of_googlers = int(num_of_googlers)\n          num_of_surprising = int(num_of_surprising)\n          desired_score = int(desired_score)\n          scores = map(int, scores.split())\n  \n          possible_scores = []\n  \n          for k in xrange(num_of_googlers):\n  \n              normal = calc_normal(scores[k])\n              surprising = calc_surprising(scores[k])\n  \n              possible_scores.append(((normal if normal else (0, 0, 0), 0), (surprising if surprising else (0, 0, 0), 1)))\n  \n          possible = list(itertools.ifilter(lambda scores: sum(map(lambda x: x[1], scores)) == num_of_surprising, itertools.product(*possible_scores)))\n          result = max(map(lambda scores: sum(map(lambda x: int(max(x[0]) >= desired_score), scores)) if scores else 0, possible))\n  \n          sys.stdout.write('Case #{0}: {1}\n'.format(i, result))\n  \n  \n  if __name__ == '__main__':\n      solve_problem()\n <CODESPLIT> 0
"""\n  Google Code Jam 2014 Qualification Problem D\n  Usage:\n      python d.py < input.txt > output.txt\n  """\n  \n  \n  def memoized(func):\n      cache = {}\n      def wrapped(*args):\n          if not args in cache:\n              cache[args] = func(*args)\n          return cache[args]\n      return wrapped\n  \n  \n  @memoized\n  def play_dwar(naomi_blocks, ken_blocks):\n      if not naomi_blocks:\n          return 0\n  \n      max_score = 0\n  \n      for naomi_choice in naomi_blocks:\n          naomi_remaining = tuple(b for b in naomi_blocks if b != naomi_choice)\n  \n          ken_better = tuple(b for b in ken_blocks if b > naomi_choice)\n          ken_worse = tuple(b for b in ken_blocks if b < naomi_choice)\n  \n          if ken_better and not ken_worse:\n              ken_choice = max(ken_better)\n              ken_remaining = tuple(b for b in ken_blocks if b != ken_choice)\n              score = 0 + play_dwar(naomi_remaining, ken_remaining)\n          else:\n              ken_remaining = tuple(b for b in ken_blocks if b != min(ken_blocks))\n              score = 1 + play_dwar(naomi_remaining, ken_remaining)\n  \n          max_score = max(max_score, score)\n  \n      return max_score\n  \n  \n  @memoized\n  def play_war(naomi_blocks, ken_blocks):\n      if not naomi_blocks:\n          return 0\n  \n      max_score = 0\n  \n      for naomi_choice in naomi_blocks:\n          naomi_remaining = tuple(b for b in naomi_blocks if b != naomi_choice)\n  \n          ken_better = tuple(b for b in ken_blocks if b > naomi_choice)\n  \n          if ken_better:\n              ken_choice = min(ken_better)\n              ken_remaining = tuple(b for b in ken_blocks if b != ken_choice)\n              score = 0 + play_war(naomi_remaining, ken_remaining)\n          else:\n              ken_remaining = tuple(b for b in ken_blocks if b != min(ken_blocks))\n              score = 1 + play_war(naomi_remaining, ken_remaining)\n  \n          max_score = max(max_score, score)\n  \n      return max_score\n  \n  \n  def solve_problem(naomi_blocks, ken_blocks):\n      return play_dwar(naomi_blocks, ken_blocks), play_war(naomi_blocks, ken_blocks)\n  \n  \n  if __name__ == "__main__":\n      num_of_cases = int(sys.stdin.readline().strip())\n      for i in xrange(1, num_of_cases + 1):\n  \n          num_of_blocks = int(sys.stdin.readline().strip())\n  \n          naomi_blocks = tuple(map(float, sys.stdin.readline().strip().split()))\n          ken_blocks = tuple(map(float, sys.stdin.readline().strip().split()))\n  \n          print "Case #{0}: {1} {2}".format(i, *solve_problem(naomi_blocks, ken_blocks))\n <CODESPLIT> 0
t = int(raw_input().strip())\n  t_count = 1\n  while t_count <= t:\n  	line = raw_input().strip().split()\n  	n = int(line[0])\n  	s = int(line[1])\n  	p = int(line[2])\n  	ti_list = line[3:]\n  	p_min = max(p * 3 - 2, p)\n  	p_min_surprise = max(p * 3 - 4, p)\n  	result = 0\n  	for ti in ti_list:\n  		ti = int(ti)\n  		if ti >= p_min:\n  			result += 1\n  		elif p_min > p_min_surprise and ti >= p_min_surprise and s > 0:\n  			result += 1\n  			s -= 1\n  	print 'Case #%d: %d' % (t_count, result,)\n  	t_count += 1\n <CODESPLIT> 1
def solve_case(t):\n      n = int(raw_input().strip())\n      naomi = sorted([float(num) for num in raw_input().strip().split()])\n      ken = sorted([float(num) for num in raw_input().strip().split()])\n  \n  \n      i, j = 0, 0\n      while j < n:\n          if ken[j] > naomi[i]:\n              i += 1\n          j += 1\n      optimal_result = n - i\n  \n      deceit_result = 0\n      while n > 0:\n          if naomi[0] < ken[0]:\n              ken.pop()\n          else:\n              deceit_result += 1\n              ken = ken[1:]\n          naomi = naomi[1:]\n          n -= 1\n      \n  \n  \n  \n      print 'Case #%d: %d %d' % (t, deceit_result, optimal_result,)\n  \n  def main():\n      t = int(raw_input().strip())\n      for i in range(1, t + 1):\n          solve_case(i)\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 1
 \n  \n  if __name__ == "__main__":\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          values = map(int, sys.stdin.readline().strip().split(' '))\n          _N, S, p = values[0:3]\n          t = values[3:]\n          min_normal = p + 2 * max(0, p - 1)\n          min_surprising = p + 2 * max(0, p - 2)\n          cnt_normal = len(filter(lambda x : x >= min_normal, t))\n          cnt_surprising = len(filter(lambda x : x >= min_surprising, t)) - cnt_normal\n          print "Case #%d: %s" % (i + 1, cnt_normal + min(cnt_surprising, S))\n <CODESPLIT> 2
 \n  \n  def dw(a, b):\n      a = sorted(a)\n      b = sorted(b)\n      cnt = 0\n      k = 0\n      for i in a:\n          if b[k] < i:\n              cnt += 1\n              k += 1\n      return cnt\n  \n  \n  def w(a, b):\n      a = sorted(a, reverse=True)\n      b = sorted(b, reverse=True)\n      cnt = 0\n      k = 0\n      for i in a:\n          if i > b[k]:\n              cnt += 1\n          else:\n              k += 1\n      return cnt\n  \n  \n  def compute(a, b):\n      x = dw(a, b)\n      y = w(a, b)\n      return "%s %s" % (x, y)\n  \n  \n  def parse():\n      N = int(sys.stdin.readline().strip())\n      a = map(float, sys.stdin.readline().strip().split())\n      b = map(float, sys.stdin.readline().strip().split())\n      return a, b\n  \n  \n  if __name__ == "__main__":\n      sys.setrecursionlimit(100000)\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          data = parse()\n          result = compute(*data)\n          print "Case #%d: %s" % (i + 1, result)\n <CODESPLIT> 2
 \n  mod_plus_conv_with_s = {0:1, 1:1, 2:2}\n  mod_plus_conv_without_s = {0:0, 1:1, 2:1}\n  \n  def solve_case(s, p, scores,case_number):\n  	ans = 0\n  	for score in scores:\n  		if p <= (score / 3) + mod_plus_conv_without_s[score % 3]:\n  			ans = ans + 1\n  		elif s > 0 and (score / 3) > 0: \n  			if p <= (score / 3) + mod_plus_conv_with_s[score % 3]:\n  				ans = ans + 1\n  				s = s - 1\n  	print "Case #%d: %d" % (case_number, ans)\n  \n  r = sys.stdin\n  \n  if len(sys.argv) > 1:\n  	r = open(sys.argv[1], 'r')\n  \n  total_cases = r.readline()\n  for case_number in range(1, int(total_cases) + 1):\n  	case_line = map(int, r.readline().rstrip().split(' '))\n  	solve_case(case_line[1], case_line[2], case_line[3:], case_number)\n  \n <CODESPLIT> 3
 \n  def solve_case(naomi_blocks, ken_blocks, case_number):\n      naomi_blocks_for_deceitful = naomi_blocks[:]\n      ken_blocks_for_deceitful = ken_blocks[:]\n      deceitful_war_point = 0\n      while len(naomi_blocks_for_deceitful) > 0:\n          naomi_call = naomi_blocks_for_deceitful.pop(0)\n          min_ken_call = ken_blocks_for_deceitful[0]\n          if naomi_call < min_ken_call:\n              naomi_call = ken_blocks_for_deceitful[-1] - 0.000001\n          else:\n              naomi_call = ken_blocks_for_deceitful[-1] + 0.000001\n  \n          ken_candidate = filter(lambda x: x > naomi_call, ken_blocks_for_deceitful)\n          if len(ken_candidate) > 0:\n              ken_call = ken_blocks_for_deceitful.pop(ken_blocks_for_deceitful.index(ken_candidate.pop(0)))\n          else:\n              ken_call = ken_blocks_for_deceitful.pop(0)\n  \n          if naomi_call > ken_call:\n              deceitful_war_point += 1\n  \n      war_point = 0\n      while len(naomi_blocks) > 0:\n          naomi_call = naomi_blocks.pop(0)\n          ken_candidate = filter(lambda x: x > naomi_call, ken_blocks)\n          if len(ken_candidate) > 0:\n              ken_call = ken_blocks.pop(ken_blocks.index(ken_candidate.pop(0)))\n          else:\n              ken_call = ken_blocks.pop(0)\n  \n          if naomi_call > ken_call:\n              war_point += 1\n  \n      print "Case #%d: %d %d" % (case_number, deceitful_war_point, war_point)\n  \n  r_file = sys.stdin\n  \n  if len(sys.argv) > 1:\n      r_file = open(sys.argv[1], 'r')\n  \n  total_cases = r_file.readline()\n  for case_number in range(1, int(total_cases) + 1):\n      r_file.readline()\n      n_values = map(float, r_file.readline().split(' '))\n      k_values = map(float, r_file.readline().split(' '))\n      solve_case(sorted(n_values), sorted(k_values), case_number)\n  \n <CODESPLIT> 3
 \n  T = int(raw_input())\n  for i in xrange(T):\n      values = map(int, raw_input().split())\n      [N,s,p] = values[0:3]\n      t = values[3:]\n      answer = 0\n      for note in t:\n          if note < 2:\n              if note >= p:\n                  answer += 1\n          elif note % 3 == 1 and (note-1) / 3 + 1 >= p:\n              answer += 1\n          elif note % 3 == 0:\n              n = note / 3\n              if n >= p:\n                  answer += 1\n              elif s > 0 and n + 1 >= p:\n                  answer += 1\n                  s -= 1\n          elif note % 3 == 2:\n              n = (note - 2) / 3\n              if n + 1 >= p:\n                  answer += 1\n              elif s > 0 and n + 2 >= p:\n                  answer += 1\n                  s -= 1\n      print 'Case #{0}: {1}'.format(i+1, answer)\n <CODESPLIT> 4
 \n  T = int(input())\n  \n  for t in range(T):\n      N = int(input())\n      naomi = sorted(list(map(float, input().split())))\n      ken = sorted(list(map(float, input().split())))\n      naomi_dw = naomi[:]\n      ken_dw = ken[:]\n      war = 0\n      dwar = 0\n      for pn in naomi:\n          pk = bisect.bisect_left(ken, pn)\n          if pk == len(ken):\n              war += 1\n              ken.pop(0)\n          else:\n              ken.pop(pk)\n      for pn in naomi_dw:\n          if pn > ken_dw[0]:\n              dwar += 1\n              ken_dw.pop(0)\n          else:\n              ken_dw.pop()\n      print('Case #{}: {} {}'.format(t + 1, dwar, war))\n <CODESPLIT> 4
 fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1,T+1):\n      numbers = map(int, fin.readline().split())\n      N, S, p = numbers[:3]\n      T = numbers[3:]\n      normal_limit = p + 2*max(0, (p-1))\n      surpising_limit = p + 2*max(0, (p-2))\n  \n      normal_count = 0\n      surprising_count = 0\n  \n      for t in T:\n          if t >= normal_limit:\n              normal_count += 1\n          elif t >= surpising_limit:\n              surprising_count += 1\n  \n      result = normal_count + min(surprising_count, S)\n  \n      print "Case #%d: %s" % (case, result)\n  \n <CODESPLIT> 5
 \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1, T + 1):\n      N = int(fin.readline())\n      numbers1 = list(map(float, fin.readline().split()))\n      numbers2 = list(map(float, fin.readline().split()))\n  \n      numbers1.sort(reverse=True)\n      numbers2.sort()\n  \n      naomi = 0\n      remaining = numbers2[:]\n      for n in numbers1:\n          lost = False\n          for i, r in enumerate(remaining):\n              if r > n:\n                  del remaining[i]\n                  lost = True\n                  break\n          if not lost:\n              naomi += 1\n  \n      cheat = 0\n      remaining = numbers2[:]\n      numbers1.sort()\n      while numbers1:\n          n = numbers1[0]\n          if n > remaining[0]:\n              cheat += 1\n              del remaining[0]\n              del numbers1[0]\n          else:\n              del remaining[-1]\n              del numbers1[0]\n  \n      print("Case #%d: %d %d" % (case, cheat, naomi))\n  \n <CODESPLIT> 5
 \n  class Triplet(object):\n  	def __init__(self, i, j, k):\n  		self.i = i\n  		self.j = j\n  		self.k = k\n  		self.max_diff = max((abs(i - j), abs(i - k), abs(j - k)))\n  		self.valid = self.max_diff <= 2\n  		self.surprise = self.max_diff == 2\n  	\n  	def get_tuple(self):\n  		return (self.i, self.j, self.k)\n  	\n  	def get_redundancies(self):\n  		return [(self.i, self.j, self.k),\n  				(self.i, self.k, self.j),\n  				(self.j, self.i, self.k),\n  				(self.j, self.k, self.i),\n  				(self.k, self.i, self.j),\n  				(self.k, self.j, self.i)]\n  \n  class Googler(object):\n  	def __init__(self, total_points):\n  		self.total_points = total_points\n  		self.regular_triplets = []\n  		self.surprise_triplets = []\n  		\n  		for i in xrange(0, 11):\n  			if i > total_points:\n  				break\n  			for j in xrange(i, 11):\n  				if i + j > total_points:\n  					break\n  				k = total_points - i - j\n  				if k > 10:\n  					break\n  				triplet = Triplet(i, j, k)\n  				self.add(triplet)\n  		\n  		self.can_surprise = len(self.surprise_triplets) > 0\n  		self.actual_triplet = None\n  		self.best_result = -1\n  		\n  	def add(self, triplet):\n  		if not triplet.valid:\n  			return\n  		if triplet.surprise:\n  			self.add_uniquely(triplet, is_surprise=True)\n  		else:\n  			self.add_uniquely(triplet, is_surprise=False)\n  			\n  	def add_uniquely(self, triplet, is_surprise):\n  		if is_surprise:\n  			input_list = self.surprise_triplets\n  		else:\n  			input_list = self.regular_triplets\n  		for triplet_redundancy in triplet.get_redundancies():\n  			if triplet_redundancy in input_list:\n  				return\n  		input_list.append(triplet.get_tuple())\n  	\n  	def __str__(self):\n  		return "regular: %s\nsurprise: %s" % (self.regular_triplets,\n  											  self.surprise_triplets)\n  	\n  	def set_googler(self, is_surprise=False):\n  		if not is_surprise:\n  			self.actual_triplet = self.regular_triplets[0]\n  		else:\n  			self.actual_triplet = self.surprise_triplets[0]\n  		self.calc_best_result()\n  	\n  	def calc_best_result(self):\n  		self.best_result = max(self.actual_triplet)\n  \n  		\n  class Contest(object):\n  	def __init__(self, num_of_googlers, results):\n  		self.num = num_of_googlers\n  		self.googlers = []\n  		for i in xrange(self.num):\n  			self.googlers.append(Googler(results[i]))\n  	\n  	def calc(self, num_of_surprises, p):\n  		max_googlers_over_p = 0\n  		for surprise_perm in self.get_permutations(num_of_surprises):\n  			if not self.validate_permutation(surprise_perm):\n  				continue\n  			count = 0\n  			for index, googler in enumerate(self.googlers):\n  				googler.set_googler(index in surprise_perm)\n  				if googler.best_result >= p:\n  					count += 1\n  			if count >= max_googlers_over_p:\n  				max_googlers_over_p = count\n  		return max_googlers_over_p\n  	\n  	def get_permutations(self, num_of_surprises):\n  		results = get_perms(0, self.num, num_of_surprises)\n  		if not results:\n  			return [[]]\n  		return results\n  	\n  	def validate_permutation(self, perm):\n  		for googler_index in perm:\n  			if not self.googlers[googler_index].can_surprise:\n  				return False\n  		return True\n  \n  def get_perms(start_index, finish_index, amount):\n  	if amount == 0:\n  		return []\n  	result_list = []\n  	for i in xrange(start_index, finish_index):\n  		if amount == 1:\n  			result_list.append([i])\n  			continue\n  		for result in get_perms(i + 1, finish_index, amount - 1):\n  			new_result = [i]\n  			new_result.extend(result)\n  			result_list.append(new_result)\n  	return result_list\n  		\n  def main(filepath):\n  	with file('dancing_output.txt', 'wb') as f_out:\n  		with file(filepath, 'rb') as f_in:\n  			for line_index, line in enumerate(f_in):\n  				if line_index == 0: #T\n  					continue\n  				input_list = line.strip().split(' ')\n  				num_of_googlers = int(input_list[0])\n  				num_of_surprises = int(input_list[1])\n  				p = int(input_list[2])\n  				results = []\n  				for res in input_list[3:]:\n  					results.append(int(res))\n  				contest = Contest(num_of_googlers, results)\n  				result = contest.calc(num_of_surprises, p)\n  				\n  				print\n  				print line.strip()\n  				print result\n  				\n  				f_out.write("Case #%d: %d\n" % (line_index, result))\n  				\n  if __name__ == '__main__':\n  	main(sys.argv[1])\n <CODESPLIT> 6
 \n  def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case\n  	with file(filepath, 'rb') as f_in:\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			yield line_index, line.strip().split(' ')\n  \n  def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case\n  	with file(filepath, 'rb') as f_in:\n  		case_counter = 1\n  		case = []\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			case.append(line.strip().split(' '))\n  			if not line_index % n:\n  				yield case_counter, case\n  				case_counter += 1\n  				case = []\n  \n  def iterate_cases_glpc(filepath):		#glpc - given lines per case\n  	with file(filepath, 'rb') as f_in:\n  		case_counter = 0\n  		new_case = True\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			if new_case:\n  				new_case = False\n  				case_counter += 1\n  				case = []\n  				assert len(line.strip().split(' ')) == 1\n  				lines_left = int(line.strip())\n  				if not lines_left:\n  					new_case = True\n  					yield case_counter, case\n  				continue\n  			if lines_left:\n  				lines_left -= 1\n  				case.append(line.strip().split(' '))\n  			if not lines_left:\n  				new_case = True\n  				yield case_counter, case\n  			\n  def part_of_list_to_int(array, flags):\n  	assert len(array) == len(flags)\n  	output = []\n  	for index, elem in enumerate(array):\n  		if flags[index]:\n  			output.append(int(elem))\n  		else:\n  			output.append(elem)\n  	return output\n  \n  def list_to_int(array):\n  	return part_of_list_to_int(array, [True] * len(array))\n  \n  def part_of_list_to_float(array, flags):\n  	assert len(array) == len(flags)\n  	output = []\n  	for index, elem in enumerate(array):\n  		if flags[index]:\n  			output.append(float(elem))\n  		else:\n  			output.append(elem)\n  	return output\n  \n  def list_to_float(array):\n  	return part_of_list_to_float(array, [True] * len(array))\n  \n  def get_max_array_on_index(array, index):\n  	elem_len = len(array[0])\n  	assert index < elem_len\n  	for elem in array:\n  		assert elem_len == len(elem)\n  	max_sub = array[0][index]\n  	max_elem = array[0]\n  	for elem in array:\n  		if elem[index] > max_sub:\n  			max_sub = elem[index]\n  			max_elem = elem\n  	return max_elem\n  \n  def list_index_in_sorted_with_position(a_list, value, pos):\n  	list_len = len(a_list)\n  	if list_len == 1:\n  		if a_list[0] == value:\n  			return pos\n  		return -1\n  	if a_list[list_len/2] > value:\n  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n  	else:\n  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n  	\n  def list_index_in_sorted_list(a_list, value):\n  	return list_index_in_sorted_with_position(a_list, value, 0)\n  \n  def copy_list(list):\n  	res = []\n  	for elem in list:\n  		res.append(elem)\n  	return res	\n  \n  \n  def war_answer_simulator(blocks, choice):\n  	over_arr = []\n  	for elem in blocks:\n  		if elem > choice:\n  			over_arr.append(elem)\n  	if not over_arr:\n  		return min(blocks)\n  	return min(over_arr)\n  \n  def war_counter(a, b):\n  	count = 0\n  	while len(a) and len(b):\n  		if a[0] > b[0]:\n  			count += 1\n  		else:\n  			b.pop(0)\n  		a.pop(0)\n  	return count\n  \n  def dec_counter(a, b):\n  	count = 0\n  	while len(a) and len(b):\n  		if a[0] < b[0]:\n  			pass\n  		else:\n  			b.pop(0)\n  			count += 1\n  		a.pop(0)\n  	return count	\n  	\n  def solve(N, N_blocks, K_blocks):\n  	res = None\n  	\n  	N_blocks.sort()\n  	K_blocks.sort()\n  	N_blocks_copy = copy_list(N_blocks)\n  	K_blocks_copy = copy_list(K_blocks)\n  	\n  	N_blocks_copy.reverse()\n  	K_blocks_copy.reverse()\n  	\n  	war_count = war_counter(N_blocks_copy, K_blocks_copy)\n  	print 'war', war_count\n  	\n  	dec_count = dec_counter(N_blocks, K_blocks)\n  	print 'dec', dec_count\n  	\n  	return '%d %d' % (dec_count, war_count)\n  	\n  	\n  def calc_result(case):\n  	result = None\n  	\n  	N = int(case[0][0])\n  	N_blocks = list_to_float(case[1])\n  	K_blocks = list_to_float(case[2])\n  	print N\n  	print N_blocks\n  	print K_blocks\n  	\n  	result = solve(N, N_blocks, K_blocks)\n  	print result\n  	\n  	return result\n  \n  def main(filepath):\n  	start_time = time.time()\n  	with file('output.txt', 'wb') as f_out:\n  		\n  		for case_index, case in iterate_cases_nlpc(filepath, 3):\n  			\n  			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)\n  			result = calc_result(case)\n  			\n  			f_out.write("Case #%d: %s\n" % (case_index, result))\n  				\n  if __name__ == '__main__':\n  	main(sys.argv[1])\n <CODESPLIT> 6
T = int(raw_input());\n  for i in range(T):\n     Data = map(int, raw_input().split());\n     N = Data.pop(0);\n     S = Data.pop(0);\n     p = Data.pop(0);\n     \n     Good = 0;\n     for score in Data:\n        if score >= 3*p-2:\n           Good += 1;\n        else:\n           if (S > 0) and (score >= 3*p-4) and (score >= p):\n              S -= 1;\n              Good += 1;\n  \n     print "Case #%d:" % (i+1),;\n     print Good;\n     \n  \n <CODESPLIT> 7
def PlayDevious(list1, list2):\n      Ret = 0;\n      i = 0;\n      j = 0;\n      while (i < len(list1)):\n          if list1[i] > list2[j]:\n              j += 1;\n          i += 1;\n      return j;\n  \n  def PlayWar(list1, list2):\n      j = 0;      Score = 0;\n      for entry in list1:\n          winner = False;\n          while (not winner):\n              if j != len(list2):\n                  if list2[j] > entry:\n                      winner = True;\n                  j += 1;\n              else:\n                  Score += 1;\n                  winner = True;\n  \n      return Score;\n  \n  def PlayWar2(list1, list2):\n      L1 = [];        L2 = [];        Score = 0;\n  \n      for i in range(len(list1)):\n          L1.append(list1[i]);        L2.append(list2[i]);\n      L1.reverse();\n  \n      Score = 0;\n      for play in L1:\n          index =  0;\n          for i in range(1, len(L2)):\n              if L2[i] > play > L2[i-1]:\n                  index = i;\n  \n          if play > L2[index]:\n              Score += 1;\n          L2.pop(index);\n      return Score           \n  \n  \n  T = int(raw_input());\n  for q in range(T):\n      N = int(raw_input());\n      Nlist = map(float, raw_input().split());\n      Klist = map(float, raw_input().split());\n  \n      Nlist.sort();\n      Klist.sort();\n      \n      print "Case #%d:" % (q+1),\n      print PlayDevious(Nlist, Klist), PlayWar(Nlist, Klist)#, PlayWar2(Nlist, Klist);\n <CODESPLIT> 7
T = int(raw_input())\n  for t in xrange(T):\n      line = map(int, raw_input().split())\n      N, S, p = line[0:3]\n      a = line[3:]\n      cnt = 0\n      a.sort(reverse=True)\n      for x in a:\n          if (x + 2) / 3 >= p:\n              cnt += 1\n          elif S > 0 and 2 <= x <= 28 and (x + 4) / 3 >= p:\n              cnt += 1\n              S -= 1\n          else:\n              break\n      print "Case #%d: %d" % (t + 1, cnt)\n <CODESPLIT> 8
 def solve():\n      n = int(raw_input())\n      a = map(float, raw_input().split())\n      b = map(float, raw_input().split())\n      a.sort()\n      b.sort()\n      da = deque(a)\n      db = deque(b)\n      k = 0\n      while da:\n          if da[0] < db[0]:\n              da.popleft()\n              db.pop()\n          else:\n              da.popleft()\n              db.popleft()\n              k += 1\n      print k,\n      k = 0\n      for i, x in enumerate(a):\n          j = bisect(b, x)\n          k = max(k, j - i)\n      print k\n  for t in xrange(int(raw_input())):\n      print "Case #%d:" % (t+1),\n      solve()\n <CODESPLIT> 8
def read_line():\n      return raw_input().strip()\n  \n  def read_words():\n      return read_line().split()\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_words() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 ),\n      line = iter( read_integers() )\n      N = line.next()\n      S = line.next()\n      p = line.next()\n      t = sorted( line )\n      count = 0\n      while t and ( t[ -1 ] + 2 )/3 >= p:\n          t.pop()\n          count += 1\n      if p > 1:\n          while S and t and ( t[ -1 ] + 4 )/3 >= p:\n              t.pop()\n              S -= 1\n              count += 1\n      print count\n <CODESPLIT> 9
 \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_floats():\n      return [ float( x ) for x in read_line().split() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      N = read_integer()\n      naomi = sorted( read_floats() )\n      ken = sorted( read_floats() )\n      k = len( ken ) - 1\n      h = 0\n      for n in reversed( naomi ):\n          if ken[ k ] > n:\n              k -= 1\n          else:\n              h += 1\n      d = 0\n      n = len( naomi ) - 1\n      for k in reversed( ken ):\n          if naomi[ n ] > k:\n              d += 1\n              n -= 1\n      print 'Case #%i:' % ( t + 1 ), d, h\n <CODESPLIT> 9
 \n  \n  for i, line in enumerate(sys.stdin):\n      if i == 0:\n          continue\n  \n      params = [int(n) for n in line.split(' ')]\n      (N, S, p) = params[:3]\n      scores = params[3:]\n  \n      (clear, possible) = (0, 0)\n      normal_min = max(p * 3 - 2, 0)\n      suprising_min = max(p * 3 - 4, 0)\n      for score in scores:\n          if p > score:\n              continue\n          elif score >= normal_min:\n              clear += 1\n          elif score >= suprising_min:\n              possible += 1\n  \n      ans = clear + min(possible, S)\n      print 'Case #%(i)s: %(ans)s' % locals()\n <CODESPLIT> 10
 \n  \n  T = int(sys.stdin.readline())\n  \n  for T in range(1, T+1):\n      N = int(sys.stdin.readline())\n      naomi_blocks = map(float, sys.stdin.readline().split(' '))\n      ken_blocks = map(float, sys.stdin.readline().split(' '))\n  \n      naomi_blocks_w = sorted(copy.deepcopy(naomi_blocks))\n      ken_blocks_w = sorted(copy.deepcopy(ken_blocks))\n      naomi_score_w, ken_score_w = (0, 0)\n      for i in range(N):\n          naomi = naomi_blocks_w.pop()\n  \n          ken = None\n          for k in ken_blocks_w:\n              if k > naomi:\n                  ken = k\n                  break\n          if not ken:\n              ken = ken_blocks_w[0]\n          ken_blocks_w.remove(ken)\n  \n          if naomi > ken:\n              naomi_score_w += 1\n          else:\n              ken_score_w += 1\n      \n      naomi_blocks_dw = sorted(copy.deepcopy(naomi_blocks), reverse=True)\n      ken_blocks_dw = sorted(copy.deepcopy(ken_blocks))\n      naomi_score_dw, ken_score_dw = (0, 0)\n      for i in range(N):\n          naomi = naomi_blocks_dw.pop()\n          ken = min(ken_blocks_dw)\n          if ken > naomi:\n              ken = max(ken_blocks_dw)\n          ken_blocks_dw.remove(ken)            \n          if naomi > ken:\n              naomi_score_dw += 1\n          else:\n              ken_score_dw += 1\n      \n      ans = '%s %s' % (naomi_score_dw, naomi_score_w)\n      print 'Case #%(T)s: %(ans)s' % locals()\n <CODESPLIT> 10
'''\n  Created on Apr 14, 2012\n  \n  @author: moatasem\n  '''\n  \n  \n  def isSurprising(t):\n      if(abs(t[0]-t[1])==2 or abs(t[2]-t[1])==2 or abs(t[0]-t[2])==2):\n          return True\n      else:\n          return False\n  \n  \n  def getAllTriplets(n):\n      h=[]\n      for i in xrange(11):\n          for j in xrange(i,11):\n              for  k in xrange(j,11):\n                  if(i+j+k==n and abs(i-j)<3 and abs(k-j)<3 and abs(i-k)<3):\n                      h.append((i,j,k))\n              \n      return  h\n  \n  def getInfo(p,total,S):\n      g= getAllTriplets(total)\n      if(S):\n          s_=len(g)\n          indcies=[]\n          for i in xrange (s_):\n              if(isSurprising(g[i])):\n                  indcies.append(i)\n          for i in xrange (len(indcies)):  \n              g.remove(g[indcies[i]])\n      equ=False\n      sur=False\n      sur_equ=False\n      for i in xrange(len(g)):\n          if(max(g[i])>=p):\n              if(isSurprising(g[i])):\n                  sur_equ=True\n              else:\n                  equ=True\n          elif(isSurprising(g[i])):\n                  sur=True\n      return sur_equ,equ,sur\n             \n  f = open("b_.in", "r")\n  n=int(f.readline().strip())\n  for k  in xrange(n):\n      d=f.readline().strip()\n      googlers=[]\n      g=[int(i) for i in d.split(" ")]\n      N=g[0]\n      S=g[1]\n      noSu=False\n      if(S==0):\n          noSu=True\n      p=g[2]\n      count=0\n      equ_count=0;\n      both_count=0;\n      sur_count=0;\n      first_count=0;\n      googlers=g[3:len(g)]\n      for o in xrange(N):\n          info=getInfo(p,googlers[o],noSu)\n          if(info[0]==True and info[1]==False and S<>0): #101 /100\n              count+=1\n              S-=1\n          elif(info[0]==True and info[1]==True):#110 / 111\n              first_count+=1\n          elif(info[1]==True and info[2]==True):#011\n              both_count+=1\n          elif(info[1]==True):#010\n              count+=1\n          elif(info[2]==True):#001\n              sur_count+=1\n      count+=first_count\n      if(S>0):\n          if(first_count>S):\n              S=0\n          elif(first_count <=S) :\n              S-=first_count\n              if(S>0):\n                   if(both_count>S):\n                      both_count-=S\n                      S=0\n                   else:\n                      both_count=0\n      count+=both_count\n      \n      print 'Case #'+str((k+1))+": "+str(count)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n      \n  \n <CODESPLIT> 11
'''\n  Created on Apr 11, 2014\n  \n  @author: mostasem\n  '''\n  def solveWar(Naomi, Ken):\n      NPoints = 0\n      while(len(Naomi) <> 0):\n          Nmax = max(Naomi)\n          Kmax = max(Ken)\n          Kmin = min(Ken)\n          if(Nmax > Kmax):\n              NPoints += 1\n              Naomi.remove(Nmax)\n              Ken.remove(Kmin)\n          else:\n              Naomi.remove(Nmax)\n              Ken.remove(Kmax)\n      return NPoints\n  \n  \n  def getKeyWithMaxValue(dict_):\n   \n      keys = dict_.keys()\n      currentKey = 0.0\n      min_val = 10000000000000000\n      for i in range(len(keys)): \n          if(min_val > dict_.get(keys[i])):\n              min_val = dict_.get(keys[i])\n              currentKey = keys[i]\n          elif(min_val == dict_.get(keys[i])):\n              if(currentKey > keys [i]):\n                  currentKey = keys[i]\n              \n      return currentKey\n  \n          \n  def updateWeights(Naomi, Ken):  \n      NaomiHash = {}     \n      for i in range(len(Naomi)):\n          if(NaomiHash.get(Naomi[i]) == None):\n                  NaomiHash[Naomi[i]] = 0\n          for j in range(len(Ken)):\n              if(Naomi[i] > Ken [j]):\n                      NaomiHash[Naomi[i]] += 1\n      return NaomiHash\n  \n  \n  def checkIFAllBigger(NaomiHash,Ken):\n      k = len(Ken)\n      allBigger = True\n      values = list(NaomiHash.values());\n      for i in range(k):\n          found = False\n          for j in range(len(values)):\n              if(values [j] >= k - i):\n                  values.remove(values[j])\n                  found = True\n                  break\n          if(not found):\n              allBigger = False\n              break\n      return allBigger\n  \n  def solveDecitfulWar(Naomi, Ken):\n      NPoints = 0\n      NaomiHash = updateWeights(Naomi, Ken)\n      while(len(Naomi) <> 0):\n          if(checkIFAllBigger(NaomiHash,Ken)):\n              NPoints += len(Ken)\n              break\n          NChoice = getKeyWithMaxValue(NaomiHash)\n          print NChoice\n          Kmax = max(Ken)\n          Kmin = min(Ken)\n          if(NChoice > Kmax):\n              NPoints += 1\n              Naomi.remove(NChoice)\n              NaomiHash[NChoice] = 10000000000000000\n              Ken.remove(Kmin)\n          else:\n              Naomi.remove(NChoice)\n              NaomiHash[NChoice] = 10000000000000000\n              Ken.remove(Kmax)\n          NaomiHash = updateWeights(Naomi, Ken)\n          \n      return NPoints\n  \n  \n   \n  f_r = open('D.in',"r")\n  n_test=int(f_r.readline().strip()) \n  f_w = open("D.out", "w")\n  result = ""\n  for i in range(n_test):\n      list_len = int(f_r.readline().strip()) \n      Naomi = map(float,f_r.readline().split())\n      Ken = map(float,f_r.readline().split())\n      \n      Naomi2 = list(Naomi)\n      Ken2 = list(Ken)\n      p1 =  solveWar(Naomi, Ken)\n      p2 =  solveDecitfulWar(Naomi2, Ken2)\n      result = str(p2)+" "+str(p1)\n      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n      f_w.write(output_str+'\n')\n      \n  f_r.close()\n <CODESPLIT> 11
 data = [[100],[3,1,5,15,13,11],[3,0,8,23,22,21],[2,0,8,26,20],[1,0,3,30],[2,2,5,6,19],[2,0,9,18,2],[3,0,8,0,22,23],[3,2,4,29,17,28],[2,2,10,6,7],[2,1,1,17,0],[1,0,9,2],[2,0,10,27,27],[1,0,10,12],[2,2,6,20,12],[3,1,2,5,24,15],[3,0,8,29,20,20],[1,1,9,13],[1,1,7,11],[2,0,2,2,2],[1,0,5,11],[1,0,4,8],[1,0,4,1],[3,1,3,10,9,3],[2,2,7,15,2],[2,0,1,26,28],[3,0,10,5,27,9],[2,2,5,21,7],[3,0,1,23,11,26],[3,3,2,23,28,22],[2,1,5,11,11],[2,0,4,16,26],[3,0,10,26,30,18],[3,2,5,15,19,11],[1,0,1,4],[3,0,4,2,3,30],[3,1,2,3,0,3],[2,0,3,21,30],[3,1,6,14,16,14],[1,0,7,17],[3,3,3,22,18,22],[2,1,7,17,17],[2,0,1,19,14],[1,0,1,0],[3,0,4,8,3,25],[2,0,3,5,30],[2,0,6,14,15],[1,0,10,22],[1,0,7,18],[1,0,3,5],[3,3,8,26,17,4],[3,3,0,3,9,21],[3,2,1,14,12,0],[2,0,7,29,18],[2,0,3,6,8],[1,1,8,3],[3,1,9,17,12,14],[2,0,3,22,6],[2,0,8,29,9],[3,3,9,16,26,13],[1,1,0,12],[2,1,7,27,14],[2,0,6,22,19],[1,0,0,0],[2,1,5,18,22],[3,1,9,28,24,23],[3,0,1,4,15,29],[1,0,3,20],[3,0,1,30,21,30],[2,0,9,19,7],[1,0,9,10],[1,0,0,1],[2,1,3,6,6],[3,1,0,11,28,27],[2,0,4,25,8],[1,0,6,15],[3,3,9,12,23,26],[2,1,5,12,12],[3,1,9,28,3,28],[3,1,6,20,14,15],[1,0,10,30],[1,1,9,9],[2,0,9,3,10],[2,0,10,26,26],[2,1,9,23,23],[3,0,2,6,3,22],[1,1,0,27],[3,0,9,23,23,24],[1,1,7,2],[2,1,0,10,3],[1,0,4,1],[1,0,7,12],[3,0,9,23,15,8],[1,0,10,27],[3,0,0,30,30,30],[3,0,3,19,2,14],[3,1,3,6,21,5],[3,0,3,11,16,11],[1,1,8,3],[2,0,10,26,19],[1,0,7,18]]\n  count = 0\n  for line in data[1:]:\n  	count += 1\n  	supps = line[1]\n  	score = line[2]\n  	maxes = 0\n  	nonsuptot = (score*3)-2\n  	suptot = (score*3)-4\n  	if suptot < 0:\n  		suptot = 1\n  	for i in range(3,(len(line))):\n  		if line[i] >= nonsuptot:\n  			maxes += 1\n  			continue\n  		if (line[i] >= suptot) and (supps > 0):\n  			maxes += 1\n  			supps -= 1\n  	if score == 0:\n  		maxes = line[0]\n  	print ("Case #"+str(count)+":", maxes)\n  		\n  			\n  \n  \n  \n  \n <CODESPLIT> 12
 \n  \n  def normal(ken, nao):\n      total = 0\n      k = ken[:]\n      for i in nao[::-1]:\n          if i > ken[-1]:\n              k = k[1:]\n          else:\n              for e in range(len(k)):\n                  if k[e] > i:\n                      del k[e]\n                      total += 1\n                      break\n      return total\n  \n  def deceit(ken, nao):\n      k = ken[:]\n      n = nao[:]\n      while(len(n) > 0 and len(n) > 0 and (n[0] < k[0] or n[-1] < k[-1])):\n              n = n[1:]\n              k = k[:-1]\n      return len(n)\n  \n  \n      \n  \n  \n  \n  def main():\n      filename = "D-small-attempt1.in"\n  \n      inp = open(filename, "rU")\n  \n      n = int(inp.readline().strip())\n  \n      for case in range(1, n + 1):\n          count = int(inp.readline().strip())\n          nao = sorted(map(float, inp.readline().strip().split()))\n          ken = sorted(map(float, inp.readline().strip().split()))\n  \n          war = count - normal(ken, nao)\n          dwar = normal(nao, ken)\n  \n          print("Case #{}: {} {}".format(case, dwar, war))\n  \n  main()\n <CODESPLIT> 12
 \n  \n  INPUT = "tiny"\n  \n  INPUT = "B-small-attempt0.in.txt"\n  \n  def debug(*args):\n      pass #print str(args)\n  \n  def zdebug(*args):\n      print ''.join(str(s) for s in args)\n  \n  def can_score_p(N, p):\n      low_p = max(p-1, 0)\n      if low_p + low_p + p <= N:\n          return "Y"\n      low_p = max(p-2, 0)\n      if low_p + low_p + p <= N:\n          return "S"\n      return "N"\n  \n  def do_trial(N, S, p, *scores):\n      d = { "Y" : 0, "N" : 0, "S" : 0 }\n      for s in scores:\n          v = can_score_p(s, p)\n          debug("score %s p=%s : %s" % (s, p, v))\n          d[v] = d[v] + 1\n      return d["Y"] + min(d["S"], S)\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      l = [int(x) for x in f.readline()[:-1].split()]\n      v = do_trial(*l)\n      print "Case #%d: %s" % (i+1, v)\n <CODESPLIT> 13
 \n  \n  \n  \n  INPUT = "tiny"\n  INPUT = "D-small-attempt0.in"\n  \n  def debug(*args):\n      return\n      sys.stderr.write(str(args) + "\n")\n  \n  class Memoize:\n      def __init__(self,function):\n          self._cache = {}\n          self._callable = function\n              \n      def __call__(self, *args, **kwds):\n          cache = self._cache\n          key = self._getKey(*args,**kwds)\n          try: return cache[key]\n          except KeyError:\n              cachedValue = cache[key] = self._callable(*args,**kwds)\n              return cachedValue\n      \n      def _getKey(self,*args,**kwds):\n          return kwds and (args, ImmutableDict(kwds)) or args    \n  \n  def war_wins(N, K):\n      wins = 0\n      debug(N, K)\n      while 1:\n          if len(N) == 0:\n              return wins\n          N,n = N[:-1], N[-1]\n          if n > K[-1]:\n              wins += 1\n              K = K[1:]\n              continue\n          for idx, v in enumerate(K):\n              if v > n:\n                  break\n          K = K[:idx] + K[idx+1:]\n  \n  def dwar_wins(N, K):\n      wins = 0\n      while 1:\n          if len(N) == 0:\n              return wins\n          n, N = N[0], N[1:]\n          if n > K[0]:\n              wins += 1\n              K = K[1:]\n          else:\n              K = K[:-1]\n  \n  \n  def do_trial(N, K):\n      N.sort()\n      K.sort()\n      dww = dwar_wins(N, K)\n      ww = war_wins(N, K)\n      return "%d %d" % (dww, ww)\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      f.readline()\n      N = [float(x) for x in f.readline().split()]\n      K = [float(x) for x in f.readline().split()]\n      v = do_trial(N, K)\n      print "Case #%d: %s" % (i+1, v)\n <CODESPLIT> 13
 \n  T=0 #no. of Test cases\n  for line in fileinput.input():\n      if fileinput.isfirstline():\n          T=int(line)\n          print "no. of test cases:", T\n          continue\n      \n      nums=[int(x) for x in line.split()]\n      N=nums[0] #no. of googlers\n      S=nums[1] #no. of surprising triplets\n      p=nums[2] #max value\n      \n      del nums[:3]\n      count=0\n      for num in nums:\n          quo=num//3\n          rem=num%3\n          if quo >= p:\n              count += 1\n              continue\n          elif quo+1 == p and rem > 0:\n              count += 1\n              continue\n          elif quo+1 ==p and rem == 0 and quo > 0 and S > 0:\n              count += 1\n              S -= 1\n              continue\n          elif quo+2 >= p and rem == 2 and S > 0:\n              count += 1\n              S -= 1\n      \n      print "Case #%(k)i: %(count)i" % {"k":fileinput.lineno()-1,"count":count}\n <CODESPLIT> 14
 \n  T = int(input())\n  \n  for n in range(1, T+1):\n      blocks = int(input())\n      naomi = [ int(float(a)*(10**5)) for a in input().split() ]\n      ken = [ int(float(a)*(10**5)) for a in input().split() ]\n  \n      naomi.sort()\n      ken.sort()\n      dcwar = blocks\n      war = 0\n      i = 0\n      j = 0\n      while i<blocks and j<blocks:\n          if ken[i] > naomi[j]:\n              dcwar -= 1\n          else:\n              i += 1\n          j += 1\n      i = 0\n      j = 0\n      while i<blocks and j<blocks:\n          if ken[i] < naomi[j]:\n              war += 1\n          else:\n              j += 1\n          i += 1\n  \n      print("Case #%d: %d %d" % (n, dcwar, war))\n          \n  \n <CODESPLIT> 14
fin = open('B-small-attempt0.in', 'r')\n  fout = open('B-output.txt', 'w')\n  \n  cases = int(fin.readline()[:-1])\n  \n  for case in range(cases) :\n      line = map(int, fin.readline()[:-1].split(' '))\n      N, S, p = line[:3]\n      T = line[3:]\n      okLimit = p + 2*max(p-1,0)\n      okIfSLimit = p + 2*max(p-2,0)\n      ok = len(filter(lambda x : x >= okLimit, T))\n      okIfS = len(filter(lambda x : okLimit > x >= okIfSLimit, T))\n      res = ok + min(okIfS, S)\n      fout.write('Case #' + str(case+1) + ': ' + str(res) + '\n')\n      \n  fin.close()\n  fout.close()\n <CODESPLIT> 15
f = open('input.in')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for case in xrange(T) :\n      N = int(f.readline()[:-1])\n      Naomi = sorted(map(float, f.readline()[:-1].split()))\n      Ken = sorted(map(float, f.readline()[:-1].split()))\n      Ken2 = Ken[:]\n      War, DWar = 0, 0\n      for n in Naomi :\n          if n > max(Ken) :\n              Ken.pop(0)\n              War += 1\n          else :\n              for i, k in enumerate(Ken) :\n                  if k > n : break\n              Ken.pop(i)\n      Ken = Ken2\n      for n in Naomi :\n          if n < min(Ken) :\n              Ken.pop(-1)\n          else :\n              Ken.pop(0)\n              DWar += 1\n      output = 'Case #' + str(case + 1) + ': ' + str(DWar) + ' ' + str(War)\n      g.write(output + '\n')\n      print output\n  \n  f.close()\n  g.close()\n <CODESPLIT> 15
 \n  \n  def best(total):\n      """Return the best possible score for the given `total`.  Assume\n      the total is computed by summing exactly three scores (each in the\n      interval of 0 to 10 inclusive) and no score can be 2 points apart\n      \n      Arguments:\n      - `total`:\n      """\n      m = total % 3\n      if m == 2:\n          b = total // 3 + 2\n      else:\n          b = total // 3 + 1\n      if b > 10:\n          b = 10\n      return b\n  \n  def best_non_surprising(total):\n      """Return the best possible score for the given `total`, but\n      assume that there should be no more than 1 point difference\n      between the scores.\n  \n      Arguments:\n      - `total`:\n      """\n      if total % 3 == 0:\n          return total // 3\n      else:\n          return total // 3 + 1\n  \n  def max_num_gte_p(totals, S, p):\n      """Return the maximum number of Googlers that could have had a\n      best result of at least p.\n      \n      Arguments:\n      - `totals`:\n      - `S`: number of surprising triplets of scores\n      - `p`:\n      """\n      res = 0\n      for total in totals:\n          if total == 0:\n              if p == 0:\n                  res += 1\n              continue\n  \n          if best_non_surprising(total) >= p:\n              res += 1\n          elif S > 0 and best(total) >= p:\n              res += 1\n              S -= 1\n  \n      return res\n  \n  def main():\n      with open(sys.argv[1], 'r') as f:\n          f.readline()            # skip T\n  \n          n = 0\n          for line in f:\n              n += 1\n  \n              line = [int(s) for s in line.split()]\n              N = line[0]\n              S = line[1]\n              p = line[2]\n              totals = line[3:]\n  \n              print 'Case #%d: %d' % (n, max_num_gte_p(totals, S, p))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 16
 \n  \n  def ken(naomi_told, kens_blocks):\n  	heavier = list(filter(lambda b: b > naomi_told, kens_blocks))\n  	if heavier:\n  		chosen = min(heavier)\n  	else:\n  		chosen = min(kens_blocks)\n  	kens_blocks.remove(chosen)\n  	return chosen\n  \n  \n  def remove_lightest(blocks):\n  	lightest = sorted(blocks)[0]\n  	blocks.remove(lightest)\n  	return lightest\n  \n  \n  def remove_heaviest(blocks):\n  	heaviest = sorted(blocks)[-1]\n  	blocks.remove(heaviest)\n  	return heaviest\n  \n  \n  def dwar(naomis_blocks, kens_blocks):\n  	wins = 0\n  	kens_blocks = copy.copy(kens_blocks)\n  	for block in sorted(naomis_blocks):\n  		if any(map(lambda x: x < block, kens_blocks)):\n  			wins += 1\n  			remove_lightest(kens_blocks)\n  \n  		elif any(map(lambda x: x > block, kens_blocks)):\n  			remove_heaviest(kens_blocks)\n  	return wins\n  \n  \n  def war(naomis_blocks, kens_blocks):\n  	wins = 0\n  	kens_blocks = copy.copy(kens_blocks)\n  	for block in naomis_blocks:\n  		k = ken(block, kens_blocks)\n  		if block > k:\n  			wins += 1\n  	return wins\n  \n  \n  def read_case(f):\n  	N = int(f.readline())\n  	naomis_blocks = list(map(float, f.readline().split()))\n  	kens_blocks = list(map(float, f.readline().split()))\n  	return N, naomis_blocks, kens_blocks\n  \n  \n  def solve(n, k):\n  	return '{} {}'.format(dwar(n, k), war(n, k))\n  \n  \n  def main():\n  	fn = sys.argv[1]\n  	with open(fn, encoding='utf-8') as f:\n  		ncases = int(f.readline())\n  		for case in range(1, ncases + 1):\n  			N, naomi, ken = read_case(f)\n  			solution = solve(naomi, ken)\n  			print('Case #{}: {}'.format(case, solution))\n  \n  \n  if __name__ == '__main__':\n  	main()\n <CODESPLIT> 16
'''\n  Created on 2012-4-14\n  \n  @author: hemnd\n  '''\n  def cal(args):\n      rslt = 0\n      N = int(args[0])\n      S = int(args[1])\n      p = int(args[2])\n      for i in range(N):\n          s = int(args[i + 3])\n          e = s / 3\n          r = s % 3\n          if e >= p:\n              rslt += 1\n          elif r == 1:\n              if e + 1 >= p:\n                  rslt += 1\n          elif r == 0:\n              if e == 0:\n                  continue\n              if S > 0 and e + 1 >= p:\n                  rslt += 1\n                  S -= 1\n          elif r == 2:\n              if e + 1 >= p:\n                  rslt += 1\n              elif S > 0 and e + 2 >= p:\n                  rslt += 1\n                  S -= 1\n      return rslt\n  \n  inputFile = open('B-small-attempt0.in', 'r')\n  inputLines = inputFile.readlines()\n  inputFile.close()\n  \n  T = int(inputLines[0])\n  outputLines = []\n  \n  for i in range(1, T + 1):\n      args = inputLines[i].strip().split(' ')\n      outputLines.append('Case #%d: %d\n' % (i, cal(args)))\n      print outputLines[i - 1],\n  \n  outputFile = open('B-small.out', 'w')\n  outputFile.writelines(outputLines)\n  outputFile.close()\n <CODESPLIT> 17
 \n  \n  def process(N, naomi, ken):\n  	pointer_n = pointer_k = 0\n  	score0 = 0\n  	score1 = N\n  	for i in range(N):\n  		if naomi[i] > ken[pointer_k]:\n  			score0 += 1\n  			pointer_k += 1\n  		if ken[i] > naomi[pointer_n]:\n  			score1 -= 1\n  			pointer_n +=1\n  	return str(score0) + ' ' + str(score1)\n  \n  input_file = open(sys.argv[1], 'r')\n  T = int(input_file.readline())\n  for i in range(T):\n  	N = int(input_file.readline())\n  	naomi = sorted(map(float, input_file.readline().split()))\n  	ken = sorted(map(float, input_file.readline().split()))\n  	print 'Case #%d:' % (i + 1), process(N, naomi, ken)\n <CODESPLIT> 17
fileName = raw_input("File name: ")\n  \n  f = open(fileName,"r")\n  \n  t = int(f.readline()[:-1])\n  \n  tests = []\n  \n  for i in range (t):\n      tests += [f.readline()[:-1]]\n  \n  f.close()\n  \n  \n  def compute(raw):\n      dataN = [] # keeps the max mark for not surprising\n      dataS = [] # keeps the max marks for surprisings\n      \n      items = raw.split() \n      \n      for i in range (int(items[0])):\n          ti = int(items[3+i])\n          if ti < 1:\n              dataS += [0]\n              dataN += [0]\n          elif ti > 28:\n              dataS += [10]\n              dataN += [10]\n          else:\n              dataN += [int((ti+2)/3)] # put the values for all participants\n              dataS += [int((ti+4)/3)]\n          \n          \n  \n      \n      p = int(items[2])\n      s = int(items[1])\n      \n      n_vals = dataN\n      n_vals.sort()\n      \n  \n      i=0\n      minimum = 0 # how many numbers greater than p are there in "not surprising"\n      if n_vals[0] < p:\n          while n_vals[-1-i] >= p:\n              minimum += 1\n              i += 1\n      else:\n          minimum = len(n_vals)\n          \n  \n      s_vals = dataS\n      s_vals.sort()\n      i=0\n      maximum = 0 # how many numbers greater than p are there in "surprising"\n      if s_vals[0] < p:\n          while s_vals[-1-i] >= p:\n              maximum += 1\n              i += 1\n      else:\n          maximum = len(n_vals)\n      \n      return min(maximum, minimum+s) \n      \n  \n  for i in range (t):\n      print "Case #%d: %d" %(i+1,compute(tests[i]))\n  \n  \n      \n <CODESPLIT> 18
filename = raw_input("Name of file: ")\n  infile = open(filename, "r")\n  outfile = open(filename + ".out", "w")\n  \n  \n  T = int(infile.readline()[:-1])\n  \n  def playDecWars(her, his):\n      n = len(her)\n      count = 0\n      while n > 0:\n          if her[0] < his[0]:\n              del(her[0])\n              del(his[-1])\n          else:\n              del(her[0])\n              del(his[0])\n              count += 1\n          n -= 1\n      return count\n  \n  def playWars(her, his):\n      n = len(her)\n      count = 0\n      while n > 0:\n          if her[0] > his[-1]:\n              count += 1\n              del(her[0])\n              del(his[0])\n          else:\n              his_index = 0\n              for num in his:\n                  if num > her[0]:\n                      break\n                  his_index += 1\n              del(her[0])\n              del(his[his_index])\n          n -= 1\n      return count\n  \n  for t in range(1, T + 1):\n      n = int(infile.readline()[:-1])\n      her = infile.readline()[:-1].split(" ")\n      his = infile.readline()[:-1].split(" ")\n      her = [float(x) for x in her]\n      his = [float(x) for x in his]\n  \n      her.sort()\n      his.sort()\n  \n      d_wars = playDecWars(her[:], his[:])\n      wars = playWars(her[:], his[:])\n      \n      outfile.write("Case #%d: %d %d\n" % (t, d_wars, wars))\n      \n          \n      \n  \n  outfile.close()\n  infile.close()\n <CODESPLIT> 18
 \n  \n  case = 1\n  problem = "B"\n  practice = False\n  \n  if practice:\n      practice = "-practice"\n  else:\n      practice = "-attempt0"\n  if case == 0:\n      infile = open("%s-%s%s.in" % (problem, "sample", practice), 'r')\n      outfile = open("%s-%s%s.out" % (problem, "sample", practice), 'w')        \n  elif case == 1:\n      infile = open("%s-%s%s.in" % (problem, "small", practice), 'r')\n      outfile = open("%s-%s%s.out" % (problem, "small", practice), 'w')    \n  elif case == 2:\n      infile = open("%s-%s%s.in" % (problem, "large", practice), 'r')\n      outfile = open("%s-%s%s.out" % (problem, "large", practice), 'w')   \n  else:\n      raise ValueError, 'Invalid case'\n      \n  lookup = {}\n  \n  def check_total(total, p):\n      assert type(total) == int\n      resid = total % 3\n  \n      min_nosurprise = (total / 3)    \n      max_nosurprise = (total / 3) + min(1, resid)\n      \n      \n      if resid == 1 or max_nosurprise == 10 or (resid == 0 and min_nosurprise == 0):\n          if max_nosurprise >= p:\n              return 1\n          else:\n              return -1\n  \n      if max_nosurprise >= p:\n          return 1\n      elif max_nosurprise == p-1:\n          return 0\n      else:\n          return -1\n      \n  cases = int(infile.readline().strip('\n'))\n  for i in range(cases):\n      print 'case %i of %i' % (i+1, cases)\n      line = infile.readline().split()\n      N = int(line[0])\n      S = int(line[1])\n      p = int(line[2])\n      points = []\n      for item in line[3:]:\n          points.append(int(item))\n      assert N == len(points)\n      assert p <= 10\n      assert p >= 0\n      assert S >= 0\n      assert S <= N\n      \n      always = 0\n      possible = 0\n      \n      for total in points:\n          if (total, p) in lookup:\n              depends = lookup[total, p]\n          else:\n              depends = check_total(total, p)\n          \n          if depends == 1:\n              always += 1\n          elif depends == 0:\n              possible += 1\n      \n      output = '%i' % (always + min(possible, S))\n      \n      outfile.write('Case #%i: %s\n' % (i+1, output))\n      \n  infile.close()\n  outfile.close()\n <CODESPLIT> 19
 \n  \n  \n  \n  \n  \n  \n  class memoize(object):\n     """Decorator. Caches a function's return value each time it is called.\n     If called later with the same arguments, the cached value is returned\n     (not reevaluated).\n     """\n     def __init__(self, func):\n        self.func = func\n        self.cache = {}\n     def __call__(self, *args):\n        if not isinstance(args, collections.Hashable):\n           return self.func(*args)\n        if args in self.cache:\n           return self.cache[args]\n        else:\n           value = self.func(*args)\n           self.cache[args] = value\n           return value\n     def __repr__(self):\n        '''Return the function's docstring.'''\n        return self.func.__doc__\n     def __get__(self, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(self.__call__, obj)\n  \n  \n  def precalculate():\n      """Perform any calculations that need to be performed before the main path\n      (e.g., preparing lookup tables, etc.)\n      \n      N.B. Make sure you make any important variables global so that other\n      functions can access them.\n      """\n      pass\n  \n  def read_input(infile):\n      """This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      """\n      def read_int():\n          return int(infile.readline().strip())\n      def read_ints():\n          return np.array(infile.readline().split(), dtype=int)\n      def read_bigints(): #For ints that won't fit directly in an int32 array\n          line = infile.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(infile.readline().strip())\n      def read_floats():\n          return np.array(infile.readline().split(), dtype=float)\n      def read_string():\n          return infile.readline().strip()\n      def read_strings():\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n      \n      N = read_int()\n      naomi = read_floats()\n      ken = read_floats()\n      naomi.sort()\n      ken.sort()\n      assert len(naomi) == N\n      assert len(ken) == N\n      \n      return naomi, ken\n  \n  def ken_choice(told_naomi, ken, ken_free):\n      N = len(ken)\n      lowest = None\n      for j in range(N):\n          if not ken_free[j]:\n              continue\n          if lowest is None:\n              lowest, idx = ken[j], j\n          if ken[j] > told_naomi:\n              return ken[j], j\n      return lowest, idx\n  \n  def normal_war(naomi, ken):\n      \n      N = len(naomi)\n      ken_free = np.ones(N, dtype=bool)\n      score = 0\n      for i in range(N)[::-1]:\n          chosen_naomi = naomi[i]\n          chosen_ken, j = ken_choice(chosen_naomi, ken, ken_free)\n          ken_free[j] = False\n          \n          if chosen_naomi > chosen_ken:\n              score += 1\n      return score\n  \n  \n  def new_deceitful_war(naomi, ken):\n      score = 0\n      \n      N = len(naomi)\n      \n      for i in range(N):\n          if naomi[-1] > ken[-1]:\n              score += 1\n              naomi = naomi[:-1]\n              ken = ken[:-1]\n          else:\n              naomi = naomi[1:]\n              ken = ken[:-1]\n      return score\n  \n  \n  def deceitful_war(naomi, ken):\n      \n      \n      \n      \n      N = len(naomi)\n      no_hopers = 0\n      for i in range(N):\n          if naomi[i] < ken[0]:\n              no_hopers += 1\n      def_losses = 0\n      for i in range(N)[::-1]:\n          if ken[i] > naomi[-1]:\n              def_losses += 1\n      \n      edge = max(no_hopers, def_losses)\n      naomi = naomi[edge:]\n      ken = ken[:N-edge]\n  \n      '''\n      print "After removing sure losers:"\n      print N, N-edge, edge\n      if N - edge > 0:\n          if min(naomi) < max(ken):\n              print naomi\n              print ken\n      '''\n  \n  \n      score = 0\n      for i in range(N - edge):\n          if naomi[i] > ken[i]:\n              score += 1\n              \n      return score\n  \n  def solve_case(case):\n      """Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      """\n      \n      naomi, ken = case\n      print naomi\n      print ken\n      \n      new = new_deceitful_war(naomi, ken)\n      \n      good, bad = deceitful_war(naomi, ken), normal_war(naomi, ken)\n      \n      if not new == good:\n          print 'Hey!', new, good\n      \n      output = "%i %i" % (new, bad)\n      return output\n  \n  \n  if __name__ == "__main__":\n      precalculate()\n      \n      assert len(sys.argv) == 2 #only one argument\n      assert sys.argv[1][-3:] == ".in" #input must end with .in\n      infile = open("%s" % sys.argv[1], 'r')\n      outfile = open("%s.out" % sys.argv[1][:-3], 'w')\n      \n      cases = int(infile.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(infile)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      infile.close()\n      outfile.close()\n <CODESPLIT> 19
 \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in xrange(t):\n          ns = map(int, f.readline().split())\n          n = ns[0]\n          s = ns[1]\n          p = ns[2]\n          assert len(ns) == n + 3\n          scores = ns[3:3+n]\n  \n          sure = 0\n          if_surprising = 0\n          for x in scores:\n              not_surprising = (x + 2) / 3\n              is_surprising = (x + 4) / 3\n              if not_surprising >= p:\n                  sure += 1\n              elif (2 <= x <= 28) and is_surprising >= p:\n                  if_surprising += 1\n          print "Case #%d: %d" % (_t+1, sure + min(if_surprising, s))\n <CODESPLIT> 20
 \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          N = int(f.readline())\n          naomi = map(float, f.readline().split())\n          ken = map(float, f.readline().split())\n          assert len(ken) == len(naomi) == N\n  \n          naomi = [(w, 1) for w in naomi]\n          ken = [(w, 0) for w in ken]\n  \n          blocks = ken + naomi\n          blocks.sort(reverse=True)\n          blocks = [p[1] for p in blocks]\n  \n          honest = 0\n          adv = 0\n          for b in blocks:\n              if b == 1:\n                  adv += 1\n                  honest = max(honest, adv)\n              else:\n                  adv -= 1\n  \n          deceitful = 0\n          kept = 0\n          for b in blocks:\n              if b == 1:\n                  kept += 1\n              else:\n                  if kept:\n                      kept -= 1\n                      deceitful += 1\n          print "Case #%d: %d %d" % (_T+1, deceitful, honest)\n <CODESPLIT> 20
 \n  \n  def calculate_max_score(scores_sum):\n      if scores_sum % 3 == 1:\n          max_score = (scores_sum + 2) / 3\n          return (max_score, max_score)\n      if scores_sum % 3 == 2:\n          max_score = (scores_sum + 1) / 3\n          return (max_score, max_score + 1)\n      max_score = scores_sum / 3\n      if max_score == 0:\n          return (0, 0)\n      return (max_score, max_score + 1)\n  \n  def find_max_dancers(s, p, *scores_sums):\n      dancers_count = 0\n      for scores_sum in scores_sums:\n          (normal_max, surprise_max) = calculate_max_score(scores_sum)\n          if normal_max >= p:\n              dancers_count = dancers_count + 1\n              continue\n          if surprise_max >= p and s > 0:\n              s = s - 1\n              dancers_count = dancers_count + 1\n              continue\n      return dancers_count\n  \n  def main():\n  \n      case_count = int(sys.stdin.readline())\n  \n      for case_index in range(1, case_count + 1):\n          line = sys.stdin.readline().strip().split(' ')\n          s = int(line[1])\n          p = int(line[2])\n          scores_sums = [int(scores_sum) for scores_sum in line[3:]]\n          print 'Case #%i: %s' % (case_index, find_max_dancers(s, p, *scores_sums))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 21
 \n  def ken(ken_blocks, naomi_block):\n      """\n      Since ken do not know Naomi's blocks weights\n      Best strategy will be spent the smallest block to beat Naomi\n      """\n  \n      for block in ken_blocks:\n          if block > naomi_block:\n              ken_blocks = ken_blocks[:]\n              ken_blocks.remove(block)\n              return True, ken_blocks\n  \n      ken_blocks = ken_blocks[1:]\n      return False, ken_blocks\n  \n  def naomi(naomi_blocks):\n      naomi_block = naomi_blocks[0]\n      naomi_blocks = naomi_blocks[1:]\n      return naomi_block, naomi_blocks\n  \n  def play(naomi_blocks, ken_blocks):\n      naomi_points = 0\n      ken_points = 0\n  \n      naomi_blocks.sort()\n      ken_blocks.sort()\n  \n      while naomi_blocks and ken_blocks:\n          naomi_block, naomi_blocks = naomi(naomi_blocks)\n          ken_wins, ken_blocks = ken(ken_blocks, naomi_block)\n          if ken_wins:\n              ken_points += 1\n          else:\n              naomi_points += 1\n  \n      return naomi_points\n  \n  def naomi2(naomi_blocks, ken_blocks):\n      target = ken_blocks[0]\n      for block in naomi_blocks:\n          if block > target:\n              naomi_blocks = naomi_blocks[:]\n              naomi_blocks.remove(block)\n              return ken_blocks[-1] + 0.0000001, naomi_blocks\n      return naomi_blocks[0], naomi_blocks[1:]\n  \n  def cheat(naomi_blocks, ken_blocks):\n      naomi_points = 0\n      ken_points = 0\n  \n      naomi_blocks.sort()\n      ken_blocks.sort()\n  \n      while naomi_blocks and ken_blocks:\n          naomi_block, naomi_blocks = naomi2(naomi_blocks, ken_blocks)\n          ken_wins, ken_blocks = ken(ken_blocks, naomi_block)\n          if ken_wins:\n              ken_points += 1\n          else:\n              naomi_points += 1\n      return naomi_points\n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          N = int(sys.stdin.readline())\n          naomi_blocks = map(float, sys.stdin.readline().split())\n          ken_blocks = map(float, sys.stdin.readline().split())\n          assert len(naomi_blocks) is N\n          assert len(ken_blocks) is N\n  \n          normal_war = play(naomi_blocks, ken_blocks)\n          cheat_war = cheat(naomi_blocks, ken_blocks)\n          print 'Case #%d: %d %d' % (case + 1, cheat_war, normal_war)\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 21
 \n  T = int(stdin.readline())\n  for i in xrange(1,T+1):\n  	ns = map(int, stdin.readline().split())\n  	N,S,p = ns[0:3]\n  	\n  	h = 0\n  	z = 0\n  \n  	for n in ns[3:]:\n  		if n <= 1:\n  			if n >= p: h += 1	\n  		elif (n+2) // 3 >= p:\n  			h += 1\n  		elif (n+4) // 3 >= p:\n  			z += 1\n  \n  	print "Case #%d: %d" % (i, h + min(S,z))\n  \n  \n <CODESPLIT> 22
 \n  f = open(sys.argv[1])\n  count = int(f.readline())\n  \n  for i in xrange(0, count):\n      n = int(f.readline())\n      naomis = sorted(map(float, f.readline().split()))\n      kens = sorted(map(float, f.readline().split()))\n      assert len(naomis) == n and len(kens) == n\n  \n      naomis_w = set(naomis)\n      kens_w = set(kens)\n      naomi_war_wins = 0\n      while naomis_w:\n          nao = max(naomis_w)\n          try:\n              ken = min(w for w in kens_w if w > nao)\n          except ValueError:\n              ken = min(kens_w)\n              naomi_war_wins += 1\n          naomis_w.remove(nao)\n          kens_w.remove(ken)\n  \n      naomi_deceit_wins = 0\n      naomis_w = set(naomis)\n      kens_w = set(kens)\n      while naomis_w:\n          ken = min(kens_w)\n          try:\n              nao = min(w for w in naomis_w if w > ken)\n              naomi_deceit_wins += 1\n          except ValueError:\n              nao = min(naomis_w)\n          naomis_w.remove(nao)\n          kens_w.remove(ken)\n  \n      print "Case #%s: %s %s" % (i+1, naomi_deceit_wins, naomi_war_wins)\n <CODESPLIT> 22
input_file = 'B-small-attempt1.in'\n  output_file = 'b.out'\n  \n  \n  def solvecase(inp):\n  	data = [int(n) for n in inp.split()]\n  	N, S, p = data[0:3]\n  	if p == 0:\n  		return N\n  	t = data[3:]\n  	ret = 0\n  	for br in t:\n  		d, r = br / 3, br % 3\n  		if br == 0 or p - d > 2:\n  			continue\n  		if (d >= p) or (r and (d + 1) >= p):\n  			ret += 1\n  		elif S and (d + max(r, 1)) >= p:\n  			ret += 1\n  			S -= 1\n  	return ret\n  \n  lines = open(input_file, 'r').readlines()\n  out = open(output_file, 'w')\n  \n  for i, l in enumerate(lines[1:]):\n  	sout = 'Case #%i: %i' % (i + 1, solvecase(l))\n  	print sout\n  	out.write(sout + '\n')\n  \n  out.close()\n <CODESPLIT> 23
 \n  INPUT = 'D-small-attempt3.in'\n  OUTPUT = 'D-small-attempt3.out'\n  \n  \n  def solve(N, naomis, kens):\n      naomis.sort()\n      kens.sort()\n  \n      def play_war(naomis, kens):\n          score = 0\n          for game_round in range(N):\n              nweight = naomis.pop(0)\n              if nweight > kens[-1]:\n                  kweight = kens.pop(0)\n              else:\n                  for i, weight in enumerate(kens):\n                      if weight > nweight:\n                          kweight = kens.pop(i)\n                          break\n              if nweight > kweight:\n                  score += 1\n          return score\n  \n      def play_deceitful_war(naomis, kens):\n          score = 0\n          crap = 0\n          for i, weight in enumerate(naomis):\n              if weight < kens[i]:\n                  crap += 1\n  \n          for game_round in range(N):\n              if crap:\n                  ntold = kens[-1] - 0.0000001\n                  crap -= 1\n              else:\n                  ntold = naomis[-1]\n              nweight = naomis.pop(0)\n  \n              if ntold > kens[-1]:\n                  kweight = kens.pop(0)\n              else:\n                  for i, weight in enumerate(kens):\n                      if weight > ntold:\n                          kweight = kens.pop(i)\n                          break\n              if nweight > kweight:\n                  score += 1\n          return score \n  \n      return play_deceitful_war(naomis[:], kens[:]), play_war(naomis[:], kens[:])\n  \n  \n  if __name__ == '__main__':\n      inp = open(INPUT)\n      out = open(OUTPUT, 'w')\n      \n      T = int(inp.readline())\n  \n      for case in range(T):\n          N = int(inp.readline())\n          naomis = map(float, inp.readline().split())\n          kens = map(float, inp.readline().split())\n          sol = solve(N, naomis, kens)\n          out.write('Case #%i: %i %i\n' % (case + 1, sol[0], sol[1]))\n <CODESPLIT> 23
 \n  def decode_data(input):\n      output = ""\n      for letter in input:\n          if letter in library:\n              output += library[letter]\n      return output\n  \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())    \n      for _t in range(t):\n          s = f.readline()\n          s = s.split()\n          N = int(s[0])\n          S = int(s[1])\n          p = int(s[2])\n          low_scores = (p - 1) * 2\n          ti = s[3:]\n          ti.sort()\n          r = 0\n          ti = [int(x) for x in ti]\n          for i in ti:\n              score = i - low_scores\n              if p <= i:\n                  if score >= p:\n                      r += 1\n                  elif score >= p - 2 and S > 0:\n                      S -= 1\n                      r +=1\n          print ("Case #" + str(_t+1) + ": " + str(r))\n      \n  \n <CODESPLIT> 24
 \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in range(t):\n          N = int(f.readline())\n          Naomi = sorted([float(x) for x in f.readline().split()])\n          Ken = sorted([float(x) for x in f.readline().split()])\n          NMax = max(Naomi)\n          DWScore = 0\n          WScore = 0\n          NaomiW = [x for x in Naomi]\n          KenW = [x for x in Ken]\n          for i in range(N):\n              if(Naomi[-1] > Ken[-1]):\n                  DWScore += 1\n                  Naomi.pop()\n                  Ken.pop()\n              else:\n                  Naomi.pop(0)\n                  Ken.pop()\n          for i in range(N):\n              Na = NaomiW.pop(0)\n              KWinners = [x for x in KenW if x > Na]\n              if len(KWinners) > 0:\n                  KenW.remove(KWinners[0])\n              else:\n                  KenW.pop(0)\n                  WScore += 1\n          print ("Case #" + str(_t+1) + ": " + str(DWScore) + " " + str(WScore))\n      \n  \n <CODESPLIT> 24
T=int(input())\n  for t in range(T):\n    l = [int(x) for x in input().split()]\n    n,huh,p = l[:3]\n    ss = l[3:]\n    nice, maybe = 0,0\n    for s in ss:\n      if s>= p+2*max(p-1,0):\n        nice += 1\n      elif s>= p+2*max(p-2,0):\n        maybe += 1\n    y = nice + min(maybe,huh)\n    print('Case #',t+1,': ',y,sep = '')\n  \n  \n <CODESPLIT> 25
def findmin(l,y):\n      for (i,x) in enumerate(l):\n          if x>y:\n              return i\n      return None\n  \n  T = int(input())\n  for case in range(1,T+1):\n      N = int(input())\n      Ns = [float(x) for x in input().split()]\n      Ks = [float(x) for x in input().split()]\n  \n      Ns.sort()\n      Ks.sort()\n      bad = 0\n  \n      Ns1 = Ns[:]\n      Ks1 = Ks[:]\n      while Ns1:\n          y = Ks1.pop()\n          if Ns1[-1]>y:\n              i = findmin(Ns1,y)\n              Ns1[i:i+1]=[]\n              bad += 1\n          else:\n              Ns1[:1] = []\n  \n      good = 0\n      Ns2 = Ns[:]\n      Ks2 = Ks[:]\n      for x in Ns2:\n          if Ks2[-1]>x:\n              i = findmin(Ks2,x)\n              Ks2[i:i+1]=[]\n          else:\n              Ks2[:1]=[]\n              good += 1\n  \n      print("Case #",case,": ",bad,' ',good,sep = '')\n <CODESPLIT> 25
 \n  \n  \n  def solve(num_surprises, p, ts):\n      s = 0\n      u = 0\n      for t in ts:\n          a = int(t/3)\n          r = t % 3\n          if a+1 >= p and not r == 0:\n              u += 1\n          elif a >= p and r == 0:\n              u += 1\n          elif a > 0 and a+1 >= p and r == 0:\n              s += 1\n          elif a+2 >= p and r == 2:\n              s += 1\n  \n      return min(num_surprises, s) + u\n          \n          \n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          line = [int(x) for x in sys.stdin.readline().split()]\n          num_surprises = line[1]\n          p = line[2]\n          ts = line[3:]\n          result = solve(num_surprises, p, ts)\n          print ("Case #%s: %s" % (i+1, result))\n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 26
 \n  \n  def solveWar(n_weights, k_weights):\n      nweights = sorted(n_weights)\n      kweights = sorted(k_weights)\n      score = 0\n      \n  \n      for w in nweights:\n          while kweights and kweights[0] < w:\n              kweights.pop(0)\n              score += 1\n  \n          if not kweights:\n              break\n          else:\n              kweights.pop(0)\n              \n      return score\n  \n  def solveDWar(n_weights, k_weights):\n      nweights = sorted(n_weights)\n      kweights = sorted(k_weights)\n      score = 0\n  \n      for w in nweights:\n          if w > kweights[0]:\n              score += 1\n              kweights.pop(0)\n          else:\n              kweights.pop(-1)\n      \n      return score\n  \n  def solve(nweights, kweights):\n      return ("%s %s" % (solveDWar(nweights, kweights), solveWar(nweights, kweights)))\n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          sys.stdin.readline()\n          nweights = [float(x) for x in sys.stdin.readline().rstrip().split()]\n          kweights = [float(x) for x in sys.stdin.readline().rstrip().split()]\n  \n          result = solve(nweights, kweights)\n          print ("Case #%s: %s" % (i+1, result))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 26
arq = file("input.in")\n  n_cases = eval(arq.readline())\n  out = file("output.txt", "w")\n  \n  for case in xrange(n_cases):\n  \n  	data = arq.readline()\n  	data = data.strip()\n  	data = data.split(" ")\n  \n  	n = eval(data[0])\n  	s = eval(data[1])\n  	p = eval(data[2])\n  \n  	scores = []\n  	n_googlers_with_best_result = 0\n  	candidates = 0\n  \n  	for j in data[3:]:\n  		i = eval(j)\n  		if i%3 == 0:\n  			score = i/3\n  			scores.append([score, score, score])\n  		elif (i+1)%3 == 0:\n  			score = (i+1)/3\n  			scores.append([score-1, score, score])\n  		else: #(i+2)%3 == 0\n  			score = (i+2)/3\n  			scores.append([score-1, score-1, score])\n  \n  	for score in scores:\n  		if score[2] >= p:\n  			n_googlers_with_best_result +=1\n  		elif score[2] + 1 == p and score[1] == score[2] and score[2] != 0:\n  			candidates += 1\n  \n  	n_googlers_with_best_result = n_googlers_with_best_result + min(s, candidates)\n  \n  	out.write("Case #%d: %d\n" % (case+1, n_googlers_with_best_result))\n <CODESPLIT> 27
 \n  def pointsWar(naomi, ken, N):\n  	points = 0\n  	iNaomi = 0\n  	iKen = 0\n  	while iNaomi < N and iKen < N:\n  		if naomi[iNaomi] > ken[iKen]:\n  			points += 1\n  		else:\n  			iNaomi += 1\n  		iKen += 1\n  	return points\n  \n  def pointsDeceitfulWar(naomi, ken, N):\n  	points = N\n  	iNaomi = 0\n  	iKen = 0\n  	while iNaomi < N and iKen < N:\n  		if naomi[iNaomi] > ken[iKen]:\n  			iKen += 1\n  		else:\n  			points -= 1\n  		iNaomi += 1\n  	return points\n  \n  \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file("output.txt", "w")\n  \n  T = int(f.readline())\n  \n  for case in xrange(T):\n  	N = int(f.readline().strip())\n  	naomi = f.readline().strip().split()\n  	ken = f.readline().strip().split()\n  \n  	for i in xrange(N):\n  		naomi[i] = (float(naomi[i]),"N")\n  		ken[i] = (float(ken[i]),"K")\n  \n  	naomi.sort()\n  	ken.sort()\n  \n  	fout.write("Case #%d: %d %d\n" %(case + 1, pointsDeceitfulWar(naomi, ken, N), pointsWar(naomi, ken, N)))\n <CODESPLIT> 27
 \n  \n  def findbest(score):\n  	if score == 0: return (0, 0)\n  \n  	best = math.ceil(score / 3)\n  	bestsurp = round(score / 3) + 1\n  \n  	return (best, bestsurp)\n  	\n  sys.stdin.readline()\n  \n  casenum = 0\n  for line in sys.stdin:\n  	casenum += 1\n  \n  	data = line.strip().split(' ')\n  	maxsurprising = int(data[1])\n  	p = int(data[2])\n  	scores = data[3:]\n  	maxgooglers = 0\n  \n  	for s in scores:\n  		(best, bestsurp) = findbest(int(s))\n  		if best >= p:\n  			maxgooglers += 1\n  		else:\n  			if bestsurp >= p and maxsurprising > 0:\n  				maxgooglers += 1\n  				maxsurprising -= 1\n  \n  	print("Case #%d: %d" % (casenum, maxgooglers))\n <CODESPLIT> 28
 \n  \n  ncases = int(sys.stdin.readline().strip())\n  \n  for t in range(1, ncases+1):\n      nblocks = int(sys.stdin.readline().strip())\n      naomi_blocks = [float(x) for x in sys.stdin.readline().strip().split()]\n      ken_blocks = [float(x) for x in sys.stdin.readline().strip().split()]\n  \n      naomi_blocks.sort()\n      ken_blocks.sort()\n  \n      ken_lightest = 0\n      ken_heaviest = nblocks-1\n      points_deceitful = 0\n  \n      for i in range(0, nblocks):\n          if naomi_blocks[i] > ken_blocks[ken_lightest]:\n              points_deceitful += 1\n              ken_lightest += 1\n          else:\n              ken_heaviest -= 1\n  \n      ken_lightest = 0\n      ken_heaviest = nblocks-1\n      points_standard = 0\n  \n      for i in range(nblocks-1, -1, -1):\n          if naomi_blocks[i] > ken_blocks[ken_heaviest]:\n              points_standard += 1\n              ken_lightest += 1\n          else:\n              ken_heaviest -= 1\n  \n      print("Case #{0}: {1} {2}".format(t, points_deceitful, points_standard))\n <CODESPLIT> 28
 \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for t in range(T):\n      temp = map(int, f.readline().split())\n      N = temp[0]\n      S = temp[1]\n      p = temp[2]\n      scores = temp[3:]\n      non_surprising_scores = len(filter(lambda x: x >= (3*p-2), scores))\n      if (p<=1):\n          surprising_scores = 0\n      else:\n          surprising_scores = len(filter(lambda x: (x >= (3*p-4) and x < (3*p-2)), scores))\n      num_scores = non_surprising_scores + min(surprising_scores, S)   \n      print "Case #%d:" % (t + 1), num_scores\n <CODESPLIT> 29
 \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for test in range(T):\n      N = int(f.readline())\n      naomi_blocks = map(float, f.readline().strip().split(" "))\n      ken_blocks = map(float, f.readline().strip().split(" "))\n      naomi_blocks.sort()\n      ken_blocks.sort()\n      naomi_clone = list(naomi_blocks)\n      ken_clone = list(ken_blocks)\n  \n      naomi_standard_score = 0\n      while naomi_blocks != []:\n          naomi_new_val = naomi_blocks.pop()\n          if naomi_new_val > ken_blocks[-1]:\n              naomi_standard_score += 1\n              ken_blocks.pop(0)\n          else:\n              ii = 0\n              while ken_blocks[ii] < naomi_new_val:\n                  ii += 1\n              ken_blocks.pop(ii)\n  \n      assert(ken_blocks == [])\n  \n      naomi_blocks = naomi_clone\n      ken_blocks = ken_clone\n      naomi_blocks.sort(reverse=True)\n      ken_blocks.sort(reverse=True)\n      deceiving_strat_score = 0\n      while naomi_blocks != []:\n          naomi_new_val = naomi_blocks.pop()\n          if naomi_new_val > ken_blocks[-1]:\n              ken_blocks.pop()\n              deceiving_strat_score += 1\n  \n      print "Case #%d: " % (test + 1), deceiving_strat_score, naomi_standard_score\n  \n  \n  \n <CODESPLIT> 29
 \n  infile=open(sys.argv[1],'r')\n  \n  NumCases=int(infile.readline())\n  \n  for iCase in xrange(NumCases):\n      line=[ int(i) for i in infile.readline().split() ]\n  \n      n=line.pop(0)\n      s=line.pop(0)\n      p=line.pop(0)\n  \n      scores=line\n      assert(len(scores))==n\n  \n      imax=0\n      isurprise=0\n  \n      for score in scores:\n          if score<p: continue\n          if score<3*p-4:\n              pass\n          elif 3*p-2>score>=3*p-4:\n              isurprise+=1\n          else:\n              imax+=1\n  \n      print 'Case #'+str(iCase+1)+':',imax+min(isurprise,s)\n  \n <CODESPLIT> 30
 \n  \n  def Solve(N,n,k):\n      n.sort(reverse=True)\n      k.sort(reverse=True)\n      nDW=0\n      i_n,i_k=0,0\n      while i_n<N and i_k<N:\n          if n[i_n]>k[i_k]:\n              nDW+=1\n              i_n+=1\n              i_k+=1\n          else:\n              i_k+=1\n  \n      nW=0\n      i_n,i_k=0,0\n      while i_n<N and i_k<N:\n          if n[i_n]<k[i_k]:\n              nW+=1\n              i_n+=1\n              i_k+=1\n          else:\n              i_n+=1\n  \n      nW=N-nW\n      return '%d %d'%(nDW,nW)\n  \n  \n  \n  def parse(infile):\n      N=int(infile.readline().strip())\n      n=map(float, infile.readline().split() )\n      k=map(float, infile.readline().split() )\n      return N,n,k\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n  \n      outname=sys.argv[1].rstrip('.in')+'.out'\n      if os.path.isfile(outname):\n          oldout=outname+'.old'\n          ii=0\n          while os.path.isfile(oldout):\n              ii+=1\n              oldout=outname+'.old'+str(ii)\n          os.rename(outname,oldout)\n          print 'Rename: %s -> %s'%(outname,oldout)   \n   \n      outfile=open(outname,'w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n <CODESPLIT> 30
 \n  def testcases():\n      with open(sys.argv[1], "r") as f:\n          f.readline()  # skip number of testcases\n          for X, T in enumerate(f, 1):\n              yield X, [int(t) for t in T.split()]\n  \n  def main():\n      for X, T in testcases():\n          N = T[0]   # the number of Googlers\n          S = T[1]   # the number of surprising triplets of scores\n          p = T[2]   # best result of at least\n  \n          y = 0\n  \n          for t in T[3:]:\n              d, m = divmod(t, 3)\n              if m == 0:\n                  if p <= d:\n                      y += 1\n                  elif 0 <= d - 1 <= p <= d + 1 <= 10 and S:\n                      y += 1\n                      S -= 1\n              elif m == 1:\n                  if p <= d + 1:\n                      y += 1\n              else:\n                  if p <= d + 1:\n                      y += 1\n                  elif p <= d + 2 and S:\n                      y += 1\n                      S -= 1\n  \n          print("Case #{:d}: {:d}".format(X, y))\n  \n  if __name__=="__main__":\n      main()\n <CODESPLIT> 31
 \n  def debug(v):\n      pass#print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def readf(f):\n      t = tuple(float(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, Y, Z):\n      out = "Case #{}: {} {}".format(X, Y, Z)\n      f.write(out)\n      f.write("\n")\n      print(out)\n  \n  \n  \n  def main(inf, outf):\n      T, = read(inf)\n      for casenmbr in range(1, T + 1):\n          N = read(inf)\n          naomi_blks = sorted(readf(inf))\n          ken_blks = sorted(readf(inf))\n  \n          y = len([None for naomi in naomi_blks if ken_blks[0] < naomi])\n  \n          z = 0\n          for naomi in naomi_blks:\n              for i in range(len(ken_blks)):\n                  if naomi < ken_blks[i]:\n                      del ken_blks[i]\n                      break\n              else:\n                  z += 1\n                  del ken_blks[0]\n  \n          answer(outf, casenmbr, y, z)\n  \n  \n  if __name__=="__main__":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + ".out"\n      with open(infname, "r") as inf:\n          with open(outfname, "w") as outf:\n              main(inf, outf)\n <CODESPLIT> 31
 \n  tCase = int(sys.stdin.readline())\n  \n  def alien(frases,case):\n  	\n  	case = case.replace('(','[')\n  	case = case.replace(')',']')\n  	\n  	ER1 = re.compile(case, re.I)\n  	count = 0\n  	for frase in frases:\n  		if ER1.search(frase):\n  			count += 1\n  	return count\n  \n  \n  for i in xrange(tCase):	\n  	linha = sys.stdin.readline().split()\n  	P = int(linha[1])\n  	T = int(linha[2])\n  	list = []\n  	for j in range (3,len(linha)):\n  		list.append(int(linha[j]))\n  	list.sort(reverse=True)\n  	realT = T*3 - 2\n  	supT = realT - 2\n  	\n  	count = 0\n  	for item in list:\n  		if item >= realT:\n  			count += 1\n  		elif P > 0 and item >= supT and T >= 2:\n  			count += 1\n  			P -= 1\n  		elif P > 0 and item >= realT and T == 1:\n  			count += 1\n  			P -= 1\n  		elif T == 0:\n  			count += 1\n  		else:\n  			break\n  		\n  	print "Case #%d: %d" % (i+1, count)\n  	\n  	\n  \n <CODESPLIT> 32
 \n  \n  tCase = int(sys.stdin.readline())\n  \n  def ken(bet, list):\n  	for i in list:\n  		if i >= bet:\n  			list.remove(i)\n  			return i, list\n  	\n  	x = list[0]\n  	list.remove(x)\n  	return x, list\n  	\n  def naomi(YList, ZList):\n  	l1 = list(YList)\n  	l2 = list(ZList)\n  	\n  	while len(l1) > 0:\n  		cy = l1.pop()\n  		cz = l2.pop()\n  \n  		if (cy < cz):\n  				return YList[0], ZList[len(ZList)-1]\n  		\n  	return YList[len(YList)-1], ZList[len(ZList)-1]\n  		\n  def main(YList, ZList):\n  	dnp = 0\n  	np = 0\n  	YList.sort()\n  	ZList.sort()\n  	\n  	YList2 = list(YList)\n  	ZList2 = list(ZList)\n  	\n  	YList.sort()\n  	\n  	while len(YList) > 0:\n  		cy, ty = naomi(YList, ZList)\n  		YList.remove(cy)		\n  		cz, ZList = ken(ty, ZList)\n  		if (cy > cz):\n  			dnp += 1\n  			\n  	while len(YList2) > 0:\n  		cy = YList2.pop()\n  		cz, ZList2 = ken(cy, ZList2)\n  		if (cy > cz):\n  			np += 1\n  			\n  			\n  	\n  \n  	return str(dnp) + " " + str(np)\n  		\n   \n  if __name__ == '__main__':\n  	for i in xrange(tCase):	\n  		\n  		N = [int(x) for x in sys.stdin.readline().split(' ')]\n  		YList = [float(x) for x in sys.stdin.readline().split(' ')]\n  		ZList = [float(x) for x in sys.stdin.readline().split(' ')]\n  		print "Case #%d: %s" % (i + 1, main(YList, ZList))\n <CODESPLIT> 32
 \n  def readfile(filename):\n  	"""\n  		The first line of the input gives the number of test\n  		cases, T. T test cases follow. Each test case consists of\n  		a single line containing integers separated by single\n  		spaces. The first integer will be N, the number of\n  		Googlers, and the second integer will be S, the number\n  		of surprising triplets of scores. The third integer will\n  		be p, as described above. Next will be N integers ti:\n  		the total points of the Googlers.\n  	"""\n  \n  	file = open(filename, "rt")\n  \n  	retval = {}\n  \n  	T = int(file.readline().strip())\n  	retval['T'] = T\n  \n  	tests = []\n  \n  	for i in xrange(T):\n  		line = file.readline().strip()\n  \n  		parts = line.split(" ")\n  \n  		N = int(parts[0])\n  		S = int(parts[1])\n  		p = int(parts[2])\n  		t = []\n  \n  		for j in xrange(N):\n  			t = t + [int(parts[3 + j]), ]\n  \n  		test = { 'N' : N, 'S': S, 'p' : p, 't' : t }\n  		tests = tests + [test, ]\n  \n  	retval['tests'] = tests\n  	return retval\n  \n  def spread(triplet):\n  	return max(abs(triplet[0] - triplet[1]), abs(triplet[1] - triplet[2]), abs(triplet[2] - triplet[0]))\n  \n  def bestresult(triplet):\n  	if triplet:\n  		return max(triplet)\n  	return 0\n  \n  def getcombos(points):\n  	"""\n  		Returns ([unsurprising possibilities, ], [surprising possibilities])\n  	"""\n  \n  	unsurps = []\n  	surps = []\n  \n  	avg = points / 3.0\n  \n  	avg = int(avg)\n  \n  	tested = []\n  \n  	for i in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  		for j in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  			for k in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  				if (i + j + k) != points:\n  					continue\n  \n  				scores = (i,j,k)\n  				scores = sorted(scores)\n  \n  				if scores in tested:\n  					continue\n  				tested.append(scores)\n  \n  				s = spread((i,j,k))\n  \n  				if (s < 2):\n  					unsurps.append(scores)\n  				elif (s == 2):\n  					surps.append(scores)\n  				else:\n  					continue\n  \n  	return (unsurps, surps)\n  \n  def getbesttriplet(triplets):\n  	best = None\n  \n  	for i in triplets:\n  		if best:\n  			if (bestresult(i) > bestresult(best)):\n  				best = i\n  		else:\n  			best = i\n  \n  	return best\n  	\n  \n  def getmulticombos(peeps):\n  	"""\n  		Return the best surprising and non-surprising possibility for\n  		each person.\n  	"""\n  \n  	ret = []\n  \n  	for p in peeps:\n  		u,s = getcombos(p)\n  \n  		bestu = getbesttriplet(u)\n  		bests = getbesttriplet(s)\n  \n  		ret.append((bestu, bests))\n  \n  	return ret\n  \n  def getbestresults(scores, best, numsur):\n  	"""\n  		Figure out the maximum number of people that could have gotten\n  		a single score >= best.  Limited to choosing only numsur surprising\n  		triplets.\n  	"""\n  \n  	peeps = getmulticombos(scores)\n  \n  	count = 0\n  	surcount = 0\n  \n  	for p in peeps:\n  		if (bestresult(p[0]) >= best):\n  			count = count + 1\n  		elif ((bestresult(p[1]) >= best) and (surcount < numsur)):\n  			count = count + 1\n  			surcount = surcount + 1\n  \n  	return count\n  \n  def process(test):\n  	N = test['N']\n  	S = test['S']\n  	p = test['p']\n  	t = test['t']\n  \n  	return getbestresults(t, p, S)\n  \n  data = readfile("B-small-attempt0.in")\n  \n  for i in xrange(data['T']):\n  	test = data['tests'][i]\n  \n  	result = process(test)\n  \n  	print "Case #%d: %d" % (i+1, result)\n <CODESPLIT> 33
 \n  \n  \n  class War_2014_QD(puzutils.CodeJamProblem):\n    def __init__(self, inputFilename):\n      puzutils.CodeJamProblem.__init__(self, inputFilename)\n  \n      self.T = None\n  \n    def load(self):\n      """\n        input:\n  \n        T (number of test cases)\n  \n        N (number of blocks)\n        N1 N2 N3 ... (mass of Naomi's blocks, real)\n        K1 K2 K3 ... (mass of Ken's blocks, real)\n  \n      """\n  \n      self.tests = []\n  \n      with open(self.inputFilename, "rt") as file:\n        self.T = int(file.readline().strip())\n  \n        for i in xrange(self.T):\n          N = int(file.readline().strip())\n          naomi = [float(x) for x in file.readline().split(' ')]\n          ken = [float(x) for x in file.readline().split(' ')]\n  \n          test = {'N': N, 'Naomi': naomi, 'Ken': ken}\n  \n          self.tests.append(test)\n  \n      return True\n  \n    def playWar(self, naomi, ken):\n      """\n        How many points does naomi get when playing standard War?\n      """\n  \n      if (len(naomi) <= 0):\n        return 0\n  \n      maxN = max(naomi)\n  \n      maxK = max(ken)\n  \n      if maxK > maxN:\n        k = min([x for x in ken if x > maxN])\n  \n  \n        naomi.remove(maxN)\n        ken.remove(k)\n  \n        return 0 + self.playWar(naomi, ken)\n      else:\n        k = min(ken)\n  \n  \n        naomi.remove(maxN)\n        ken.remove(k)\n  \n        return 1 + self.playWar(naomi, ken)\n  \n    def playDWar(self, naomi, ken):\n      """\n        How many points does naomi get when playing decietful war?\n      """\n  \n      if (len(naomi) <= 0):\n        return 0\n  \n      minN = min(naomi)\n      minK = min(ken)\n      maxK = max(ken)\n  \n      if (minN < minK):\n        naomi.remove(minN)\n        ken.remove(maxK)\n        return 0 + self.playDWar(naomi, ken)\n  \n      naomi.remove(minN)\n      ken.remove(minK)\n      return 1 + self.playDWar(naomi, ken)\n  \n    def executeTest(self, test):\n      """\n        Run a test and return output.\n      """\n  \n      dwar = self.playDWar(list(test['Naomi']), list(test['Ken']))\n      war = self.playWar(list(test['Naomi']), list(test['Ken']))\n      return "%d %d" % (dwar, war)\n  \n  with War_2014_QD(sys.argv[1]) as problem:\n    problem.load()\n  \n    problem.run()\n <CODESPLIT> 33
 \n  FILE_NAME_BASE = 'B-small-attempt0'\n  NUM_PROCESSES = 0\n  \n  def parse(inp):\n  	data = tuple(int(x) for x in inp.readline().split())\n  	dancers, surprises, points = data[ : 3]\n  	totals = data[3 : ]\n  	assert len(totals) == dancers\n  	return totals, surprises, points\n  \n  def totalAtDist():\n  	'''\n  	If a dancer's best result is b, the total can be:\n  	  distance 0: 3b\n  	  distance 1: [3b-2..3b-1]\n  	  distance 2: [3b-4..3b-2]\n  	Note: distance d is only possible if d <= b.\n  \n  	total 15:\n  	b = 0..4:  impossible\n  	b = 5:     dist = 0\n  	b = 6:     dist = 2\n  	b = 7..10: impossible\n  \n  	For every total we have a number of explanations, which are\n  	(b, d) pairs where b is the best result and d is the distance.\n  \n  	The output of this function shows:\n  \n  	Except for 0, 1, 29 and 30, every total t has exactly 2 explanations:\n  	  ((t+2) div 3, 0|1)  and  ((t+4) div 3, 2)\n  	In other words, always one surprise option and one normal option.\n  	The surprise option can have a result one higher than the normal one or\n  	equal to it.\n  	'''\n  \n  	print '  ',\n  	for b in xrange(0, 11):\n  		print 'b=%d' % b,\n  	print\n  	for total in xrange(0, 31):\n  		print '%2d' % total,\n  		for b in xrange(0, 11):\n  			s = '0' if total == b * 3 else '.'\n  			s += '1' if b >= 1 and b * 3 - 2 <= total <= b * 3 - 1 else '.'\n  			s += '2' if b >= 2 and b * 3 - 4 <= total <= b * 3 - 2 else '.'\n  			print s,\n  		print\n  \n  \n  def solve(totals, surprises, points):\n  	countCertain = 0\n  	countSurprise = 0\n  	for total in totals:\n  		if (total + 2) / 3 >= points:\n  			countCertain += 1\n  		elif 2 <= total <= 28 and (total + 4) / 3 >= points:\n  			countSurprise += 1\n  		else:\n  			pass\n  \n  \n  	return countCertain + min(countSurprise, surprises)\n  \n  if __name__ == '__main__':\n  	inp = open(FILE_NAME_BASE + '.in.txt', 'r')\n  	numCases = int(inp.readline())\n  	if NUM_PROCESSES == 0:\n  		results = [\n  			solve(*parse(inp))\n  			for _ in range(numCases)\n  			]\n  	else:\n  		pool = Pool(NUM_PROCESSES)\n  		results = [\n  			pool.apply_async(solve, parse(inp))\n  			for _ in range(numCases)\n  			]\n  	inp.close()\n  	out = open(FILE_NAME_BASE + '.out.txt', 'w')\n  	for case, result in enumerate(results):\n  		value = result if NUM_PROCESSES == 0 else result.get()\n  		out.write('Case #%d: %s\n' % (case + 1, value))\n  		out.flush()\n  	out.close()\n <CODESPLIT> 34
 \n  FILE_NAME_BASE = 'D-small-attempt0'\n  NUM_PROCESSES = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  RECURSION_LIMIT = 1000\n  \n  \n  def parse(inp):\n  	numBlocks, = (int(x) for x in inp.readline().split())\n  	naomiBlocks = tuple(sorted(float(x) for x in inp.readline().split()))\n  	kenBlocks = tuple(sorted(float(x) for x in inp.readline().split()))\n  	assert len(naomiBlocks) == numBlocks\n  	assert len(kenBlocks) == numBlocks\n  	return naomiBlocks, kenBlocks\n  \n  def solve(naomiBlocks, kenBlocks):\n  	numBlocks = len(naomiBlocks)\n  \n  	kenPointsHonest = 0\n  	naomiLowerBlocks = 0\n  	for _, owner in sorted(chain(\n  			((b, 'n') for b in naomiBlocks),\n  			((b, 'k') for b in kenBlocks)\n  			)):\n  		if owner == 'n':\n  			naomiLowerBlocks += 1\n  		elif naomiLowerBlocks != 0:\n  			naomiLowerBlocks -= 1\n  			kenPointsHonest += 1\n  	naomiPointsHonest = numBlocks - kenPointsHonest\n  \n  	naomiLoIdx = 0\n  	naomiHiIdx = numBlocks - 1\n  	kenLoIdx = 0\n  	kenHiIdx = numBlocks - 1\n  	naomiPointsDeceit = 0\n  	while naomiLoIdx <= naomiHiIdx:\n  		assert naomiHiIdx - naomiLoIdx == kenHiIdx - kenLoIdx\n  		naomiLo = naomiBlocks[naomiLoIdx]\n  		kenLo = kenBlocks[kenLoIdx]\n  		if naomiLo > kenLo:\n  			naomiPointsDeceit += 1\n  			kenLoIdx += 1\n  		else:\n  			kenHiIdx -= 1\n  		naomiLoIdx += 1\n  \n  \n  	return '%d %d' % (naomiPointsDeceit, naomiPointsHonest)\n  \n  def main():\n  	sys.setrecursionlimit(RECURSION_LIMIT)\n  \n  	soft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  	inp = open(FILE_NAME_BASE + '.in', 'r')\n  	numCases = int(inp.readline())\n  	if NUM_PROCESSES == 0:\n  		results = [\n  			solve(*parse(inp))\n  			for _ in range(numCases)\n  			]\n  	else:\n  		pool = Pool(NUM_PROCESSES)\n  		results = [\n  			pool.apply_async(solve, parse(inp))\n  			for _ in range(numCases)\n  			]\n  	inp.close()\n  	out = open(FILE_NAME_BASE + '.out', 'w')\n  	for case, result in enumerate(results):\n  		value = result if NUM_PROCESSES == 0 else result.get()\n  		out.write('Case #%d: %s\n' % (case + 1, value))\n  		out.flush()\n  	out.close()\n  \n  if __name__ == '__main__':\n  	main()\n <CODESPLIT> 34
 \n  surprising = [[], [], [(0, 0, 2)], [(0, 1, 2)], [(0, 2, 2)], [(1, 1, 3)], [(1, 2, 3)], [(1, 3, 3)], [(2, 2, 4)], [(2, 3, 4)], [(2, 4, 4)], [(3, 3, 5)], [(3, 4, 5)], [(3, 5, 5)], [(4, 4, 6)], [(4, 5, 6)], [(4, 6, 6)], [(5, 5, 7)], [(5, 6, 7)], [(5, 7, 7)], [(6, 6, 8)], [(6, 7, 8)], [(6, 8, 8)], [(7, 7, 9)], [(7, 8, 9)], [(7, 9, 9)], [(8, 8, 10)], [(8, 9, 10)], [(8, 10, 10)], [], []]\n  regular = [[(0, 0, 0)], [(0, 0, 1)], [(0, 1, 1)], [(1, 1, 1)], [(1, 1, 2)], [(1, 2, 2)], [(2, 2, 2)], [(2, 2, 3)], [(2, 3, 3)], [(3, 3, 3)], [(3, 3, 4)], [(3, 4, 4)], [(4, 4, 4)], [(4, 4, 5)], [(4, 5, 5)], [(5, 5, 5)], [(5, 5, 6)], [(5, 6, 6)], [(6, 6, 6)], [(6, 6, 7)], [(6, 7, 7)], [(7, 7, 7)], [(7, 7, 8)], [(7, 8, 8)], [(8, 8, 8)], [(8, 8, 9)], [(8, 9, 9)], [(9, 9, 9)], [(9, 9, 10)], [(9, 10, 10)], [(10, 10, 10)]]\n  \n  f = open(argv[1], 'r')\n  T = int(f.readline().strip('\n'))\n  for i in range(T):\n  	both = 0\n  	surp_only = 0\n  	line = f.readline().strip('\n').split(' ')\n  	N = int(line[0]) # What for?\n  	S = int(line[1])\n  	p = int(line[2])\n  	ts = map(int, line[3:])\n  	for t in ts:\n  		if reduce(max, map(max, regular[t])) >= p:\n  			both += 1\n  		elif surprising[t] != [] and reduce(max, map(max, surprising[t])) >= p:\n  			surp_only += 1\n  \n  	print "Case #%s: %s" % (i + 1, both + min(surp_only, S))\n <CODESPLIT> 35
T = int(raw_input().strip())\n  \n  for i in xrange(T):\n  	N = int(raw_input().strip())\n  	naomi = sorted(map(float, raw_input().strip().split(' ')))\n  	ken = sorted(map(float, raw_input().strip().split(' ')))\n  \n  	war_score = N\n  	np = 0\n  	kp = 0\n  	while np < N and kp < N:\n  		while kp < N and naomi[np] >= ken[kp]:\n  			kp += 1\n  		if kp < N:\n  			kp += 1\n  			np += 1\n  			war_score -= 1\n  \n  	d_war_score = N\n  	best = None\n  	for start_from in xrange(N):\n  		j = 0\n  		good = True\n  		while start_from + j < N:\n  			if ken[j] >= naomi[start_from + j]:\n  				good = False\n  				break\n  			j += 1\n  		if good:\n  			best = N - start_from\n  			break\n  	if best is not None:\n  		d_war_score = best\n  	else:\n  		d_war_score = 0\n  \n  	print "Case #%s: %s %s" % (i + 1, d_war_score, war_score)\n <CODESPLIT> 35
inputFile = open("B-small-attempt0 (3).in", 'r')\n  outputFile = open("dancingOutSmall.txt", 'w')\n  numTests = int(inputFile.readline())\n  \n  def countDancers(n,s,p,totals):\n      guaranteed = 0\n      needSurprise = 0\n      if p == 1:\n          for total in totals:\n              if total != 0:\n                  guaranteed += 1\n          return guaranteed\n      for total in totals:\n          if total >= p*3 - 2:\n              guaranteed += 1\n          elif total >= p*3 - 4:\n              needSurprise += 1\n      if needSurprise > s:\n          return guaranteed + s\n      else:\n          return guaranteed + needSurprise\n  \n  for i in range(numTests):\n      line = inputFile.readline().split()\n      n = int(line[0])\n      s = int(line[1])\n      p = int(line[2])\n      totals = []\n      for j in range(n):\n          totals += [int(line[3+j])]\n      outputFile.write('Case #' + str(i+1) + ': ' + str(countDancers(n,s,p,totals)) + '\n')\n  \n  outputFile.close()\n <CODESPLIT> 36
inputFile = open('D-small-attempt0.in', 'r')\n  lines = inputFile.readlines()\n  inputFile.close()\n  \n  outputFile = open('D-small-attempt0.out', 'w')\n  \n  numTests = int(lines[0])\n  \n  def scoreWar(naomiNums, kenNums):\n      naomiInd = 0\n      kenInd = 0\n      while naomiInd < len(naomiNums):\n          naomiPlay = naomiNums[naomiInd]\n          while kenInd < len(kenNums) and kenNums[kenInd] < naomiPlay:\n              kenInd += 1\n          if kenInd == len(kenNums):\n              break\n          naomiInd += 1\n          kenInd += 1\n      return len(naomiNums) - naomiInd\n  \n  def scoreDeceit(naomiNums, kenNums):\n      naomiInd = 0\n      kenInd = 0\n      while kenInd < len(kenNums):\n          kenPlay = kenNums[kenInd]\n          while naomiInd < len(naomiNums) and naomiNums[naomiInd] < kenPlay:\n              naomiInd += 1\n          if naomiInd == len(naomiNums):\n              break\n          naomiInd += 1\n          kenInd += 1\n      return kenInd\n  \n  for i in range(1, numTests+1):\n      naomiNums = map(lambda x: float(x), lines[3*i-1].split())\n      kenNums = map(lambda x: float(x), lines[3*i].split())\n      naomiNums.sort()\n      kenNums.sort()\n      deceitScore = scoreDeceit(naomiNums, kenNums)\n      warScore = scoreWar(naomiNums, kenNums)\n      outputFile.write('Case #'+str(i)+': ' + str(deceitScore) + ' ' + str(warScore) + '\n')\n  \n  outputFile.close()\n <CODESPLIT> 36
directory = 'C:/users/hai/my projects/google code jam/2012/qualification/B/'\n  \n  \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      print ('Test cases : ',T)\n      for i in range(1,T+1):\n          line = f_in.readline()\n          nnn = [int(x) for x in line.split()]\n          S = nnn[1]\n          p = nnn[2]\n          t = nnn[3:]\n          if p > 1:\n              A = 0\n              B = 0\n              for t_i in t:\n                  if t_i >=3*p-2:\n                      A += 1\n                  elif t_i >= 3*p-4:\n                      B += 1\n              result = A + min(B,S)\n          if p == 1:\n              result = len([x for x in t if x>=1])\n          if p == 0:\n              result=  len(t)\n          f_out.write('Case #' + str(i) + ': ' + str(result) + '\n')\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n  \n  \n  \n  main_run()\n <CODESPLIT> 37
directory = 'C:/users/me/desktop/google code jam/2014/qualification/D/'\n  \n  \n  \n  \n  INCREASING = 501\n  DECREASING = 502\n  NO_ORDER = 503\n  \n  def play_war (l_n, l_k, inc_val):\n      assert inc_val in [INCREASING, DECREASING, NO_ORDER]\n      assert len(l_n) == len(l_k)\n      if inc_val == INCREASING:\n          l_n = list(sorted(l_n))\n      if inc_val == DECREASING:\n          l_n = list(reversed(sorted(l_n)))\n      l_k = list(sorted(l_k))\n      naomi_wins = 0\n      for i in range(len(l_n)):\n          val = l_n[0]\n          l_n = l_n[1:]\n          if l_k[-1] < val:\n              l_k = l_k[1:]\n              naomi_wins += 1\n          else:\n              for j in range(len(l_k)):\n                  if l_k[j] > val:\n                      del l_k[j]\n                      break\n  \n      return naomi_wins\n  \n  \n  def play_deceitful (l_n, l_k):\n      l_n = list(sorted(l_n))\n      l_k = list(sorted(l_k))\n      naomi_wins = 0\n      assert len(l_n) == len(l_k)\n      while len(l_n):\n          if l_n[-1] < l_k[-1]:\n              l_n = l_n[1:]\n              l_k = l_k[:-1]\n          else:\n              l_n = l_n[:-1]\n              l_k = l_k[:-1]\n              naomi_wins += 1\n      return naomi_wins\n              \n              \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          N = int(f_in.readline())\n          l_n = [float(x) for x in f_in.readline().split()]\n          l_k = [float(x) for x in f_in.readline().split()]\n  \n          a1 = play_war (l_n, l_k, INCREASING)\n          a2 = play_war (l_n, l_k, DECREASING)\n          a3 = play_war (l_n, l_k, NO_ORDER)\n          assert a1 == a2\n          assert a2 == a3\n          b = play_deceitful (l_n, l_k)\n  \n          f_out.write('Case #' + str(testcase) + ': ' + str(b) + ' ' + str(a1) + '\n')\n  \n  \n          \n          \n  \n      \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n  \n  def randomize_arrs (n):\n      l = []\n      for i in range(2*n):\n          r = choice(range(2**30))\n          while r in l:\n              r = choice(range(2**30))\n          l.append(r)\n      return l[:n], l[n:]\n  \n <CODESPLIT> 37
 \n  OEXT = ".out"\n  IN_S = "small.in"\n  IN_L = "large.in"\n  CASE_PRFX = "Case #%s: "\n  \n  \n  def avg(L):\n      return 1.0*sum(L)/len(L)\n  \n  triplets = [[0,0,0], [0,0,1], [0,1,1], \n              [0,0,2], [0,2,2], [0,1,2],\n              [10,10,9], [10,9,8], [10,9,9], [10, 10, 8],\n              ]\n  \n  def analyze_sum(sm, tgt):\n      av = 1.0 * sm / 3\n      av_cls = av % 1\n  \n      if av_cls > 0.1:\n          ns_max_val = math.ceil(av)\n      else:\n          ns_max_val = av \n      \n      s_max_val = 0 \n      if sm >= 2 and sm <= 28:\n          if av_cls > 0.5:\n              s_max_val = math.ceil(av) + 1\n          elif av_cls > 0.1:\n              s_max_val = math.ceil(av) \n          else:\n              s_max_val = av + 1\n      \n      if ns_max_val >= tgt:\n          res = [ns_max_val, None]\n          kind = 1\n      elif s_max_val < tgt:\n          res = [None, None]\n          kind = 0\n      else:\n          res = [None, s_max_val]\n          kind = 2\n          \n      print sm, tgt, av, av_cls, ns_max_val, s_max_val, res, kind\n      return res, kind\n  \n  def analyze_triplet(trip, tgt):\n      sm = sum(trip)\n      analyze_triplet(sm, tgt)\n      \n  \n  def read_input(filename):\n      data = []\n      with open(filename, "r") as f:\n          cases = int(f.readline())\n          for _ in xrange(cases):\n              case = f.readline().strip().split()\n              case = [int(c) for c in case]\n              data.append({"ngoog": case[0], "ssurp": case[1], "ptgt": case[2],\n                           "trips": case[3:]})\n      return data\n  \n  def make_output(fname, output):\n      fname = fname + OEXT\n      with open(fname, "w") as f:\n          restext = []\n          for i, v in enumerate(output):\n              restext.append(CASE_PRFX % (i+1,) + str(v) + "\n")\n          f.writelines(restext)\n      \n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for case in data:\n          ansys = [analyze_sum(c, case["ptgt"]) for c in case["trips"]]\n          non_surp_is_enough = len([k for _, k in ansys if k == 1])\n          surp_needed = len([k for _, k in ansys if k == 2])\n          if surp_needed >= case["ssurp"]:\n              res = non_surp_is_enough + case["ssurp"]\n          else:\n              res = non_surp_is_enough + surp_needed\n          output.append(res)\n      print "output:", output\n      make_output(fname, output)\n       \n  \n  main("examples.in")\n  main("small.in")\n <CODESPLIT> 38
 \n  \n  EOL = "\n"\n  \n  \n  def is_equal_approx(x, y, epsilon=1e-6):\n      """Returns True iff y is within relative or absolute 'epsilon' of x.\n      \n      By default, 'epsilon' is 1e-6.\n      """\n      if -epsilon <= x - y <= epsilon:\n          return True\n  \n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n          return False\n  \n      return (-epsilon <= (x - y) / x <= epsilon\n          or -epsilon <= (x - y) / y <= epsilon)\n    \n  def read_syms(fd):\n      """Read a line of whitespace separated symbols."""\n      return fd.readline().strip().split()\n  \n  def read_ints(fd):\n      """Read a line of whitespace separated integers."""\n      return [int(p) for p in read_syms(fd)]\n  \n  def read_floats(fd):\n      """Read a line of whitespace separated floats."""\n      return [float(p) for p in read_syms(fd)]\n  \n  \n  class Mtrx(object):\n      """A matrix object."""\n      \n      def __init__(self, rows, cols, data):\n          assert len(data) == rows * cols\n          self.rows = rows\n          self.cols = cols\n          self.data = data\n          \n      def cell(self, r, c):\n          return self.data[r * self.cols + c]\n      \n      def getrow(self, i):\n          return [self.cell(i, c) for c in xrange(self.cols)]\n  \n      def getcol(self, i):\n          return [self.cell(c, i) for c in xrange(self.rows)]\n      \n      @classmethod\n      def readfromfile(cls, fd, readfunc, rows=None, cols=None):\n          """Read matrix from file, assuming first line at location is `R C`.\n          \n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\n          Pre-determined size can be passed using `rows` and `cols`.\n          """\n          data = []\n          if rows is None:\n              assert cols is None\n              rows, cols = read_ints(fd)\n          else:\n              assert cols is not None\n          for _ in range(rows):\n              line = readfunc(fd)\n              assert len(line) == cols\n              data.extend(line)\n          return Mtrx(rows, cols, data)\n              \n      @classmethod\n      def read_int_matrix(cls, fd, rows=None, cols=None):\n          return cls.readfromfile(fd, read_ints, rows, cols)\n              \n      @classmethod\n      def read_sym_matrix(cls, fd, rows=None, cols=None):\n          return cls.readfromfile(fd, read_syms, rows, cols)\n              \n      def __str__(self):\n          res = ""\n          for i in xrange(self.rows):\n              res += str(self.getrow(i)) + EOL\n          return res\n      \n      def __repr__(self):\n          return "{}({}, {}, {})".format(self.__class__.__name__, self.rows,\n                                         self.cols, self.data)\n  \n  \n  cachetotals = 0\n  cachemisses = 0\n  \n  def statreset():\n      global cachemisses, cachetotals\n      cachemisses = 0\n      cachetotals = 0\n  \n  class memoizeit(object):\n      """Decorator. Caches a function's return value each time it is called.\n      \n      If called later with the same arguments, the cached value is returned \n      (not reevaluated).\n      """\n      \n      def __init__(self, func):\n          self.func = func\n          self.cache = {}\n          \n      def __call__(self, *args):\n          \n          global cachetotals, cachemisses\n          cachetotals += 1\n          \n          try:\n              return self.cache[args]\n          except KeyError:\n              \n              cachemisses += 1\n              \n              value = self.func(*args)\n              self.cache[args] = value\n              return value\n          except TypeError:\n  \n              cachemisses += 1\n  \n              return self.func(*args)\n      \n      @property\n      def __name__(self):\n          return self.func.__name__\n      \n      def __get__(self, obj, objtype):\n          """Support instance methods."""\n          return functools.partial(self.__call__, obj)\n  \n  \n  class timeit(object):\n      """Decorator that times a function.\n      \n      When function ends, print name, runtime, return value and cache stats.\n      """\n      \n      def __init__(self, func):\n          self.func = func\n          \n      def __call__(self, *args):\n          start = time.time()\n          value = self.func(*args)\n          delta = time.time() - start\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\n              cachetotals else 0\n          print self.func.__name__, "{:7.3f}s, (res: {}, cache: {:.2%})".format(\n              delta, value, cachedata)\n          return value\n      \n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n  \n  def read_input(filename):\n      data = []\n      with open(filename, "r") as f:\n          cases = read_ints(f)[0]\n          for _ in xrange(cases):\n              case = {}\n              case["N"] = read_ints(f)\n              case["Naomi"] = sorted(read_floats(f))\n              case["Ken"] = sorted(read_floats(f))\n              data.append(case)\n      return data\n  \n  def make_output(fname, output):\n      CASE_PRFX = "Case #%s: "\n      fname = fname + time.strftime("%H%M%S") + ".out"\n      with open(fname, "w") as f:\n          restext = []\n          print "Output content ==============="\n          for i, outdata in enumerate(output):\n              line = CASE_PRFX % (i + 1,) + str(outdata) + EOL\n              print line,\n              restext.append(line)\n          print "=" * 30\n          f.writelines(restext)\n  \n  \n  @timeit\n  def solveit(case):\n      ns = case["Naomi"]\n      ks = case["Ken"]\n      \n      nsmin = 0\n      ksmin = 0\n      \n      dwpoints = 0\n      while nsmin < len(ns):\n          if ns[nsmin] > ks[ksmin]:\n              ksmin += 1\n              dwpoints += 1 \n          nsmin += 1\n      \n      nsmax = len(ns) - 1\n      ksmin = 0\n      \n      wpoints = 0\n      while len(ks) >= ksmin + 1:\n          print ns, ks, nsmax, ksmin\n          if ns[nsmax] > ks[-1]:\n              ksmin += 1\n              wpoints += 1\n          else:\n              m = ksmin\n              for i in xrange(len(ks)-1, ksmin-1, -1):\n                  if ks[i] < ns[nsmax]:\n                      m = i + 1\n                      break\n              del ks[m]\n          nsmax -= 1\n      \n      return str(dwpoints) + " " + str(wpoints) \n  \n  \n  \n  @timeit\n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for case in data:\n          statreset() # reset cache stats\n          res = solveit(case)\n          output.append(res)\n      make_output(fname, output)\n  \n  \n  if __name__ == '__main__':\n      main("D-small-attempt0.in")\n <CODESPLIT> 38
f = open('cj2.in','r')\n  out = open('out1.txt','w')\n  inp = [[int(n) for n in s.split()] for s in f.readlines()]\n  \n  def score_partition(score):\n      poss = []\n      if score == 0:\n          return [[0,0,0]]\n      if score == 1:\n          return [[0,0,1]]\n      if score % 3 == 0:\n          poss.append([score/3,score/3,score/3])\n          poss.append([score/3-1,score/3,score/3+1])\n      if score % 3 == 1:\n          poss.append([score/3, score/3,score/3+1])\n          poss.append([score/3-1,score/3+1,score/3+1])\n      if score % 3 == 2:\n          poss.append([score/3,score/3+1,score/3+1])\n          poss.append([score/3,score/3,score/3+2])\n  \n      return poss\n  \n  \n  s = 0\n  c = 1\n  for e in inp[1:len(inp)]:\n      count = 0\n      surprises = e[1]\n      s = 0\n      p = e[2]\n      for i in e[3:len(e)]:\n          scores = score_partition(i)\n          for j in scores: \n              if max(j) >= p:\n                  if max(j)-min(j) == 2:\n                      if s < surprises:\n                          s +=1\n                          count +=1\n                          break\n                  else:\n                      count += 1\n                      break\n                  \n      out.write('Case #'+str(c)+': '+str(count)+'\n')\n      c += 1\n  \n  out.close()\n  f.close()\n                  \n          \n      \n      \n  \n      \n <CODESPLIT> 39
def war(n, k):\n      k.sort()\n      score = 0\n      for x in n:\n          for i  in xrange(len(k)):\n              if k[i] > x:\n                  score += 1\n                  k.pop(i)\n                  break\n      return len(n) - score    \n              \n  \n  def deceit(n, k):\n      n.sort()\n      k.sort()\n      score = 0\n      for y in k:\n          for i in xrange(len(n)):\n              if n[i] > y:\n                  score +=1\n                  n.pop(i)\n                  break\n      return score\n      \n  \n  f = open('Dsmall.in', 'r')\n  g = open('outputD.txt', 'w')\n  \n  data = [[float(e) for e in line.strip("\n").split(' ')] for line in f]\n  T = int(data.pop(0)[0])\n  c = 1\n  for i in xrange(0, T*3, 3):\n      N = data[i+1]\n      K = data[i+2]\n  \n      w = war(N, list(K))\n      d = deceit(list(N), list(K))\n      g.write('Case #%i: %i %i\n' %(c, d, w))\n      c += 1\n  \n  f.close()\n  g.close()\n  \n <CODESPLIT> 39
 \n  \n  \n  \n  \n  def solve(S, p, tlist):\n  	above = 0\n  	consider = 0\n  \n  	for t in tlist:\n  		avg = t / 3\n  		mod = t % 3\n  \n  		if mod == 0:\n  			if avg >= p:\n  				above += 1\n  			elif avg + 1 >= p and t > 0:\n  				consider += 1\n  \n  		elif mod == 1:\n  			if avg + 1 >= p:\n  				above += 1\n  \n  		elif mod == 2:\n  			if avg + 1 >= p:\n  				above += 1\n  			elif avg + 2 >= p:\n  				consider += 1\n  \n  	return above + min(S, consider)\n  \n  \n  def main(IN, OUT):\n  	N = int(IN.readline())\n  	for index in range(N):\n  		data = map(int, IN.readline().strip().split())\n  		(N, S, p), tlist = data[:3], data[3:]\n  		OUT.write('Case #%d: %d\n' % (index + 1, solve(S, p, tlist)))\n  \n  \n  if __name__ == '__main__':\n  	main(sys.stdin, sys.stdout)\n  \n <CODESPLIT> 40
 \n  \n  \n  def solve1(naomi, ken):\n      win = 0\n      while naomi:\n          chosenK = max(ken)\n          chosenN = min(filter(lambda mass: mass > chosenK, naomi) or naomi)\n          if chosenN > chosenK:\n              win += 1\n          naomi.remove(chosenN)\n          ken.remove(chosenK)\n      return win\n  \n  \n  def solve2(naomi, ken):\n      win = 0\n      while naomi:\n          chosenN = min(naomi)\n          chosenK = min(filter(lambda mass: mass > chosenN, ken) or ken)\n          if chosenN > chosenK:\n              win += 1\n          naomi.remove(chosenN)\n          ken.remove(chosenK)\n      return win\n  \n  \n  def main(IN, OUT):\n      T = int(IN.readline())\n      for index in range(T):\n          N = int(IN.readline())\n          naomi = map(float, IN.readline().split())\n          ken = map(float, IN.readline().split())\n          OUT.write('Case #%d: %d %d\n' % (index + 1, solve1(naomi[:], ken[:]), solve2(naomi[:], ken[:])))\n  \n  \n  def makesample(maxN=1000, T=50):\n      print T\n      for index in range(T):\n          N = random.randint(1, maxN)\n          print N\n          print ' '.join(map(str, (random.random() for n in range(N))))\n          print ' '.join(map(str, (random.random() for n in range(N))))\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n <CODESPLIT> 40
 \n  T = int(sys.stdin.readline())\n  for i in range(T):\n      line = sys.stdin.readline().strip()\n      values = map(int, line.split(' '))\n      N = values[0]\n      S = values[1]\n      p = values[2]\n      totals = values[3:]\n      ans = 0\n      for total in totals:\n          base = total / 3\n          remainder = total - (base * 3)\n          scores = [base, base, base]\n          j = 0\n          while remainder > 0:\n              scores[j] += 1\n              remainder -= 1\n              j = (j + 1) % 3\n          if max(scores) >= p:\n              ans += 1\n          else:\n              if S > 0:\n                  remainder = total - (base * 3)\n                  if remainder == 0 and base > 0:\n                      if base + 2 >= p:\n                          ans += 1\n                          S -= 1\n                  elif base + min(remainder, 2) >= p:\n                      ans += 1\n                      S -= 1\n      print 'Case #%s: %s' % (i+1, ans)\n <CODESPLIT> 41
 \n  def dwar(N, K):\n    N = sorted(N)\n    K = sorted(K)\n    \n    naomi = 0\n    \n    while len(N) > 0:\n      if N[-1] > K[-1]:\n        k = K.pop()\n        for i, n in enumerate(N):\n          if N[i] > k:\n            choosen = i\n            break\n        del(N[choosen])\n        naomi += 1\n      else:\n        N = N[1:]\n        k = K.pop()\n    return naomi\n  \n  def war(N, K):\n    N = sorted(N)\n    K = sorted(K)\n    \n    naomi = 0\n    while len(N) > 0:\n      n = N.pop()\n      chosen = None\n      for i, k in enumerate(K):\n        if k > n:\n          chosen = i\n          break\n      if not chosen == None:\n        del(K[chosen])\n      else:\n        naomi += 1\n    return naomi\n  \n  T = int(raw_input())\n  for t in range(T):\n    _ = raw_input()\n    N = map(float, raw_input().split())\n    K = map(float, raw_input().split())\n    \n    print 'Case #%i: %i %i' % (t+1, dwar(N, K), war(N, K))\n <CODESPLIT> 41
 \n  def threshold(p, maxdiff):\n      minval = max(p - maxdiff, 0)\n      return p + minval + minval\n  \n  def process_case(numdata):\n      N,S,p = numdata[0:3]\n      scores = numdata[3:]\n      thre_normal = threshold(p, 1)\n      thre_surprise = threshold(p, 2)\n      result = 0\n      for tot in scores:\n          if tot >= thre_normal:\n              result += 1\n          elif S > 0 and tot >= thre_surprise:\n              result += 1\n              S -= 1\n      return result\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          result = process_case(line_of_numbers(next(lines)))\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('B-small-attempt0')\n <CODESPLIT> 42
 \n  def war_points(N, naomi_sorted, ken_sorted):\n      j=0\n      naomi_points = 0\n      for i in range(N):\n          while j < N and naomi_sorted[i] > ken_sorted[j]:\n              j += 1\n          if j < N:\n              j += 1\n          else:\n              naomi_points += 1\n      return naomi_points\n      \n  def deceitful_war_points(N, naomi_sorted, ken_sorted):\n      j=0\n      naomi_points = 0\n      for i in range(N):\n          while j < N and ken_sorted[i] > naomi_sorted[j]:\n              j += 1\n          if j < N:\n              naomi_points += 1\n              j += 1\n      return naomi_points\n  \n  def process_case(N, naomi_sorted, ken_sorted):\n      x1 = deceitful_war_points(N, naomi_sorted, ken_sorted)\n      x2 = war_points(N, naomi_sorted, ken_sorted)\n      return (x1, x2)\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          N = int(next(lines))\n          naomi_sorted = line_of_floats_sorted(next(lines))\n          ken_sorted = line_of_floats_sorted(next(lines))\n          x1, x2 = process_case(N, naomi_sorted, ken_sorted)\n          yield 'Case #{0}: {1} {2}\n'.format(ci, x1, x2)\n      \n  def line_of_floats_sorted(s):\n      fv = [float(sub) for sub in s.split()]\n      fv.sort()\n      return fv\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('D-small-attempt0')\n <CODESPLIT> 42
"""Usage:\n      X.py < X.in > X.out\n  """\n  \n  \n  \n  class Solver(object):\n      cache = {}\n  \n      def __init__(self, infile, testcase):\n          self.testcase = testcase\n          self.P = P = map(int, infile.next().split())\n  \n      def init_cache(self):\n          if 'main' in self.cache:\n              return\n  \n      def solve(self):\n  \n          N, S, p = self.P[:3]\n          G = sorted(self.P[3:], reverse=True)\n  \n          r = 0\n          s = 0\n          for g in G:\n              if g >= 3 * p - 2 and g >= p:\n                  r += 1\n              elif g >= 3 * p - 4 and g >= p:\n                  if s == S:\n                      break\n                  r += 1\n                  s += 1\n  \n          return r\n  \n  \n  def main():\n      T = int(sys.stdin.next())\n      for t in xrange(T):\n          sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))\n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 43
"""Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  """\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, C=None, **ignore):\n      N = int(infile.next())\n      P = map(float, infile.next().split())\n      I = map(float, infile.next().split())\n      return locals()\n  \n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n  \n      N = sorted(P)\n      K = sorted(I)\n  \n      W = 0\n      ik = 0\n      for n in N:\n          while ik < len(K) and K[ik] < n:\n              ik += 1\n              W += 1\n          ik += 1\n  \n      D = 0\n      i = 0\n      for k in K:\n          while i < len(N) and N[i] < k:\n              i += 1\n          i += 1\n          if i <= len(N):\n              D += 1\n  \n      return 'Case #%s: %s %s\n' % (testcase, D, W)\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n <CODESPLIT> 43
 \n  def solve(n, s, p, scores):\n      count = 0\n      for t in scores:\n          if ceil(t/3) >= p:\n              count += 1\n          elif 2 <= t <= 28 and ceil((t+2)/3) >= p and s > 0:\n              count += 1\n              s -= 1\n      return count\n  \n  if __name__ == '__main__':\n      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n          T = int(fin.readline())\n          for case in range(1, T+1):\n              line = map(int, fin.readline().split())\n              n, s, p, *scores = line\n              result = solve(n, s, p, scores)\n              print("Case #{0}: {1}".format(case, result), file=fout)\n <CODESPLIT> 44
 \n  \n  def war(N, ns, ks):\n      """Return Naomi's score in regular War\n  \n      Strategy: Naomi and Ken both play their smallest possible block. When Ken\n      runs out of winning blocks, Naomi's score is the number of remaining blocks.\n  \n      Ken's strategy is to select the smallest block which will beat Naomi's\n      choice, or if there is none, then his smallest block.\n      """\n      i = 0   # position through naomi's blocks\n      j = 0   # position through ken's blocks\n  \n      while i < N:\n          while j < N and ks[j] < ns[i]:\n              j += 1\n  \n          if j == N:\n              break\n  \n          i += 1\n          j += 1\n  \n      return N - i\n  \n  def deceit(N, ns, ks):\n      """Return Naomi's score in Deceitful War\n  \n      Strategy: Naomi selects the smallest block with size > min(ks), and sets\n      Told_N > max(ks). Ken will choose to play min(ks), and lose the round.\n      If all of Naomi's blocks are smaller than all of Ken's, she cannot win any\n      more rounds, and her score is the number of blocks used (which is also equal\n      to N - the number of remaining blocks).\n  \n      This happens to be the same strategy as regular war, with ks and ns swapped,\n      and the final score subtracted from N. (At least, I'm pretty sure it'll work).\n      """\n      return N - war(N, ks, ns)\n  \n  \n  def solve(N, ns, ks):\n      ns.sort()\n      ks.sort()\n      return "{} {}".format(deceit(N, ns, ks), war(N, ns, ks))\n  \n  if __name__ == '__main__':\n      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n      with fin, fout:\n          T = int(fin.readline())\n          for case in xrange(1, T+1):\n              n = int(fin.readline())\n              ns = map(float, fin.readline().split())\n              ks = map(float, fin.readline().split())\n              soln = solve(n, ns, ks)\n              print >> fout, "Case #{0}: {1}".format(case, soln)\n  \n <CODESPLIT> 44
t = int(raw_input())\n  \n  max = [0, 1, 1, 2, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 7, 6, 7, 8, 7, 8, 9, 8, 9, 10, 9, 10, 10, 10]\n  \n  for i in range(t):\n  	line = raw_input().split(' ')\n  	n = int(line[0])\n  	s = int(line[1])\n  	p = int(line[2])\n  \n  	total = 0\n  \n  	for j in range(3, len(line)):\n  		t = int(line[j])\n  		if t == 0:\n  			if p == 0:\n  				total += 1\n  		elif t%3 == 0:\n  			if t/3 >= p:\n  				total +=1\n  			elif t/3 + 1 >= p and s>0:\n  				total +=1\n  				s -=1\n  		elif t%3 == 1:\n  			if (t+2)/3 >= p:\n  				total +=1\n  		else:\n  			if (t+1)/3 >= p:\n  				total +=1\n  			elif (t+1)/3 + 1 >= p and s>0:\n  				total +=1\n  				s -=1\n  \n  \n  \n  	print 'Case #'+str(i+1)+':', total\n  \n  \n <CODESPLIT> 45
t = int(raw_input())\n  \n  for case in range(t):\n  	n = int(raw_input())\n  	naomi = [float(i) for i in raw_input().split()]\n  	ken = [float(i) for i in raw_input().split()]\n  \n  	naomi.sort()\n  	ken.sort()\n  	y = 0\n  	z = 0\n  \n  \n  	na = naomi[:]\n  	ke = ken[:]\n  	while len(na) > 0:\n  		nc = na.pop(0)\n  		kc = -1\n  		for i in range(len(ke)):\n  			if ke[i] > nc:\n  				kc = ke.pop(i)\n  				break\n  		if kc == -1:\n  			kc = ke.pop(0)\n  		if nc > kc:\n  			z += 1\n  \n  \n  	na = naomi[:]\n  	ke = ken[:]\n  	while len(ke) > 0:\n  		kc = ke.pop(0)\n  		nc = -1\n  		for i in range(len(na)):\n  			if na[i] > kc:\n  				nc = na.pop(i)\n  				break\n  		if nc == -1:\n  			nc = na.pop(0)\n  		if nc > kc:\n  			y += 1\n  \n  	print 'Case #'+str(case+1)+':', y, z\n <CODESPLIT> 45
data_dict = {}\n  init = False\n  \n  \n  def partB(infile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/input3.txt",\\n                outfile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/output.txt"):\n      \n      linesA = []\n      for line in open(infile, 'r'):\n          linesA.append(line.strip())\n  \n      outA = []\n          \n      T = int(linesA[0])\n      for i in range(1, 1 + T):\n          caseA = linesA[i].split()\n          N = int(caseA[0])\n          S = int(caseA[1])\n          P = int(caseA[2])\n          \n          over_norm = 0\n          over_supr = 0\n          \n          for t in [int(conv) for conv in caseA[3:3+N]]:\n              if data_dict[t][0] >= P:\n                  over_norm += 1\n              elif data_dict[t][1] >= P:\n                  over_supr += 1\n          \n          outA.append(over_norm + min(over_supr, S))\n              \n              \n          \n      \n      out = open(outfile, 'w')\n      print "\nOUTPUT"\n      for i in range(1, 1 + T):\n          if i != 1:\n              out.write("\n")\n          print "Case #" + str(i) + ": " +str(outA[i-1])\n          out.write("Case #" + str(i) + ": " +str(outA[i-1]))\n      out.close()\n  \n  def dict_helper(total, depth=0, lowest=10):\n      pass\n  \n  def build_dict():\n      for i in range(31):\n          fullA = []\n          maxN = 0\n          maxS = 0\n          print str(i) + ": "\n          for a1 in range(0,11):\n              for a2 in range(0,11):\n                  for a3 in range(0,11):\n                      if (a1 + a2 + a3 == i) and (max(a1,a2,a3)-min(a1,a2,a3) <3):\n                          fullA.append((a1,a2,a3))\n                          \n                          print "\t", fullA[-1],\n                          if max(a1,a2,a3)-min(a1,a2,a3) == 2:\n                              print "*"\n                              maxS = max(maxN, max(a1,a2,a3))\n                          else:\n                              print\n                              maxN = max(maxN, max(a1,a2,a3))\n          data_dict[i]=[maxN, maxS]\n      init = True\n      \n  if __name__ == "__main__":\n      build_dict()\n      partB()\n <CODESPLIT> 46
__author__ = 'Jeffrey'\n  \n  inFileName = "C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\D-small-attempt0.in"\n  \n  outFileName = inFileName[: -2] + "out"\n  \n  \n  def parseInput(f):\n      T = int(f.readline())\n      L = []\n  \n      for i in range(T):\n          f.readline()\n          L.append(([float(j) for j in f.readline().split()], [float(j) for j in f.readline().split()]))\n          L[-1][0].sort()\n          L[-1][1].sort()\n  \n      return T, L\n  \n  \n  def calculateScores(naomi, ken):\n      return [calcDeceit(naomi, ken), calcHonest(naomi, ken)]\n  \n  def calcDeceit(naomi, ken):\n      wins = 0\n      while len(naomi) > 0:\n          if naomi[-1] > ken[-1]:\n              naomi = naomi[ : -1]\n              ken = ken[ : -1]\n              wins += 1\n          else:\n              naomi = naomi[1: ]\n              ken = ken[ : -1]\n      return wins\n  \n  def calcHonest(naomi, ken):\n      wins = 0\n      while len(naomi) > 0:\n          n = naomi.pop(0)\n          k = ken[0]\n          for i in range(len(ken)):\n              kTemp = ken[i]\n              if kTemp > n:\n                  k = ken.pop(i)\n                  break\n          else:\n              ken.pop(0)\n              wins += 1\n      return wins\n  \n  \n  \n  def playGame(T, L):\n      for i in range(T):\n          result = calculateScores(L[i][0], L[i][1])\n          yield "Case #{}: {} {}".format(i + 1, result[0], result[1])\n  \n  \n  if __name__ == "__main__":\n      iF = open(inFileName, 'r')\n      T, L = parseInput(iF)\n      iF.close()\n  \n      print(T)\n      for l in L:\n          print()\n          for k in l:\n              print(k)\n  \n      oF = open(outFileName, "wb")\n      for out in playGame(T, L):\n          print(out)\n          oF.write(bytes(out + "\n", 'utf-8'))\n      oF.close()\n <CODESPLIT> 46
 \n  def solve(icase, case_input):\n      case_output = 'Case #%i: '%icase\n      \n      result = 0\n      raw = [int(x) for x in case_input[0].split()]\n      ts = raw[3:]\n      ct = raw[1]\n      n = raw[2]\n      cc = 0\n      for i in ts:\n          if i > 3*n-3:\n              result += 1\n          elif i > max(3*n-5, 0):\n              cc += 1\n      result += min(cc, ct)\n  \n      case_output += '%d'%result\n      \n      return case_output\n  \n  \n  def main():\n      global use_test_data\n      global test_data\n      global input_file\n      global output_file\n      \n      if use_test_data:\n          data = [x.strip() for x in test_data.split('\n')]\n      else:\n          data = [x.strip() for x in input_file.readlines()]\n      \n      T = int(data[0])\n      iLine = 1\n      caseLineNum = 1\n      for icase in range(1, T + 1):\n          input = []\n          for i in range(caseLineNum):\n              input.append(data[iLine])\n              iLine += 1\n          rslt = solve(icase, input)\n          print rslt\n          if not use_test_data:\n              print >> output_file, rslt\n      \n      if not use_test_data:\n          input_file.close()\n          output_file.close()\n      \n      \n  if __name__ == '__main__':\n      test_data = """4\n  3 1 5 15 13 11\n  3 0 8 23 22 21\n  2 1 1 8 0\n  6 2 8 29 20 8 18 18 21\n  """\n      use_test_data = False\n      \n      test_file = 'B-small-attempt0.in'\n      if not use_test_data and '' != test_file:\n          input_file = open(test_file)\n          output_file = open(test_file + '.out', 'w')\n      \n      main()\n <CODESPLIT> 47
 \n  class Solver(object):\n      def __init__(self):\n          pass\n      \n      def solve(self, inputs):\n          nn = [float(x) for x in inputs[1].split()]\n          nn.sort()\n          kk = [float(x) for x in inputs[2].split()]\n          kk.sort()\n          dw = self.dwar(nn[:], kk[:])\n          w = self.war(nn[:], kk[:])\n          return '%d %d'%(dw, w)\n          pass\n      \n      def dwar(self, nn, kk):\n          turn = len(nn)\n          cnt = 0\n          for i in range(turn):\n              i = i\n              if nn[-1] < kk[-1]:\n                  nn.pop(0)\n                  kk.pop(-1)\n              elif nn[0] < kk[0]:\n                  nn.pop(0)\n                  kk.pop(-1)\n              else:\n                  cnt += 1\n                  nn.pop(0)\n                  kk.pop(0)\n          return cnt\n      \n      def war(self, nn, kk):\n          turn = len(nn)\n          cnt = 0\n          for i in range(turn):\n              i = i\n              j = bisect.bisect_left(kk, nn[0])\n              if j == len(kk):\n                  cnt += 1\n                  kk.pop(0)\n              else:\n                  kk.pop(j)\n              nn.pop(0)\n          return cnt\n      \n      def feed(self, inputs):\n          lines = [x.strip() for x in inputs]\n          outputs = []\n          test_case_n = int(lines[0])\n          cur = 1\n          for i in range(test_case_n):\n              i = i\n              case_line_cnt = 3\n              case_inputs = lines[cur:cur+case_line_cnt]\n              cur += case_line_cnt\n              outputs.append(self.solve(case_inputs))\n          return outputs\n  \n  if __name__ == '__main__':\n      iname = 'D-small-attempt0.in'\n      sample_in = '''\n  4\n  1\n  0.5\n  0.6\n  2\n  0.7 0.2\n  0.8 0.3\n  3\n  0.5 0.1 0.9\n  0.6 0.4 0.3\n  9\n  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n      '''\n      sample_out = '''\n  Case #1: 0 0\n  Case #2: 1 0\n  Case #3: 2 1\n  Case #4: 8 4\n      '''\n      if os.path.exists(iname):\n          with open(iname) as f:\n              inputs = f.readlines()\n      else:\n          inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n      solver = Solver()\n      outputs = solver.feed(inputs)\n      fail_flag = False\n      if os.path.exists(iname):\n          with open(iname+'.out', 'w') as f:\n              for i, v in enumerate(outputs):\n                  print >> f, 'Case #%d: %s'%(i+1, str(v))\n      else:\n          ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])\n          for i, v in enumerate(outputs):\n              t = 'Case #%d: %s'%(i+1, str(v))\n              if t not in ans:\n                  print '!!! Wrong:', t\n                  fail_flag = True\n      print '===================================================='\n      for i, v in enumerate(outputs):\n          print 'Case #%d: %s'%(i+1, str(v))\n      print '===================================================='\n      print 'done' if not fail_flag else 'fail'\n      pass\n <CODESPLIT> 47
 \n  \n  \n  D1 = {} # no suprize\n  D2 = {} # surprize\n  for i in xrange(0, 31):\n      D1[i] = D2[i] = -1\n  \n  def precompute():\n      for a in xrange(0, 11):\n          for b in xrange(a, min(a+3,11)):\n              for c in xrange(b, min(a+3,11)):\n                  t = a+b+c\n                  assert a <= b <= c <= a+2 and c <= 11\n                  if c < a+2:\n                      D1[t] = max(D1[t], c)\n                  else: # that is, c == a+2, we have a suprize\n                      D2[t] = max(D2[t], c)\n  \n  \n  precompute()\n  \n  def case(S, P, ts):\n      res_n = 0\n      res_s = 0\n      for t in ts:\n          if D1[t] >= P:\n              res_n+=1\n          elif D2[t]>=P:\n              res_s+=1\n      return (res_n + min(res_s, S))\n  \n  \n  def solve(fin, fout):\n      T = int(fin.readline())\n      for t in xrange(T):\n          nums = map(int, fin.readline().strip().split(" "))\n          N, S, P = nums[:3]\n          ts = nums[3:]\n          assert len(ts) == N    \n          fout.write("Case #%i: %i\n" % (t+1, case(S,P,ts)) )\n      return True\n  \n  if __name__ == "__main__":\n      with open(sys.argv[1],'r') as fin:\n          with open(sys.argv[2], 'w') as fout:\n              solve(fin, fout)\n <CODESPLIT> 48
def CASE(IN):\n      def rstr(): return IN.readline().strip()\n      def rint(): return int(rstr())\n      def rfs(): return map(float, rstr().split())\n      N = rint()\n      A = sorted(rfs())\n      B = sorted(rfs())\n      dwar = solve(N, A, B)\n      war = N - solve(N, B, A)\n      return "%i %i" % (dwar, war)\n  \n  \n  def solve(N, A, B):\n      i, j = 0, 0\n      while True:\n          while j < N and A[j] < B[i]:\n              j += 1\n          if j == N:\n              return i\n          i += 1\n          j += 1\n  \n  \n  def RUN(IN, OUT):\n      t = int(IN.readline().strip())\n      for i in xrange(1,t+1):\n          OUT.write("Case #%i: %s\n" % (i, CASE(IN)))\n  \n  if __name__ == "__main__":\n      RUN(sys.stdin, sys.stdout)\n <CODESPLIT> 48
def max_of_triplets(n):\n      a = n//3\n      if (n % 3) == 0:\n          if a == 0 : return (0,0)\n          return (a, a+1)\n      if (n % 3) == 1:\n          return (a+1, a+1)\n      if a == 9: return (10, 10)\n      return (a+1, a+2)\n  \n  def solve(scores, S, p):\n      t = 0\n      for s in scores:\n          a,b = max_of_triplets(s)\n          if a >= p:\n              t += 1\n          elif b >= p and S > 0:\n              t += 1\n              S -= 1\n      return t\n  \n  if __name__ == "__main__":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          nums = map(int, raw_input().strip().split())\n          N = nums[0]\n          S = nums[1]\n          p = nums[2]\n          scores = nums[3:]\n          if len(scores) != N:\n              print "WTF", i\n          print "Case #%d: %d" % (i, solve(scores, S, p))\n      \n <CODESPLIT> 49
def solve(naomi, ken):\n      N = list(sorted(naomi))\n      K = list(sorted(ken))\n      pd = 0\n      while len(N) > 0:\n          if N[0] > K[0]:\n              pd += 1\n              N.pop(0)\n              K.pop(0)\n          else:\n              N.pop(0)\n              K.pop(-1)\n      pn = 0\n      N = list(sorted(naomi))\n      K = list(sorted(ken))\n      while len(N) > 0:\n          n = N.pop(0)\n          if n < K[0]:\n              K.pop(0)\n          else:\n              found = None\n              for i,k in enumerate(K):\n                  if k > n:\n                      found = i\n                      break\n              if found is not None:\n                  K.pop(found)\n              else:\n                  K.pop(0)\n                  pn += 1\n      return pd,pn\n  \n  if __name__=="__main__":\n      T = int(raw_input())\n      for i in range(1,T+1):\n          raw_input()\n          naomi = map(float, raw_input().split())\n          ken = map(float, raw_input().split())\n          x,y = solve(naomi,ken)\n          print "Case #%d: %d %d" %(i,x,y)\n <CODESPLIT> 49
 \n  \n  if __name__ == "__main__":\n  \n      f = open( "B-small-attempt1.in.txt" )\n      g = open( "output_small.txt", "w" )\n  \n      f.readline()\n      line = f.readline()\n      caseI = 1\n      while line != "":\n          line = [ int(x) for x in line.split() ]\n          N = line[0]\n          surprise = line[1]\n          p = line[2]\n          points = line[3:]\n          points.sort()\n          points.reverse()\n  \n          maxp = 0\n          either = 0\n          make_surprise = 0\n          for x in points:\n              this_p = (x+2)/3\n              if x in [0,1,29,30]:\n                  if this_p >= p:\n                      maxp += 1\n              elif this_p >= p:\n                  either += 1\n                  maxp += 1\n              elif this_p == p-1 and (x+2)%3 > 0:\n                  make_surprise += 1\n              else:\n                  either += 1\n  \n          if make_surprise >= surprise:\n              make_surprise -= surprise\n              maxp += surprise\n              make_surprise = 0\n          else:\n              maxp += make_surprise\n  \n          g.write( "Case #%s: %s\n"%(caseI,maxp) )\n  \n          line = f.readline()\n          caseI += 1\n  \n      f.close()\n      g.close()\n      \n <CODESPLIT> 50
 \n  f = open(sys.argv[1])\n  f.readline()\n  \n  numCase = 1\n  l = f.readline()\n  while l != "":\n  	n = [float(x) for x in f.readline().split()]\n  	k = [float(x) for x in f.readline().split()]\n  \n  	n.sort()\n  	nd = deque(n)\n  	k.sort()\n  	kd = deque(k)\n  \n  	war = 0\n  	while len(nd) > 0:\n  		nblock = nd.pop()\n  		if nblock > kd[-1]:\n  			kd.popleft()\n  			war += 1\n  		else:\n  			kd.pop()\n  \n  	all = [ (x,1) for x in n ]\n  	all.extend( [(x,2) for x in k] )\n  	all.sort()\n  \n  	dwar = 0\n  	nd = deque(n)\n  	kd = deque(k)\n  	while len(nd) > 0:\n  		if nd[0] < kd[0]:\n  			kd.pop()\n  		else:\n  			kd.popleft()\n  			dwar += 1\n  		nd.popleft()\n  		\n  	print "Case #"+str(numCase)+ ": "+str(dwar)+" "+str(war)\n  	\n  \n  	numCase += 1\n  	l = f.readline()\n <CODESPLIT> 50
def build_table():\n  	table = []\n  	for i in range( 0, 31 ):\n  		table.append( ( get_max_score( i ), get_max_surprise_score( i ) ) )\n  \n  	return table\n  \n  \n  def get_max_score( i ):\n  	return max( 0, min( 10, ( i + 2 ) / 3 ) )\n  \n  def get_max_surprise_score( i ):\n  	return min( i, max( 0, min( 10, ( i + 4 ) / 3 ) ) )\n  \n  def get_max( x, scores, score_needed, num_surprises ):\n  	scores = sorted( scores, reverse=True )\n  	numPass = 0\n  	i = 0;\n  	while ( i < len(scores) ):\n  		if ( x[scores[i]][0] >= score_needed ):\n  			numPass += 1\n  		else:\n  			break\n  		i += 1\n  \n  	while ( i < len(scores) and num_surprises > 0 ):\n  		if ( x[scores[i]][1] >= score_needed ):\n  			numPass += 1\n  			num_surprises -= 1\n  			\n  		i += 1\n  \n  	return numPass\n  \n  x = build_table()\n  \n  num_cases = input()\n  \n  for i in range( 1, num_cases + 1 ):\n  	line = raw_input().split()\n  	num_surprises = int(line[1])\n  	score_needed = int(line[2])\n  	scores_raw = line[3:]\n  \n  	scores = [ int(y) for y in scores_raw ]\n  \n  	print 'Case #' + str( i ) + ': ' + str( get_max( x, scores, score_needed, num_surprises ) )\n <CODESPLIT> 51
 \n  numCases = input()\n  for case in range( 1, numCases + 1 ):\n    N = input()\n    Naomis = list( [float(x) for x in raw_input().split() ] )\n    Kens = list( [float(x) for x in raw_input().split() ] )\n    Naomis = sorted( Naomis )\n    Kens = sorted( Kens )\n  \n    NaomisOptimal = Naomis[:]\n    KensOptimal = Kens[:]\n  \n    KenScore = 0\n    for i in xrange( 0, N ):\n      Naomi = NaomisOptimal.pop()\n      x = bisect_left( KensOptimal, Naomi )\n      if x < len( KensOptimal ):\n        KenScore += 1\n        del KensOptimal[ x ]\n      else:\n        del KensOptimal[ 0 ]\n  \n    NScore = 0\n    for i in xrange( 0, N ):\n      Naomi = Naomis[0]\n      del Naomis[0]\n      x = bisect_left( Kens, Naomi )\n      if x == 0:\n        Kens.pop()\n      else:\n        NScore += 1\n        del Kens[ 0 ]\n  \n      output = str( NScore ) + ' ' + str( N - KenScore )\n    \n    print 'Case #' + str( case ) + ': ' + str( output )\n <CODESPLIT> 51
 \n  def readint():\n      return int(sys.stdin.readline())\n  \n  def readintarray():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  def readpairs(start=0):\n      elems = readintarray()[start:]\n      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n  \n  def readstring():\n      return sys.stdin.readline()[:-1]\n  \n <CODESPLIT> 52
 \n  def readint():\n      return int(sys.stdin.readline())\n  \n  def readfloatarray():\n      return map(float, sys.stdin.readline().strip().split())\n  \n  def readintarray():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  def readpairs(start=0):\n      elems = readintarray()[start:]\n      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n  \n  def readstring():\n      return sys.stdin.readline()[:-1]\n  \n <CODESPLIT> 52
def passes(p, t): #normal, surprising\n      q, r = divmod(t, 3)\n      if r == 0:\n          return q >= p, q + 1 >= p and q\n      elif r == 1:\n          return q + 1 >= p, q + 1 >= p and q\n      elif r == 2:\n          return q + 1 >= p, q + 2 >= p\n  \n  for case in range(int(input())):\n      st = input().strip().split()\n      n, s, p, t = int(st[0]), int(st[1]), int(st[2]), list(map(int, st[3:]))\n      result = 0\n      for i in t:\n          normal, surprising = passes(p, i)\n          if normal:\n              result += 1\n          elif surprising and s != 0:\n              result += 1\n              s -= 1\n      print("Case #{}: {}".format(case + 1, result))\n <CODESPLIT> 53
 \n  \n  def optimal_war_step(blocks, value):\n  \n      win_blocks = set(filter(lambda block: block > value, blocks))\n      blocks.discard(min(win_blocks if win_blocks else blocks))\n      return bool(win_blocks)\n  \n  \n  def deceitful_war(ken, naomi, epsilon = 10 ** (-6)):\n  \n      while ken:\n  \n          min_ken = min(ken)\n          max_ken = max(ken)\n          min_naomi = min(naomi)\n  \n          if min_ken > min_naomi and any(map(lambda bs: operator.lt(*bs), zip(sorted(naomi), sorted(ken)))):\n  \n              yield max_ken - epsilon\n  \n          else:\n  \n              yield 1.0 - epsilon\n  \n          naomi.discard(min_naomi)\n  \n  \n  for i in range(int(input())):\n  \n      input()\n      naomi = set(map(float, str.split(input())))\n      ken = set(map(float, str.split(input())))\n  \n      dwar_ken = ken.copy()\n      dwar_naomi = naomi.copy()\n      dwar = collections.Counter(map(functools.partial(optimal_war_step, dwar_ken), deceitful_war(dwar_ken, dwar_naomi)))\n      war = collections.Counter(map(functools.partial(optimal_war_step, ken), naomi))\n      print(str.format("Case #{}: {} {}", i + 1, dwar[False], war[False]))\n <CODESPLIT> 53
 \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  for i in range(num):\n      res = [int(x) for x in f.readline().split()]\n      nrg, nrsup, score = res[0:3]\n      del res[0:3]\n      nrpass = 0\n      nrsuppass = 0\n      for x in res:\n          if score > 1:\n              if x >= 3*score-2:\n                  nrpass += 1\n              elif x >= 3*score-4:\n                  nrsuppass += 1\n          elif score == 1:\n              if x > 0:\n                  nrpass += 1\n          else:\n              nrpass +=1\n      print 'Case #{}:'.format(i+1), nrpass + min(nrsup, nrsuppass)\n <CODESPLIT> 54
 \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  for i in range(num):\n      f.readline()\n      na = [float(x) for x in f.readline().split()]\n      ke = [float(x) for x in f.readline().split()]\n      na.sort()\n      ke.sort()\n      dw = 0\n      index = 0\n      for x in ke:\n          while index < len(na) and na[index] <= x:\n              index += 1\n          if index == len(na):\n              break\n          dw += 1\n          index += 1\n      w = 0\n      index = 0\n      na.reverse()\n      ke.reverse()\n      for x in na:\n          if ke[index] > x:\n              index += 1\n          else:\n              w += 1\n      print 'Case #{}: {} {}'.format(i+1, dw, w)\n <CODESPLIT> 54
 \n  main = interact (unlines . map showCase . zip [1..] . tail . lines)\n    where\n      showCase (i, t) = "Case #" ++ show i ++ ": " ++ solve t\n  \n  solve = show . solve' . map read . words\n    where\n      solve' (n:s:p:ts) = \n          let pts = map maxPoints ts\n              directs = filter ((>= p) . fst) pts\n              surps = filter (\(pd, ps) -> pd < p && ps >= p) pts\n          in length directs + min (length surps) s\n          \n  maxPoints :: Int -> (Int, Int)\n  maxPoints tot = \n      (maxScore $ scores normal, maxScore $ scores surprising)\n    where\n      scores cond = [ (x, y, z) |\n          x <- [0..10], y <- [0..10], z <- [0..10]\n          , x + y + z == tot, cond (x, y, z)\n          ]\n      normal t = bestScore t - badScore t <= 1\n      surprising t = bestScore t - badScore t <= 2\n      maxScore = maximum . map bestScore \n  \n  bestScore (x, y, z) = maximum [x, y, z]\n  badScore (x, y, z) = minimum [x, y, z]\n <CODESPLIT> 55
 \n  \n  data Test = Test {\n        joueur     :: [Double]\n      , adversaire :: [Double]\n      } deriving Show\n  \n  data Solution = Solution Int Int\n  \n  instance Show Solution where\n      show (Solution a b) = show a ++ " " ++ show b\n  \n  main = do\n      interact (unlines . map showCase . zip [1..] . map resoudre . goTest . tail . lines)\n  \n    where\n      goTest [] = []\n      goTest (_:js:as:ls) =\n          Test (map read $ words js) (map read $ words as) : goTest ls\n  \n      showCase :: (Int, Solution) -> String\n      showCase (i, s) = printf "Case #%d: %s" i (show s)\n  \n  resoudre :: Test -> Solution\n  resoudre Test {..} =\n      let jou    = S.fromList joueur\n          adv    = S.fromList adversaire\n          war    = goWar adv (sort joueur)\n          deceit = goDeceit (reverse $ sort adversaire) jou\n      in Solution deceit war\n    where\n      goWar _   []     = 0\n      goWar adv (j:js) =\n          case S.lookupGT j adv of\n              Just e  -> goWar (S.delete e adv)               js     -- Perd ce jeu\n              Nothing -> goWar (S.delete (S.findMin adv) adv) js + 1 -- Gagne ce jeu\n  \n      goDeceit []     _   = 0\n      goDeceit (a:as) jou =\n          -- Première étape : tente d'éliminer le plus gros chiffre restant de\n          -- l'adversaire.\n          case S.lookupGT a jou of\n              Just e  ->\n                  -- Elimine le plus gros pion de l'adversaire et gagne.\n                  goDeceit as (S.delete e jou) + 1\n              Nothing ->\n                  -- Deuxième étape: incapable de l'éliminer, sacrifie un\n                  -- point en forcant l'adversaire à jouer ce pion, en\n                  -- utilisant le plus petit point et en mentant sur son\n                  -- poids.\n                  let minJou = S.findMin jou\n                  in goDeceit as (S.delete minJou jou)\n <CODESPLIT> 55
 \n  '''\n  Limits: T in [1,100], S in [0,N], p in [0,10], Ti in [0, 30]\n  At least S of the ti values will be between 2 and 28, inclusive.\n  \n  Small dataset 1 = N = 3.\n  Large dataset 1 = N = 100.\n  \n  Sample Input \n  4\n  3 1 5 15 13 11\n  3 0 8 23 22 21\n  2 1 1 8 0\n  6 2 8 29 20 8 18 18 21\n  \n  Output \n  Case #1: 3\n  Case #2: 2\n  Case #3: 1\n  Case #4: 3\n  '''\n  \n  \n  \n  inf = open(sys.argv[1])\n  def input(): return inf.readline().strip()\n  \n  def maxBestDancers(N, S, p, *Ti):\n      cnt = 0\n      for score in Ti:\n          mx = (score + 2) // 3\n          if mx >= p:\n              cnt += 1\n          elif mx >= p-1 > 0 and S>0:\n              S -= 1\n              cnt += 1\n      return cnt\n  \n  for caseNo in range(1, int(input())+1):\n      print 'Case #%d:' % caseNo,\n      lst = map(int, input().split())\n      print maxBestDancers(*lst)\n  \n <CODESPLIT> 56
 \n  '''\n  Input\n  The first line of the input gives the number of test cases, T. T test cases follow. \n  Each test case starts with a line containing a single integer N, the number of blocks \n  each player has. Next follows a line containing N space-separated real numbers: \n  the masses of Naomi's blocks, in kg. Finally there will be a line containing N \n  space-separated real numbers: the masses of Ken's blocks, in kg.\n  \n  Output\n  For each test case, output one line containing "Case #x: y z", where \n  x is the test case number (starting from 1), \n  y is the number of points Naomi will score if she plays Deceitful War optimally, and \n  z is the number of points Naomi will score if she plays War optimally.\n  \n  Limits\n  1 <= T <= 50.\n  All the masses given to Ken and Naomi are distinct, and between 0.0 and 1.0 exclusive.\n  \n  Small dataset\n  1 <= N <= 10.\n  \n  Large dataset\n  1 <= N <= 1000.\n  \n  ---Input \n  4\n  1\n  0.5\n  0.6\n  2\n  0.7 0.2\n  0.8 0.3\n  3\n  0.5 0.1 0.9\n  0.6 0.4 0.3\n  9\n  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n  \n  ---Output \n  Case #1: 0 0\n  Case #2: 1 0\n  Case #3: 2 1\n  Case #4: 8 4\n  \n  \n  '''\n  \n  \n  f = open(sys.argv[1])\n  def input(): return f.readline().strip();\n  \n  \n  \n  def deceitfulWar(Naomi, Ken):\n      Naomi = Naomi[:]\n      Ken = Ken[:]\n      pts = 0\n      while Naomi and Ken and Naomi[-1] > Ken[0]:\n          kn = Ken.pop(0)\n          for i in range(len(Naomi)):\n              if Naomi[i] > kn:\n                  Naomi.pop(i)\n                  break\n          pts += 1        \n  \n      return pts\n  \n  def war(Naomi, Ken):\n      Naomi = Naomi[:]\n      Ken = Ken[:]\n      pts = 0\n      while Naomi and Ken:\n          nm = Naomi.pop(0)\n          if nm > Ken[-1]:\n              Ken.pop(0)\n              pts += 1\n          else:\n              for i in range(len(Ken)):\n                  if Ken[i] > nm:\n                      Ken.pop(i)\n                      break          \n      return pts\n  \n  \n  for caseNo in xrange(1, int(input())+1):\n      _ = input()\n      Naomi = sorted(map(float, input().split()))\n      Ken = sorted(map(float, input().split()))\n      print 'Case #%d:' % caseNo, deceitfulWar(Naomi, Ken), war(Naomi, Ken)\n      \n  \n  \n <CODESPLIT> 56
T = int(raw_input())\n  \n  for z in xrange(1, T+1):\n      a = map(int, raw_input().split())\n      s, p = a[1:3]\n      a = a[3:]\n      A = 0 if p == 0 else 3*p - 2\n      B = 0 if p == 0 else 1 if p == 1 else 3*p-4\n      x = len(filter(lambda x: x >= A, a))\n      y = len(filter(lambda x: x >= B, a)) - x\n      res = x + min(s, y)\n      print "Case #%d:" % z, res\n <CODESPLIT> 57
T = int(raw_input())\n  \n  def solve(a, b):\n      n = len(a)\n      a.sort()\n      b.sort()\n      i = j = m = M = 0\n      while i < n:\n          if a[i] > b[j]:\n              M += 1\n              i += 1\n              j += 1\n          else:\n              i += 1\n      i = j = 0\n      while j < n:\n          if b[j] > a[i]:\n              m += 1\n              i += 1\n              j += 1\n          else:\n              j += 1\n      return str(M) + " " + str(n-m)\n  \n  for z in xrange(T):\n      n = int(raw_input())\n      a = map(float, raw_input().split())\n      b = map(float, raw_input().split())\n      print "Case #%d: %s" % (z+1, solve(a, b))\n <CODESPLIT> 57
 \n  t = int(sys.stdin.readline())\n  for i in range(t):\n  	inputline = sys.stdin.readline().strip()\n  	inputparams = inputline.split()\n  \n  	n = int(inputparams[0])\n  	s = int(inputparams[1])\n  	p = int(inputparams[2])\n  	validcount = 0\n  	surprisingcount = 0\n  	for j in range(n):\n  		score = int(inputparams[3 + j])\n  		if (p + (p - 1) * 2) <= score:\n  			validcount += 1\n  		elif ((p + (p - 2) * 2) <= score) and (p <= score):\n  			surprisingcount += 1\n  \n  	print "Case #%d: %d" % (i + 1, validcount + min(surprisingcount, s))\n <CODESPLIT> 58
 \n  def play_war(b1, b2):\n  	if 0 == len(b1):\n  		return 0\n  		\n  	if b1[0] > b2[0]:\n  		b1.pop(0)\n  		b2.pop()\n  		return 1 + play_war(b1, b2)\n  	else:\n  		b1.pop(0)\n  		b2.pop(0)\n  		return play_war(b1, b2)\n  		\n  def play_deceitful_war(b1, b2):\n  	if 0 == len(b1):\n  		return 0\n  		\n  	i = len(b1) - 1\n  	while (i >= 0) and (b1[i] < b2[len(b2) - 1]):\n  		i -= 1\n  		\n  	if i < 0:\n  		return 0\n  	\n  	\n  	b1.pop(i)\n  	b2.pop()\n  \n  	return 1 + play_deceitful_war(b1, b2)\n  \n  \n  t = int(sys.stdin.readline().strip())\n  \n  for i in range(t):\n  	print "Case #" + str(i + 1) + ":",\n  \n  	n = int(sys.stdin.readline().strip())\n  	\n  	blocks1 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)\n  	blocks2 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)\n  \n  	print play_deceitful_war(list(blocks1), list(blocks2)), play_war(blocks1, blocks2)\n  	\n <CODESPLIT> 58
 """\n  GCJ framework (gcj.fw.framework)\n   - Command Line and Package interface\n   - output redirection\n   - parsing case input\n   - executing problem code against cases\n   - testing framework\n  """\n  \n  class Framework(object):\n      class Case(object):\n          def __init__(self, caseNumber, caseData=None):\n              self.number = caseNumber\n              self.data = caseData\n              self.result = None\n      \n          @classmethod\n          def parser(cls, f_in):\n              pass\n      \n          def run(self):\n              pass\n      \n          def execute(self, f_in=None):\n              if self.data is None:\n                  self.data = self.parser(f_in)\n              self.result = self.run(**self.data)\n      \n          def __str__(self):\n              return "Case #%d: %s" % (self.number, self.result)\n      \n      \n      class Result(object):\n          def __init__(self, resultData):\n              self.data = resultData\n      \n          def __str__(self):\n              return str(self.ata)\n  \n      def __init__(self, f_in, f_out):\n          sys.stdout = f_out\n          self.f_in = f_in if f_in is not None else sys.stdin\n  \n      def run(self):\n          nCases = int(self.f_in.readline().strip())\n          for num in xrange(nCases):\n              case = type(self).Case(num+1)\n              case.execute( f_in=self.f_in)\n              print case\n  \n  \n      @classmethod\n      def __main__(cls):\n          f_in = sys.stdin\n          if len(sys.argv) > 1:\n              if sys.argv[1] == "-t":\n                  unittest.main()\n                  sys.exit()\n              f_in = open(sys.argv[1])\n          framework = cls(f_in, sys.stdout)\n          framework.run()\n      \n  class Test(unittest.TestCase):\n      cases = []\n      case = None\n      c=[]\n      \n      def setUp(self):\n          self.c = []\n          self.defineCases()\n          counter = 1\n          self.cases = []\n          for c in self.c:\n              case = self.case(counter)\n              case.data = case.parser(StringIO.StringIO(c[0]))\n              self.cases.append( [case, c[1]])\n      \n      def defineCases(self):\n          pass\n      \n      def tearDown(self):\n          pass \n  \n      def test_Name(self):\n          self.setUp()\n          for case in self.cases:\n              print case[0].data, case[1]\n              case[0].execute()\n              self.assertEqual(case[0].result, case[1])\n  '''\n  Created on Apr 8, 2012\n  \n  @author: Joe\n  '''\n  \n  \n  class B(Framework):\n      class Case(Framework.Case):\n          def parser(self, fh):\n              args = map(int, fh.readline().strip().split(" "))\n              N,S,p = args[:3]\n              scores = args[3:] \n              return {"N":N,"S":S,"p":p,"scores":scores}\n          \n          def run(self, N=None,S=None,p=None,scores=None):\n              ret = 0\n              surps = 0\n              for score in scores:\n                  if p > 0 and score == 0: continue\n                  if 3*p-2 <= score:\n                      ret += 1\n                  else:\n                      if 3*p - 4 <= score:\n                          surps += 1\n              return str(ret + min(surps,S))\n              \n  class Test(Test):\n      def defineCases(self):\n          self.case = B.Case\n          self.c = [\n                    ["3 1 5 15 13 11","3"],\n                    ["3 0 8 23 22 21","2"],\n                    ["2 1 1 8 0","1"],\n                    ["6 2 8 29 20 8 18 18 21","3"],\n                    ["1 1 1 1", "1"]\n                    ]\n  \n  if __name__ == "__main__":\n      B.__main__()\n      \n <CODESPLIT> 59
__author__ = 'jrokicki'\n  \n  RL = lambda: sys.stdin.readline().strip()\n  IA = lambda: map(int, RL().split(" "))\n  LA = lambda: map(long, RL().split(" "))\n  FA = lambda: map(float, RL().split(" "))\n  \n  T = int(sys.stdin.readline())\n  \n  def war(N,K):\n      """\n      strategy: N plays lowest number first, K chooses next best number\n      """\n      if len(N) == 0: return 0\n      n = N[0]\n      if K[-1] > n:\n          k = len(K)-1\n          for k in range(len(K)-1):\n              if K[k] > n and K[k+1] > n:\n                  break\n          if K[k] < n: k += 1\n          K = K[:k] + K[k+1:]\n          return war(N[1:],K)\n      else:\n          return 1 + war(N[1:], K[1:])\n  \n  def beawoman(N,K):\n      if len(N) == 0: return 0\n      n = N[0]\n      bad = False\n      for i in range(len(N)):\n          if N[i] < K[i]:\n              bad = True\n      if bad:\n          return beawoman(N[1:], K[:-1])\n      else:\n          return 1 + beawoman(N[:-1], K[:-1])\n  \n  for CASE in range(T):\n      RL()\n      N = FA()\n      K = FA()\n      N.sort()\n      K.sort()\n      answer = "%d %d" % (beawoman(N,K), war(N,K))\n      print "Case #%d: %s" % (CASE+1, answer)\n  \n <CODESPLIT> 59
 \n  f = file("B-small-attempt0.in")\n  w = file("answer.txt", "w")\n  cnt = int(f.readline()[:-1])\n  for no in range(cnt):\n  	l = f.readline()[:-1].split()\n  	T, s, p = map(int, l[:3])\n  	ts = map(int, l[3:])\n  	ns = p*3-2 if p*3-2 > 0 else 0\n  	ss = p*3-4 if p*3-4 > 0 else 31\n  	l = filter(lambda x: x<ns, ts)\n  	c = min([len(filter(lambda x: x>=ss, l)), s])\n  	\n  	print>>w, "Case #%d:"%(no+1), T-len(l)+c\n  \n  \n <CODESPLIT> 60
 \n  \n  lines = iter('''\n  4\n  1\n  0.5\n  0.6\n  2\n  0.7 0.2\n  0.8 0.3\n  3\n  0.5 0.1 0.9\n  0.6 0.4 0.3\n  9\n  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n  '''.splitlines(False)[1:])\n  out = sys.stdout\n  \n  sys.setrecursionlimit(1500)\n  \n  lines = iter(open(r'D-small-attempt2.in').readlines(False))\n  out = open('d-small.answer', 'w')\n  \n  \n  caseCnt = int(next(lines))\n  \n  def solve(N, K):\n  	if N == [] and K == []:\n  		return 0\n  	if K[-1] > N[-1]:\n  		return solve(N[:-1], K[1:])\n  	else:\n  		return solve(N[:-1], K[:-1])+1\n  \n  for case in range(1, caseCnt+1):\n  	C = int(next(lines))\n  	N = sorted(map(float, next(lines).split()), reverse=True)\n  	K = sorted(map(float, next(lines).split()), reverse=True)\n  	\n  	\n  	W=0\n  	k = 0\n  	for i, n in enumerate(N):\n  		if n < K[k]:\n  			k += 1\n  		else:\n  			W += 1\n  	\n  	D = solve(N, K)\n  	print('Case #%d: %d %d'%(case, D, W), file=out)\n  	\n <CODESPLIT> 60
 \n  def solve(N,S,p,t):\n      if p == 0:\n          return N\n      outright_wins = 0\n      potential_surprises = 0\n      win_cutoff = (p * 3) - 3\n      surprise_cutoff = win_cutoff - 2\n      for score in t:\n          if score == 0:\n              continue\n          elif score > win_cutoff:\n              outright_wins += 1\n          elif score > surprise_cutoff:\n              potential_surprises += 1\n      if potential_surprises < S:\n          return outright_wins + potential_surprises\n      else:\n          return outright_wins + S\n  \n  def parse_case(data_line):\n      bits = data_line.split()\n      N = int(bits[0])\n      S = int(bits[1])\n      p = int(bits[2])\n      t = [int(x) for x in bits[3:]]\n      return N,S,p,t\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option("-f", "--file", dest="filename",\n                        help="read input from FILE", metavar="FILE")\n  \n      (options, args) = parser.parse_args()\n      if not options.filename:\n          parser.error("Must provide a filename.")\n      input_file = open(options.filename, "r")\n      total_cases = int(input_file.readline())\n      case_number = 0\n      while case_number < total_cases:\n      	case_number += 1\n      	data_args = parse_case(input_file.readline())\n      	print "Case #%d: %d" % (case_number, solve(*data_args))\n  \n  if __name__ == "__main__":\n  	main()\n <CODESPLIT> 61
 \n  \n  TEST_CASES = [\n      ("""4\n  1\n  0.5\n  0.6\n  2\n  0.7 0.2\n  0.8 0.3\n  3\n  0.5 0.1 0.9\n  0.6 0.4 0.3\n  9\n  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n  ""","""Case #1: 0 0\n  Case #2: 1 0\n  Case #3: 2 1\n  Case #4: 8 4\n  """)\n  ]\n  \n  def parse_input(input_reader):\n      case_count = int(input_reader.readline())\n      case_idx = 0\n      while case_count > case_idx:\n          case_idx += 1\n          block_count = int(input_reader.readline())\n          naomi_blocks = [float(x) for x in input_reader.readline().split(" ")]\n          ken_blocks = [float(x) for x in input_reader.readline().split(" ")]\n          input_values = {"case":case_idx,\n                          "naomi": naomi_blocks,\n                          "ken": ken_blocks,\n                          "block_count": block_count\n                          }\n          yield input_values\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      ken = sorted(kwargs["ken"])\n      naomi = sorted(kwargs["naomi"])\n      case = kwargs["case"]\n      block_count = kwargs["block_count"]\n  \n      dw_idx = 0\n      w_idx = 0\n  \n      w_score = 0\n      dw_score = 0\n  \n      for block in naomi:\n          if block > ken[dw_idx]:\n              dw_score += 1\n              dw_idx += 1\n      naomi = sorted(naomi, key=lambda x: -x)\n      ken = sorted(ken, key=lambda x: -x)\n      for block in naomi:\n          if block > ken[w_idx]:\n              w_score += 1\n          else:\n              w_idx += 1\n  \n      print >> output_writer, "Case #%d: %d %d" % (case, dw_score, w_score)\n  \n      \n  \n  def solve_inputs(input_reader, output_writer):\n      """\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      """\n      for input_values in parse_input(input_reader):\n          solve_problem(output_writer=output_writer, **input_values)\n  \n  def run_tests():\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          input_reader = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(input_reader, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print "Test %d: Success" % idx\n          else:\n              all_pass = False\n              print "Test %d: Failure" % idx\n          input_reader.close()\n          output_writer.close()\n      if all_pass:\n          print "All tests were successful!"\n      else:\n          print "Something didn't match - try again."\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option("-f", "--file",\n                        dest="filename_stem",\n                        help="read input from FILE.in and write to FILE.out",\n                        metavar="FILE")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print "Running in file mode."\n          input_reader = open("%s.in" % options.filename_stem, "r")\n          output_writer = open("%s.out" % options.filename_stem, "w")\n          solve_inputs(input_reader, output_writer)\n      else:\n          print "Running in test mode."\n          run_tests()\n  \n  if __name__ == "__main__":\n      main()\n <CODESPLIT> 61
 \n  __file__ = sys.argv[0]\n  __path__ = os.path.dirname(__file__)\n  __prob__ = os.path.basename(__path__)\n  \n  def pout(s, back=0):\n      f = sys._getframe(back+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))\n  \n  def perr(s, back=0):\n      f = sys._getframe(back+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))\n  \n  def argmin(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best > y:\n              best = y\n              res = x\n      return res\n  \n  def argmax(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best < y:\n              best = y\n              res = x\n      return res\n  \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_word_arr(f, R):\n      res = []\n      for i in range(R):\n          res.append(read_word(f))\n      return res\n  \n  def read_ints_arr(f, R, dtype=int, *args, **kwargs):\n      res = []\n      for i in range(R):\n          res.append(read_ints(f, *args, **kwargs))\n      return numpy.array(res, dtype)\n  \n  def solve(solver, fn, start_case=0, end_case=None, out_fn=None):\n      global ERR_FILE\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      err_fn = fn + '.err'\n      if start_case == 0:\n          append = True\n          if os.path.exists(out_fn):\n              with open(out_fn, 'r') as f:\n                  for l in f:\n                      if l[:6] == 'Case #':\n                          start_case = int(l[6:l.index(':')])+1\n      else:\n          append = False\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'a' if append else 'w') as fo:\n              with open(err_fn, 'w') as ERR_FILE:\n                  T = read_int(fi)\n                  for i in range(T):\n                      case = read_case(fi)\n                      if i+1 < start_case:\n                          continue\n                      print('Case #%d of %d'%(i+1, T))\n                      ERR_FILE.write('Case #%d of %d\n'%(i+1, T))\n                      perr('case')\n                      res = solver(case)\n                      perr('res')\n                      write_case(fo, i, res)\n                      fo.flush()\n                      if end_case is not None and i+1 == end_case:\n                          break\n  \n  def test(start_case=1, end_case=None):\n      fn = os.path.join(__path__, 'test')\n      solve(solve_small, fn, start_case, end_case)\n  \n  def small(start_case=1, end_case=None):\n      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n      solve(solve_small, fn, start_case, end_case)\n  \n  def small2(start_case=1, end_case=None):\n      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n      solve(solve_large, fn, start_case, end_case, fn + '2.out')\n  \n  def large(start_case=0, end_case=None):\n      fn = os.path.join(__path__, '%s-large-attempt0'%__prob__)\n      solve(solve_large, fn, start_case, end_case)\n  \n  \n  def read_case(f):\n      Z = read_ints(f)\n      (N, S, p) = Z[:3]\n      t = Z[3:]\n      return (N, S, p, t)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%(i+1))\n      f.write('%s'%res)\n      f.write('\n')\n  \n  FAIL = 'NO SOLUTION'\n  \n  def solve_small(case):\n      (N, S, p, t) = case\n      res = 0\n      for i in range(N):\n          if p >= 2:\n              if t[i] >= 3*p-2:\n                  res += 1\n              elif S > 0 and t[i] >= 3*p-4:\n                  res += 1\n                  S -= 1\n          elif p == 1:\n              if t[i] >= 3*p-2:\n                  res += 1\n          elif p == 0:\n              res += 1\n      return res\n  \n  solve_large = solve_small\n  \n  pout = perr\n <CODESPLIT> 62
 \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_letters(f):\n      return list(read_word(f))\n  \n  def read_digits(f, b=10):\n      return [int(x, b) for x in read_letters(f)]\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_floats(f, d=' '):\n      return [float(x) for x in read_words(f, d)]\n  \n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\n      return [reader(f, *args, **kwargs) for i in range(R)]\n  \n  def solve(solver, fn, out_fn=None):\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(f):\n      N = read_int(f)\n      MN = read_floats(f)\n      MK = read_floats(f)\n      return (N, MN, MK)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%i)\n      f.write('%d %d'%res)\n      f.write('\n')\n  \n  \n  def solve_small(case):\n      (N, MN, MK) = case\n      MN = sorted(MN)\n      MK = sorted(MK)\n      y = 0\n      i = 0\n      for j in range(N):\n          while i < N and MN[i] < MK[j]:\n              i += 1\n          if i < N:\n              y += 1\n              i += 1\n      z = N\n      j = 0\n      for i in range(N):\n          while j < N and MN[i] > MK[j]:\n              j += 1\n          if j < N:\n              z -= 1\n              j += 1\n      return (y, z)\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'i'\n  \n <CODESPLIT> 62
 \n  def program():\n  	T = int(stdin.readline())\n  	for Ti in xrange(T):\n  		numbers = a = map(int, stdin.readline().rstrip().split(' '))\n  		N, S, p, totals = numbers[0], numbers[1], numbers[2], numbers[3:]\n  		\n  		m = 0\n  		curr_S = S\n  		for i in xrange(N):\n  			t = totals[i]\n  			\n  			if t / 3 >= p or (t / 3 == p - 1 and t % 3 > 0):\n  				m += 1\n  			elif curr_S > 0 and t > 0:\n  				if (t / 3 == p - 1 and t % 3 == 0) or (t / 3 == p - 2 and t % 3 == 2):\n  					m += 1\n  					curr_S -= 1\n  		\n  		print 'Case #%d: %d' % (Ti + 1, m)	\n  	\n  if __name__ == '__main__':\n  	program()\n <CODESPLIT> 63
 \n  \n  def read_str(): return stdin.readline().rstrip('\n')\n  def read_int(): return int(stdin.readline())\n  def read_ints(): return map(int, stdin.readline().split())\n  def read_floats(): return map(float, stdin.readline().split())\n  \n      \n  def war(N, K):\n      points = 0\n      j = 0\n      for i in range(len(N)):\n          while j < len(K) and K[j] < N[i]:\n              j += 1\n          if j == len(K):\n              points += 1\n          else:\n              j += 1\n      return points\n  \n  \n  def deceitful_war(N, K):\n      return len(N) - war(K, N)\n      \n  \n  def solve_case():\n      read_int()\n      N = sorted(read_floats())\n      K = sorted(read_floats())\n      \n      return '{} {}'.format(deceitful_war(N, K), war(N, K))\n  \n      \n  def main():\n      cases = read_int()\n      for case in range(1, cases + 1):\n          print('Case #{}: {}'.format(case, solve_case()))\n  \n          \n  main()\n <CODESPLIT> 63
n_cases = input()\n  \n  for case in xrange(1, n_cases + 1):\n      ins = map(int, raw_input().strip().split())\n      n = ins[0]\n      s = ins[1]\n      p = ins[2]\n      t = ins[3:]\n  \n      out = 0\n      for x in t:\n          if (x + 2) / 3 >= p:\n              out += 1\n          elif s and x > p and p - ((x - p) / 2) <= 2:\n              out += 1\n              s -= 1\n              \n      print "Case #%d: %s" % (case, out)\n <CODESPLIT> 64
 if len(sys.argv) == 1:\n      sys.stdin = open("D.in")\n  else:\n      sys.stdin = open(sys.argv[1])\n  \n  def to_floats(s):\n      return map(float, s.split())\n  \n  def get_floats():\n      return to_floats(raw_input())\n  \n  n_cases = input()\n  \n  \n  def cheat(our_blocks, opp_blocks):\n      n_blocks = len(our_blocks)\n      burned = 0\n      while any(our_blocks[x+burned] < opp_blocks[x] for x in xrange(0, n_blocks - burned)):\n          burned += 1\n      return n_blocks - burned\n  \n  def fair(our_blocks, opp_blocks):\n      score = 0\n      opp_left, opp_right = 0, len(opp_blocks)-1\n      for our in our_blocks:\n          for n, opp in enumerate(opp_blocks):\n              if opp > our:\n                  opp_blocks.pop(n)\n                  break\n          else:\n              score += 1\n              opp_blocks.pop(0)\n      return score\n  \n  for case in xrange(1, n_cases + 1):\n      n_blocks, = get_floats()\n      our_blocks = sorted(get_floats())\n      opp_blocks = sorted(get_floats())\n  \n      deceitful_score = cheat(our_blocks, opp_blocks)\n      fair_score = fair(our_blocks, opp_blocks)\n  \n      print "Case #%d: %d %d" % (case, deceitful_score, fair_score)\n <CODESPLIT> 64
 \n  \n  poss = dict([(i, {}) for i in xrange(0, 30 + 1)])\n  for a, b, c in itertools.product(range(10 + 1), repeat=3):\n      if a <= b <= c and c - a <= 2:\n          n = a + b + c\n          if c - a == 2:\n              poss[n]['s'] = tuple(sorted((a, b, c)))\n          else:\n              poss[n]['n'] = tuple(sorted((a, b, c)))\n  \n  \n  T = int(raw_input())\n  for case in xrange(1, T + 1):\n      div = map(int, raw_input().split())\n      N, S, p = div[:3]\n      t = div[3:]\n  \n      ans = 0\n      t.sort(reverse=True)\n      for i in xrange(len(t)):\n          na, nb, nc = poss[t[i]]['n']\n          sa, sb, sc = poss[t[i]].get('s', (-1, -1, -1))\n          if p <= nc:\n              ans += 1\n          elif 0 < S and p <= sc:\n              ans += 1\n              S -= 1\n  \n      print 'Case #%d: %d' % (case, ans)\n  \n <CODESPLIT> 65
 \n  \n  T = int(raw_input())\n  for test_case in xrange(1, T + 1):\n      N = int(raw_input())\n      W1 = sorted(map(float, raw_input().split()))\n      W2 = sorted(map(float, raw_input().split()))\n  \n      y = 0\n      c1 = c2 = 0\n      while c1 < N and c2 < N:\n          if W2[c2] < W1[c1]:\n              y += 1\n              c1 += 1\n              c2 += 1\n          while c1 < N and c2 < N and W1[c1] < W2[c2]:\n              c1 += 1\n  \n      z = N\n      c1 = c2 = 0\n      while c1 < N and c2 < N:\n          if W1[c1] < W2[c2]:\n              z -= 1\n              c1 += 1\n              c2 += 1\n          while c1 < N and c2 < N and W2[c2] < W1[c1]:\n              c2 += 1\n  \n      print 'Case #{}: {} {}'.format(test_case, y, z)\n <CODESPLIT> 65
