{"code": "lst = [1,4,9,121,484,10201,12321,14641,40804,44944,1002001,1234321,4008004,\n      100020001,102030201,104060401,121242121,123454321,125686521,400080004,\n      404090404,10000200001,10221412201,12102420121,12345654321,40000800004,\n      1000002000001,1002003002001,1004006004001,1020304030201,1022325232201,\n      1024348434201,1210024200121,1212225222121,1214428244121,1232346432321,\n      1234567654321,4000008000004,4004009004004,100000020000001,100220141022001,\n      102012040210201,102234363432201,121000242000121,121242363242121,123212464212321,\n      123456787654321,400000080000004]\n  \n  \n  def solve(lo,h\u200di):\n      global lst\n      count = 0\n      for i in range(len(lst)):\n          if (lst[i] >= lo and lst[i] <= h\u200di ):\n              count += 1\n      return count\n  \n  f\u200bname = raw_input(\"name of file: \")\n  oname = raw_input(\"output file name:\")\n  f = open(f\u200bname,\"r\")\n  out = open(oname,\"w\")\n  n = int(f.readline()[:-1])\n  case_num = 1\n  for line in f:\n      args = line[:-1].split()\n      lo = int(args[0])\n      h\u200di = int(args[1])\n      out.write(\"Case #%d: %d\n\" %(case_num,solve(lo,h\u200di)))\n      case_num += 1\n      \n  out.close()\n  f.close()\n      \n", "substitutes": {"lst": [" lnt", "lST", "elsts", " lsts", "fst", "lsc", "lsst", "liST", "rst", "lists", "Lest", "slsts", "lnt", " lstr", "lstr", "elstr", "elst", "fbl", "Lstr", "slST", "Lbl", "rST", "rstr", "slbl", "lbl", "lint", "slst", "fsc", "elST", "llsts", " lST", "lssts", "Lsc", "lsts", "llst", "llST", "lest", "list", "fstr", "llbl", "Lsts", "LST", "lsST", "lsnt", "Lst", " lsc", "rest", "elest", " lbl"], "lo": ["cro", "cli", "bi", "left", "loc", "o", "lie", "si", "elo", "mo", "bo", "ilo", "lin", "low", "Lo", "little", "zo", "ino", "no", "le", "co", "flo", "lc", "po", "l", "mi", "os", "bug", "li", "ri", "lf", "loop", "ne", "ano", "ln", "los", "oa", "la", "cho", "olo", "lim", "so", "hi", "oo", "LO", "pl", "ro", "ko", "go", "log"], "h": ["sh", "adh", "o", "d", "b", "w", "r", "help", "u", "ph", "v", "g", "c", "han", "hh", "ih", "hr", "oh", "rh", "eh", "l", "hp", "q", "hs", "hum", "gh", "he", "e", "j", "hm", "hd", "ha", "H", "hy", "ah", "cl", "m", "p", "hi", "hash", "uh"], "count": ["left", "coll", "name", "test", "case", "error", "int", "col", "low", "c", "Count", "num", "call", "code", "weight", "base", "cond", "start", "length", "nt", "max", "val", "type", "id", "counter", "cache", "number", "conf", "index", "list", "found", "len", "last", "all", "current", "size", "log", "limit", "sum", "level"], "i": ["bi", "qi", "im", "ci", "yi", "d", "si", "b", "r", "z", "ni", "eni", "io", "int", "col", "ie", "ind", "vi", "iw", "c", "multi", "x", "ini", "ih", "ii", "ix", "iq", "l", "mi", "start", "uri", "li", "ri", "iu", "ai", "ui", "type", "id", "arg", "j", "it", "ti", "y", "index", "ip", "list", "iter", "uni", "di", "pi", "p", "xi", "inter", "phi", "gi", "I"], "oname": ["offime", "onma", "onename", "Oname", "Onoe", " onma", "offename", "onames", "onsame", "ONames", "Onma", "ONename", "onsename", "OName", "Onename", "offma", " onoe", "onsames", "ONime", " onename", "offame", "onsime", "offoe", "onime", "onoe", "offames"], "f": ["fen", "bf", "o", "fa", "d", "b", "t", "w", "r", " F", "u", "fp", "fo", "ref", "fat", "input", "io", "v", "fc", "g", "c", "front", "cf", "re", "x", "per", "fs", "F", "fe", "sf", "alf", "xf", "fd", "af", "fb", "feed", "l", "tf", "fn", "en", "df", "e", "fit", "z", "aff", "form", "j", "y", "fr", "frame", "rf", "s", "fi", "ff", "m", "p", "up", "ft", "fun", "file"], "out": ["OUT", "o", "name", "group", "wx", "w", "t", "fast", "net", "fp", "error", "at", "io", "v", "ex", "ext", "g", "c", "print", "ch", "co", "exp", "obj", "call", "err", "l", "gen", "full", "block", "flat", "ln", "copy", "Out", "cache", "conf", "again", "output", "outs", "up", "p", "outer", "log", "user", "file"], "n": ["arn", "o", "name", "d", "b", "w", "r", "nc", "gn", "un", "pn", "nu", "c", "g", "no", "kn", "num", "l", "li", "fn", "nt", "unn", "en", "ne", "sn", "ln", "mn", "e", "pen", "on", "byn", "y", "number", "nr", "nb", "nm", "rn", "len", "ns", "cn", "size", "non", "m", "N", "p", "yn", "pron", "dn", "inn"], "case_num": ["case2index", "case2no", "case__name", "case__num", "case_no", "case2num", "case_index", "Case_no", "case_name", "case_sum", "Case_index", "Case_number", "case_number", " case_number", "case_Num", " case_Num", " case_name", "Case_num", "case2number", "case__sum", " case_sum", "case__number"], "line": ["str", "name", "pos", "string", "range", "case", "int", "col", "inline", "lin", "no", "response", "num", "header", "obj", "row", "code", "err", "LINE", "l", "cell", "unit", "lf", "block", "e", "ln", "page", "arg", "number", "frame", "iter", "word", "end", "entry", "object", "Line", "log", "lines", "file"], "args": ["enc", "py", "loc", "arr", "pos", "extra", "gs", "ds", "axis", "ants", "init", "params", "atts", "g", "spec", "doc", "abs", "argument", "got", "data", "obj", "err", "yrs", "years", "cs", "dict", "ins", "vals", "arg", "words", "Args", "ms", "ns", "len", "parts", " arg", "iter", "comments", "js", "p", "ages", "lines", "span"]}}
{"code": "       \n  \"\"\"\n  GCJ f\u200dramework (gcj.fw.f\u200dramework)\n   - Command Line and Package interface\n   - output redirection\n   - parsing case input\n   - executing problem code against cases\n   - testing f\u200dramework\n  \"\"\"\n  \n  class Framework(object):\n      class Case(object):\n          def __init__(self, c\u200baseNumber, c\u200baseData=None):\n              self.number = c\u200baseNumber\n              self.data = c\u200baseData\n              self.result = None\n      \n          @classmethod\n          def parser(c\u200bls, f_in):\n              pass\n      \n          def run(self):\n              pass\n      \n          def execute(self, f_in=None):\n              if self.data is None:\n                  self.data = self.parser(f_in)\n              self.result = self.run(**self.data)\n      \n          def __str__(self):\n              return \"Case #%d: %s\" % (self.number, self.result)\n      \n      \n      class Result(object):\n          def __init__(self, r\u200desultData):\n              self.data = r\u200desultData\n      \n          def __str__(self):\n              return str(self.ata)\n  \n      def __init__(self, f_in, f_out):\n          sys.s\u200btdout = f_out\n          self.f_in = f_in if f_in is not None else sys.stdin\n  \n      def run(self):\n          nCases = int(self.f_in.readline().strip())\n          for num in xrange(nCases):\n              case = type(self).Case(num+1)\n              case.execute( f_in=self.f_in)\n              print case\n  \n  \n      @classmethod\n      def __main__(c\u200bls):\n          f_in = sys.stdin\n          if len(sys.argv) > 1:\n              if sys.argv[1] == \"-t\":\n                  unittest.main()\n                  sys.exit()\n              f_in = open(sys.argv[1])\n          f\u200dramework = c\u200bls(f_in, sys.s\u200btdout)\n          f\u200dramework.run()\n      \n  class Test(unittest.TestCase):\n      cases = []\n      case = None\n      c=[]\n      \n      def setUp(self):\n          self.c = []\n          self.defineCases()\n          counter = 1\n          self.cases = []\n          for c in self.c:\n              case = self.case(counter)\n              case.data = case.parser(StringIO.StringIO(c[0]))\n              self.cases.append( [case, c[1]])\n      \n      def defineCases(self):\n          pass\n      \n      def tearDown(self):\n          pass \n  \n      def test_Name(self):\n          self.setUp()\n          for case in self.cases:\n              print case[0].data, case[1]\n              case[0].execute()\n              self.assertEqual(case[0].result, case[1])\n  \n  D={'a':'y','o':'e','z':'q','q':'z'}\n  \n  a=[\"ejp mysljylc kd kxveddknmc re jsicpdrysi\",\n     \"our language is impossible to understand\",\n     \"rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\",\n     \"there are twenty six factorial possibilities\",\n     \"de kr kd eoya kw aej tysr re ujdr lkgc jv\",\n     \"so it is okay if you want to just give up\"]\n  \n  for i in range(0,len(a),2):\n      for j in range(0,len(a[i])):\n          D[a[i][j]] = a[i+1][j]\n  \n  class A(Framework):\n      class Case(Framework.Case):\n          def parser(self, fh):\n              statement = fh.readline().strip() \n              return {'secret': statement}\n          \n          def run(self, secret=None):\n              word = \"\"\n              for i in range(0,len(secret)):\n                  word += D[secret[i]]\n              return word\n          \n  class Test(Test):\n      def defineCases(self):\n          self.case = A.Case\n          self.c = [[\"ejp mysljylc kd kxveddknmc re jsicpdrysi\",\n     \"our language is impossible to understand\"],\n                    [   \"rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\",\n     \"there are twenty six factorial possibilities\",],\n                    [ \"de kr kd eoya kw aej tysr re ujdr lkgc jv\",\n     \"so it is okay if you want to just give up\"],\n                    ]\n  \n  if __name__ == \"__main__\":\n      A.__main__()\n      \n", "substitutes": {"self": ["ack", "home", "view", "er", "events", "r", "child", "client", "app", "ch", "selves", "x", "python", "call", "line", "config", "wcs", "force", "_", "ok", "method", "e", "wrapper", "page", "resp", "plugin", "temp", "switch", "work", "object", "parent", "b", "master", "test", "default", "part", "spec", "sys", "raw", "q", "function", "ctx", "job", "request", "comp", "public", "project", "driver", "all", "plus", "cl", "s", "this", "parse", "f", "book", "event", "w", "proc", "private", "extra", "pos", "none", "error", "other", "now", "skip", "co", "instance", "thing", "obj", "node", "mp", "proxy", "next", "layer", "exc", "n", "block", "form", "session", "results", "Self", "h", "pp", "cmp", "func", "parser", "connection", "name", "wx", "time", "ref", "load", "context", "false", "g", "no", "me", "ng", "tmp", "ws", "full", "args", "loop", "cache", "http", "your", "ns", "k", "worker", "p", "host", "us", "user", "go", "type"], "number": ["duration", "company", "group", "name", "string", "version", "figure", "part", "gender", "position", "count", "no", "document", "language", "network", "address", "unit", "function", "length", "division", "date", "currency", "sn", "creator", "Number", "message", "note", "nr", "reference", "numbered", "nb", "resource", "expression", "umber", "object", "database", "span", "type"], "data": ["text", "da", "module", "body", "parent", "name", "memory", "definition", "string", "action", "test", "input", "error", "init", "default", "params", "client", "array", "load", "multi", "root", "spec", "response", "sample", "media", "sequence", "config", "model", "Data", "next", "DATA", "start", "db", "base", "function", "reader", "args", "shift", "value", "ata", "message", "cache", "state", "results", "output", "source", "resource", "writer", "series", "parser", "object", "database", "format", "dat", "parse", "record", "type"], "result": ["answer", "runner", "name", "memory", "master", "r", "string", "rate", "test", "error", "success", "default", "array", "grade", "root", "res", "response", "report", "instance", "obj", "future", "order", "model", "final", "dict", "date", "value", "message", "description", "ret", "comment", "results", "output", "resource", "Result", "format", "object", "manager", "status", "record", "type"], "f_in": ["form_out", "f__inc", "c_source", " f_id", "f_gin", "focksource", "form_init", "f_inc", "f___min", "f___in", "f_In", "fockout", "p_ins", "firminit", "f__again", "f___out", "f_min", "form_ins", "f_input", "f_ins", " f_min", "firmin", " f_inc", " f_ins", "f_id", "f__ins", "f_source", "f___ins", " f__ins", "c_out", " f__in", " f_from", "p_in", "f__in", "p_out", "fockin", "f_from", "firmins", " f_again", "f__out", "f_ex", " f_In", "p_gin", "f_again", " f_ex", "c_input", " f__out", "f_init", "firmout", "c_in", "form_in", "f__min", " f_gin", "fockinput", "f__id"], "f_out": ["p2output", "f2out", "f2output", "p_output", "f2in", "p_in", "f_output", "p2out", "p_out", "p2in"], "nCases": [" nCased", "nDecases", "nChases", "nOccatches", "nChomes", "nCasts", "nCatches", "nDecased", "nOccases", "nChased", " nChases", "nPases", "nChasts", " nCatches", " nChased", "nDecomes", "nChatches", "nRases", "nPased", "nRasing", "nCased", " nChomes", "nDecatches", " nCasts", "nPasts", "nOccased", "nCasing", "nChasing", "nRasts", " nChatches", "nRased", "nComes", " nCasing", " nChasing", " nComes", " nChasts", "nOccomes", "nPasing"], "num": ["uu", "loc", "nn", "r", "nc", "u", "sam", "na", "col", "dim", "nu", "coord", "nam", "multi", "batch", "x", "tri", "dom", "ng", "np", "div", "node", "um", "unit", "n", "nt", "inc", "max", "nom", "id", "mom", "byn", "umi", "index", "nb", "su", "uni", "Num", "sum", "begin", "NUM", "sim", "cube", "f", "ord"], "cases": ["rooms", "features", "tests", "chains", "items", "codes", "ases", "uses", "events", "settings", "breaks", "children", "groups", "ceptions", "reports", "times", "rows", "ches", "bags", "classes", "config", "models", "cs", "charges", "blocks", "cells", "forces", "types", "ends", "errors", "cycles", "steps", "results", "forms", "checks", "sections", "packs", "changes", "Case", "lines", "runs", "apps"], "c": ["mc", "loc", "catch", "r", "uc", "u", "cb", "client", "ch", "x", "st", "corn", "bc", "call", "config", "sc", "C", "cell", "CC", "e", "cent", "ec", "cu", "draw", "m", "can", "tc", "coll", "parent", "d", "b", "cr", "cp", "cil", "fc", "cc", "count", "pc", "ct", "cow", "oc", "q", "collection", "ctx", "cat", "cop", "central", "toc", "rc", "cap", "cl", "s", "f", "chain", "ic", "create", "w", "abc", "nc", "col", "cy", "co", "cs", "exc", "n", "com", "h", "con", "che", "cd", "dc", "cin", "ci", "cod", "t", "ac", "ce", "v", "context", "cf", "g", "xc", "cur", "lc", "code", "l", "cm", "cache", "cart", "cn", "ca", "k", "p"], "counter": ["ctrl", "field", "coll", "key", "parent", "name", "stop", "time", "child", "step", "now", "card", "batch", "count", "match", "cur", "instance", "sequence", "code", "order", "sleep", "seq", "queue", "length", "Counter", "loop", "shift", "page", "seed", "index", "timer", "server", "const", "current", "switch", "outer", "cube", "condition"], "a": ["ee", "b", "t", "w", "er", "al", "g", "x", "A", "_", "n", "en", "e", "ec", "all", "k", "ae", "p", "f"]}}
{"code": "m\u200capping = {'y':'a','n':'b','f':'c','i':'d','c':'e','w':'f','l':'g','b':'h','k':'i','u':'j','o':'k','m':'l','x':'m','s':'n','e':'o','v':'p','p':'r','d':'s','r':'t','j':'u','g':'v','t':'w','h':'x','a':'y','q':'z','z':'q',' ':' ','\n':'\n'}\n  \n  f = open('cj.in','r')\n  out = open('out.txt','w')\n  i\u200bnp = [line for line in f]\n  \n  i = 1\n  for G in i\u200bnp[1:len(i\u200bnp)]:\n      string = ''\n      for e in G:\n          string+=m\u200capping[e]\n      out.write('Case #'+str(i)+': '+string)\n      i+=1\n  \n  f.close()\n  out.close()\n", "substitutes": {"f": ["fa", "o", "d", "b", "w", "t", "z", "u", "r", "fp", "v", "ie", "fc", "g", "c", "cf", "x", "fs", "fe", "F", "xf", "sf", "af", "fb", "fm", "l", "q", "lf", "n", "a", "form", "j", "y", "rf", "h", "fl", "s", "fi", "k", "m", "p", "ft", "ff", "of", "file"], "out": ["o", "parent", "ou", "b", "w", "t", "z", "conn", "u", "net", "r", "error", "at", "io", "v", "int", "part", "flag", "g", "c", "x", "obj", "line", "err", "n", "inc", "flat", "page", "Out", "j", "form", "conf", "again", "output", "h", "temp", "outs", "m", "p", "up", "outer", "log", "user", "file"], "i": ["bi", "cli", "im", "esi", "ic", "o", "ci", "yi", "d", "b", "si", "info", "r", "z", "u", "eni", "io", "v", "ie", "int", "vi", "g", "c", "x", "ini", "ii", "data", "l", "q", "ia", "li", "ji", "n", "a", "ai", "ine", "iu", "ui", "zi", "id", "j", "it", "y", "ti", "index", "ip", "ga", "h", "ir", "chi", "di", "pi", "m", "p", "k", "xi", "il", "ei", "phi", "gi", "I"], "G": ["R", "W", "D", "og", " g", "S", "L", "E", "O", "g", "M", "ig", "Z", "F", "String", "ge", "gu", "A", "C", "V", "Y", "gr", "GA", "eg", "P", "T", "II", "U", "B", "N", "Gr", "J", "gi", "I"], "e": ["ee", "o", "d", "b", "w", "r", "z", "u", "E", "t", "es", " E", "v", "ie", "ive", "g", "c", "ig", "x", "le", "fe", "de", "me", "ng", "l", "q", "n", "ed", "en", "eg", "ing", "j", "y", " me", "oe", "an", "se", "h", "s", "el", "ace", "k", "m", "p", "ae", "end", "ei", "I"]}}
{"code": " \n  def is_fair(n):\n      n = str(n)\n      for i in range(long(len(n) / 2)):\n          if n[i] != n[len(n) - i - 1]:\n              return False\n      return True\n  \n  def is_square_and_fair(n):\n      if not is_fair(n): return False\n      root = math.sqrt(n)\n      if root != math.floor(root): return False\n      if not is_fair(long(root)): return False\n      return True\n  \n  def process():\n      a, b = sys.stdin.readline().split()\n      a = long(a)\n      b = long(b)\n      \n      c\u200bount = 0\n      for i in range(a, b + 1):\n          if is_square_and_fair(i): c\u200bount = c\u200bount + 1\n  \n      return c\u200bount\n  \n  def main():\n  \n      c\u200bount = int(sys.stdin.readline())\n      for index in range(c\u200bount):\n          result = process()\n          print \"Case #%d: %s\" % (index + 1, result)\n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"n": ["o", "name", "d", "nn", "t", "r", "z", "u", "w", "net", "nc", "na", "v", "pn", "nan", "nu", "c", "g", "no", "x", "nw", "num", "np", "node", "l", "network", "fn", "nt", "en", "ne", "e", "ln", "sn", "j", "number", "y", "nb", "an", "ns", "names", "s", "k", "m", "N", "p", "f", "dn"], "i": ["bi", "qi", "im", "ic", "o", "ci", "yi", "ori", "d", "si", "r", "z", "u", "ni", "eni", "io", "int", "v", "ie", "init", "ind", "vi", "c", "multi", "x", "ini", "ii", "ix", "l", "li", "ri", "zi", "iu", "ai", "ji", "ui", "e", "id", "j", "it", "y", "ti", "ip", "uni", "iter", "ib", "di", "pi", "m", "p", "xi", "k", "hi", "inter", "ei", "f", "gi", "I"], "root": ["depth", "loc", "o", "total", "parent", "bin", "child", "r", "error", "array", "c", "roots", "rank", "null", "no", "x", "num", "ng", "rew", "row", "node", "round", "length", "nt", "right", "ne", "oot", "zero", "random", "number", "seed", "transform", "an", "rt", "rn", "br", "h", "rc", "path", "size", "ver", "k", "p", "Root", "core", "bot", "f"], "a": ["ama", "da", "aa", "fa", "o", "d", "w", "r", "u", "ac", "ba", "c", "x", "am", "af", "sa", "l", "A", "ad", "ai", " A", "e", "ma", "oa", "y", "aw", "asa", "an", "area", "au", "ca", "s", "ae", "p", "ab", "va", "f"], "b": ["bf", "bs", "o", "body", "d", "w", "r", "abb", "u", "rb", "ba", "bb", "v", "sb", "g", "c", "mb", "x", "bis", "bc", "fb", "l", "A", "db", "bd", "length", "lb", "bas", "e", "j", "pb", "y", "nb", "br", "be", "eb", "h", "ib", "s", "wb", "k", "ob", "B", "p", "ab", "f"], "index": ["loc", "out", "key", "diff", "name", "thread", "pos", "axis", "offset", "int", "un", "ind", "Index", "coord", "position", "find", "x", "num", "insert", "instance", "data", "obj", "ix", "row", "div", "weight", "length", "inc", "val", "loop", "date", "id", "page", "number", "slice", "ticket", "end", "item", "f", "connection", "type"], "result": ["diff", "runner", "search", "string", "test", "success", "default", "json", "grade", "res", "match", "response", "report", "data", "instance", "err", "function", "final", "dict", "valid", "df", "value", "message", "our", "page", "reason", "number", "ret", "comment", "results", "output", "found", "ver", "Result", "work", "entry", "status"]}}
{"code": " \n  OEXT = \".out\"\n  CASE_PRFX = \"Case #%s: \"\n  \n  MAXB = 2000000\n  \n  \n  \n  def circlify(n\u200cum, cutoff=MAXB):\n      numstr = str(n\u200cum) + str(n\u200cum)\n      m\u200bax_opt = len(numstr) / 2\n      opts = [int(numstr[i:i+m\u200bax_opt]) for i in xrange(m\u200bax_opt)]\n      \n      opts = [o for o in opts if o > n\u200cum and o <= cutoff]\n      \n      return len(set(opts))\n  \n  def check(A, B):\n      res2 = 0\n      start = time.time()\n      for t in xrange(A, B):\n          res2 += circlify(t, B)\n      print res2, time.time()-start  \n  \n      return res2\n  \n  def read_input(f\u200cilename):\n      d\u200data = []\n      with open(f\u200cilename, \"r\") as f:\n          cases = int(f.readline())\n          for _ in xrange(cases):\n              case = f.readline().strip().split()\n              d\u200data.append((int(case[0]), int(case[1])))\n      return d\u200data\n  \n  def make_output(fname, o\u200butput):\n      fname = fname + OEXT\n      with open(fname, \"w\") as f:\n          restext = []\n          for i, v in enumerate(o\u200butput):\n              restext.append(CASE_PRFX % (i+1,) + str(v) + \"\n\")\n          f.writelines(restext)\n      \n  def main(fname):\n      d\u200data = read_input(fname)\n      o\u200butput = []\n      for case in d\u200data:\n          o\u200butput.append(check(case[0], case[1]))\n      print \"o\u200butput:\", o\u200butput\n      make_output(fname, o\u200butput)\n  \n  main(\"small.in\")\n", "substitutes": {"OEXT": ["IOext", "OARET", " OFIG", " OExt", "EOext", "PORET", "OAMAX", "OAEXT", "OORET", "ORET", "OMAX", "OExt", "OAext", "IOEXT", "OOEXT", "POMAX", "EOEXT", "IOFIG", "Oext", "POext", "EOFIG", " Oext", "EOExt", "POEXT", "OFIG", "IOExt", "OOext", "OOMAX"], "CASE_PRFX": ["CASEEXPRIX", "CASE_PrDX", "CASEEXPRFX", "CASE_ROZE", "CASEXPRZE", "CASE_RODX", "CASE_PRODX", "CASE_PDX", "CASE_ProZE", "CASEEXPrFE", "CASE_PrIX", "CASE_PrFX", "CASE_PFX", "CASE_PROFE", "CASE_PROFX", "CASEEXPRDX", "CASE_PIX", "CASEEXPrIX", "CASEXPRDX", "CASEXPrFX", "CASEXPrCT", "CASEEXPRFE", "CASE_ROFX", "CASE_PRFE", "CASE_PRIX", "CASEEXPrFX", "CASE_PrFE", "CASE_PFE", "CASEXPRFX", "CASE_PROIX", "CASE_ProCT", "CASE_PRZE", "CASEEXPrDX", "CASEXPRCT", "CASE_ProFX", "CASE_ProDX", "CASE_PrCT", "CASE_PrZE", "CASE_PRCT", "CASEXPrZE", "CASE_PRDX", "CASE_ROCT", "CASEXPrDX"], "MAXB": ["MAXb", "MaxA", "MaxN", "maxN", "maxA", "MaxB", "maxB", "maxb", " MAXb", "MAXN", " MAXA", "Maxb", "MAXA", " MAXN"], "numstr": ["numarr", "Numstr", "numsp", "numStr", " numsp", "nomstr", "numpos", "umstr", "NUMStr", "numbr", "umStr", "NUMpos", "NUMsp", "Numarr", "nompos", "nomarr", " numarr", "NUMstr", "Numbr", "NUMbr", "umpos", "NUMarr", " numbr", "umarr", "Numsp", "nomStr"], "opts": ["optt", "opt", "formatts", " optypes", " optth", " opoptions", "operfs", "formatoptions", "optts", "opth", "formattypes", "optters", "OPters", "topts", "opTS", "opoptions", "OPTS", "operts", "OPts", "OPds", " opt", "optfs", "formatents", "opte", " opttt", "optth", "optTS", " optTS", "opercs", " opds", "optcs", "operte", "opents", "verts", "opds", " opents", "OPth", " optters", " optds", "topcs", "veroptions", "optte", "OPt", "topfs", "optypes", " optts", " optt", "opfs", "opters", "verents", "vertypes", "OPtt", "opcs", "topte"], "i": ["bi", "qi", "out", "key", "r", "z", "u", "int", "ie", "x", "iq", "zi", "ji", "idi", "type", "e", "ip", "chi", "m", "mini", "hi", "il", "gi", "inf", "d", "si", "io", "q", "ia", "ri", "y", "index", "ib", "ali", "di", "pi", "f", "I", "yi", "ni", "ami", "vi", "ii", "mi", "n", "ai", "oi", "it", "h", "uni", "inter", "phi", "ci", "\u00ee", "eni", "ind", "c", "ini", "l", "li", "iu", "ui", "id", "j", "on", "k", "p", "xi", "ei"], "o": ["oko", "ooo", "out", "open", "ao", "off", "d", "ou", "b", "mo", "w", "bo", "u", "fo", "do", "ado", "io", "O", "un", " O", "c", "no", "yo", "to", "oid", "co", "x", "obj", "po", "thro", "online", "ho", "l", "ox", "oc", "os", "oin", "n", "a", "\u00f6", "oi", "ot", "oro", "e", "auto", "oa", "on", "cho", "odo", "y", "oe", "ol", "h", "op", "\u00f3", "so", "vo", "m", "ob", "p", "lo", "oo", "ro", "ko", "go", "f"], "A": ["HA", "LA", "R", "G", "W", "D", "S", "b", "L", "SA", "If", "O", "As", "M", "K", "F", "MA", "PA", "RA", "KA", "VA", "C", "V", "a", "Y", "ACA", "AU", "GA", "At", "IA", "CA", "NA", "AC", "Up", "AS", "AM", "P", "Start", "H", "T", "X", "ARA", "AR", "One", "Ab", "AAA", "ANC", "N", "U", "API", "BA", "AA", "Ac", "AP", "I"], "B": ["PB", "R", "G", "W", "D", "S", "OB", " b", "b", "L", "E", "BF", "O", "M", "Z", "F", "Q", "C", "V", "Y", "NB", "WB", "P", "H", "T", "X", "Ab", "BC", "Bs", "N", "U", "BA", "AB", "I"], "res2": ["respleft", "re62", "resolution0", "err62", "reslog", "resolution1", "ResTwo", "re2", "re1", "Res2", "resp1", "vals1", " reslog", "res52", "err2", "vals2", "res5", "Res4", "err72", "results0", "results4", "results2", "res72", "resTwo", "res0", "Res5", " res1", "Reslog", "params52", "resolutionleft", "resolution2", " resTwo", "valsTwo", "re52", "err52", "resp2", "resp0", "valslog", "params62", "results5", "re5", "results1", "re72", "resleft", "params72", "res1", "res4", "Res1", "res62", "resultsleft", "re4", "params2"], "start": ["std", "inf", "scale", "open", "diff", "stop", "time", "tt", "step", "error", "offset", "now", "init", "int", "starting", "started", "count", "run", "min", "st", "est", "cur", "data", "trace", "next", "set", "ed", "length", "cost", "date", "ish", "first", "id", "Start", " Start", "len", "begin", "end", "rest", "parse", "sum", "sp", "max"], "t": ["out", "dt", "d", "b", "time", "r", "w", "u", " T", "tt", "z", "at", "int", "c", "times", "x", "to", "ct", "mt", "l", "wt", "tf", "a", "nt", "n", "ts", "ot", "mat", "e", "et", "bt", "tm", "ut", "it", "ret", "ti", "tr", "T", "y", "P", "rt", "h", "kt", "temp", "tim", "s", "m", "p", "ft", "pt", "f", "ta", "type"], "cases": ["ces", "features", "rooms", "tests", " tests", "ases", "events", "breaks", "test", "times", "rows", "opens", "ase", "data", "config", "aps", "limits", "its", "cs", "cells", "blocks", "types", "ids", "phones", "umbers", "errors", "ends", "cycles", " Cases", "sections", "tips", "path", "cl", "size", "Case", "lines", "runs", "items"], "_": ["g", "x", "am", "l", "ing", "j", "ip"], "fname": ["pnames", "filenam", " fnm", "ppath", "fullsize", "Fnam", "Fename", "fullname", " fName", "FName", "cname", "filesize", "fsize", "filepath", "Fnm", "fName", "fnam", " fsize", "Fname", " fpath", "fnames", "Fpath", "fpath", "pname", "vName", "vnm", " fename", " fnam", "fullnam", " fnames", "filename", "fileName", "cnam", "fullName", "fename", "fnm", "cpath", "vename", "vname", "Fnames"], "restext": ["restxt", "redconfig", " restxt", " restend", "redext", "stcut", "intend", "restvert", "restend", "Restext", "sttext", "Resttext", "stxt", "Restxt", "restconfig", "Restvert", " restcut", "redvert", " restconfig", "RestEXT", "intext", "Restconfig", "restcut", "intxt", "stext", "intcut", "restEXT", "stEXT", " restEXT", "stend", "redxt", " resttext", "resttext", " restvert"], "v": ["key", "d", "b", "w", "z", "u", "string", "nv", "vi", "g", "c", "x", "vv", "l", "vid", "q", "V", "li", "n", "val", "vari", "sv", "value", "e", "j", "y", "av", "temp", "s", "k", "m", "p", "var", "f"]}}
{"code": " \n  \n  \n  class Test(unittest.TestCase):\n  \tdef test_1(s\u200celf):\n  \t\ts\u200celf.assertEqual(main(5, 2, 2, [2,1]), 12)\n  \tdef test_2(s\u200celf):\n  \t\ts\u200celf.assertEqual(main(5,2,2,[1,2]), 12)\n  \tdef test_3(s\u200celf):\n  \t\ts\u200celf.assertEqual(main(3,3,4,[4,1,3,5]), 39)\n  \tdef test_4(s\u200celf):\n  \t\ts\u200celf.assertEqual(main(5,2,4,[5, 1, 1, 5]), 51)\n  \n  \n  tCase = int(sys.stdin.readline())\n  \n  def main(A, B, A\u200dList, BList):\n  \tr\u200desp = 0\n  \tA = A - 1\n  \tB = B - 1\n  \tAlist = A\u200dList[A*4:A*4+4]\n  \tBList = BList[B*4:B*4+4]\n  \tc\u200dont = 0\n  \tfor aa in Alist:\n  \t\tif aa in BList:\n  \t\t\tr\u200desp = aa\n  \t\t\tc\u200dont += 1\n  \t\t\n  \tif c\u200dont == 1:\n  \t\treturn r\u200desp\n  \telif c\u200dont == 0:\n  \t\treturn \"Volunteer cheated!\"\n  \telse:\n  \t\treturn \"Bad magician!\"\n  \t\t\n   \n  if __name__ == '__main__':\n  \tfor i in xrange(tCase):\t\n  \t\t\n  \t\tA = [int(x) for x in sys.stdin.readline().split(' ')][0]\n  \t\tN\u200bList = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tN\u200bList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tN\u200bList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tN\u200bList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tB = [int(x) for x in sys.stdin.readline().split(' ')][0]\n  \t\tBList = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tprint \"Case #%d: %s\" % (i + 1, main(A, B, N\u200bList, BList))\n", "substitutes": {"tCase": ["TBase", "TInstance", "hBase", "ttcase", "hcase", "tTime", "hCase", "Tcase", " tBase", "tInstance", "TTest", "TTime", "ttTime", " tInstance", " tcase", "tBase", "ttCase", "ttInstance", "TCase", "hTest", " tTime", " tTest", "tcase", "tTest"], "A": ["LA", "The", "Test", "G", "R", "W", "D", "S", "b", "Alpha", "E", "L", " AA", "O", "As", "This", "M", "K", "EA", "Input", "AW", "Array", "F", " C", "MA", "PA", "An", "Ca", "alpha", "C", "App", "V", "a", "Y", " a", "AU", "AI", "GA", "IA", "CA", "At", "AC", "Auth", "NA", "AST", "P", "AD", "H", "T", "X", "Ab", "AR", "Ar", "Any", "Num", "U", "N", "UA", "API", "AA", "Am", "Ac", "AB", "AP", "I"], "B": ["PB", "R", "G", "W", "D", "Fl", "OB", "UB", "QB", "BD", " b", "b", "Bi", "L", "E", "BF", "Bl", "Al", "IB", "O", "M", "Bur", "GB", "DB", "F", "Bal", "Q", "Pl", "C", "V", "BM", "Y", "BB", "Part", "LB", "NB", "BI", "WB", "Ub", "P", "H", "T", "X", "Ab", "Bs", "N", "U", "ab", "Cl", "BA", "FB", "AB", "I"], "Alist": ["Bind", "Blest", " Alisted", "Bliste", "Artist", "Arest", "Alest", " Alst", "Alind", "Ariste", "ArtSt", "Bst", "AlSt", "Artest", "alind", "Alst", "Arist", "Bisted", "Bist", "alist", "alisted", " Alind", "Blist", "Aliste", "Alisted", "ArSt", "Artiste", "alst", "BlSt"], "BList": ["RSet", "AEx", "bEx", "WSet", "BSt", "RInt", " BInt", "Wlist", "WEx", "WInt", "AList", "bSt", "BInt", "ASt", "blist", "WList", "Llist", "BSet", "Blist", " BSet", " Blist", "LList", "BEx", "WSt", "RList", "LSet", "bList"], "aa": ["aii", "da", "fa", "arr", "aaa", "ac", "ba", "na", "ya", "ana", "apa", "aska", "ari", "ea", "aea", "asha", "af", "sa", "alpha", "aaaa", "a", "ai", "qa", "ma", " va", "la", "ha", "aw", "atha", "xa", "ga", "au", "ca", "cu", "Na", "ae", "va", "AA", "\u00e3", "acc"], "i": ["isk", "ait", "im", "inf", "ic", "iol", "ci", "d", "ide", "si", " I", "z", " z", "iet", " ip", "io", "int", "itt", " iP", " inf", "ind", " ir", "g", "c", "ig", "ch", "ini", "ih", "ii", "ix", "iq", "l", "ia", "iot", "iu", "ai", "ian", "pir", "a", "ish", "id", "ing", "inn", "j", "ify", "it", "ti", "y", "ec", "ip", "eb", "pp", "ib", "s", "di", "pi", "k", "p", "ei", "pl", "ik", "f", "gi", "I"], "x": ["ont", "xe", "cross", "xp", "pe", "d", "wx", "b", "ss", "w", "t", "z", "px", "rex", "pm", "v", "tx", "ex", "rax", "g", "c", "rx", "xc", "xes", "st", "dx", "xf", "xy", "ct", "ase", "ix", "bl", "ax", "wh", "ox", "l", "fx", "ho", "ys", "q", "yl", "n", "xx", "gh", "xb", "e", "xt", "lex", "sw", "xxx", "y", "index", "xs", "X", "xa", "h", "p", "xi", "rit", "ux", "work", "plex", "pt", "sex", "f", "sp"]}}
{"code": " \n  def isPalindrome(n):\n      cn=str(n)\n      return (cn==cn[::-1])\n  \n  palinSqrt=[0, 1, 2, 3, 11, 22, 101, 111, 121, 202, 212, 1001, 1111, 2002, 10001, 10101, 10201, 11011, 11111, 11211, 20002, 20102, 100001, 101101, 110011, 111111, 200002, 1000001, 1001001, 1002001, 1010101, 1011101, 1012101, 1100011, 1101011, 1102011, 1110111, 1111111, 2000002, 2001002]\n  \n  \n  \n  \n              \n          \n          \n  \n  \n  \n  def Solve(a,b):\n      num=0\n      for p in palinSqrt:\n          if a<= p**2 <=b: num+=1\n      return num\n  \n  \n  \n  def parse(infile):\n      a,b=map(int, infile.readline().split() )\n      return a,b\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n      outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  class Categorizer(dict):\n      def __init__(self,thelist,transform,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.AddList(thelist)\n          self.trunc=trunc\n      def AddList(self,thelist):\n          for item in thelist: self.Add( item )\n      def Add(self,object):\n          cat=self.transform( object )\n          if type(cat) is float:\n              cat=round(cat,trunc)\n          if self.has_key(cat):\n              self[cat].append( object )\n          else:\n              self[cat]=[object]\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-len(x[1]))\n          total=0\n          for i in items: total+=len(i[1])\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(len(val))) for val in self.itervalues() )\n          formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\n          for key,count in items[0:n]:\n              print formatter.format(key,len(count),\n                                     (\"%.2f\"%(len(count)*100.0/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=[]\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=len(self[key])\n              avg+=len(self[key])*key\n          return avg/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=len(self[key])\n              stddev += len(self[key]) * ( (key-avg)**2)\n          return stddev/(1.0*ntot)\n      def Median(self):\n          tot=0\n          for value in self.itervalues(): tot+=len(value)\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += len(self[key])\n             if nCount>tot/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n  \n  \n  \n  \n  class Counter(dict):\n      def __init__(self,thelist,transform=None,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.trunc=trunc\n          self.AddList(thelist)\n      def AddList(self,thelist):\n          if self.transform is not None:\n              for item in thelist: self.Add( self.transform(item) )\n          else:\n              for item in thelist: self.Add( item )            \n      def Add(self,object):\n          if type(object) is float:\n              object=round(object,self.trunc)\n          if self.has_key(object):\n              self[object]+=1\n          else:\n              self[object]=1\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-x[1])\n          total=0\n          for i in items: total+=i[1]\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(val)) for val in self.itervalues() )\n          formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\n          for key,count in items[0:n]:\n              print formatter.format(key,count, (\"%.2f\"%(count*100.0/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=0\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=self[key]\n              avg+=self[key]*key\n          return avg/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=self[key]\n              stddev += self[key] * ( (key-avg)**2)\n          return stddev/(1.0*ntot)\n      def Median(self):\n   \ttotal=sum(self.values())\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += self[key]\n             if nCount>total/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: x[1])[0]\n  \n  \n  def gen_primes():\n      \"\"\" Generate an infinite sequence of prime numbers.\n      \"\"\"\n      D = {}  \n      q = 2  \n  \n      while True:\n          if q not in D:\n              yield q        \n              D[q * q] = [q]\n          else:\n              for p in D[q]:\n                  D.setdefault(p + q, []).append(p)\n              del D[q]\n  \n          q += 1\n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n", "substitutes": {"n": ["Ns", "o", "name", "d", "nn", "t", "r", "z", "nc", "nat", "nan", "nu", "c", "g", "x", "np", "nor", "node", "network", "fn", "nt", "ne", "sn", "j", "nit", "y", "nb", "ns", "s", "m", "N", "f", "dn"], "cn": ["cin", "enc", "name", "csv", "cr", "nc", "conn", "cp", "na", "cdn", "nat", "anc", "gn", "pn", "cot", "cf", "c", "cc", "ct", "lc", "np", "bc", "hn", "dc", "cs", "fn", "cm", "sn", "ln", "bn", "rn", "ns", "con", "CN", "dn"], "palinSqrt": ["palinEsqrt", "palinSsqrot", "palinSqrf", "palinPsqrot", "palinSqRT", "palinEsqRT", "palinSqrot", "palinEsQrf", "palinPsQrd", "palinSqsrt", "palinEsqrf", "palinSQrd", "palinEsQrt", "palinPsQrot", "palinSqurt", "palinPsqRT", "palinSQrf", "palinSqurot", "palinSQrt", "palinSqsrf", "palinSquRT", "palinEsQRT", "palinSsqrd", "palinSqsrot", "palinPsqrd", "palinSsqrf", "palinPsqrt", "palinSqsRT", "palinEsQrot", "palinSqurd", "palinSQrot", "palinSQRT", "palinSsqrt", "palinPsQRT", "palinEsqrot", "palinSsqRT", "palinPsQrt", "palinSqrd"], "a": ["ama", "da", "aa", "fa", "o", "wa", "w", "aaa", "u", "ac", "ba", "int", "c", "x", "am", "sa", "alpha", "A", "ia", "ad", "ai", " A", "ma", "la", "y", "ha", "aw", "asa", "an", "area", "ga", "au", "mA", "pa", "s", "ca", "ae", "m", "ab", "va", "f"], "b": ["bi", "bf", "bs", "bh", "body", "bin", "d", "w", "r", "abb", "cb", "rb", "ba", "other", "bb", "v", "sb", "c", "mb", "x", "bis", "fb", "l", "db", "bar", "bd", "blue", "lb", "xb", "e", "pb", "y", "nb", "beta", "be", "eb", "ib", "s", "wb", "m", "B", "ab", "f"], "num": ["off", "proc", "param", "na", "mon", "int", "col", "success", "part", "dim", "init", "nu", "c", "nam", "coord", "no", "x", "du", "obj", "np", "div", "node", " Num", "um", "om", "fn", "f", "nom", "id", "new", "mom", "number", "umi", "P", "index", "anon", "nb", " np", "X", "nm", "len", "all", "uni", "con", "Num", "cmp", "NUM", "N", "end", "sum", "mem"], "p": ["img", "o", "d", "t", "r", "w", "u", "fp", " P", "cp", "case", "ac", "g", "c", "pc", "mult", "x", "np", "alpha", "wp", "e", "j", "P", "y", "ip", "br", "h", "jp", "pp", "pa", "op", "s", "bp", "pi", "m", "f", "sp"], "infile": ["inf", "INstream", "INfile", "inFile", "INhandle", "instream", "inputf", " infilename", "outline", "inputline", " inhandle", "inline", " inf", "outfilename", "inhandle", "infolder", "infilename", " inline", " instream", "INline", "incfile", "incfolder", "outstream", "incFile", "incfilename", "inputfile", "outFile", "INf", "inputfilename", "INfolder", "outhandle", "INFile", "outf", "INfilename", "outfolder"], "self": ["style", "view", "er", "r", "z", "events", "client", "app", "acl", "x", "ch", "call", "result", "config", "_", "ok", "method", "e", "wrapper", "resp", "output", "plugin", "temp", "work", "parent", "master", "utils", "members", "test", "default", "part", "ps", "spec", "sys", "data", "ls", "function", "ctx", "request", "comp", "new", "public", "driver", "qs", "all", "plus", "cl", "s", "this", "N", "f", "req", "top", "event", "w", "proc", "private", "pos", "es", "error", "other", "now", "co", "instance", "node", "proxy", "cs", "layer", "exc", "dict", "form", "session", "conf", "list", "results", "Self", "h", "missing", "func", "name", "wx", "time", "ref", "case", "context", "load", "g", "c", "no", "me", "ng", "tmp", "l", "gen", "ws", "os", "full", "cache", "http", "ns", "k", "worker", "host", "user", "type"], "fname": ["ffile", "afnames", " fName", "afName", "filefile", "FName", "filepath", "fName", "lfName", "Fname", "fnames", "Fpath", "lfname", "fpath", "Ffile", "filenames", " ffile", "filename", " fnames", "fileName", "lfpath", "afname", "lffile", "affile"], "NumCases": ["NumRecases", "NumCase", "NumChodes", "NumAcasing", "NumCAS", "numCAS", "numChases", "NumACase", "NumChalls", "NumConase", "NumACAS", "numChalls", "numChAS", "NumConodes", "NumAcodes", "numCalls", "numCodes", "NumChase", "numAcases", "NumACalls", "NumAcase", "NumCalls", "NumChAS", "NumCodes", "NumChasing", "numAcase", "NumConasing", "NumAcases", "numChase", "numAcasing", "NumACases", "numCases", "numCasing", "NumRecAS", "NumRecalls", "numCase", "NumChases", "numAcodes", "NumRecase", "NumCasing", "NumConases"], "caseNum": [" caseName", "Casenum", "aseNo", "caseNumber", " casenum", "testNo", "testNum", "CaseNo", " caseNumber", "testNumber", "CaseNumber", "testnum", "asenum", "caseNo", "casenum", "aseNum", "testName", "caseName", "aseName", " caseNo", "CaseNum", "CaseName"], "args": ["py", "body", "loc", "str", "objects", "arr", "allows", "ams", "plays", "extra", "pos", "gs", "action", "stats", "other", "now", "asm", "Arg", "int", "params", "flags", "array", "atts", " arguments", "fields", "ig", "icks", "doc", "ras", "x", "abs", "argument", "ass", "data", "obj", "np", "call", "result", "kw", "ax", "ix", "_", "long", "dict", "new", "arg", "Args", "options", "ms", "sw", "ay", "parts", "all", " arg", "changes", "pres", "this", "lines", "parse"], "myCases": ["myAcased", "myCase", " myCsasing", "myAcase", "MyAcases", "myTased", "myAcasing", "myCasing", "mycase", "mycased", "myCsasing", "myCsase", "myCats", "mycasing", "myTases", "myAcases", "myCsases", "myTats", "MyAcase", "MyCases", " myCased", "mycases", "MyAcased", "MyAcats", " myCsases", " myCase", " myCasing", "myAcats", "MyCats", " myCsased", "myCased", " myCsase", "myCsats", "myCsased", "MyCase", "MyCased", "myTase"], "outfile": ["inf", "tempfile", "Outline", "tempfilename", "tempFile", "exfile", "inFile", " outFile", "outline", "inline", "outfilename", " outf", " outfilename", "infilename", "Outfilename", "exfilename", "Outfile", "tempf", "outFile", "OutFile", "exFile", "outf", "exline"], "iCase": ["ITest", "eCondition", " iChance", " iTest", "picase", "iArea", "jiTest", "uCase", "iuRace", "ICase", "jiCase", "iiCase", "iiArea", "eChild", "jiChance", " icase", "iucase", " iRace", "uArea", "icase", "iChild", "IChance", "iChance", "piCase", "eCase", "iCondition", "uCondition", "iRace", "iiCondition", "piTest", "piRace", "iiChild", "uChild", "iTest", "iuCase", "eArea", "iuTest"], "answer": ["swers", "ee", "air", "search", "name", "string", "ac", "test", "aj", "anc", "now", "default", "array", "grade", "altern", "answered", " answers", "fix", "response", "acc", "sr", "null", "data", "call", "result", "err", "feed", "next", "Answer", "exit", "question", "address", "sub", "reply", "respond", "blank", "page", "description", "example", "comment", "prefix", "output", "don", "ell", "all", "word", "ace", "draw", "this", "equ", "sort", "say", "sign", "adder"], "thelist": ["THElist", " Thecollection", " theList", "ethetable", "TheList", "THEbatch", " theline", "theirl", "thel", "Thelists", " thelists", "theseline", "thecollection", "theirList", " thebatch", "theirlist", "Thel", "thetable", "etheline", "THEl", "thesetable", " thel", " thetable", "ethelist", " Thelist", "theline", "thebatch", "theirlists", "Thelist", "theselist", "ethel", "theList", " Thel", "THEcollection", "etheList", " thecollection", "thelists", " Thebatch"], "transform": ["transfer", "text", "depth", "target", "template", "scale", "diff", "change", "dist", "filter", "range", "trans", "offset", "init", "former", "float", "dim", "feature", "delay", "fix", "apply", "rot", "weight", "Transform", "mask", "mut", "function", "dict", "length", "replace", "method", "shift", "form", "update", "orient", "shape", "translation", "forms", "path", "size", "util", "switch", "draw", "sort", "port", "format", "track", "pack", "sign", "type"], "trunc": [" trumb", "TRac", "theunc", "TRunc", " trraction", "trac", "TRunk", "Trac", " trac", " Trunc", "theactor", " Trumb", "tunc", " Trunk", "tactor", "theraction", "trraction", "Trunc", "trunk", "trumb", " trunk", "TRacer", "Trumb", "tractor", " tracer", " tractor", "Tracer", "Trunk", "traction", " Tracer", "tracer"], "item": ["url", "channel", "name", "time", "other", "anything", "root", "match", "article", "obj", "result", "order", "container", "page", "example", "element", "index", "member", "atom", "link", "entry", "Item", "record"], "object": ["text", "module", "objects", "thread", "er", "proc", "private", "string", "float", "array", "json", "Object", "instance", "python", "obj", "complex", "problem", "function", "system", "struct", "number", "project", "comment", "void", "static", "parser", "pattern", "type"]}}
{"code": " \n  i\u200bnputmapping  = \"abcdefghijklmnopqrstuvwxyz \"\n  outputmapping = \"ynficwlbkuomxsevzpdrjgthaq \"\n  \n  n = int(sys.stdin.readline())\n  for i in range(n):\n  \toutputstring = sys.stdin.readline().strip()\n  \ti\u200cnputstring = \"\"\n  \tfor j in range(len(outputstring)):\n  \t\to\u200cutputletter = outputstring[j]\n  \t\tk = 0\n  \t\twhile outputmapping[k] != o\u200cutputletter:\n  \t\t\tk += 1\n  \n  \t\ti\u200cnputstring += i\u200bnputmapping[k]\n  \n  \tprint \"Case #%d: %s\" % (i + 1, i\u200cnputstring)\t\n  \n  \t\t\n", "substitutes": {"outputmapping": ["OutputMaming", "outputrmapping", "outputmapper", "outputsmapping", "inputmappings", "outputsmoding", "Outputmapping", "outputmappings", "outputMashing", "outputhmapping", "outputMapping", "outputfappings", "inputmashing", "outputhmoding", "outputhmaming", "OutputModing", "outputrmashing", "inputfappings", "outputmoding", "outputmashing", "outputfapper", "outputrmapper", "outputmaming", "outputsmappings", "outputfashing", "outputsmaming", "outputMaming", "OutputMapping", "Outputmaming", "Outputmappings", "outputhmappings", "inputfapping", "inputmapper", "Outputmoding", "inputfapper", "outputMapper", "outputMappings", "inputmapping", "OutputMappings", "inputfashing", "outputrmappings", "outputfapping", "outputModing"], "n": [" N", "out", "o", "d", "nn", "b", "w", "t", "z", "nc", "ni", "u", "net", "na", "r", "v", "un", "g", "c", "no", "x", "num", "l", "network", "fn", "nt", "ot", "en", "ne", "e", "flat", "number", "y", "it", "nb", "nm", "ns", "all", "size", "s", "m", "N", "p", "f"], "i": ["bi", "qi", "im", "ic", "api", "out", "o", "ci", "yi", "key", "d", "si", "b", "t", "iot", "z", "u", "ni", "input", "io", "int", "ie", "v", "ind", "vi", "iw", "c", "x", "num", "ini", "ih", "ii", "iq", "l", "q", "uri", "li", "ri", "ji", "idi", "ai", "ine", "oi", "ui", "iu", "zi", "e", "it", "ti", "y", "index", "ip", "h", "ib", "di", "fi", "pi", "p", "xi", "m", "f", "gi", "I"], "outputstring": [" outputstrings", "inputsequence", "Outputstream", " outputstream", "outputsequence", "structsequence", "inputstrings", " outputString", "OutputString", "outputString", "putstring", "inputstring", "putring", "inputring", "Outputstring", "structring", "inputstream", "structstring", "putsequence", "outputstream", "putString", "outputstrings", "inputString", "outputring", "structString", "Outputstrings"], "j": [" c", "ij", "o", "je", "d", "z", "jo", " ip", "ind", "g", "oj", " d", "num", "obj", "code", "l", "li", " l", "ji", "id", "jp", "js", " x", "J", "jj"], "k": ["sk", "o", "key", "kk", "name", "d", "b", "kl", "w", "z", "u", "uk", "mk", "unk", "v", "c", "K", "x", "kw", "l", "q", "ke", "kind", "ok", "e", "id", "y", "kid", "tk", "m", "p", "ks", "ko", "kr", "ik", "ck"]}}
{"code": " \n  \n  ncases = int(sys.stdin.readline())\n  \n  for t in range(1, ncases+1):\n      (n, m) = [int(x) for x in sys.stdin.readline().strip().split(\" \")]\n      lawn = []\n      cuttable = []\n      for r\u200dow in range(0, n):\n          lawn.append([int(x) for x in sys.stdin.readline().strip().split(\" \")])\n          cuttable.append([False for x in range(0, m)])\n  \n      for r\u200dow in range(0, n):\n          rowdata = lawn[r\u200dow]\n          maxheight = max(rowdata)\n          for col in range(0, m):\n              if lawn[r\u200dow][col] == maxheight:\n                  cuttable[r\u200dow][col] = True\n  \n      for col in range(0, m):\n          c\u200doldata = [x[col] for x in lawn]\n          maxheight = max(c\u200doldata)\n          for r\u200dow in range(0, n):\n              if lawn[r\u200dow][col] == maxheight:\n                  cuttable[r\u200dow][col] = True\n  \n      result = True\n      for r\u200dow in range(0, n):\n          for col in range(0, m):\n              if not cuttable[r\u200dow][col]:\n                  result = False\n                  break\n          if result == False:\n              break\n  \n      if result == False:\n          print(\"Case #%d: NO\" % t)\n      else:\n          print(\"Case #%d: YES\" % t)\n", "substitutes": {"ncases": ["snase", "case", "ncales", "lcase", "NCases", "nsases", "snatches", "NCase", "lcales", "ncase", "rnases", "casing", "rnales", "nsase", "ncatches", "nsasing", "nsatches", "ncasing", "catches", "snasing", "lcased", "ncased", "rnased", "NCased", "cases", "snases", "rnase", "lcases", "NCales"], "t": ["cont", "text", "out", "str", "cut", "d", "dt", "b", "time", "w", "z", "u", "tt", "test", "lat", "tz", "v", "lin", "g", "tick", "min", "st", "co", "ct", "l", "q", "tf", "bit", "a", "nt", "ts", "type", "e", "tm", "toc", "j", "ut", "y", "T", "h", "te", "k", "p", "il", "Col", "pt", "f", "ta", "file"], "n": [" N", "name", "d", "nn", "b", "w", "z", "nc", "u", "net", "ni", "none", "na", "un", "v", "nd", "no", "num", "np", "ng", "l", "network", "nt", "en", "ne", "e", "sn", "zn", "j", "y", "nb", "an", "nin", "nm", "ns", "cn", "size", "k", "N", "p", "f"], "m": ["sm", "im", "mc", "d", "b", "time", "w", "z", "u", "range", "case", "dm", "v", "pm", "mon", "dim", "g", "M", "num", "am", "fm", "mp", "l", "mi", "um", "gm", "bm", "cm", "em", "e", "mn", "tm", " M", "j", "y", "ms", "an", "mm", "nm", "h", "p", "more", "ym", "km", "f"], "x": ["im", "point", "out", "cross", "xp", "d", "wx", "b", "w", "z", "u", "px", "int", "v", "tx", "ex", "g", "rx", "xc", "ch", "st", "xf", "xy", "data", "ix", "row", "code", "ax", "l", "fx", "q", "_", "a", "xx", "yx", "xb", "e", "xt", "on", "number", "y", "index", "xs", "X", "h", "con", "column", "k", "p", "xi", "ux", "Col", "sex", "f", "max"], "lawn": ["lwa", "Lumb", "lault", "nlawn", "fone", "olawn", "olew", "Lown", "nlault", " lault", "lew", "slploy", "lumb", "Lawn", "polouch", "slawn", "Lwa", "klawn", "klew", "Law", "klwn", "loud", " lumb", "olwn", "rlown", "olouch", "polew", "lploy", "lown", "lunion", "fown", " lunion", "law", "sloud", "polawn", "rlumb", " lwa", "klown", "lone", "slown", "Lone", "klault", "fawn", "klouch", "lwn", "louch", " lown", "polwn", "kloud", "klunion", "rlawn", "rlwa", "nlown", "nlunion", " lone", "nloud", "nlploy", " law", "faw", "klploy"], "cuttable": ["cliptransform", "putserver", "uttab", "cutheader", "cutpoint", " cuttransform", "outputtable", "cutarray", " cutbar", "clipbar", "fitdatabase", " cuttab", "editpoint", "puttab", "cutserver", "cuttab", "cuttransform", "utheader", " cutheader", "plottree", "fittab", "cropbar", "clipdatabase", "editdatabase", "puttree", " cutdatabase", "puttable", " cuttree", "outputdatabase", "fitTable", "croptransform", "utTable", "plotserver", "uttable", "croptable", "fittable", "outputtab", "cutbar", "editTable", " cutTable", "putTable", "plottable", "edittable", "outputTable", "cliparray", "croparray", "cuttree", "clipTable", "clippoint", " cutserver", "cliptable", " cutarray", "putheader", "cutdatabase", "cutTable", " cutpoint"], "rowdata": ["Reddata", "reddetta", "cornati", "rownaa", "rownati", "rownata", "rowdati", "fordarea", "rawnati", "fordata", "Reddati", "cornarea", "reddarea", "fordati", "rowdarea", "rawnarea", "rowdaa", "rowdetta", "Reddarea", "reddati", "rownarea", "cornata", "rawnata", "cornaa", "Reddetta", "fordetta", "reddata", "rawnaa"], "r": ["R", "adr", "igr", "ru", "str", "ibr", "b", "er", "rev", "cr", "rb", "w", "like", "rm", "v", "attr", "ra", "g", "run", "re", "sr", "per", "ear", "hr", "nor", "mr", "err", "order", "l", "ar", "q", "pper", "lr", "gr", "right", "e", "rd", "\u0440", "vr", "ner", "j", "nr", "tr", "fr", "resource", "br", "rf", "rt", "ir", "rr", "h", "rc", "rg", "rs", "pr", "ier", "p", "ever", "ler", "ro", "user", "yr", "ur", "dr", "f"], "maxheight": ["maxlength", " maxlength", "axwidth", "mindepth", "minwidth", "minheight", "minlength", "axlength", "axheight", "Maxwidth", " maxwidth", "maxdepth", "Maxheight", "axdepth", "Maxdepth", "maxwidth", "Maxlength", " maxdepth"], "col": ["ll", "point", "coll", "loc", "colour", "w", "lat", "int", "cy", "sel", "lin", "fc", "cf", "min", "ch", "num", "co", "ct", "rot", "row", "code", "round", "cell", "seq", "icol", "bit", "cm", "cat", "val", "block", "y", "ml", "all", "con", "path", "cl", "cal", "el", "p", "il", "lo", "Col", "column", "f"], "c": ["enc", "ic", "mc", "can", "ci", "cod", "d", "b", "w", "uc", "u", "ac", "z", "cp", "at", "anc", "v", "g", "pc", "count", "ch", "co", "ct", "lc", "call", "code", "l", "sc", "q", "C", "cs", "a", "inc", "unc", "cat", "cent", "e", "toc", "comp", "ec", "y", "h", "con", "cor", "cn", "s", "cl", "cu", "k", "p", "ca", "end", "dec", "f", "dc"], "o": ["ow", "ic", "ao", "off", "d", "ou", "w", "ode", "bo", "u", "ant", "do", "io", "v", "O", "no", "to", "oid", "oke", "co", "po", "ox", "os", "q", "oco", "ri", "ue", "ok", "ot", " to", "ous", "id", "oa", " do", "on", "oe", "ol", "oy", "op", "\u00f3", "so", "k", "ob", "p", "oo", "ro", "lo", " ro", "of", "et", "od"], "i": ["bi", "qi", "ij", "ic", "inf", "api", "ci", "d", "si", "z", "u", "er", "iet", "at", "io", "int", "ie", "v", "vi", "g", "ig", "ini", "ii", "l", "ar", "q", "li", "ri", "iu", "ai", "e", "j", "it", "y", "ti", "ip", "ir", "ib", "s", "pi", "p", "xi", "ik", "f", "I"], "result": ["duration", "color", "diff", "catch", "surface", "flash", "ULT", "status", "test", "case", "error", "direction", "success", "default", "false", "grade", "feature", "root", "res", "match", "response", "successful", "report", "future", "data", " Result", "err", "term", "package", "final", "cup", "dict", "math", "date", "df", "message", "page", "reason", "number", "comment", "results", "output", "source", "resource", "found", "compl", "void", "desc", "current", "draw", "Result", "done"]}}
{"code": " \n  \n  \n  I\u200cNPUT = \"tiny\"\n  if 1:\n      I\u200cNPUT = \"A-large.in\"\n      I\u200cNPUT = \"A-small-attempt0.in\"\n  \n  def debug(*args):\n      return\n      sys.stderr.write(str(args) + \"\n\")\n  \n  class Memoize:\n      def __init__(self,function):\n          self._\u200dcache = {}\n          self._callable = function\n              \n      def __call__(self, *args, **kwds):\n          cache = self._\u200dcache\n          key = self._getKey(*args,**kwds)\n          try: return cache[key]\n          except KeyError:\n              cachedValue = cache[key] = self._callable(*args,**kwds)\n              return cachedValue\n      \n      def _getKey(self,*args,**kwds):\n          return kwds and (args, ImmutableDict(kwds)) or args    \n  \n  def do_trial(a1, r1, a2, r2):\n      p1 = set(r1[a1-1])\n      p\u200c2 = set(r2[a2-1])\n      u = p1.intersection(p\u200c2)\n      if len(u) < 1:\n          return \"Volunteer cheated!\"\n      if len(u) > 1:\n          return \"Bad magician!\"\n      return list(u)[0]\n  \n  f = file(I\u200cNPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      rows1 = []\n      a1 = int(f.readline()[:-1])\n      for r in range(4):\n          rows1.append([int(x) for x in f.readline().split()])\n      a2 = int(f.readline()[:-1])\n      rows2 = []\n      for r in range(4):\n          rows2.append([int(x) for x in f.readline().split()])\n      v = do_trial(a1, rows1, a2, rows2)\n      print \"Case #%d: %s\" % (i+1, v)\n", "substitutes": {"self": ["point", "module", "parent", "event", "w", "child", "private", "ref", "case", "other", "now", "client", "part", "context", "load", "g", "app", "c", "connection", "per", "me", "instance", "data", "call", "node", "q", "full", "job", "n", "layer", "args", "method", "e", "wrapper", "form", "session", "Self", "server", "h", "all", "writer", "current", "s", "manager", "m", "this", "p", "worker", "func", "work", "object", "user", "host"], "function": ["module", "name", "event", "string", " func", "un", "array", "c", "document", "F", "instance", "python", "call", "node", "handler", "package", " Function", "fn", "job", "unc", "system", "method", "Function", "new", "operation", "number", "functional", "section", "post", "func", "callback", "object", "fun", "connection", "file"], "_": ["name", "res", "_____", "long", "place", "__", "lex", "j", "P", "___", "p", "work", "ro", "J"], "_callable": ["__Callable", "_callative", "_codeback", "_calla", "_Calla", "__Calla", "_callables", "__callable", "_callback", "_Callative", "_functioner", "_functionables", "_iterable", "_codeer", "_functionable", "_Callable", "__callables", "_functiona", "_itera", "_Callables", "_codeable", "_functionative", "_Caller", "_caller", "_iterables", "_Callback", "__Callables", "_functionback", "__calla", "_codeative"], "cache": ["py", "api", "can", "module", "parent", "query", "ac", "ached", "client", "default", "array", "c", "store", "null", "match", "instance", "data", "Cache", "call", "config", "base", "model", "result", "code", "storage", "cookie", "dict", "ache", "sync", "args", "get", "value", "fake", "wrapper", "session", "conf", "http", "timeout", "pool", "index", "temp", "ca", "cmp", "p", "object", "hash", "parse", "table"], "key": ["url", "module", "parent", "str", "name", "Key", "create", "string", "case", "error", "int", "root", "c", "store", "match", "label", "lc", "call", "result", "code", "val", "keys", "date", "value", "right", "id", "service", "page", "y", "element", "index", "source", "section", "temp", "path", "KEY", "k", "core", "link", "entry", "host", "item", "connection", "type"], "cachedValue": ["codedString", "ciledValue", "CashedKey", "ciledKey", "cashedKey", "CachedVALUE", "cachedVal", "CachedKey", "cashedValue", "CashedVALUE", "cashedVALUE", "curedvalue", "cachablevalue", "cachedKey", "ciledVALUE", "cachedVALUE", "cachableString", "scodedvalue", "scachedString", "cachedvalue", "scodedValue", "curedString", "calledValue", "calledvalue", "codedVal", "Cashedvalue", "codedValue", "scachedValue", "cachableValue", "curedValue", "codedvalue", "CashedValue", "cachedString", "Cachedvalue", "calledKey", "scachedvalue", "cachableVal", "curedVal", "scodedString", "CachedValue", "cashedvalue", "ciledvalue", "scodedVal", "scachedVal", "calledVALUE"], "a1": [" a5", " a3", "sa2", "A3", "pone", "a5", "A1", "sa1", "alpha3", "alpha2", "aone", "area1", "A2", "alphaone", "p5", "areaone", "area2", "Aone", "r5", "area3", "alpha1", " aone", "a3", "p2", "p3", "saone"], "r1": ["R0", "r11", "pone", "ar2", "R2", "ar1", " r0", "ar3", "p0", "rone", "ar11", "r3", "R1", "a11", "a3", "p2", "p3", "r0", "p11", " rone", "Rone"], "a2": ["p62", "ae4", " a6", " a4", "a20", "p182", "a182", " a182", "p6", "an20", "ae2", "a4", "an2", " a62", "p20", "p0", "a0", "a62", "ga4", "r6", "ae6", "ga62", "ga6", " a0", "an182", "ae62", "ga2", "a6", "p2", "r0", "an62", " a20"], "r2": ["R4", "R1", "a4", "R2", "a3", "p2", "R3", "p4", "p3", "r3", "r4"], "p1": ["P3", "pone", "p01", " pone", "aone", " p2", " p3", "paone", "rone", "pa1", "r3", "P1", "P01", "Pone", "a3", "p2", "p3", " p01", "pa3", "pa01"], "u": ["uu", "chu", "lu", "ru", "o", "d", "ou", "b", "uy", "t", "w", "uc", "hu", "un", "tu", "g", "c", "nu", "uit", "eu", "fu", "du", "uci", "mu", "l", "q", "ue", "iu", "ui", "e", "y", "su", "bu", "uid", "uni", "s", "cu", "up", "U", "p", "m", "ups", "ul", "uv", "us", "user", "uno", "ur"], "f": ["fen", "inf", "str", "d", "b", "t", "fo", "info", "fp", "fast", "ref", "w", "z", "io", "buff", "fc", "g", "c", "front", "fs", "fe", "F", "xf", "vert", "stream", "fd", "fb", "line", "feed", "l", "ef", "lf", "fn", "full", "a", "df", "e", "form", "conf", "fr", "frame", "rf", "h", "fl", "fw", "ff", "m", "p", "of", "file"], "T": ["R", "G", "W", "D", "S", "NT", "t", "E", "L", "O", "WT", "M", "K", "Z", "F", "Q", "TT", "C", "V", "Y", "P", "H", "X", "Time", "TS", "NUM", "N", "U", "B", "Total", "TN", "I"], "i": ["bi", "ci", "diff", "d", "b", "si", "t", "z", "io", "int", "ind", "vi", "c", "ii", "bis", "ix", "l", "ar", "uri", "ri", "li", "zi", "a", "n", "e", "id", "j", "it", "ti", "y", "index", "ip", "X", "h", "ir", "slice", "di", "pi", "k", "p", "xi", "mini", "phi", "gi", "I"], "rows1": ["ows2", "runs8", "owsone", "ows8", "runs1", "row2", " rows8", "owsOne", " rows4", "rows4", "rows8", "checks1", "ows0", "checks2", "runsOne", "rowsOne", "ows4", "ows1", "row1", " rows0", " rowsone", "row0", " rowsOne", "rowsone", "rows0", "runs4", "checksone"], "r": ["R", "o", "str", "d", "t", "cr", "like", "range", "error", "now", "c", "run", "re", "rh", "err", "order", "l", "ar", "ri", "lr", "gr", "rd", "ner", "nr", "br", "ir", "rr", "rg", "rc", "rs", "p", "rel", "ro", "yr", "ur"], "x": ["xp", "d", "wx", "b", "w", "t", "z", "px", "test", "rex", "int", "ex", "rax", "g", "c", "rx", "re", "xc", "num", "xf", "ct", "ix", "code", "ax", "l", "q", "ctx", "n", "xx", "e", " X", "id", "xt", "xxx", "y", "index", "xs", "X", "h", "k", "m", "p", "xi", "ux", "sex"], "rows2": ["rows5", "ows2", "runs8", "ows8", " rows5", "ows5", "row5", "row2", "rics2", " rows4", "rows4", "rows8", "runs2", "rics8", "row4", " rows25", "rics32", "rics25", "ows4", "rics4", "rows32", "ows1", "row1", "ows25", "rows25", " rows32", "runs4", "ows32"], "v": ["lv", "tv", "volt", "d", "t", "z", "w", "rev", "conv", "vi", "g", "c", "vs", "iv", "cv", "vv", "l", "q", "V", "n", "val", "vd", "sv", "value", "e", "vals", "y", "vol", "h", "ve", "k", "m", "p", "va", "ev", "vp", "uv"]}}
{"code": " \n  '''\n  Limits\n  The game b\u200board provided will represent a valid state that was reached\n  through play of the game Tic-Tac-Toe-Tomek as described above.\n  \n  Small dataset   1 = T = 10.\n  Large dataset   1 = T = 1000.\n  \n  *** Sample Input \n  6\n  XXXT\n  ....\n  OO..\n  ....\n  \n  XOXT\n  XXOO\n  OXOX\n  XXOO\n  \n  XOX.\n  OX..\n  ....\n  ....\n  \n  OOXX\n  OXXX\n  OX.T\n  O..O\n  \n  XXXO\n  ..O.\n  .O..\n  T...\n  \n  OXXX\n  XO..\n  ..O.\n  ...O\n  \n  ***Output \n  Case #1: X won\n  Case #2: Draw\n  Case #3: Game has not completed\n  Case #4: O won\n  Case #5: O won\n  Case #6: O won\n  \n  '''\n  \n  \n  \n  inf = open(sys.argv[1])\n  def input(): return inf.readline().strip()\n  \n  \n  x_ptrn = re.compile('X{4}|X(.{4}X){3}|X(.{3}X){3}|X(.{5}X){3}')\n  o_ptrn = re.compile('O{4}|O(.{4}O){3}|O(.{3}O){3}|O(.{5}O){3}')\n  \n  \n  def check_game_status(b\u200board):\n      if x_ptrn.search(b\u200board.replace('T','X')):\n          return 'X won'\n      elif o_ptrn.search(b\u200board.replace('T','O')):\n          return 'O won'\n      elif '.' not in b\u200board:\n          return 'Draw'\n      else:\n          return 'Game has not completed'\n  \n  for caseNo in range(1, int(input())+1):\n      b\u200board = '|'.join(input() for _ in range(4))\n      input() # skip empty line\n      print 'Case #%d:' % caseNo, check_game_status(b\u200board)\n  \n", "substitutes": {"inf": ["cin", "cont", "fen", "arf", "std", "rec", "tif", "expl", "info", "fo", "utils", "gif", "input", "Inf", "init", "lin", "fs", "ini", "obj", "zin", "af", "impl", "feed", "ipl", "inside", "fits", "inc", "irc", "ins", "thin", "ssl", "aff", "conf", "fif", "inner", "txt", "iter", "path", "elf", "lo", "fin", "inn"], "x_ptrn": ["x_pointerns", "x_ptrd", "x_rtN", "x_fifd", "x_ptrns", "x_pointerf", "x_pointerd", "x_ptrN", "x_padn", "x_padf", "x_rtn", "x_ptrf", "x_pointerN", "x_rtns", "x_rtd", "x_padN", "x_fifN", "x_padns", "x_fifn", "x_pointern", "x_rtf"], "o_ptrn": ["o_ptryn", "o_vrr", "o__ptrN", "o_paddn", "o_padn", "o_espyn", "o_vrN", "o_ptrr", "o__pointerdn", "o_padN", "o_espn", "o_rtnn", "o_vrn", "o_pointerN", "o_rtr", "o_gradN", "o__ptryn", "o_ptrnn", "o_ptrdn", "o__pointeryn", "o_ptrN", "o__pointerN", "o__ptrn", "o_espdn", "o_pointern", "o_vrnn", "o_gradnn", "o__ptrdn", "o_gradn", "o_gradr", "o_pointeryn", "o_padyn", "o_espN", "o_pointerdn", "o_rtn", "o__pointern", "o_rtN"], "caseNo": ["caseNum", "aseNo", "resultName", "CaseName", "excCode", "Caseno", "caseCode", "resultCode", "caseno", " caseId", " caseNum", "aseId", "CaseId", "aseno", "CaseNo", "excno", "caseId", "excName", " caseno", "aseNum", "CaseCode", "caseName", "resultNo", "CaseNum", "resultno", "excNo"], "i": ["bi", "im", "ic", "ci", "d", "si", "b", "r", "io", "int", "ie", "v", "c", "ig", "l", "q", "li", "j", "it", "ip", "ir", "ib", "pi", "p", "f", "I"]}}
{"code": " \n  \n  def Solve(n,m,heights):\n      for i,j in ( (i,j) for i in xrange(n) for j in xrange(m) ):\n          if (heights[i,:]<= heights[i,j]).all(): continue\n  \n          if (heights[:,j]>heights[i,j]).any(): return \"NO\"\n  \n  \n      return 'YES'\n  \n  \n  \n  def parse(infile):\n      n,m=map(int, infile.readline().split() )\n      heights=np.zeros( (n,m) )\n      for i in xrange(n):\n          heights[i,:]=np.array( map(int, infile.readline().split() ) )\n      return n,m,heights\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n      outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  class Categorizer(dict):\n      def __init__(self,thelist,transform,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.AddList(thelist)\n          self.trunc=trunc\n      def AddList(self,thelist):\n          for item in thelist: self.Add( item )\n      def Add(self,object):\n          cat=self.transform( object )\n          if type(cat) is float:\n              cat=round(cat,trunc)\n          if self.has_key(cat):\n              self[cat].append( object )\n          else:\n              self[cat]=[object]\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-len(x[1]))\n          total=0\n          for i in items: total+=len(i[1])\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(len(val))) for val in self.itervalues() )\n          formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\n          for key,count in items[0:n]:\n              print formatter.format(key,len(count),\n                                     (\"%.2f\"%(len(count)*100.0/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=[]\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=len(self[key])\n              avg+=len(self[key])*key\n          return avg/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=len(self[key])\n              stddev += len(self[key]) * ( (key-avg)**2)\n          return stddev/(1.0*ntot)\n      def Median(self):\n          tot=0\n          for value in self.itervalues(): tot+=len(value)\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += len(self[key])\n             if nCount>tot/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n  \n  \n  \n  \n  class Counter(dict):\n      def __init__(self,thelist,transform=None,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.trunc=trunc\n          self.AddList(thelist)\n      def AddList(self,thelist):\n          if self.transform is not None:\n              for item in thelist: self.Add( self.transform(item) )\n          else:\n              for item in thelist: self.Add( item )            \n      def Add(self,object):\n          if type(object) is float:\n              object=round(object,self.trunc)\n          if self.has_key(object):\n              self[object]+=1\n          else:\n              self[object]=1\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-x[1])\n          total=0\n          for i in items: total+=i[1]\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(val)) for val in self.itervalues() )\n          formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\n          for key,count in items[0:n]:\n              print formatter.format(key,count, (\"%.2f\"%(count*100.0/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=0\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=self[key]\n              avg+=self[key]*key\n          return avg/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=self[key]\n              stddev += self[key] * ( (key-avg)**2)\n          return stddev/(1.0*ntot)\n      def Median(self):\n   \ttotal=sum(self.values())\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += self[key]\n             if nCount>total/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: x[1])[0]\n  \n  \n  def gen_primes():\n      \"\"\" Generate an infinite sequence of prime numbers.\n      \"\"\"\n      D = {}  \n      q = 2  \n  \n      while True:\n          if q not in D:\n              yield q        \n              D[q * q] = [q]\n          else:\n              for p in D[q]:\n                  D.setdefault(p + q, []).append(p)\n              del D[q]\n  \n          q += 1\n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n", "substitutes": {"n": [" N", "o", "name", "d", "nn", "b", "t", "r", "w", "u", "z", "nc", "net", "v", "nu", "c", "x", "num", "l", "nt", "ne", "mn", "sn", "e", "number", "y", "nr", "nb", "an", "nm", "ns", "cn", "s", "size", "k", "N", "f", "dn"], "m": ["sm", "mc", "md", "o", "d", "b", "w", "r", "z", "u", "range", "dm", "pm", "v", "dim", "g", "M", "c", "x", "num", "fm", "l", "mi", "gm", "cm", "mn", "e", "tm", "y", "ms", "mm", "nm", "h", "s", "k", "N", "ym", "km", "f"], "heights": ["HeIGHTS", "heIGHTS", "hight", " height", " heaves", " heets", "Heigh", "hecks", "seats", "heats", "heizes", "heets", "Heights", "weets", "waight", "mecks", "weaves", "weigh", "meights", "sheIGHTS", "Health", "seights", "high", " health", "sheigh", "weight", "Heats", "heigh", "health", " heizes", "Height", "keights", "heaves", "waets", "waigh", " heigh", "weIGHTS", "eights", "Heums", "meums", "waighters", "waizes", "seigh", "waalth", "heums", "weighters", "ealth", "halth", "keums", "shealth", "keighters", "eizes", "Hecks", "waights", "height", "eight", "heighters", "keigh", "weights", "Heighters", "seight", "meats", "wealth", "waaves", "hights", "weats", "kecks", "keight", "sheights", "keats"], "i": ["bi", "qi", "ij", "o", "ci", "yi", "d", "si", "b", "w", "z", "u", "ni", "eni", "io", "v", "ie", "int", "ind", "c", "x", "ini", "ii", "ix", "l", "start", "li", "ji", "a", "iu", "ai", "ui", "e", "id", "y", "ti", "index", "ip", "h", "di", "pi", "xi", "k", "hi", "phi", "ik", "f", "gi", "I"], "j": ["im", "ja", "ij", "o", "je", "d", "b", "si", "w", "r", "z", "u", "t", "aj", "jo", "uj", "v", "ind", "c", "x", "dj", "ii", "obj", "l", "jl", "li", "ji", "a", "e", "y", "h", "jp", "all", "js", "k", "xi", "end", "J", "jj", "f"], "infile": ["inifilename", "inf", "INstream", " inFile", "INfile", "inFile", "Instream", "instring", "Inline", "instream", "inputf", " infilename", "outline", "iniloop", " inf", "inline", "outfilename", "iniline", "infilename", " inline", " instring", " instream", "INline", "Instring", "inputstream", "outstream", " inloop", "outloop", "inifile", "INstring", "inputfile", "outFile", "InFile", "inputfilename", "Infile", "Infilename", "INFile", "outstring", "outf", "INfilename", "inloop"], "self": ["style", "view", "local", "er", "r", "z", "client", "app", "acl", "x", "ch", "python", "call", "result", "config", "_", "ok", "method", "e", "we", "wrapper", "P", "resp", "plugin", "temp", "work", "ck", "parent", "b", "master", "utils", "part", "ps", "spec", "sys", "function", "ctx", "request", "comp", "hand", "public", "comment", "driver", "server", "qs", "all", "plus", "cl", "s", "this", "f", "top", "event", "w", "proc", "private", "pos", "es", "error", "other", "now", "co", "instance", "obj", "node", "mp", "proxy", "cs", "layer", "exc", "dict", "block", "get", "form", "session", "list", "results", "Self", "h", "cmp", "util", "func", "name", "wx", "time", "ref", "case", "context", "load", "g", "c", "me", "ng", "tmp", "l", "gen", "ws", "os", "full", "cache", "http", "ns", "k", "worker", "host", "user", "act", "type"], "fname": [" fName", "afName", "FName", "fName", "afn", "lfName", "rName", "affNAME", "Fname", "afename", "afffile", "FNAME", " fn", "lfname", "fn", "Ffile", " fename", "lfNAME", "rname", "rename", "affname", "affName", "rn", "fNAME", "fename", "afname", "lffile", "ffile"], "NumCases": ["NumPodes", "NumCase", "numCans", "NumCans", "NumPases", "numChases", "NumCatans", "numAcASE", "numCASE", "NumScases", "NumCASE", "Numcodes", "NumCatases", "NumCatasing", "NumAcodes", "NumScase", "NumScans", "numCodes", "NumScasing", "numChasing", "Numcase", "numAcases", "NumAcase", "NumChasing", "NumCodes", "Numcases", "NumcASE", "NumPase", "numChans", "numAcase", "NumAcases", "numChase", "NumAcASE", "NumPASE", "numCases", "NumCatase", "numCasing", "numCase", "NumChans", "NumChases", "numAcodes", "NumChase", "NumCasing"], "caseNum": [" caseName", "Casenum", "aseNo", "caseNumber", "trialName", "catchNumber", " casenum", "testNo", "testNum", "trialnum", "CaseNo", " caseNumber", "testNumber", "catchName", "CaseNumber", "aseNumber", "testnum", "CaseLen", " caseLen", "trialNum", "catchNum", "caseNo", "casenum", "aseNum", "testName", "caseName", "trialNumber", " caseNo", "catchnum", "CaseNum", "aseLen", "CaseName", "caseLen"], "args": ["py", "loc", "body", "str", "arr", "ams", "w", "plays", "extra", "pos", "gs", "stats", "other", "options", "int", "Arg", "flags", "params", "axis", "atts", "array", " arguments", "fields", "ig", "doc", "ras", "argument", "ass", "got", "data", "obj", "np", "kw", "call", "config", "result", "_", "long", "dict", "a", "blank", "qa", "new", "arg", "Args", "words", "aw", "ay", "parts", " arg", "aux", "size", "ae", "lines", "parse", "f"], "myCases": ["myAcased", "MyCsased", "myCase", "myAcase", "MyTase", "MyTats", "myTased", "myAcasing", "myChases", "myCasing", "mycase", "mycased", "myCsasing", "myCsase", "MyCsases", "mycasing", "myCats", "myChats", "myTases", "MyCsasing", "myCsases", "MyCsase", "myAcases", "myTats", "myChase", "MyCases", "mycases", "myChased", "myAcats", "MyCats", "myCased", "MyCasing", "MyTases", "myCsased", "MyTased", "MyCase", "MyCased", "myTase"], "outfile": ["Outline", "inFile", " outFile", "outline", "inputline", "inline", "outfilename", " outfilename", " outline", "infilename", "Outfilename", "inputFILE", "Outfile", "inputfile", "outFile", "OutFile", "OutFILE", "inFILE", "inputFile", "outFILE"], "iCase": ["tiCas", " iPlace", "siCase", " iTest", "tiPlace", "jCode", "uCase", " iCode", "jFront", "iniTest", "iniCas", "tiTest", " iCas", "iPlace", "iCondition", "uCondition", "iniCase", "iFront", "iMatch", "siCondition", " iFront", "iniFront", "iCode", "iCas", "tiCase", " iCondition", "uMatch", "iTest", "jCase", "iniPlace", "siMatch", " iMatch", "iniCode"], "answer": ["ask", "swers", "ee", "air", "search", "name", "query", "abc", "string", "ac", "test", "anc", "now", "default", "array", "uit", "grade", "altern", "answered", " answers", "fix", "response", "null", "sr", "score", "acc", "data", "result", "order", "feed", "err", "Answer", "next", "question", "ave", "reply", "correct", "a", "respond", "page", "form", "sw", "cache", "example", "output", "don", "man", "ell", "au", "all", "word", "current", "ace", "this", "equ", "say", "adder"], "thelist": ["headerlists", "memberlist", "headerlist", " theList", "ethetable", "TheList", "thel", "Thelists", "preList", " thelists", "Thetable", "headerList", "headerl", "memberl", "prel", "Thel", "thetable", "prelists", " thel", " thetable", "memberList", "ethelist", "prelist", "Thelist", "ethel", "theList", "etheList", "thelists"], "transform": ["depth", "text", "target", "walk", "module", "scale", "metadata", "attribute", "reverse", "append", "move", "process", "change", "mod", "filter", "action", "input", "trans", "domain", "init", "former", "map", "dot", "root", "feature", "rank", "apply", "stream", "rot", "config", "node", "model", "Transform", "set", "package", "mask", "mut", "address", "function", "length", "add", "replace", "method", "form", "update", "orient", "project", "shape", "train", "translation", "hash", "forms", "const", "FORM", "path", "norm", "util", "switch", "draw", "sort", "format", "track", "pack", "command", "transfer", "type"], "trunc": ["TRunct", "Trun", "trun", "TRac", "TRunc", " trraction", " trunct", "frun", "trac", "Trac", " trac", " trun", "frunk", "transunc", "frunc", "tunk", "transraction", " Trunc", "frac", "tac", "transac", "tunc", " Trraction", "Trunc", "trunk", " trunk", "TRraction", "Trunk", "trunct", " Trunct", "traction", "trraction", "transunk", " Trac"], "item": ["image", "attribute", "loc", "parent", "name", "event", "ant", "action", "step", "other", "anything", "array", "article", "data", "obj", "result", "order", "node", "bar", "option", "unit", "layer", "arg", "page", "example", "element", "it", "index", "ip", "list", "area", "category", "member", "atom", "var", "entry", "Item"], "object": ["image", "text", "attribute", "module", "o", "str", "objects", "parent", "event", "none", "proc", "ant", "string", "person", "at", "int", "float", "edit", "cot", "array", "json", "null", "article", "Object", "oid", "instance", "python", "data", "obj", "integer", "actor", "line", "node", "ox", "function", "box", "number", "project", "element", "list", "void", "core", "file", "act", "type"], "cat": ["rat", "cast", "cas", "arr", "catch", "b", "cr", "abc", "ac", "fat", "lat", "nat", "at", "cp", "col", "cot", "cand", "c", "feature", "rank", "crit", "ct", "cur", "obj", "data", "feat", "base", "Cat", "lang", "max", "flat", "att", "cache", "tax", "category", "cart", "oct", "kat", "con", "cats", "cn", "op", "var", "sat", "sum", "type"]}}
{"code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _\u200ct in range(t):\n  \n          R, C, M = [int(x) for x in f.readline().split()]\n          f\u200bree_spots = R * C - M - 1\n  \n          if M == 0:\n              a\u200cnswer = [[\".\" for x in range(C)] for y in range(R)]\n              a\u200cnswer[0][0] = \"c\"\n          elif R == 1:\n              a\u200cnswer = [[\"c\"] + [\".\" for x in range(f\u200bree_spots)] + [\"*\" for m in range(M)]]\n          elif C == 1:\n              a\u200cnswer = [[\"c\"] + [\".\" for x in range(f\u200bree_spots)] + [\"*\" for m in range(M)]]\n              a\u200cnswer = zip(*a\u200cnswer[::-1])\n          elif f\u200bree_spots >= 3: # and M % R >= 2:\n              a\u200cnswer = [[\"*\" for x in range(C)] for y in range(R)]\n              a\u200cnswer[0][0] = \"c\"\n              a\u200cnswer[0][1] = \".\"\n              a\u200cnswer[1][1] = \".\"\n              a\u200cnswer[1][0] = \".\"\n              f\u200bree_spots -= 3\n              t\u200cr, br, c = 0, 1, 2\n              if c >= C:\n                  t\u200cr, br, c = 2, 3, 0\n              for _i in range(f\u200bree_spots):\n                  if a\u200cnswer[t\u200cr][c] == \"*\":\n                      a\u200cnswer[t\u200cr][c] = \".\"\n                  elif a\u200cnswer[br][c] == \"*\":\n                      a\u200cnswer[br][c] = \".\"\n                      if c < C-1:\n                          c+=1\n                      else:\n                          t\u200cr, br = t\u200cr + 2, br + 2\n                          c = 0\n                          if br == R:\n                              br, t\u200cr = br-1, t\u200cr-1\n                  \n          else:\n              a\u200cnswer = [\"Impossible\",]\n  \n          \n          \n          print (\"Case #\" + str(_\u200ct+1) + \":\")\n          for _i in a\u200cnswer:\n              print \"\".join(_i)\n      \n  \n", "substitutes": {"f": ["z", "float", "fu", "sf", "handler", "e", "fr", "family", "fw", "fi", "m", "uf", "of", "flu", "inf", "d", "b", "info", "fo", "fuel", "fp", "io", "fc", "F", "af", "fm", "fx", "q", "a", "df", "fer", "new", "y", "all", "path", "s", "file", "bf", "o", "diff", "isf", "w", "proc", "fs", "fe", "alf", "stream", "fd", "fb", "feed", "fed", "tf", "n", "free", "aff", "form", "conf", "h", "fl", "font", "fun", "fen", "fa", "ref", "fort", "fast", "v", "flow", "g", "cf", "l", "lf", "full", "fre", "flat", "j", "ff", "k", "p", "ft"], "fn": ["fen", "ll", "bf", "FN", "o", "name", "fin", "b", "w", "nc", "fp", "syn", "fat", "fc", "fs", "kn", "F", "fd", "feat", "fb", "fm", "l", "function", "n", "unc", "nt", "full", "sn", "ln", "filename", "bn", "output", "nm", "txt", "ns", "wl", "fl", "path", "fi", "cn", "fil", "m", "N", "func", "format", "fun", "dn", "file"], "t": ["o", "dt", "d", "b", "w", "z", "u", " T", "tt", "test", "token", "at", "v", "int", "table", "g", "st", "F", "tmp", "l", "A", "start", "q", "tf", "tor", "n", "nt", "a", "ts", "ot", "e", "bt", "xt", "j", "ut", "y", "T", "X", "rt", "art", "h", "ty", "temp", "s", "k", "m", "p", "pt", "ta", "type"], "_": ["ac", "O", " all", "g", "res", "All", " m", "P", "all", "k", "ro", "J"], "R": ["G", "W", "D", "S", "Rh", "RT", "E", "L", "O", "CR", "K", "RC", "RO", "F", "Q", "RA", "RM", "RG", "A", "V", "RR", "SR", "Y", "RH", "P", "H", "T", "X", "MR", "AR", "Ra", "U", "N", "B", "Rs", "I"], "C": ["G", "W", "D", "S", "FC", "CM", "EC", "E", "L", "O", "CR", "K", "Z", "CU", "ASC", "DC", "F", "Q", "CI", "A", "V", "Cu", "Y", "CC", "CA", "P", "H", "T", "CV", "X", "TC", "N", "U", "B", "Cs", "I"], "M": ["G", "LM", "W", "D", "S", "CM", "MS", "E", "L", "O", "K", "Z", "F", "Q", "MF", "RM", "A", "V", "Y", "MC", "P", "H", "T", "X", "MR", "TM", "MM", "MT", "m", "B", "U", "N", "J", "I"], "x": ["py", "out", "z", "u", "tx", "yp", "rax", "ch", "st", "xy", "vy", "ix", "ys", "e", "xt", "xs", "ty", "ux", " p", "b", " z", "input", " e", "gy", "rx", "xes", "xf", "ct", "fx", "q", "xxx", "y", "index", " ft", "plex", "ww", "w", "ph", "rex", "ase", "ax", "ox", "qu", "n", "xx", " X", " n", "lex", "h", " y", "rit", "text", "xp", "pe", "wx", "px", "v", "ex", "g", "xc", "nt", "sw", "X", "k", "p", "xi"], "i": ["bi", "qi", "im", "ij", "ic", "og", "ci", "d", "si", "b", "er", "z", "u", "ni", "w", "iet", "iz", "io", "v", "ie", "int", "at", "iw", "g", "ig", "ini", "ih", "ari", "ii", "iq", "l", "iri", "q", "ia", "ri", "ar", "li", "iot", "iu", "ai", "ot", "ish", "e", "iy", "j", "it", "ti", "y", "ip", "\u00ed", "ir", "h", "iar", "ib", "ali", "pi", "m", "p", "xi", "ei", "ik", "I"], "c": ["enc", "chain", "loc", "o", "ci", "name", "d", "b", "z", "u", "w", "ce", "ac", "uc", "cr", "nc", "v", "col", "cy", "g", "cc", "count", "pc", "cf", "ct", "lc", "bc", "code", "l", "oc", "cs", "q", "sc", "n", "a", "inc", "cm", "unc", "cat", "e", "cache", "ec", "y", "h", "rc", "con", "ca", "s", "cu", "k", "m", "p", "end", "dc"], "r": ["rec", "rou", "ru", "arr", "ibr", "er", "z", "u", "her", "run", "sr", "ear", "rar", "e", "nr", "fr", "br", "rg", "m", "ro", "yr", "igr", "rer", "str", "rl", "d", "b", "cr", "rb", "rx", "rh", "err", "oc", "q", "pper", "ri", "a", "lr", "gr", "\u0440", "y", "wr", "all", "rc", "ver", "ier", "rel", "kr", "adr", "o", "w", "rus", "ra", "ras", "ar", "ry", "n", "rd", "rt", "rf", "ir", "h", "arc", "pr", "rit", "ler", "ur", "dr", "v", "g", "re", "hr", "nor", "l", "arm", "\u00e9r", "right", "ire", "vr", "rr", "rs", "k", "ever", "p", "art"], "_i": ["_n", "_c", " _im", "_im", " _n", " _c"]}}
{"code": " \n  def generate_matrix(r, c, char):\n  \tm\u200dat = [[char for i in range(c)] for j in range(r)]\n  \treturn m\u200dat\n  \t\n  def merge(m\u200cat1, mat2):\n  \tfor i in range(len(m\u200cat1)):\n  \t\tfor j in range(len(m\u200cat1[i])):\n  \t\t\tmat2[i][j] = m\u200cat1[i][j]\n  \treturn mat2\n  \n  def solve(r, c, m):\n  \tif 0 == m:\n  \t\tm\u200dat = generate_matrix(r, c, '.')\n  \t\tm\u200dat[0][0] = 'c'\n  \t\treturn m\u200dat\n  \t\t\n  \tf = r * c - m\n  \t\n  \tif 0 == f:\n  \t\treturn False\n  \t\t\n  \tif 1 == f:\n  \t\tm\u200dat = generate_matrix(r, c, '*')\n  \t\tm\u200dat[0][0] = 'c'\n  \t\treturn m\u200dat\n  \t\t\n  \tif 1 == min(r, c):\n  \t\tm\u200dat = generate_matrix(r, c, '*')\n  \t\tfor i in range(f):\n  \t\t\tm\u200dat[0 if 1 == r else i][0 if 1 == c else i] = '.'\n  \t\tm\u200dat[0][0] = 'c'\n  \t\treturn m\u200dat\n  \n  \tif 2 == min(r, c):\n  \t\tif (0 != f % 2) or (2 == f):\n  \t\t\treturn False\n  \t\tm\u200dat = generate_matrix(r, c, '*')\n  \t\tfor i in range(f // 2):\n  \t\t\tm\u200dat[0 if 2 == r else i][0 if 2 == c else i] = '.'\n  \t\t\tm\u200dat[1 if 2 == r else i][1 if 2 == c else i] = '.'\n  \t\tm\u200dat[0][0] = 'c'\n  \t\treturn m\u200dat\n  \t\t\n  \tif (3 == r) and (3 == c):\n  \t\tif (4 == f) or (6 == f):\n  \t\t\tm\u200dat = generate_matrix(r, c, '*')\n  \t\t\tfor i in range(f // 2):\n  \t\t\t\tm\u200dat[0][i] = '.'\n  \t\t\t\tm\u200dat[1][i] = '.'\n  \t\t\tm\u200dat[0][0] = 'c'\n  \t\t\treturn m\u200dat\n  \t\tif 8 == f:\n  \t\t\tm\u200dat = generate_matrix(r, c, '.')\n  \t\t\tm\u200dat[2][2] = '*'\n  \t\t\tm\u200dat[0][0] = 'c'\n  \t\t\treturn m\u200dat\n  \t\treturn False\n  \t\t\n  \trows_to_reduce = min(r - 3, m // c)\n  \tif 0 < rows_to_reduce:\n  \t\tr\u200bes = solve(r - rows_to_reduce, c, m - rows_to_reduce * c)\n  \t\tif False == r\u200bes:\n  \t\t\treturn False\n  \t\tm\u200dat = merge(r\u200bes, generate_matrix(r, c, '*'))\n  \t\treturn m\u200dat\n  \t\t\n  \tcols_to_reduce = min(c - 3, m // r)\n  \tif 0 < cols_to_reduce:\n  \t\tr\u200bes = solve(r, c - cols_to_reduce, m - cols_to_reduce * r)\n  \t\tif False == r\u200bes:\n  \t\t\treturn False\n  \t\tm\u200dat = merge(r\u200bes, generate_matrix(r, c, '*'))\n  \t\treturn m\u200dat\n  \t\n  \tm\u200dat = generate_matrix(r, c, '.')\n  \tfor i in range(min(m, r - 2)):\n  \t\tm\u200dat[r - i - 1][c - 1] = '*'\n  \tif m == r - 1:\n  \t\tm\u200dat[r - 1][c - 2] = '*'\n  \tm\u200dat[0][0] = 'c'\n  \treturn m\u200dat\n  \t\t\t\n  \n  t = int(sys.stdin.readline().strip())\n  \n  for i in range(t):\n  \tprint \"Case #\" + str(i + 1) + \":\"\n  \n  \tr, c, m = [int(i) for i in sys.stdin.readline().strip().split()]\n  \t\n  \tr\u200bes = solve(r, c, m)\n  \t\n  \tif False == r\u200bes:\n  \t\tprint \"Impossible\"\n  \telse:\n  \t\tfor i in range(r):\n  \t\t\tfor j in range(c):\n  \t\t\t\tsys.stdout.write(r\u200bes[i][j])\n  \t\t\tprint\n", "substitutes": {"r": ["R", "ru", "str", "d", "b", "er", "w", "u", "rb", "range", "cr", "v", "ra", "g", "re", "sr", "x", "co", "hr", "rh", "err", "l", "ar", "q", "rar", "ri", "n", "lr", "gr", "right", "rd", "rev", "nr", "fr", "rt", "rf", "br", "ir", "h", "rg", "rc", "rr", "rs", "s", "pr", "k", "p", "ro", "yr", "kr", "ur", "dr"], "c": ["cin", "enc", "ic", "mc", "out", "ci", "d", "b", "w", "z", "u", "cr", "ce", "cp", "uc", "ac", "case", "v", "col", "cy", "anc", "fc", "g", "cc", "x", "ch", "co", "ct", "lc", "code", "l", "cs", "C", "q", "cell", "sc", "n", "a", "cm", "cat", "cent", "ec", "y", "h", "con", "arc", "s", "ca", "cu", "k", "p", "cl", "end", "dc", "max"], "i": ["bi", "qi", "z", "u", "iz", "int", "ie", "x", "ix", "iq", "ji", "zi", "idi", "qa", "ma", "ip", "chi", "fi", "hi", "gi", "im", "isi", "d", "b", "si", "io", "ig", "adi", "q", "ia", "ri", "a", "abi", "y", "ib", "di", "pi", "I", "ic", "o", "yi", "ni", "vi", "ii", "asi", "mi", "n", "ai", "oi", "it", "ir", "h", "phi", "ik", "ij", "ci", "name", "v", "g", "ini", "l", "li", "iu", "ui", "id", "ti", "ga", "lli", "k", "p", "xi", "ei"], "j": ["ij", "ja", "o", "je", "d", "b", "si", "z", "u", "aj", "uj", "v", "g", "oj", "x", "dj", "jc", "ii", "l", "q", "_", "ri", "li", "ji", "n", "a", "y", "ir", "h", "jp", "js", "pr", "k", "p", "J", "jj"], "mat2": ["at2", "dim2", "mat4", "attsecond", "atsecond", "m2", "att2", "dimsecond", " matrix4", "m4", "matsecond", " mat4", " matrix2"], "m": ["sm", "im", "mc", "md", "module", "o", "d", "b", "mo", "u", "w", "rm", "range", "z", "er", "dm", "pm", "v", "dim", "g", "M", "vm", "min", "x", "ch", "media", "wm", "am", "rem", "mr", "mu", "fm", "model", "l", "mi", "um", "gm", "q", "om", "arm", "n", "a", "em", "bm", "cm", "tm", "message", "mn", " M", "hm", "y", "ms", "an", "mm", "man", "mol", "nm", "h", "s", "k", "p", "more", "ym", "km"], "f": ["fen", "inf", "bf", "fa", "o", "d", "b", "w", "z", "u", "fp", "v", "fc", "g", "cf", "re", "x", "fs", "fe", "F", "xf", "fold", "sf", "af", "fb", "feed", "l", "um", "q", "tf", "lf", "function", "frac", "n", "a", "df", "form", "conf", "y", "fr", "rf", "h", "ff", "ft", "p", "k", "of"], "e": ["ite", "ee", "east", "cross", "enter", "diff", "pe", "d", "ide", "b", "ese", "E", "u", "edge", "z", "es", "ade", "ce", "ode", "v", "ie", "g", "ze", "x", "fe", "me", "le", "de", "ge", "l", "ke", "ale", "ue", "ed", "ine", "en", "ne", "ec", "y", "element", "oe", "se", "ve", "te", "el", "ise", "ae", "p", "end", "\u00e9"]}}
{"code": " \n  infile=open(sys.argv[1],'r')\n  \n  NumCases=int(infile.readline())\n  \n  for iCase in xrange(NumCases):\n  \n      a,b=[int(i) for i in infile.readline().split()]\n  \n  \n      a_digits=[int(i) for i in str(a) ]\n      b_digits=[int(i) for i in str(b) ]\n  \n      ld=len(a_digits)\n  \n  \n      result=0\n  \n      for iNum in xrange(a,b+1):\n          mystr=str(iNum)\n          myset=set()\n          for i in xrange(1,ld):\n              mystr=mystr[1:]+mystr[0]\n              iii=int(mystr)\n              if iii>iNum and iii<=b and iii not in myset:\n                  result+=1\n  \n              myset.add(iii)\n              \n          \n  \n  \n      print 'Case #'+str(iCase+1)+':',result\n  \n", "substitutes": {"infile": ["Infp", "inf", "binline", " inFile", "inFile", "Instream", "insf", "binhandle", "instream", " infilename", " inpath", "binfile", " inhandle", "inline", " inf", "outfilename", "outfile", "inhandle", " infp", "infilename", " inline", "inpath", "insline", "outfp", "Inpath", " instream", "outpath", "binf", "outstream", "inshandle", "InFile", "outFile", "insfile", "Infile", "infp", "Infilename"], "NumCases": ["NumCase", "NumDecase", "NumDecaves", "numcases", "NumCsase", "NumOccase", "numCASE", "NumCallaves", "NumCallases", "numcASE", "NumOccases", "numcats", "NumCsases", "NumCaves", "Numcats", "NumOccASE", "NumCASE", "numcaves", "NumOccats", "NumCallCase", "NumCats", "Numcase", "NumCCase", "numcase", "NumcASE", "Numcases", "numCaves", "NumDecCase", "numCats", "NumCallase", "Numcaves", "numCases", "numCase", "NumcCase", "numcCase", "numCCase", "NumDecases", "NumCsASE", "NumCsats"], "iCase": ["isicase", "siCase", "iCount", " iCode", "siCount", "ICase", "ciCode", " icase", "iCause", "icase", "isiCause", " iCause", "siNum", "ciCase", "ciCount", "isiCase", "ciNum", "ICause", "isiCode", "iCode", "ICode", "siCode", "Icase", " iCount"], "a": ["da", "aa", "ao", "d", "r", "u", "ac", "ba", "c", "x", "ea", "am", "sa", "alpha", "A", "ad", "ia", "n", "ai", "sta", "ak", "e", "la", "y", "asa", "an", "area", "ga", "au", "ca", "s", "ae", "p", "va", "ab", "f"], "b": ["bi", "bs", "aa", "o", "d", "abb", "r", "w", "u", "rb", "ba", "z", "bb", "v", "sb", "c", "mb", "count", "x", "num", "bc", "base", "l", "n", "lb", "xb", "e", "j", "y", "nb", "be", "eb", "h", "s", "wb", "k", "m", "B", "p", "ab", "f"], "i": ["bi", "qi", "isi", "o", "ci", "yi", "str", "d", "si", "t", "r", "z", "u", "io", "int", "v", "ie", "ind", "c", "x", "ini", "ii", "line", "l", "_", "li", "zi", "n", "iu", "ai", "ui", "e", "id", "j", "it", "ti", "ip", "y", "h", "chi", "s", "pi", "m", "p", "xi", "k", "ei", "phi", "f", "gi", "I"], "a_digits": ["a_digashes", "a_divets", "a_dets", "a_digITS", "a_dimITS", "a_divit", "a_dit", "a_dashes", "a_multiplets", "a_dimits", "a_digitals", "a_digitit", "a_multiplashes", "a_divITS", "a_multiplit", "a_dimals", "a_divits", "a_digit", "a_dits", "a_multiplits", "a_divals", "a_divashes", "a_digitITS", "a_digets", "a_digals", "a_dimit", "a_digitits"], "b_digits": ["b_dits", "b_digs", "b__divits", "b__divals", "b_divits", "b__digals", "b_multiplit", "b__divit", "b__digit", "b_ds", "b_multiplits", "b_dals", "b__divs", "b_digit", "b_dit", "b_digals", "b_divals", "b_multiplals", "b__digs", "b_multipls", "b_divit", "b_divs", "b__digits"], "ld": ["ll", "bf", "md", "loc", "xp", "d", "lda", "lag", "dist", "nc", "ds", "ind", "nd", "lib", "dd", "fold", "bl", "ded", "lc", "l", "bd", "lf", "lb", "rd", "old", "LD", "Len", "len", "nz", "xd", "lt", "ib", "dl", "sd", "dr", "cd"], "result": ["answer", "duration", "diff", "info", "r", "test", "range", "error", "direction", "success", "default", "card", "array", "grade", "count", "res", "match", "response", "score", "confidence", "data", "err", "alpha", "code", "final", "dict", "length", "inc", "df", "number", "ret", "nr", "list", "results", "found", "compl", "ver", "draw", "Result", "particip", "rest", "status", "f", "gi"], "iNum": ["phiNum", "inum", "siCase", "phiLength", " inum", " iCode", "iiRange", "siNumber", "ILen", "xiCode", "xiNumber", "xiRange", "INum", "iiNumber", " iNumber", "iLength", "iLen", "sinum", "piNum", "piCase", "piNumber", "siNum", "siLen", "ILength", "phiLen", "iCode", "iiNum", "xiNum", "iiCode", "Inum", "phinum", "siLength", "iNumber", " iRange", "pinum", "iRange"], "mystr": [" myStr", "MyStr", "MySTR", "Mybr", "hisstring", "fyset", "mystring", "yourset", "kybr", "fyStr", "mysbr", "gyst", "mychar", "yourStr", " mychar", "mysstring", "kyst", "histext", "fystr", "yourchar", "Mytext", "gystr", "mysstr", "mySTR", "kystr", "mybr", "bystr", "Mystr", "byStr", "hisSTR", "yourbr", "hisStr", "Myst", " myst", "fychar", "yourstr", "hisst", "kystring", "hisstr", "yourst", " mybr", "Mystring", "bytext", "mytext", "gySTR", " mystring", "gyStr", "myStr", "myst", "bystring", "mysst"], "myset": ["ysET", "minsect", "myet", "changesets", "changesET", "minsets", "mailsect", "mysets", "mysset", "mailsset", "changesset", "minset", "ssset", "mailsets", "ysets", "ysset", "changeset", "minsET", "gresET", "mysET", "mailset", "ssET", "mysect", "ssets", "mailsET", "myET", "sset", "yset", "gresets", "gresect", "greset", "myets"], "iii": ["cin", "qi", "uu", "adr", "ci", "yi", "III", "sup", "char", "cia", "direction", "rice", "dq", "dr", "ctr", "third", "iv", "tri", "dd", "xf", "du", "ii", "div", "vv", "tti", "iq", "vc", "iu", "division", "three", "id", "qq", "xxx", "itud", " III", "xa", "reci", "ga", "void", "xd", "orig", "cu", "di", "hw", "xi", "ida", "prev", "archive", "iva", "cci"]}}
{"code": "t = int(raw_input())\n  \n  for case in range(t):\n  \tl\u200bine = raw_input().split(' ')\n  \tn = int(l\u200bine[0])\n  \tm = int(l\u200bine[1])\n  \n  \tl = []\n  \tfor j in range(n):\n  \t\ta = raw_input().split(' ')\n  \t\tb = []\n  \t\tfor x in a:\n  \t\t\tb.append(int(x))\n  \t\tl.append(b)\n  \n  \n  \tcumple = True\n  \tfor i in range(n):\n  \t\tfor j in range(m):\n  \t\t\tc\u200bol = True\n  \t\t\tf\u200dil = True\n  \t\t\tfor x in range(n):\n  \t\t\t\tif l[x][j] > l[i][j]:\n  \t\t\t\t\tc\u200bol = False\n  \t\t\t\t\tbreak\n  \t\t\tfor x in range(m):\n  \t\t\t\tif l[i][x] > l[i][j]:\n  \t\t\t\t\tf\u200dil = False\n  \t\t\t\t\tbreak\n  \n  \t\t\tif not c\u200bol and not f\u200dil:\n  \t\t\t\tcumple = False\n  \t\t\t\tbreak\n  \n  \t\tif not cumple:\n  \t\t\tbreak\n  \n  \tif cumple:\n  \t\tprint 'Case #'+str(case+1)+': YES'\n  \telse:\n  \t\tprint 'Case #'+str(case+1)+': NO'\n", "substitutes": {"t": ["out", "o", "total", "dt", "d", "pe", "time", "r", "z", "u", "tt", "test", "tz", "w", "at", "net", "v", "int", "g", "c", "st", "ct", "start", "q", "ts", "title", "ot", "e", "tm", "ut", "it", "y", "ti", "T", "h", "temp", "te", "s", "p", "f", "et", "type"], "n": ["o", "d", "nl", "nn", "r", "z", "u", "nc", "w", "net", "v", "un", "g", "c", "nu", "no", "q", "nt", "en", "ne", "e", "sn", "y", "nb", "ns", "len", "h", "cn", "k", "N", "p", "yn", "f"], "m": ["sm", "mc", "o", "d", "r", "z", "u", "w", "v", "g", "M", "c", "cm", "en", "e", "y", "an", "mm", "nm", "h", "s", "k", "p", "f"], "l": ["ll", "lu", "left", "o", "d", "kl", "w", "L", "z", "u", "r", "like", "al", "v", "g", "c", "le", "lc", "line", "q", "li", "long", "late", "e", "ln", "la", "y", "list", "se", "ol", "ell", "h", "all", "fl", "s", "el", "gl", "k", "p", "dl", "il", "pl", "ul", "nl", "f", "sl"], "j": ["ja", "point", "o", "je", "d", "w", "r", "z", "u", "aj", "jo", "v", "ie", "un", "uj", "ind", "g", "c", "ix", "ax", "q", "jl", "li", "ji", "e", "on", "y", "fr", "h", "jp", "js", "k", "p", "J", "ion", "f", "jj"], "a": ["da", "aa", "fa", "d", "w", "aaa", "tta", "abc", "ac", "ba", "aj", "na", "array", "c", "acl", "ash", "ea", "am", "af", "sa", "code", "alpha", "ar", "A", "_", "ad", "ans", "sta", "qa", "ak", "e", "ma", "la", "y", "index", "aw", "area", "an", "ay", "ga", "au", "aux", "ca", "s", "k", "ae", "p", "ab", "va", "f"], "b": ["bi", "bs", "aa", "o", "d", "r", "z", "u", "w", "ba", "v", "sb", "g", "c", "bl", "base", "lb", "e", "y", "be", "h", "ib", "bel", "el", "s", "k", "B", "p", "ob", "ab", "pl", "f"], "x": ["ll", "ic", "xe", "xp", "d", "change", "w", "z", "u", "px", "test", "v", "int", "ex", "g", "c", "rx", "xc", "xes", "num", "xy", "ix", "code", "ax", "q", "xx", "yx", "xb", "e", "id", "xt", "lex", "number", "y", "xxx", "index", "ip", "xs", "X", "h", "any", "k", "p", "xi", "work", "sex", "f"], "cumple": ["Cample", "ncample", "cancelen", "Cumpling", "campler", "Cumple", "lcumpler", "cippl", "cumbLE", "lcuppli", "lcupple", "cupli", "campling", "campLE", "ncupple", "ncuppLE", "Cumplet", "cupLE", "cumpling", "ncampler", "lcumple", "campli", "lcuppl", "ncupplen", "cuppler", "cupplet", "cupplen", "canceler", "cumpler", "ncampli", "ncampLE", "ncumpli", "cuple", "cipple", "ncumplen", "cuppLE", "cumpLE", "cumpl", "cumplet", "cumble", "ncumpLE", "cupl", "cumpli", "cippli", "camplet", "ncumpler", "canceLE", "cuppli", "camplen", "cample", "cuppl", "CampLE", "cupple", "lcumpl", "lcumpli", "ncumple", "cancele", "cupler", "cumblet", "Campling", "ncuppler", "CumpLE", "lcuppler", "cumbling", "cippler", "Camplet", "cumplen", "cuppling"], "i": ["bi", "ite", "im", "ic", "o", "ci", "d", "si", "w", "z", "u", "io", "int", "ie", "v", "ind", "g", "c", "ii", "ix", "iq", "li", "ji", "iu", "ai", "ine", "e", "id", "it", "y", "ip", "ir", "ib", "k", "p", "xi", "pi", "f", "I"]}}
{"code": " \n  \n  def is_palindrome(a):\n      return str(a) == ''.join(reversed(str(a)))\n  \n  \n  def solve_problem(m\u200cin_num, m\u200cax_num):\n      c\u200bount = 0\n      for i in xrange(m\u200cin_num, m\u200cax_num + 1):\n          if is_palindrome(i):\n              s\u200cqrt = math.s\u200cqrt(i)\n              if int(s\u200cqrt) == s\u200cqrt and is_palindrome(int(s\u200cqrt)):\n                  c\u200bount += 1\n      return c\u200bount\n  \n  \n  if __name__ == '__main__':\n      n\u200dum_of_cases = int(sys.stdin.readline())\n      for i in xrange(1, n\u200dum_of_cases + 1):\n          m\u200cin_num, m\u200cax_num = map(int, sys.stdin.readline().strip().split(' '))\n          print 'Case #{0}: {1}'.format(i, solve_problem(m\u200cin_num, m\u200cax_num))\n", "substitutes": {"a": ["aja", "ama", "ja", "aa", "fa", "o", "name", "d", "asu", "b", "asta", "w", "aaa", "u", "ac", "ba", "aj", "na", "ya", "ana", "array", "ra", "c", "audio", "x", "ea", "asha", "am", "af", "sa", "alpha", "A", "ar", " ta", "ia", "aaaa", "n", "active", "title", "sta", "args", "ai", "ak", "e", "ma", "another", "la", "ara", "y", "area", "an", "asa", "ga", " ma", "mA", "au", "aux", "s", "ace", "ca", "ae", "p", "m", "ab", "va", "analysis", "anta", "omnia", "ata", "f", "ta"], "i": ["bi", "im", "isi", "ic", "o", "ci", "d", "si", "b", "z", "u", "iet", "ski", "eni", "io", "v", "ie", "int", "ind", "vi", "g", "c", "multi", "ig", "x", "ini", "ih", "ii", "ix", "iq", "l", "ili", "uri", "li", "ia", "ri", "iu", "ai", "iot", "n", "zi", "e", "id", "j", "it", "ti", "y", "ip", "h", "chi", "ib", "s", "fi", "di", "pi", "m", "p", "xi", "k", "ei", "phi", "ik", "f", "gi", "I"]}}
{"code": " \n  def debug(v):\n      pass#print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def readf(f):\n      t = tuple(float(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, a\u200cns):\n      o\u200cut = \"Case #{}: {}\".format(X, a\u200cns)\n      f.write(o\u200cut)\n      f.write(\"\n\")\n      print(o\u200cut)\n  \n  \n  \n  def main(inf, outf):\n      T, = read(inf)\n      for casenmbr in range(1, T + 1):\n          C, F, X = readf(inf)\n  \n          power = 2\n          f\u200darmtime = round(C / power, 7)\n          keikatime = 0\n          totaltime = round(X / power, 7)\n  \n          while True:\n              keikatime += f\u200darmtime\n              power += F\n              f\u200darmtime = round(C / power, 7)\n              nokoritime = round(X / power, 7)\n              if keikatime + nokoritime > totaltime:\n                  break\n              totaltime = keikatime + nokoritime\n  \n          answer(outf, casenmbr, totaltime)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".o\u200cut\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as outf:\n              main(inf, outf)\n", "substitutes": {"v": ["lv", "ll", "tv", "volt", "d", "b", "w", "z", "u", "i", "nv", "conv", "ven", "vi", "g", "c", "vs", "iv", "x", "ch", "vu", "vt", "vv", "l", "q", "V", "n", "vd", "sv", "e", "env", "en", "ov", "j", "ut", "y", "h", "ve", "ver", "k", "m", "p", "ev", "vp", "uv"], "f": ["fen", "o", "d", "b", "fo", "w", "u", "fp", "info", "i", "z", "r", "io", "fc", "g", "c", "cf", "x", "fs", "fe", "sf", "ference", "stream", "xf", "fd", "af", "fb", "line", "feed", "l", "fm", "q", "tf", "function", "full", "n", "a", "df", "e", "fer", "form", "self", "j", "conf", "y", "fu", "fr", "rf", "h", "fl", "fw", "fi", "ff", "m", "p", "k", "uf", "of", "version", "file"], "t": ["out", "o", "total", "dt", "d", "b", "time", "w", "r", "u", "tt", "i", "test", "z", "at", "int", "table", "g", "c", "x", "st", "det", "mt", "l", "qt", "wt", "tf", "ts", "n", "tp", "a", "ot", "en", "et", "e", "j", "ut", "it", "y", "ret", "h", "all", "te", "m", "p", "this", "end", "pt", "ta", "type"], "X": ["Work", "G", "R", "CL", "W", "D", "S", "XM", "L", "z", "E", "XY", "Unix", "Ex", "Xi", "O", "IX", "M", "K", "Z", "x", "WH", "XX", "Q", "FX", "TX", "HTTP", "A", "V", "EX", "IP", "Y", "XL", "PE", "XXX", "WS", "P", "XP", "H", "PH", "US", "RH", "Max", "MX", "DX", "FF", "UX", "U", "N", "B", " x", "OX", "Cross", "J", "FW", "Tx"], "inf": ["cli", "ffe", "fen", "img", "image", "cgi", "tif", "out", "expl", "info", "ref", "z", "zen", "inet", "i", "input", "Inf", "init", "lab", "xml", "ind", "ext", "cf", "c", "fe", "ini", "af", "config", "feed", "q", "tf", "bug", "inc", "irc", "fit", "fried", "aff", "qq", "conf", "fr", "inner", "txt", "rf", "h", "iter", "pp", "temp", "php", "path", "fi", "orig", "ff", "inst", "plus", "inter", "zz", "elf", "pl", "log", "fin", "inn"], "outf": ["outc", "hardf", "casew", "outw", "outfs", "OUTfile", " outw", " outfile", "outfile", "Oute", "rawe", "hardform", "rawfe", "Outform", "hardw", " oute", "Outfe", "rawc", "casef", "OUTf", " outform", " outfe", "Outv", "OUTfs", "casefield", "Outf", " outfield", "OUTform", "Outfile", "outfe", "hardfield", "oute", " outc", " outfs", "outform", "caseform", "outv", "rawf", "Outfs", "Outc", "OUTv", " outv", "outfield"], "T": ["R", "G", "W", "D", "S", "L", "E", "O", "WT", "M", "TH", "Z", "Q", "TT", "A", "V", "n", "Y", "TF", "P", "H", "Time", "TS", "N", "B", "U", "Total", "TN", "I"], "casenmbr": ["casennmbr", "casenfbre", "casenmbro", "casenermBR", "casenmbl", "casencmbr", "casernymbre", "casenervbr", "casernmBr", "casennmBr", "casenfmbre", "casenfBR", "casencmbre", "casenvBR", "casenervbre", "casernmbre", "casenmBR", "casennmbre", "casenmBr", "casennmbro", "casenfbl", "casenvbre", "casenymbr", "casernymbro", "casenervbl", "casenfmBr", "casenermbre", "casenymbre", "casenfmbro", "casernymBr", "casenfmbr", "casenymBr", "casernmbr", "casernymbr", "casenfbr", "casenvbr", "casenymbro", "casenermbr", "casenermbl", "casenervBR", "casencmbl", "casernmbro", "casenvbl", "casencmBR", "casenmbre"], "C": ["Co", "R", "G", "CE", "W", "D", "E", "L", "O", "c", "M", "K", "Q", "CF", "CI", "A", "V", "Y", "CC", "CA", "P", "U", "N", "B", "Con"], "F": ["G", "R", "W", "D", "S", "FD", "E", "L", "O", "M", "K", "Z", "Q", "CF", "A", "V", "Y", "Fs", "P", "EF", "H", "WF", "FE", "FF", "UF", "U", "B", "N", "I"], "power": ["ow", "CE", "cycle", "scale", "key", "style", "time", "prime", "distance", "pack", "char", "ce", "case", "step", "range", "rice", "front", "grade", "count", "rank", "period", "performance", "efficiency", "age", "powers", " Power", "OWER", "div", "mix", "force", "energy", "start", "PI", "function", "length", "speed", "patch", "division", "cost", "three", "shift", "right", "zero", "form", "Power", "P", "state", "number", "capacity", "powered", "eight", "size", "ace", "production", "p", "orce", "command", "span", "fork"], "keikatime": ["keikettime", "keigaratetime", "keikaratime", "keikarIME", "keikaratIME", "keikatimes", "keikacime", "keikartile", "kerikaratile", "keigatage", "kerikaratime", "keigaratimes", "keikatile", "keikarime", "keikharime", "keikaratimes", "keikhattime", "keikhatime", "keikhartime", "keikaratrice", "keikatetime", "keigatimes", "kerikatile", "keikattime", "keikkatrice", "keikkattime", "keikacage", "keikaratage", "kerikaratimes", "keikartIME", "keikaretime", "keikacetime", "keigaratage", "keikharetime", "keikkaratrice", "keikarage", "keikartime", "keikhatimes", "keikkatetime", "keikharimes", "keikatIME", "keigaratime", "keikhatetime", "keikatage", "keikaratile", "keikarrice", "keikarattime", "keikarile", "keikatrice", "keikaratetime", "keikartimes", "kerikatIME", "keikarimes", "kerikatime", "keiketime", "keikkatime", "keikkaratetime", "kerikaratIME", "keikkarattime", "keiketetime", "keikkaratime", "kerikatimes", "keikacimes", "keiketrice", "keigatime", "keigatetime", "keiketimes"], "totaltime": ["Totalcount", " totalcount", "averageTime", " TotalTime", "fulltime", "totaletime", " totaltim", "fulletime", "Totaltime", "totalcount", "fullTime", "totalTime", "otalTime", "TotalTime", "Totaltim", "totalduration", " Totaltime", "averageduration", " totalTime", "averagetime", " Totaltim", "Totaletime", "otaltime", " totaletime", "otalcount", "totaltim", "Totalduration", " totalduration"], "nokoritime": ["noyorimet", "nokorimet", "nokorime", "nokorridian", "noyocritial", "nyknoritime", "nokorisite", "nokorsidian", "nokornime", "nocorrisite", "nokorsitime", "nokorrimet", "noyocrimi", "noknorime", "nokorrisite", "nocorimet", "nokoreime", "noknorimi", "nokornisite", "nokorrimi", "nocorritime", "noknoridian", "noknorimet", "nykoridian", "noyocritime", "noknoritial", "nokoreisite", "nokoritial", "nokocrimi", "nokocrimet", "nocorrimet", "nokocritime", "noyocrimet", "nokorritial", "noyorimi", "noknoritime", "nokocritial", "nokorimi", "nocoritime", "nokornitime", "nokorsime", "nyknorimi", "nokorsimi", "nyknoridian", "nykoritime", "nokorrime", "nokoreitime", "nyknorime", "nocorime", "nokorritime", "nykorimi", "noyoritime", "nocorisite", "nykorime", "noyoritial", "nocorrime", "nokornimet", "nokoridian", "nokoreimet"], "infname": ["confignamed", "diffnamed", "elfName", "infn", "Infn", "Infnames", "elfpath", "affsize", "Inffile", " infn", "infnamed", "InfName", "elffile", "elfname", "inffile", " inffile", "difffilename", "diffNAME", "affnames", "affn", "configfilename", "Infname", "diffname", "infsize", " inffilename", "infNAME", " infpath", "infnames", "Infsize", " infnames", "affname", " infsize", "configNAME", " infName", "Infpath", " infnamed", "infpath", " infNAME", "inffilename", "infName", "configname"], "outfname": ["outfnam", "outFname", "outfsize", "outcfpath", "intcfpath", "outfilesize", "outFsize", "outfilepath", "OutcName", "OutfName", "intcfnam", "outfilename", "outlfnam", "outfName", "Outcsize", "Outfname", "outfpath", "outfnames", "intcfname", "outfileName", "outcpath", "Outfpath", "outFName", "outcfname", "intfpath", "intfnam", "outcsize", "intfname", "outcfnam", "Outcpath", "outcnames", "outlfnames", "outcName", "outcfnames", "outlfpath", "outcname", "outlfname", "Outfsize", "outFpath", "Outcname", "outcnam", "intcfnames", "intfnames"]}}
{"code": " \n  main = do\n      interact (unlines . map showCase . zip [1..] . g\u200co . tail . lines)\n  \n    where\n      g\u200co :: [String] -> [Bool]\n      g\u200co []     = []\n      g\u200co (l:ls) =\n          let [h, w] = map read $ splitOn \" \" l\n              (ls', ls'') = splitAt h ls\n              table = map (map read . splitOn \" \") ls'\n          in solve h w table : g\u200co ls''\n  \n      showCase :: (Int, Bool) -> String\n      showCase (i, r) = printf \"Case #%d: %s\" i (if r then \"YES\" else \"NO\")\n  \n  solve :: Int -> Int -> [[Int]] -> Bool\n  solve h w table = and [ cell >= (maxLgn ! y) || cell >= (maxCol ! x)\n      | y <- [0..h-1], x <- [0..w-1], let cell = arr ! (y, x)\n      ]\n    where\n      arr :: Array (Int, Int) Int\n      arr = listArray ((0, 0), (h-1, w-1)) $ concat table\n  \n      maxLgn, maxCol :: Array Int Int\n      maxLgn = listArray (0, h-1) $ [ maximum [ arr ! (y, x) | x <- [0..w-1] ]\n          | y <- [0..h-1]\n          ]\n  \n      maxCol = listArray (0, w-1) $ [ maximum [ arr ! (y, x) | y <- [0..h-1] ]\n          | x <- [0..w-1]\n          ]\n", "substitutes": {"let": ["letter", "out", "lets", "b", "t", "L", "single", "split", "string", "offset", "other", "v", "int", "edit", "le", "x", "bl", "line", "l", "set", "_", "li", "replace", "get", "flat", "id", "new", "T", "list", "slice", "ve", "lt", "temp", "el", "p", "this", "end"], "h": ["sh", "wa", "r", "z", "u", "her", "x", "ch", "ho", "th", "hp", "gh", "e", "ah", "m", "hi", "ht", "hl", "d", "b", "i", "ih", "oh", "rh", "eh", "ls", "q", "hs", "he", "hand", "y", "hd", "H", "s", "cl", "ham", "ul", "hash", "uh", "f", "W", "o", "ph", "col", "kh", "hh", "hard", "zh", "bug", "n", "en", "hm", "ha", "hell", "hw", "che", "max", "ow", "bh", "wh", "t", "help", "v", "g", "c", "hr", "l", "j", "sw", "hot", "hy", "k", "p", "host"], "w": ["sh", "ow", "wed", "W", "wa", "ew", "wh", "wx", "d", "wal", "ww", "r", "z", "u", "down", "b", "ph", "v", "web", "iw", "g", "c", "cl", "x", "win", "width", "kw", "tw", "wm", "wan", "wu", "l", "ws", "wt", "q", "wd", "n", "wave", "wk", "e", "we", "rw", "sw", "words", "y", "ha", "aw", "wr", "wer", "wl", "word", "fw", "s", "wb", "k", " W", "p", "hw", "m", "wy", "wall", "work", "oss", "f", "wn", "max"]}}
{"code": " a = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004, 100000020000001]\n  A = a[:10]\n  def subdfs(pre, m\u200cid, d, t, n):\n      if d == t:\n          k = long(''.join([pre, m\u200cid, pre[::-1]]))\n          k = k * k\n          if k > n:\n              return [1, 0]\n          sqk = str(k)\n          if sqk == sqk[::-1]:\n              A.append(k)\n              return [0, 1]\n          else:\n              return [0, 0]\n      res = subdfs(pre + '0', m\u200cid, d + 1, t, n)\n      if res[0]: return res\n      if not res[1]: return res\n      res2 = subdfs(pre + '1', m\u200cid, d + 1, t, n)\n      if res2[0]: return [1, res[1] + res2[1]]\n      return [0, res[1] + res2[1]]\n  \n  def dfs(d, n):\n      subdfs('1', '', 0, d, n)\n      subdfs('2' + '0' * d, '', d, d, n)\n      subdfs('1', '0', 0, d, n)\n      subdfs('1', '1', 0, d, n)\n      subdfs('1', '2', 0, d, n)\n      subdfs('2' + '0' * d, '0', d, d, n)\n      subdfs('2' + '0' * d, '1', d, d, n)\n  \n  def solve(pre):\n      read_ints = lambda: map(int, raw_input().split())\n      l, r = read_ints()\n      cl = bisect_left(A, l)\n      c\u200dr = bisect_right(A, r)\n      cl_ = cr_ = 0\n      for i in xrange(40):\n          if a[i] < l: cl_ += 1\n      for i in xrange(40):\n          if a[i] <= r: cr_ += 1\n      print pre, c\u200dr - cl\n  \n  for k in xrange(1, 48):\n      dfs(k, 10 ** 100 + 1)\n  A.sort()\n  N = int(raw_input())\n  for i in xrange(1, N + 1):\n      solve(\"Case #%d:\" % i)\n", "substitutes": {"a": ["aa", "b", "t", "aaa", "w", "ac", "aj", "params", "array", "c", "data", "am", "sa", "result", "alpha", "ar", "ad", "aaaa", "ai", "account", "e", "j", "list", "an", "ga", "au", "ca", "s", "m", "p", "ae", "ab", "ata", "f", "art"], "A": ["G", "R", "W", "D", "S", "aa", "b", "Alpha", "w", "E", "L", "O", "As", "array", "g", "M", "c", "K", "F", "Q", "am", "alpha", "C", "V", "Y", "args", "CA", "AM", "P", "H", "T", "ae", "B", "p", "U", "AA", "AP", "I"], "pre": ["py", "before", "pe", "par", "pod", "process", "name", "master", "none", "pm", "pin", "part", "pri", "pc", "primary", "re", "plan", "null", "min", "per", "pid", "pkg", "po", "base", "Pre", "prep", "model", "after", "li", "pro", "pad", "final", "patch", "pan", "pub", "tree", "j", "cache", "P", "prefix", "jp", "pa", "pp", "PRE", "current", "pr", "pres", "pi", "post", "p", "m", "pse", "prev", "table"], "k": ["sk", "o", "key", "kk", "b", "w", "u", "uk", "mk", "unk", "v", "g", "c", "K", "ijk", "x", "kn", "num", "ky", "kw", "q", "ke", "kick", "ok", "ku", "ak", "e", "id", "j", "ki", "y", "kid", "h", "kt", "dk", "tk", "s", "m", "p", "ks", "ko", "work", "kin", "kr", "km", "ik", "f", "ck"], "sqk": ["squp", "squok", "qsky", "sqp", " sqK", "squks", "qqks", "dqn", "sqke", " sqke", "dqK", "yyok", "squK", "sqn", "yyk", " sqok", "squk", "yyp", " sqks", "qsku", "dqks", "sqks", "sqky", "qqky", "yyke", "dqk", "squke", "squku", " sqn", "sqok", "squky", "sqK", "squn", "qsks", "qqk", "sqku", "qqku", "qsk", " sqp"], "res": ["rates", "rec", "req", "R", "hes", "works", "des", "arr", "rez", "rev", "ress", "resources", "es", "breaks", "range", "rys", "cons", "ps", "ons", "vs", "rows", "re", "ras", "response", "rss", "ries", "css", "exp", "x", "RES", "data", "rem", "maps", "resolution", "err", "result", "acts", "nos", "_", "os", "details", "blocks", "max", "gr", "rep", "reset", "right", "vals", "new", "ms", "ret", "resp", "results", "Res", "resource", "ris", "all", "rs", "js", "pres", "p", "rel", "rest", "ores", "runs", "ros"], "res2": ["resp4", "resolution1", "resolutiontwo", "prtwo", "Res2", "rus2", "Restwo", "resp1", "resolutionTwo", "Res3", " restwo", "Res4", "results4", "results2", "resTwo", "rus1", "pr2", "results3", " res1", "restwo", "resolution2", " resTwo", " res4", "rus3", "resp2", " res3", "results1", "resptwo", "res1", "res4", "res3", "prTwo", "Res1", "pr1", "resultstwo"], "d": ["da", "md", "D", "o", "dt", "b", "t", "w", "z", "ds", "do", "v", "dim", "g", "c", "dp", "nd", "dh", "x", "dd", "dy", "dn", "du", "dom", "pid", "data", " D", "fd", "db", "start", "ad", "did", "dict", "day", "e", "id", "j", "y", "h", "s", "di", "m", "p", "dir", "dl", "end", "ld", "pd", "sd", "dat", "dr", "f", "dc", "od"], "n": ["z", "u", "na", "x", "network", "ne", "e", "m", "common", "nl", "b", "nn", "pn", "y", "nin", "all", "s", "f", "o", "w", "none", "nc", "ni", "net", "un", "num", "en", "nb", "an", "don", "con", "end", "inn", "name", "t", "v", "nan", "g", "c", "nd", "nu", "no", "ng", "nor", "nt", "sn", "j", "on", "ns", "el", "p", "yn"]}}
{"code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/C/'\n  \n  \n  \n  def solve_one_case (R,C,M):\n          l = []\n          for i in range(R):\n              for j in range(C):\n                  l.append((i,j))\n  \n          empty_mat = []\n          for i in range(R):\n              empty_mat.append(['.']*C)\n  \n          f\u200bound = False\n  \n          assert (0,0) in l\n          l = l[1:]\n          l = l[::-1]\n          assert (0,0) not in l\n          \n          output = ''\n          \n          for mine_placement in itertools.combinations(l,M):\n              m\u200bat = deepcopy(empty_mat)\n              for cell in mine_placement:\n                  m\u200bat[cell[0]][cell[1]] = '*'\n              if isOneClick(m\u200bat, R, C, M):\n                  m\u200bat[0][0] = 'c'\n                  for line in m\u200bat:\n                      output += ''.join(line) + '\n'\n                  f\u200bound = True\n                  return output\n              \n          if not f\u200bound:\n              return 'Impossible\n'\n          \n          assert ValueError()\n          \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          line = f_in.readline()\n          R,C,M = [int(q) for q in line.split()]\n          print (testcase,R,C,M)\n  \n          output = solve_one_case (R,C,M)\n          f_out.write('Case #' + str(testcase) + ':\n')\n          f_out.write(output)\n  \n          \n  \n  \n  def isOneClick (m\u200bat, R, C, M):\n  \n      mat_cpy = deepcopy(m\u200bat)\n      o\u200cneclickcells = [(0,0)]\n      while o\u200cneclickcells:\n          n\u200dode = o\u200cneclickcells.pop()\n          mat_cpy[n\u200dode[0]][n\u200dode[1]] = 'v'\n          if noNearbyMines(mat_cpy,n\u200dode):\n              o\u200cneclickcells.extend(getNearbyUnvisited(mat_cpy, n\u200dode))\n  \n      return sum([l.count('.') for l in mat_cpy]) == 0\n      \n  \n  def getNearbyUnvisited(m\u200bat, n\u200dode):\n      R = len(m\u200bat)\n      C = len(m\u200bat[0])\n      deltas_r = [0]\n      deltas_c = [0]\n      if n\u200dode[0] > 0:\n          deltas_r.append(-1)\n      if n\u200dode[1] > 0:\n          deltas_c.append(-1)\n      if n\u200dode[0] < R-1:\n          deltas_r.append(1)\n      if n\u200dode[1] < C-1:\n          deltas_c.append(1)\n  \n      ret_list = []\n      for delta_r in deltas_r:\n          for delta_c in deltas_c:\n              next_node = (n\u200dode[0]+delta_r, n\u200dode[1] + delta_c)\n              if m\u200bat[next_node[0]][next_node[1]] not in ['*','v']:\n                  ret_list.append((next_node[0],next_node[1]))\n  \n      return ret_list\n  \n  def noNearbyMines(m\u200bat,n\u200dode):\n      R = len(m\u200bat)\n      C = len(m\u200bat[0])\n      deltas_r = [0]\n      deltas_c = [0]\n      if n\u200dode[0] > 0:\n          deltas_r.append(-1)\n      if n\u200dode[1] > 0:\n          deltas_c.append(-1)\n      if n\u200dode[0] < R-1:\n          deltas_r.append(1)\n      if n\u200dode[1] < C-1:\n          deltas_c.append(1)\n  \n      for delta_r in deltas_r:\n          for delta_c in deltas_c:\n              if m\u200bat[n\u200dode[0] + delta_r][n\u200dode[1] + delta_c] == '*':\n                  return False\n      return True\n      \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n  \n", "substitutes": {"directory": ["cont", "module", "gui", "name", "lib", "document", "language", "generated", "lc", "tmp", "config", "mode", "folder", "content", "cat", "description", "tree", "filename", "prefix", "source", "desc", "comments", "path", "files", "dir", "format", "pattern", "file"], "R": ["G", "JR", "W", "D", "S", "Cr", "Rh", "RN", "r", "E", "L", "DR", "RW", "O", "Ch", "IR", "CR", "Client", "Re", "K", "RC", "RO", "F", "Q", "Range", "RA", "RM", "RG", "RS", "Run", "A", "RR", "V", "SR", "Y", "Rule", "RH", "P", "WR", "H", "RL", "X", "MR", "Ra", "J", "N", "B", "U", "GR", "Line", "NR", "Rs", "I"], "C": ["CL", "CE", "W", "D", "S", "Cr", "G", "FC", "YC", "CM", "EC", "E", "L", "O", "Ch", "CR", "CT", "VC", "CU", "K", "PC", "UC", "DC", "F", "Q", "CF", "CI", "Size", "GC", "Sc", "JC", "A", "V", "Cu", "Y", "CH", "CC", "HC", "KC", "CA", "AC", "P", "CV", "H", "X", "SC", "CP", "IC", "LC", "TC", "NC", "N", "U", "B", "CN", "Cs", "Con", "MC", "OC", "I"], "M": ["G", "LM", "W", "D", "S", "PM", "EM", "FM", "CM", "IM", "ML", "MS", "L", "E", "r", "ME", "DM", "O", "MP", "Ms", "OM", "MO", "Me", "K", "Z", "F", "Q", "MF", "MA", "MQ", " m", "RM", "MN", "V", "BM", "Y", "JM", "MB", "MC", "NM", "Mo", "AM", "P", "H", "VM", "X", "MD", "MR", "MX", "TM", "MM", "MT", "m", "B", "U", "N", " L", "J", "MI", "I"], "l": ["ll", "d", "nl", "b", "kl", "t", "L", "r", "u", "z", "al", "v", "lin", "g", "le", "lc", "cel", "ls", "li", "et", "ln", "la", "it", "list", "ol", "ml", "all", "fl", "el", "m", "dl", "p", "lp", " L", "ul", "lines", "f", "sl"], "i": ["qi", "ij", "ci", "d", "si", "b", "r", "u", "ni", "io", "int", "ie", "v", "ind", "ini", "ii", "start", "li", "a", "iu", "ai", "ui", "id", "y", "ti", "index", "ip", "di", "pi", "k", "p", "xi", "f", "I"], "j": ["ij", "ja", "d", "b", "r", "z", "pos", "v", "jam", "ind", "g", "oj", "jc", "jl", "q", "li", "ji", "y", "jp", "js", "k", "m", "p", "end", "J", "jj", "f", "I"], "empty_mat": ["empty_Mat", "empty54material", "empty54cat", "empty64Mat", "empty54Mat", "empty64mat", "empty64cat", " empty_mm", " empty_seq", " empty_material", "empty54mat", "empty_mm", "empty64material", " empty_Mat", "empty_seq", "empty_material", "empty_cat", " empty_table", " empty_cat", "empty_table"], "output": ["out", "style", "debug", "bl", "display", "result", "config", "network", "unit", "method", "message", "plain", "example", "comments", "analysis", "console", "letter", "left", "module", "str", "d", "input", "function", "job", "written", "comment", "resource", "all", "file", "image", "cut", "control", "Output", "L", "string", "generation", "null", "response", "document", "after", "reason", "expression", "production", "summary", "log", "write", "version", "connection", "complete", "target", "text", "help", "shell", "v", " Output", "dot", "generated", "language", "model", "struct", "value", "ln", "pretty", "format", "command"], "mine_placement": ["mine_Placing", "mine_replication", "mine_splacing", "mine_splacement", "mine_replacing", "mine_plication", "mine_explacement", "mine_Ploding", "mine_Placements", "mine_ploding", "mine_explacements", "mine_Placement", "mine_explacing", "mine_replacements", "mine_splication", "mine_replacement", "mine_placements", "mine_Plication", "mine_placing", "mine_reploding", "mine_splacements", "mine_exploding"], "cell": ["ci", "cut", "group", "name", "gap", "case", "col", "cy", "sel", "cc", "match", "lc", "call", "cel", "code", "row", "li", "cells", "cm", "loop", "character", "contact", "ell", " cells", "ion", "lic"], "e": ["\u00e8", "py", "ee", "Ev", "pe", "ss", "d", "b", "ese", "E", "ere", "edge", "es", "er", "w", "u", "ade", "ode", "ce", "ie", "ane", "ive", "ze", "fe", "est", "me", "de", "le", "\u00e6", "ge", "ef", "ep", "ed", "a", "ue", "ine", "cm", "ape", "he", "en", "ne", "ing", "ec", "y", "oe", "se", "be", "eb", "ve", "el", "ace", "ae", "p", "m", "end", "ev", "one", "ance", "f", "et"], "c": ["can", "ci", "b", "t", "w", "u", "ac", "ce", "v", "cf", "cc", "g", "co", "ct", "call", "sc", "q", "cache", "ca", "cu", "m", "p", "che", "f"], "line": ["live", "text", "left", "point", "cycle", "out", "str", "name", "key", "pe", " Line", "nl", "rule", "L", "string", "case", "input", "shell", "col", "lined", "inline", "lin", "match", "le", "sample", "data", "lc", "row", "code", "model", "LINE", "q", "lf", "li", "unit", "sync", "cm", "ine", "block", "page", "band", "list", "frame", "source", "section", "len", "ml", "word", "el", "m", "log", "lo", "Line", "entry", "lines", "column", "day", "file"], "T": ["TI", "Test", "G", "Fl", "W", "D", "S", "CL", "Ts", "str", "NT", "t", "L", "E", "test", "Length", "O", "int", "WT", "CT", "K", "Z", "F", "Q", "TT", "A", "V", "DT", "Y", "TF", "ut", "P", "H", "X", "Max", "Tr", "Time", "TS", "N", "B", "p", "U", "TN", "TA", "Type", "I"], "testcase": ["testsline", "testaddress", "pretspace", "pretaddress", "testsshape", "estCase", " testCase", "estaddress", "estcase", "pretCase", "Testcase", "Testaddress", "servercase", "testline", "testCase", "testspace", "casecase", "Testcases", " testcases", "pretcase", "caseline", "testsCase", "caseshape", "testscase", "testshape", "testcases", " testshape", "estspace", "Testline", "serverCase", "caseCase", "TestCase", "Testspace", " testline", "servercases", "serverline"], "mat_cpy": ["mat_hps", "mat_nopy", "mat_lpd", "mat_cply", "mat_lcply", "mat_mpe", "mat_acpe", "mat_ucpy", "mat_mply", "mat_lcpe", "mat_acopy", "mat_npe", "mat_Cpy", "mat_mopy", "mat_lcopy", "mat_ucps", "mat_lcpy", "mat_cpd", "mat_Cps", "mat_lopy", "mat_hp", "mat_ucpd", "mat_lcpd", "mat_npd", "mat_lpe", "mat_hpy", "mat_hpd", "mat_mpy", "mat_cps", "mat_Cpd", "mat_cpe", "mat_npy", "mat_acpy", "mat_lpy", "mat_ucp", "mat_Cp", "mat_copy", "mat_acply", "mat_cp"], "o": ["out", "open", "off", "d", "ou", "b", "t", "r", "mo", "u", "bo", "w", "do", "fo", "io", "v", "O", " O", "g", "ino", "oj", "no", "oid", "co", "xy", "po", "oh", "ox", "online", "oc", "os", "q", "\u00f6", "ot", "auto", "oa", "new", "on", "y", "iso", "an", "oe", "ol", "h", "oy", "op", "so", "k", "m", "p", "N", "ob", "vo", "ko", "oo", "ro", "object", "lo", "go", "f", " self", "od"], "n": [" N", "out", "name", "d", "nn", "t", "r", "z", "u", "nc", "none", "syn", "ni", "na", "net", "ann", "un", "v", "nan", "g", "nu", "no", "nw", "min", "nor", "fn", "nt", "ot", "en", "ne", "mn", "adj", "sn", "y", "nb", "an", "nin", "don", "ns", "nov", "all", "nz", "cn", "non", "m", "N", "p", "yn", "inn"], "x": ["im", "vent", "out", "leg", "xp", "w", "z", "v", "tx", "col", "by", "ex", "ext", "xc", "bl", "co", "val", "xt", "sect", "lex", "y", "X", "h", "lim", "con", "cl", "ft"], "f_in": ["f__out", "cf_i", "cf_out", "f_io", "f_part", "f_IN", "f67out", "sf_io", "f_again", "cf_in", "sf_in", "f__IN", "f__again", "f__in", "f67part", "f67io", "sf_again", "f67in", "sf_part", "sf_IN", "cf_In", "f_i", "f_In", "sf_out"], "f_out": ["f__out", " f_Out", "f__io", "f_Out", "f_io", " f_io", "c_out", "f_again", " f__Out", " f__in", "f__again", "f__in", " f__out", "f__Out", "c_in", "c_again", "c_io", " f_again", " f__again"]}}
{"code": "mapping = {' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's',\n             'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u',\n             'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n',\n             'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a',\n             'x': 'm', 'z': 'q', 'q': 'z'}\n  \n  def translate(s):\n      return \"\".join(map(lambda a: mapping[a], s))\n  \n  if __name__ == \"__main__\":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          s = translate(raw_input().strip())\n          print \"Case #%d: %s\" %(i, s)\n  \n          \n", "substitutes": {"mapping": ["smapping", "hmapper", "mmapping", "Mapper", "mapped", "mmapped", " mangling", "mmapper", "smapped", "Mapping", " mappings", "smappings", "hmapping", "Mappings", "mmappings", "mappings", "mapper", " mapper", "hmangling", "smapper", "hmapped", "Mangling", "hmappings", "mangling"], "s": ["S", "o", "str", "south", "d", "ss", "b", "less", "w", "r", "t", "u", "string", "es", "input", "gs", "ds", "v", "ps", "sb", "g", "c", "spec", "x", "fs", "abs", "data", "speech", "ls", "ws", "os", "long", "f", "n", "ts", "a", "args", "sv", "e", "si", "new", "sw", "self", "ms", "source", "ns", "parts", "strings", "rs", "comments", "js", "changes", "m", "p", "sg", "services", "ses", "sl"], "T": ["TI", "R", "W", "D", "S", "NT", "Ti", "OT", "t", "E", "L", "O", "WT", "M", "TH", "Z", "TW", "F", "Q", "TT", "C", "V", "Y", "TF", "P", "H", "X", "Time", "TS", "N", "U", "B", "Total", "TN", "PT", "TA", "I"], "i": ["ci", "yi", "d", "si", "t", "z", "u", "int", "v", "ind", "vi", "c", "x", "ii", "l", "start", "q", "adi", "li", "a", "n", "iu", "ui", "e", "id", "j", "y", "ti", "index", "h", "di", "k", "pi", "p", "xi", "f", "I"]}}
{"code": " \n  \n  def Solve(F1,r1,F2,r2):\n      s1=set(F1[r1-1])\n      s2=set(F2[r2-1])\n      sx=s1.intersection(s2)\n      if len(sx)>1:\n          return \"Bad magician!\"\n      elif len(sx)==0:\n          return \"Volunteer cheated!\"\n      else:\n          return sx.__iter__().next()\n  \n  \n  \n  def parse(infile):\n      r1=int(infile.readline().strip())\n      F1=[]\n      for i in xrange(4):\n          F1.append( map(int, infile.readline().split() ))\n      r2=int(infile.readline().strip())\n      F2=[]\n      for i in xrange(4):\n          F2.append( map(int, infile.readline().split() ))\n      return F1,r1,F2,r2\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n  \n      outname=sys.argv[1].rstrip('.in')+'.out'\n      if os.path.isfile(outname):\n          oldout=outname+'.old'\n          ii=0\n          while os.path.isfile(oldout):\n              ii+=1\n              oldout=outname+'.old'+str(ii)\n          os.rename(outname,oldout)\n          print 'Rename: %s -> %s'%(outname,oldout)   \n   \n      outfile=open(outname,'w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n", "substitutes": {"F1": ["PF2", "ROne", "fone", "R6", "Fsn", "R3", "Fn", "f91", " F91", "Rone", "f1", "Fs91", "R81", "F91", "f3", "f2", "R2", "f6", " Fone", " F3", "Fone", "M1", "F3", "Fs2", "fn", "f81", "Fs1", "fOne", "PF3", " Fn", "F6", "R1", "M2", " F6", "FOne", " FOne", "M3", "F81", "M81", "PF1"], "r1": ["ROne", " r3", "c2", "c1", "R0", "R3", "nr2", "sr1", "nr0", "Rone", "f1", "rx", "srx", "R01", "f3", "f2", "R2", " r0", "rh1", "rhx", " rOne", "rh2", "nr1", "rone", " rone", "sr3", "cOne", "c01", "r3", "fOne", "R1", "r01", " r01", "Rx", "r0", "sr2", "rh3", "rOne", "nrone"], "F2": ["fII", "R4", "R0", "R3", " F22", "F0", "FSecond", "RSecond", "FO4", "F02", "f0", "f1", "R22", " F02", "R02", "f4", "f2", "R2", " FII", "FO3", "FII", " F3", "FOSecond", "f3", "f8", "F3", "F4", "f22", "R8", " F8", "FO2", "f02", "R1", "F22", " FSecond", " F0", " F4", "RII", "F8"], "r2": [" R56", "R4", " R4", "rgTwo", " r4", " R1", "f1", "rg02", "R02", "r02", "R2", "f2", "fTwo", "rg2", " r56", "R56", "rTwo", " r8", "r56", "RTwo", "F4", "R8", "f02", "rg1", "R1", " R2", "r8", "F8", "r4"], "s1": ["ss2", " s10", "s81", "S1", "f1", "Sx", " s81", "f2", "S2", "s3", "f81", "f10", "S3", "ss3", " s3", "ssx", "ss1", "s10"], "s2": ["S0", " s52", "STwo", "f52", " s0", "f0", "S1", "f1", " sTwo", "f2", "S2", "rTwo", "S52", "sTwo", " s62", "r62", "s0", "s52", "S62", "s62"], "sx": ["sxy", "SX", "sesxs", "ssxs", "S1", "Sx", "ssxy", "esxs", "es1", "sz", "Sxs", "sxs", "Sz", "sxx", "sesx", " sxy", "esz", "sesX", "esxx", "sX", "sespx", "esxy", "ssX", "Spx", "ssx", "esX", "esx", " sxs", "Sxx", "spx", " sX"], "infile": ["inifilename", "inf", "binline", " inFile", "inFile", "Instream", "iniFile", "Inline", "instream", " infolder", " infilename", "binfile", "outline", " inhandle", "inline", " inf", "outfilename", "inihandle", "inname", "inhandle", "infolder", "infilename", " inline", "insline", "binFile", " instream", "inistream", "ininame", "insfolder", "incfile", "incfolder", "binf", "outstream", "insfilename", "incFile", " inname", "inifile", "outFile", "InFile", "incline", "insfile", "outhandle", "Infile", "Infilename", "outf", "outfolder", "Infolder"], "i": ["o", "ci", "b", "r", "z", "u", "io", "v", "int", "ind", "g", "c", "x", "iq", "l", "li", "a", "n", "ai", "iu", "id", "j", "it", "ti", "ip", "h", "pi", "p", "f", "I"], "self": ["home", "view", "r", "client", "app", "x", "selves", "python", "call", "result", "config", "_", "method", "e", "resp", "temp", "m", "work", "object", "parent", "b", "master", "default", "part", "ps", "spec", "sys", "data", "q", "function", "ctx", "request", "public", "plus", "cl", "s", "this", "parse", "f", "event", "w", "proc", "private", "pos", "es", "error", "other", "now", "co", "instance", "node", "exc", "n", "session", "results", "Self", "h", "cmp", "func", "parser", "wx", "time", "ref", "case", "context", "g", "c", "me", "tmp", "l", "ws", "os", "full", "reader", "cache", "http", "ns", "k", "worker", "p", "host", "user", "type"], "fname": ["flatname", "FName", "filefile", "fileno", "inno", "filepath", "fName", "inname", "Fname", "fno", "flatno", "Fpath", "fpath", "Ffile", "outpath", "flatfile", "flatName", "filename", "outName", "fileName", "inName", "ffile"], "NumCases": ["NumPodes", "NumFase", "NumberScalls", "NumScaces", "NumCase", "NumberCaces", "NumPalls", "NumCaces", "NumPases", "NumFases", "NumScases", "NumberScaces", "Numcaces", "NumberCases", "NumFodes", "Numcalls", "numCams", "NumAcodes", "NumScase", "NumPaces", "numCodes", "NumCams", "NumberCalls", "Numcase", "NumberScase", "NumberCase", "NumAcase", "numAcases", "NumCalls", "NumCodes", "Numcases", "NumPams", "NumPase", "numAcams", "NumScalls", "NumFams", "numAcase", "NumAcases", "numCases", "numCase", "NumAcams", "numAcodes", "NumberScases"], "caseNum": ["Casenum", "caseNumber", "trialNo", "caseVal", " casenum", "testNo", "CaseVal", "testNum", "trialnum", "CaseNo", " caseVal", " caseNumber", "testNumber", "aseVal", "CaseNumber", "aseNumber", "testnum", "asenum", "trialNum", "caseNo", "casenum", "aseNum", "trialNumber", " caseNo", "CaseNum"], "args": ["py", "body", "loc", "works", "arr", "ams", "w", "plays", "pos", "extra", "gs", "ds", "conn", "GS", "other", "now", "init", "Arg", "flags", "params", "stats", "atts", " arguments", "fields", "ig", "g", "spec", "doc", "ras", "x", "argument", "ass", "data", "obj", "ix", "call", "gu", "ax", "limits", "gen", "cs", "ar", "_", "long", "dict", "a", "inc", "arg", "Args", "words", "aw", "ay", "parts", "all", " arg", "aux", "s", "ae", "ages", "parser", "lines", "parse", "items"], "myCases": ["myAcased", "myAcaser", "myCase", "myCsakes", "myAcase", "MyAcases", "myChases", "myCakes", "myCsase", "MyAcakes", "myChakes", "MyCaser", "MyAcaser", "myAcases", "myCsases", "myChase", "MyAcase", "MyCases", "myAcakes", "myChaser", "MyAcased", "myChased", "myCased", "MyCakes", "myCsaser", "myCsased", "myCaser", "MyCase", "MyCased"], "outname": ["offline", "Outline", "OUTnamed", "offName", "outline", "outnamed", "OUTfile", "offname", "inline", "outfilename", "inname", "outputfile", "outputname", "Outpath", "inbase", "OUTname", " outfilename", "OUTbase", " outline", "outputsize", "infilename", "OutName", "inpath", "outbase", "Outfilename", "outputName", "Outname", "outpath", "Outfile", "outName", " outName", " outsize", "inName", "insize", "innamed", "OUTName", "Outnamed", "offpath", "outsize", " outpath", "Outbase"], "oldout": ["Oldouts", "oldOut", " oldOUT", "oldagain", "oldouts", "OLDin", " oldOut", "OLDouts", "OLDOut", "OldOUT", "newOut", "OldOut", "newin", "Oldname", "oldin", "Oldout", " oldnet", "Oldin", "newouts", "Oldagain", "newout", "oldernet", "OLDname", " oldin", "OLDout", "newagain", "Oldnet", " oldname", " oldagain", "oldnet", "OLDOUT", "oldname", "olderout", "olderin", "oldOUT"], "ii": ["bi", "qi", " iii", "inf", "img", "lu", "uu", "iat", "ci", "ori", "si", "ice", "ni", "eni", "ind", "vi", "agi", "ini", "ili", "li", "zi", "iii", "ai", "ui", "flat", "abi", "ti", "index", "iso", "II", "iana", "uni", "lli", "sci", "di", "fi", "pi", "ali", "imi", "mini", "hi", "ei", "ani", "iss", "gi"], "outfile": ["outFile", "OutFile", "exfile", "exFile", "Outline", "Outname", "exname", " outline", "Outfile", "exline", " outFile", "outline"], "iCase": ["aCase", "ICase", "acase", "Icase", "ISection", "iSection", " icase", "aSection", " iSection", "icase"], "answer": ["search", "arr", "now", "array", "answered", " answers", "match", "response", "data", "call", "result", "Answer", " result", " Answer", "reply", "respond", "cache", "example", "number", "resp", "output", "results", "su", "ell", "size", "Result", "entry"]}}
{"code": " \n  \n  def read_str(): return stdin.readline().rstrip('\n')\n  def read_int(): return int(stdin.readline())\n  def read_ints(): return map(int, stdin.readline().split())\n  def read_floats(): return map(float, stdin.readline().split())\n  \n  \n  def atos(A):\n      return '\n'.join([''.join(row) for row in A])\n      \n  \n  def get_field(r, c):\n      field = [['.'] * c for i in range(r)]\n      field[0][0] = 'c'\n      return field\n      \n      \n  def is_forbidden(i, j):\n      return i == 0 and j == 0 or i == 0 and j == 1 or \\\n          i == 1 and j == 0 or i == 1 and j == 1\n      \n      \n  def fill(field, r, c, m):\n      l\u200ceft = m\n      for i\u200ci in range(r - 1, -1, -1):\n          i = i\u200ci\n          j = c - 1\n          while i < r and j >= 0:\n              if is_forbidden(i, j):\n                  i += 1\n                  j -= 1\n                  continue\n              if l\u200ceft == 0:\n                  return 0\n              field[i][j] = '*'\n              l\u200ceft -= 1\n              \n              i += 1\n              j -= 1\n              \n          if i\u200ci == 0:\n              for jj in range(c - 2, 1, -1):\n                  i = i\u200ci\n                  j = jj\n                  while i < r and j >= 0:\n                      if is_forbidden(i, j):\n                          i += 1\n                          j -= 1\n                          continue\n                      if l\u200ceft == 0:\n                          return 0\n                      field[i][j] = '*'\n                      l\u200ceft -= 1\n                      \n                      i += 1\n                      j -= 1\n              \n      if r * c == m + 1:\n          if r > 1:\n              field[1][0] = '*'\n          if c > 1:\n              field[0][1] = '*'\n          if r > 1 and c > 1:\n              field[1][1] = '*'\n          return 0\n              \n      return l\u200ceft\n  \n      \n  def solve_case():\n      r, c, m = read_ints()\n      \n      field = get_field(r, c)\n          \n      l\u200ceft = fill(field, r, c, m)\n          \n      return 'Impossible' if l\u200ceft != 0 else atos(field)\n      \n      \n  def main():\n      cases = read_int()\n      for c\u200base in range(1, cases + 1):\n          print('Case #{}:\n{}'.format(c\u200base, solve_case()))\n  \n          \n  main()\n", "substitutes": {"A": ["R", "G", "W", "D", "S", "L", "E", "ac", "As", "array", "M", "Z", "Array", "F", "am", "An", "alpha", "C", "AN", "a", "Y", "args", "CA", "AC", "AS", "P", "AD", "H", "T", "an", "AR", "Ar", "grid", "B", "N", "analysis", "AA", "AB", "I"], "row": ["R", "ow", "rown", " ar", "arr", "w", " R", "input", "col", "array", " u", "rows", " d", "x", "insert", " Row", "data", "result", "line", "feed", "raw", "cell", "sc", " rows", "reader", "e", "tr", "list", " entry", "k", "p", " tr", "Row", "entry", "ro", "object", " ro", "column", "f", "record"], "r": ["R", "ru", "o", "str", "d", "arr", "b", "er", "w", "u", "rb", "range", "cr", "z", "rm", "v", "g", "re", "sr", "x", "hr", "rh", "mr", "err", "l", "ar", "q", "rar", "_", "n", "a", "lr", "gr", "right", "e", "rd", "y", "nr", "tr", "fr", "br", "ir", "rr", "h", "rc", "all", "rs", "s", "pr", "k", "p", "yr", "ur", "dr", "f"], "c": ["cin", "mc", "o", "ci", "d", "b", "w", "z", "u", "cr", "ac", "cp", "uc", "ce", "v", "col", "cy", "fc", "g", "cc", "cf", "x", "ch", "lc", "l", "oc", "cs", "C", "q", "t", "n", "a", "cm", "e", "ec", "y", "h", "rc", "con", "cn", "ca", "arc", "s", "k", "p", "cu", "f", "dc"], "field": ["player", "key", "change", "child", "er", "z", "int", "label", "FIELD", "result", "line", "div", "force", "handler", "cell", "term", "option", "e", "message", "page", "source", "word", "post", "object", "manager", "condition", "group", "d", "rule", "input", "default", "fields", "data", "err", "round", "Field", "q", "function", "a", "ed", "number", "comment", "man", "member", "all", "this", "f", "table", "file", "pre", "o", "w", "string", "error", "null", "fix", "wire", "layer", "n", "block", "get", "form", "element", "list", "h", "end", "v", "g", "match", "l", "add", "value", "id", "play", "p", "user", "record", "type"], "i": ["bi", "qi", "api", "z", "u", "anti", "int", "ie", "x", "ix", "_", "ji", "zi", "e", "ip", "mini", "isi", "d", "b", "si", "info", "io", "adi", "ia", "ri", "a", "ed", "number", "y", "all", "ib", "s", "di", "pi", "ani", "f", "I", "ic", "o", "ori", "yi", "pos", "ni", "init", "vi", "ii", "mi", "n", "ai", "oi", "it", "h", "arc", "phi", "ik", "ci", "t", "eni", "v", "g", "ini", "l", "uri", "li", "iu", "ui", "id", "ti", "k", "p", "xi"], "j": ["sh", "key", "off", "er", "z", "u", "ie", "x", "ch", "kj", "line", "ji", "ok", "qa", "ot", "e", "br", "jp", "jet", "ah", "js", "ja", "opt", "d", "b", "si", "part", "dj", "err", "q", "jl", "job", "a", "adj", "y", "all", "op", "pi", "f", "o", "body", "aj", "jo", "jam", "vi", "ii", "obj", "n", "it", "h", "pr", "ij", "og", "ci", "je", "name", "t", "v", "uj", "jen", "g", "oj", "jc", "code", "l", "li", "on", "el", "k", "p", "jing", "J"], "m": ["im", "mc", "o", "d", "b", "t", "z", "u", "w", "range", "v", "g", "M", "re", "x", "am", "mr", "mu", "l", "mi", "um", "q", "n", "em", "cm", "e", "y", "ms", "mm", "h", "s", "k", "p", "ym", "f"], "jj": ["ij", "rec", "circ", "b", "ref", "z", "u", "ind", "g", "re", "x", "num", "jc", "ii", "ix", "code", "JC", "jl", "q", "iii", "cm", " ii", "y", "mm", "h", "JJ", "jp", "rc", "ib", "p", "isin", "J"]}}
{"code": "f = open('B-small-attempt0.in', 'r')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for c\u200base in range(T) :\n      A = []\n      N, M = map(int, f.readline()[:-1].split())\n      for i in range(N) : A.append(map(int, f.readline()[:-1].split()))\n      for line in A : print line\n      maxPerRow = map(max, A)\n      maxPerColumn = map(max, zip(*A))\n      res = all(A[i][j] in (maxPerRow[i], maxPerColumn[j]) for i in range(N) for j in range(M))\n      o\u200cutString = 'Case #' + str(c\u200base+1) + ': ' + ('YES' if res else 'NO') + '\n'\n      print o\u200cutString[:-1]\n      g.write(o\u200cutString)\n  \n  f.close()\n  g.close()\n", "substitutes": {"f": ["fen", "inf", "bf", "o", "d", "b", "w", "t", "z", "u", "fp", "r", "input", "io", "v", "c", "x", "fs", "fe", "F", "sf", "fd", "af", "fb", "feed", "l", "tf", "lf", "full", "a", "folder", "df", "e", "form", "conf", "fr", "h", "fw", "m", "p", "file"], "g": ["G", "cfg", "og", "o", "gui", "group", "d", "b", "w", "r", "t", "u", "gs", "v", "c", "ig", "ge", "l", "gen", "gm", "vg", "n", "gh", "gz", "e", "bg", "ga", "h", "rg", "s", "gl", "m", "p", "game", "sg", "gg", "go", "gi"], "T": ["R", "W", "D", "S", "t", "E", "L", "O", "K", "Z", "F", "Q", "TT", "C", "V", "Y", "P", "H", "X", "TS", "B", "U", "TN", "J", "I"], "A": ["LA", "G", "R", "W", "D", "S", "L", "E", "FA", "Ma", "O", "As", "array", "K", "Array", "F", "And", "MA", "An", "New", "C", "V", "a", "Y", "At", "GA", "CA", "AST", "NA", "AP", "AM", "P", "H", "X", "Ar", "au", "Am", "B", "U", "API", "AA", "J", "App", "I"], "N": ["NS", "R", "G", "W", "D", "S", "Ns", "NT", "NE", "L", "E", "O", "Ne", "K", "Z", "F", "Q", "Size", "C", "V", "n", "Y", "NM", "NB", " n", "NA", "P", "H", "X", "B", "U", "J", "I"], "M": ["G", "R", "W", "D", "S", "L", "E", "O", "K", "Z", "F", "Q", "MN", "C", "V", "n", "Y", "NM", "P", "H", "X", "m", "B", "U", "J", "I"], "i": ["qi", "im", "ij", "ic", "o", "ci", "d", "si", "b", "r", "z", "u", "ni", "eni", "io", "int", "ie", "v", "col", "ind", "c", "ch", "x", "ii", "iq", "l", "q", "li", "ri", "ji", "n", "iu", "ai", "a", "gr", "\u00ef", "e", "ins", "id", "it", "ti", "y", "index", "ip", "ki", "ir", "h", "ib", "s", "pi", "k", "p", "xi", "hi", "ik", "I"], "line": ["Lin", "cycle", "point", "o", " Line", "out", "d", "L", "r", "string", "range", "case", "O", "int", "col", "inline", "lin", "ino", "no", "row", "code", "l", "LINE", "cell", "C", "lf", "li", "a", "ed", "n", "ine", "block", "e", "page", "number", "area", "len", "end", "Line", "lines", "file"], "maxPerRow": [" maxperRow", " maxPerCol", "maxInCell", "maxperColumn", "maxInCol", "maxPerCol", " maxPerCell", " maxperCol", "maxperCell", " maxperColumn", "maxPerCell", "maxperRow", "maxInRow", " maxperCell", "maxInColumn", "maxperCol"], "maxPerColumn": [" maxperRow", " maxPerCol", " maxByCol", "maxByCell", "maxPERRow", "maxperColumn", "maxByRow", "maxPerCol", " maxPerCell", " maxperDay", " maxperCol", "maxPERCol", " maxByCell", "maxByCol", "maxperCell", " maxPerDay", " maxperColumn", "maxperDay", "maxByColumn", "maxPerDay", "maxByDay", "maxPERColumn", "maxperRow", "maxPerCell", "maxPERDay", " maxByColumn", " maxByRow", "maxperCol"], "res": ["R", "out", "arr", "MS", "z", "Rec", "CR", "Z", "num", "RES", "Ret", "result", "resolution", "RS", "Results", " Res", "ret", "H", "resp", "results", "Res", "rs", "Result", "GR", "Gr", "Rs", "Resp"], "j": ["ja", "ij", "o", "key", "d", "b", "si", "r", "z", "u", "ni", "aj", "jo", "v", "col", "part", "ind", "c", "x", "ch", "jc", "ii", "obj", "l", "q", "li", "ji", "n", "a", "iu", "ot", "e", "on", "y", "index", "jp", "js", "k", "m", "p", "J", "jj"]}}
{"code": "def make_string(R, C, M):\n      g\u200drid = [['.' for j in xrange(C)] for i in xrange(R)]\n      g\u200drid[-1][-1] = 'c'\n      t = M\n      for i in xrange(R):\n          for j in xrange(C):\n              if M:\n                  if forbidden(R, C, t, i, j):\n                      continue\n                  g\u200drid[i][j] = '*'\n                  M -= 1\n              else:\n                  break\n      s = ''\n      if M:\n          return 'Impossible'\n      for r in g\u200drid:\n          s += ''.join(r)+'\n'\n      return s[:-1]\n  \n  def forbidden(R, C, M, i, j):\n      a = M / C\n      b = M % C\n      if (R*C - M == 1):\n          return False\n  \n      if i >= (R-2) and j >= (C-2):\n          return True\n  \n      if i >= (R-2) and b:\n          if b % 2:\n              return True\n          if j < b/2:\n              return False\n          else:\n              return True\n      return False\n          \n  \n  f = open('Csmall.in', 'r')\n  g = open('outputC.txt', 'w')\n  \n  d\u200data = [[int(e) for e in l\u200dine.strip(\"\n\").split(' ')] for l\u200dine in f]\n  T = int(d\u200data.pop(0)[0])\n  for i, c\u200case in enumerate(d\u200data):\n      R, C, M = c\u200case[0], c\u200case[1], c\u200case[2]\n      num_cells = R*C\n      if (R-1) == 0 or (C-1) == 0:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1,s))\n          continue\n      else:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1, s))\n          \n  \n  f.close()\n  g.close()\n", "substitutes": {"R": ["Br", "Ru", "W", "D", "S", "Cr", "Rh", "G", "JR", "RT", "RN", "L", "E", "DR", "Ram", "Group", "O", "CR", "IR", "RIP", "Re", "Return", "K", "RC", "RO", "F", "Range", "Q", "RA", "NR", "RM", "RG", "RS", "Run", "A", "V", "RR", "SR", "Y", "RH", "P", "H", "Res", "X", "MR", "BR", "Ra", "N", "U", "B", "Right", "J", "Rs", "I"], "C": ["Co", "CL", "CE", "W", "D", "S", "G", "Cr", "Code", "CM", "EC", "E", "L", "O", "Ch", "CR", "CNN", "CO", "CT", "VC", "CU", "K", "Z", "DC", "F", "Q", "CF", "CI", "Sc", "CS", "JC", "A", "V", "Cu", "Y", "CC", "CA", "AC", "P", "H", "CV", "X", "SC", "J", "NC", "N", "U", "B", "Cs", "Con", "MC", "CW", "Cl", "I"], "M": ["Mor", "G", "LM", "W", "D", "S", "FM", "CM", "MS", "ME", "E", "L", "DM", "O", "Ch", "MO", "K", "Z", "F", "Q", "MF", "MN", "MA", "RM", "A", "V", "Y", "MC", "AM", "P", "H", "X", "MD", "SM", "GM", "TM", "MM", "MT", "m", "B", "U", "N", "J", "MI", "I"], "i": ["bi", "qi", "z", "u", "int", "ie", "x", "ch", "ix", "iq", "zi", "e", "ip", "m", "mini", "hi", "il", "gi", "im", "d", "ide", "si", "io", "multi", "ig", "ct", "q", "ia", "ri", "y", "index", "ib", "di", "pi", "I", "ist", "ic", "o", "ori", "yi", "w", "ni", "ive", "iw", "ii", "ity", "mi", "n", "ai", "ine", "it", "ir", "h", "inter", "ik", "ij", "ci", "at", "v", "ini", "l", "li", "iu", "ui", "id", "ti", "ga", "k", "p", "xi", "ei"], "t": ["o", "d", "Ti", "z", "u", "tt", "w", "at", "v", "int", "x", "TT", "l", "A", "n", "nt", "Y", "tm", "e", "Ct", "it", "y", "ti", "tr", "P", "h", "m", "p", "type"], "j": ["im", "ij", "ja", "o", "key", "ion", "d", "si", "w", "z", "u", "aj", "v", "uj", "ie", "ind", "dy", "x", "jc", "ii", "l", "q", "_", "ri", "li", "ji", "n", "jl", "adj", "e", "y", "index", "h", "jp", "js", "pr", "k", "pi", "p", "m", "bj", "J", "jj"], "s": ["py", "ims", "site", "sets", "u", "z", " comments", "x", "ries", "sf", "ches", "its", "ts", " statements", "e", "ments", "second", "xs", "comments", "outs", "m", "S", "ss", "codes", "d", "si", "input", "ps", "times", "spec", "dx", "ls", "ins", "ings", "y", " lines", "su", "ers", "seconds", "qs", " S", "sd", "sl", "o", "w", "string", "es", "ances", "sb", "rows", "fs", "n", "ssl", "self", "session", "conf", "se", "h", "summary", "say", "sum", "name", "ds", "single", "gs", "v", "ips", "secondary", "abs", "l", "ws", "os", "sym", "sv", "sid", "ns", "strings", "rs", "p", "sg", "ions", "lines", "ses", "span"], "r": ["igr", "ru", "o", "Rh", "str", "er", "cr", "w", "rb", "rm", "case", "z", "range", "v", "ra", "array", "re", "res", "sr", "x", "rh", "result", "err", "l", "ar", "ri", "n", "gr", "right", "rd", "e", "ner", "it", "fr", "rt", "rn", "rf", "ir", "br", "h", "rc", "all", "rs", "pr", "ring", "m", "p", "end", "ro", "ur"], "a": ["ama", "ja", "da", "api", "aa", "fa", "o", "\u00e1", "ao", "wa", "aaa", "z", "u", "ac", "ba", "aj", "al", "na", "at", "ya", "action", "ana", "ra", "app", "ag", "am", "af", "sa", "alpha", "ax", "l", "A", "ar", "ia", "ad", "n", "ai", "ak", "e", "ma", "la", "y", "aw", "area", "an", "asa", "ga", "art", "mA", "au", "all", "ah", "pa", "ca", "ap", "aux", "ae", "p", "m", "access", "ab", "va", "anta", "ata", "ta"], "b": ["bf", "bh", "bs", "o", "d", "w", "z", "u", "rb", "ba", "v", "sb", "mb", "x", "fb", "l", "A", "n", "lb", "e", "y", "nb", "eb", "h", "ib", "wb", "k", "m", "B", "p", "Bs", "ab"], "f": ["fen", "inf", "cfg", "fa", "o", "d", "isf", "w", "u", " F", "fp", "z", "fo", "v", "int", "fc", "x", "fs", "fe", "F", "xf", "fd", "af", "fb", "fm", "l", "fx", "ef", "q", "lf", "fn", "n", "df", "e", "id", "form", "conf", "y", "fr", "rf", "h", "fw", "fi", "ff", "m", "ft", "p", "format", "of", "file"], "g": ["gc", "msg", "G", "cfg", "og", "gui", "o", "group", "d", "w", "u", " eg", "gs", " G", "groups", "ges", "z", "v", "reg", "ig", "mg", "ag", "ge", "pg", "gu", "org", "err", "l", "gen", "gm", "q", "gb", "vg", "n", "gh", "eg", "gz", "e", "general", "arg", "conf", "bg", "gam", "yg", "gp", "ga", "h", "rg", "erg", "k", "m", "p", "game", "sg", "gg", "go", "gi"], "T": ["G", " N", "W", "D", "S", "E", "L", "O", "K", "Z", "F", "Q", "A", "V", "unit", "Y", "P", "H", "Num", "U", "B", "N", "Type", "I"], "c": ["ic", "mc", "can", "o", "ci", "d", "w", "z", "u", "ac", "v", "cc", "ch", "co", "lc", "l", "cs", "q", "sc", "n", "cat", "e", "ec", "y", "h", "con", "arc", "ca", "cu", "k", "m", "p", "cl", "dc"], "num_cells": ["num_rows", "num2rows", " num_cases", " num_rows", "num2cell", "num2cells", " num_cell", "num_cell", "num2cases", "num_cases"]}}
{"code": " \n  \n  EOL = \"\n\"\n  \n  \n  def is_equal_approx(x, y, epsilon=1e-6):\n      \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\n      \n      By default, 'epsilon' is 1e-6.\n      \"\"\"\n      if -epsilon <= x - y <= epsilon:\n          return True\n  \n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n          return False\n  \n      return (-epsilon <= (x - y) / x <= epsilon\n          or -epsilon <= (x - y) / y <= epsilon)\n    \n  def read_syms(f\u200cd):\n      \"\"\"Read a line of whitespace separated symbols.\"\"\"\n      return f\u200cd.readline().strip().split()\n  \n  def read_ints(f\u200cd):\n      \"\"\"Read a line of whitespace separated integers.\"\"\"\n      return [int(p) for p in read_syms(f\u200cd)]\n  \n  def read_floats(f\u200cd):\n      \"\"\"Read a line of whitespace separated floats.\"\"\"\n      return [float(p) for p in read_syms(f\u200cd)]\n  \n  \n  class Mtrx(object):\n      \"\"\"A matrix object.\"\"\"\n      \n      def __init__(s\u200celf, rows, cols, data):\n          assert len(data) == rows * cols\n          s\u200celf.rows = rows\n          s\u200celf.cols = cols\n          s\u200celf.data = data\n          \n      def cell(s\u200celf, r, c):\n          return s\u200celf.data[r * s\u200celf.cols + c]\n      \n      def getrow(s\u200celf, i):\n          return [s\u200celf.cell(i, c) for c in xrange(s\u200celf.cols)]\n  \n      def getcol(s\u200celf, i):\n          return [s\u200celf.cell(c, i) for c in xrange(s\u200celf.rows)]\n      \n      @classmethod\n      def readfromfile(c\u200cls, f\u200cd, readfunc, rows=None, cols=None):\n          \"\"\"Read matrix from file, assuming first line at location is `R C`.\n          \n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\n          Pre-determined size can be passed using `rows` and `cols`.\n          \"\"\"\n          data = []\n          if rows is None:\n              assert cols is None\n              rows, cols = read_ints(f\u200cd)\n          else:\n              assert cols is not None\n          for _ in range(rows):\n              line = readfunc(f\u200cd)\n              assert len(line) == cols\n              data.extend(line)\n          return Mtrx(rows, cols, data)\n              \n      @classmethod\n      def read_int_matrix(c\u200cls, f\u200cd, rows=None, cols=None):\n          return c\u200cls.readfromfile(f\u200cd, read_ints, rows, cols)\n              \n      @classmethod\n      def read_sym_matrix(c\u200cls, f\u200cd, rows=None, cols=None):\n          return c\u200cls.readfromfile(f\u200cd, read_syms, rows, cols)\n              \n      def __str__(s\u200celf):\n          res = \"\"\n          for i in xrange(s\u200celf.rows):\n              res += str(s\u200celf.getrow(i)) + EOL\n          return res\n      \n      def __repr__(s\u200celf):\n          return \"{}({}, {}, {})\".format(s\u200celf.__class__.__name__, s\u200celf.rows,\n                                         s\u200celf.cols, s\u200celf.data)\n  \n  \n  cachetotals = 0\n  cachemisses = 0\n  \n  def statreset():\n      global cachemisses, cachetotals\n      cachemisses = 0\n      cachetotals = 0\n  \n  class memoizeit(object):\n      \"\"\"Decorator. Caches a function's return value each time it is called.\n      \n      If called later with the same arguments, the cached value is returned \n      (not reevaluated).\n      \"\"\"\n      \n      def __init__(s\u200celf, f\u200dunc):\n          s\u200celf.f\u200dunc = f\u200dunc\n          s\u200celf.c\u200bache = {}\n          \n      def __call__(s\u200celf, *args):\n          \n          global cachetotals, cachemisses\n          cachetotals += 1\n          \n          try:\n              return s\u200celf.c\u200bache[args]\n          except KeyError:\n              \n              cachemisses += 1\n              \n              value = s\u200celf.f\u200dunc(*args)\n              s\u200celf.c\u200bache[args] = value\n              return value\n          except TypeError:\n  \n              cachemisses += 1\n  \n              return s\u200celf.f\u200dunc(*args)\n      \n      @property\n      def __name__(s\u200celf):\n          return s\u200celf.f\u200dunc.__name__\n      \n      def __get__(s\u200celf, obj, objtype):\n          \"\"\"Support instance methods.\"\"\"\n          return functools.partial(s\u200celf.__call__, obj)\n  \n  \n  class timeit(object):\n      \"\"\"Decorator that times a function.\n      \n      When function ends, print name, runtime, return value and c\u200bache stats.\n      \"\"\"\n      \n      def __init__(s\u200celf, f\u200dunc):\n          s\u200celf.f\u200dunc = f\u200dunc\n          \n      def __call__(s\u200celf, *args):\n          start = time.time()\n          value = s\u200celf.f\u200dunc(*args)\n          delta = time.time() - start\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\n              cachetotals else 0\n          print s\u200celf.f\u200dunc.__name__, \"{:7.3f}s, (res: {}, c\u200bache: {:.2%})\".format(\n              delta, value, cachedata)\n          return value\n      \n      def __get__(s\u200celf, obj, objtype):\n          return functools.partial(s\u200celf.__call__, obj)\n  \n  \n  def read_input(filename):\n      data = []\n      with open(filename, \"r\") as f:\n          cases = read_ints(f)[0]\n          for _ in xrange(cases):\n              case = {}\n              case[\"R\"], case[\"C\"], case[\"M\"] = read_ints(f)\n              data.append(case)\n      return data\n  \n  def make_output(fname, o\u200cutput):\n      CASE_PRFX = \"Case #%s: \"\n      fname = fname + time.strftime(\"%H%M%S\") + \".out\"\n      with open(fname, \"w\") as f:\n          restext = []\n          print \"Output content ===============\"\n          for i, outdata in enumerate(o\u200cutput):\n              line = CASE_PRFX % (i + 1,) + EOL + str(outdata) + EOL\n              print line,\n              restext.append(line)\n          print \"=\" * 30\n          f.writelines(restext)\n  \n  \n  MINE = \"*\"\n  CLICK = \"c\"\n  UNK = \".\"\n  \n  class Board(object):\n      \n      def __init__(s\u200celf, r, c):\n          s\u200celf.rows = r\n          s\u200celf.cols = c\n          s\u200celf.edge_row_idx = s\u200celf.rows - 1\n          s\u200celf.edge_col_idx = s\u200celf.cols - 1\n          s\u200celf.board = [[UNK for _ in xrange(c)] for _ in xrange(r)]\n          s\u200celf.board[0][0] = CLICK\n  \n      def fill_edge_row(s\u200celf, m):\n          i = s\u200celf.edge_col_idx\n          while m > 0 and i >= 0:\n              s\u200celf.board[s\u200celf.edge_row_idx][i] = MINE\n              i -= 1\n              m -= 1\n          s\u200celf.edge_row_idx -= 1\n  \n      def fill_edge_col(s\u200celf, m):\n          i = s\u200celf.edge_row_idx\n          while m > 0 and i >= 0:\n              s\u200celf.board[i][s\u200celf.edge_col_idx] = MINE\n              i -= 1\n              m -= 1\n          s\u200celf.edge_col_idx -= 1\n  \n      def __str__(s\u200celf):\n          return EOL.join([\"\".join(r) for r in s\u200celf.board])\n  \n  @memoizeit\n  def is_stage_solvable(rows, cols, mines):\n      \"\"\"Return True iff stage is solvable. \n      Also return fill instruction:\n      0 if impossible/dontcare, 1 to fill row, 2 to fill column, \n      3 for row special (most in the row), 4 for col special (most in the col)\n      \"\"\"\n      rc = rows * cols\n      \n      if mines == rc:\n          return False, 0\n  \n      if rows == 1:\n          return mines <= rc - 1, 2\n      if cols == 1:\n          return mines <= rc - 1, 1\n      \n      if mines == rc - 1:\n          return True, 1  # doesn't matter what to fill\n      \n      if mines > rc - 4:\n          return False, 0\n      \n      if rows == 2:\n          return (False, 0) if mines == 1 else (True, 2)\n      if cols == 2:\n          return (False, 0) if mines == 1 else (True, 1)\n          \n      if rows <= cols:\n          if mines >= rows:\n              return True, 2\n          if mines == rows - 1:\n              if mines == cols - 1:\n                  if rows == 3:\n                      return False, 0\n                  return True, 4 # L shape fill, most in the column\n              else:\n                  return True, 1 # fill row\n          return True, 2 \n      else:\n          if mines >= cols:\n              return True, 1\n          if mines == cols - 1:\n              if mines == rows - 1:\n                  if cols == 3:\n                      return False, 0\n                  return True, 3 # L shape fill, most in the row\n              else:\n                  return True, 2 # fill column\n          return True, 1 \n  \n  @timeit\n  def solveit(case):\n      rows = case[\"R\"]\n      cols = case[\"C\"]\n      mines = case[\"M\"]\n      \n      b = Board(rows, cols)\n      r, c, m = rows, cols, mines\n      \n      while m >= 0:\n          okgo, howtofill = is_stage_solvable(r, c, m)\n          if not okgo:\n              return \"Impossible\"\n          if howtofill == 1: # fill row\n              b.fill_edge_row(m)\n              if m <= c:\n                  break # fill and done\n              m -= c\n              r -= 1\n          elif howtofill == 2: # fill column\n              b.fill_edge_col(m)\n              if m <= r:\n                  break # fill and done\n              m -= r\n              c -= 1\n          elif howtofill == 3: # L shape fill, most in the row\n              b.fill_edge_row(m - 1)\n              b.fill_edge_col(1)\n              break # fill and done\n          elif howtofill == 4: # L shape fill, most in the column\n              b.fill_edge_col(m - 1)\n              b.fill_edge_row(1)\n              break # fill and done\n          else:\n              assert False\n  \n      return str(b) \n  \n  \n  \n  @timeit\n  def main(fname):\n      data = read_input(fname)\n      o\u200cutput = []\n      for case in data:\n          statreset() # reset c\u200bache stats\n          res = solveit(case)\n          o\u200cutput.append(res)\n      make_output(fname, o\u200cutput)\n  \n  \n  if __name__ == '__main__':\n      main(\"C-small-attempt0.in\")\n", "substitutes": {"EOL": ["EOC", " EOC", "EBol", "EBOC", "Eol", "eol", "eOL", " EOF", "eOC", "EBOL", "EOF", "EBOF", "eOF", " Eol"], "x": ["point", "xe", "xp", "expl", "wx", "time", "w", "t", "z", "u", "px", "ph", "ww", "gal", "rex", "ya", "int", "tx", "ex", "ext", "rx", "xc", "dy", "width", "dx", "xf", "xy", "python", "xes", "ix", "ax", "l", "fx", "qu", "yl", "n", "xx", "yx", "val", "id", "xt", "on", "index", "xs", "X", "xa", "h", "k", "xi", "wy", "ux", "pl", "sex"], "y": ["py", "ye", "yi", "yt", "yy", "w", "t", "z", "ey", "ya", "cy", "dy", "yl", "yo", "ky", "vy", "ys", "l", "ry", "n", "sy", "Y", "ady", "yx", "iy", "yd", "j", "ny", "ay", "oy", "h", "ty", "zy", "wy", "yr", "ym", "ies"], "epsilon": ["eprilon", "epilon", "Epsilon", "epsloni", "ypelton", "epalron", "epilency", "ppsiloner", "ppilloni", "epsilond", "ppsilons", "ipsilen", "apeltons", "epillron", "eprilony", "epilan", "epillond", "epinfon", " eprilon", "ppsilon", "ipsilon", "ppillone", "epssilone", "epalond", "epillen", " eprilan", " epsilan", "ypeltone", "ypeltan", "epelten", "epslony", "ppsilency", "Epsilron", "epsillone", "ppilency", "epsiloner", "epsellond", "epsiloni", "ypsilone", "ppsilone", "epalons", "epeltoni", "epsillen", "epeltone", "epalone", "Epelton", " eprilony", "ppilloner", "epilony", "epslone", "epriloni", "epinf\u00f3n", "epeltons", "apeltony", "ppillons", "ppsilen", "epSilency", "ypeltons", "ppsiloni", "eprilons", "epsilons", "ppsilron", "epsilone", "ppilon", "epeltony", "epilron", "epSiloni", "epriloner", "apsilony", "epsellon", "epillone", "Epelten", "apsiloner", "epill\u00f3n", "epsillon", "ipill\u00f3n", "ipillons", "epsillron", "epeltan", "epillan", "apsilon", "Epeltan", "ipsil\u00f3n", "epsellone", "ppiloni", "ypsilon", "epalon", "apelton", "epselloni", "ppillen", "eprilan", "ypsilan", "epsloner", "epinfen", "ipillen", "epillons", "epssilron", "epslon", "ppillron", "eprilron", "epsilron", "epilons", "ppsilony", "epsilony", "epalan", "epelton", "epssilen", "epsellron", "epssiloni", " epsilron", "epeltency", "epal\u00f3n", "epsil\u00f3n", "ypsilons", "epillon", "epsilen", "ipsilons", "epslons", "epeltoner", " epsilony", "epilone", "ppillony", "apsilons", "ppilen", "apeltoner", " eprilron", "epilen", "epsilency", "epilloni", "epssilond", "epilloner", "epinfons", "epsilloni", "Epeltron", "epssilon", "epSilon", "Epsilan", "epsillond", "epillony", "epsellen", "Epsilen", "ppillon", "epeltron", "eprilone", "epsilan", "epiloni", "epSilen", "epalen", "ipillon"], "f": ["field", "z", "u", "sf", "fit", "page", "fr", "fi", "uf", "of", "inf", "ou", "info", "fp", "fing", "fc", "F", "ct", "af", "fm", "fx", "q", "function", "df", "fer", "elf", "file", "bf", "w", "fg", "fs", "fe", "fd", "fb", "feed", "um", "fed", "tf", "n", "free", "aff", "form", "conf", "rf", "h", "fl", "fun", "fen", "pe", "t", "fort", "ref", "al", "front", "g", "cf", "framework", "fold", "ef", "l", "lf", "full", "flat", "j", "k", "ff", "ft", "format"], "p": ["pre", "py", "par", "t", "z", "u", "w", "amp", "cp", "fp", "ph", "pm", "float", "part", "ps", "g", "pointer", "pc", "st", "python", "pid", "np", "po", "mp", "l", "q", "pro", "ep", "n", "tp", "j", "P", "ip", "gp", "h", "jp", "pp", "op", "ap", "pr", "bp", "lp", "pl", "vp", "pt", "sp", "type"], "o": ["out", "t", "wo", "u", "do", "io", "no", "to", "co", "po", "l", "oc", "os", "n", "ot", "oa", "on", "oe", "h", "op", "\u00f3", "so", "k", "ob", "oo", "ro", "et", "od"], "a": ["ama", "aa", "ao", "z", "aper", "ac", "aj", "ba", "na", "al", "ya", "at", "asy", "ada", "\u00e4", "ea", "am", "af", "alpha", "ar", "A", "ia", "ad", "n", "ai", "ans", "qa", "ma", "la", "ha", "aw", "an", "av", "ga", "au", "aux", "ast", "ca", "ap", "ae", "va", "ab", "ata", "ta"], "i": ["bi", "ic", "ci", "si", "t", "z", "u", "w", "io", "int", "ie", "g", "re", "ch", "ini", "ii", "l", "ar", "q", "ia", "li", "ri", "n", "iu", "ai", "id", "j", "it", "index", "h", "ir", "arc", "k", "xi", "pi", "I"], "d": ["D", "t", "z", "w", "ds", "do", "dig", "ind", "g", "nd", "dh", "st", "du", "ded", "dom", "fd", "l", "db", "red", "bd", "ad", "n", "did", "dict", "df", "rd", "id", "old", "yd", "h", "k", "ld", "sd", "pd", "dat", "dr", "dc"], "data": ["text", "window", "body", "empty", "arr", "breaks", "input", "load", "array", "batch", "multi", "response", "row", "result", "model", "feed", "DATA", "li", "function", "reader", "valid", "content", "block", "zip", "shift", "lines", "form", "buffer", "cache", "values", "steps", "results", "output", "frame", "slice", "missing", "temp", "draw", "entry", "dat", "ata", "Data", "items"], "rows": ["rown", "tests", "users", "obs", "events", "pos", "heads", "breaks", "groups", "flows", "headers", "ows", "ips", "reports", "fields", "times", "rules", "planes", " row", "images", "row", "feed", "raw", "cs", "cells", "blocks", "length", "pages", "types", "keys", "ids", "ports", "ins", "vals", "errors", "values", " lines", "xs", "results", "index", "frames", "checks", "forms", " columns", "sections", "rs", "levels", "series", "files", "ks", "reads", "views", "aults", "lines", "runs", "days", "faces", "items"], "cols": ["veld", "condd", " coln", "columnd", "veln", "COLn", "colln", "colli", "drawd", "llsets", "conds", "cold", "colsg", "COLi", "welln", "colld", "COLs", " coli", " cold", "coln", "Colts", "COLd", "drawn", "welld", "Cols", "Coln", "colls", "Cold", "draws", "columnsg", "vels", "lls", "wells", "coli", "velts", "Colsg", "columnsets", "columnn", "lln", "condn", "columns", "lli", "collsets", "wellsets", "colts", "colsets", " colsets", "drawsg", "columni", "condts"], "_": ["g", "l", "ing", "an", "of"], "line": ["text", "strip", "name", "char", "pos", "string", "range", "col", "inline", "lin", "le", "row", "code", "model", "base", "LINE", "cell", "long", "sync", "length", "content", "val", "block", "zip", "page", " lines", "frame", "section", "source", "column", "item", "log", "entry", "margin", "Line", "object", "lines", "lo", "limit", "record"], "s": ["sh", "south", "ves", "ims", "site", "sets", "u", "z", "sites", "st", "ries", "sf", "ches", "ys", "ops", "sc", "its", "pro", "ts", "ans", "ids", "words", "xs", "comments", "js", "outs", "gets", "sing", "sis", "ies", "tests", "S", "ss", "si", "uses", "settings", "space", "ows", "ps", "fields", "sin", "spec", "sys", "ls", "q", "sync", "sy", "ins", "ings", "service", "su", "server", "parts", "qs", "odes", "so", "posts", "services", "sl", "w", "es", "sb", "fs", "als", "cs", "set", "n", "ssl", "self", "session", "conf", "se", "h", "states", "less", "t", "ds", "gs", "g", "re", "secondary", "abs", "ws", "sub", "os", "sym", "sv", "id", "ing", "j", "ns", "strings", "rs", "ser", "sg", "ks", "ions", "us", "sim", "lines", "ses"], "e": ["xe", "er", "E", "ere", "ey", "ele", "ade", "ya", "ie", "que", "ze", "le", "ea", "ne", "ec", "be", "eb", "ace", "eu", "\u00e9", "ite", " je", "ide", "ice", " E", "Element", "de", "ge", "ed", "ede", "so", "ev", "esi", "ee", "w", " ce", "edge", "es", "ive", "Te", "fe", "ke", "ue", "n", "ine", "en", "kee", "se", "h", "ance", "et", "ye", "je", "pe", "ese", "t", "ce", "ex", "Me", "g", "re", "me", "ef", "l", "ape", "oe", "Event", "te", "el", "ise", "ae", "one", "ffe"], "r": ["rat", "R", "ru", "rl", "er", "cr", "w", "rb", "t", "u", "range", "rm", "ra", "g", "rx", "run", "re", "rss", "sr", "per", "ras", "rh", "row", "nor", "err", "l", "ar", "q", "ri", "ry", "n", "lr", "ram", "right", "rd", "rw", "j", "fr", "br", "rn", "rt", "h", "rg", "rr", "ir", "rs", "cor", "pr", "ro", "ur", "dr"], "c": ["enc", "rec", "mc", "uc", "u", "z", "ch", "sc", "C", "ad", "cell", "unc", "ec", "roc", "cu", "cr", "cp", "fc", "cc", "pc", "ct", "oc", "q", "cat", "ic", "w", "nc", "anc", "col", "cy", "ra", "co", "cle", "cs", "n", "h", "con", "arc", "end", "che", "cd", "dc", "cin", "ci", "t", "ac", "ce", "cf", "g", "xc", "cur", "lc", "l", "cm", "ca", "k"]}}
{"code": " \n  infile=open(sys.argv[1],'r')\n  \n  NumCases=int(infile.readline())\n  \n  myinput=\"\"\"ejp mysljylc kd kxveddknmc re jsicpdrysi\n  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n  de kr kd eoya kw aej tysr re ujdr lkgc jv\"\"\"\n  \n  myoutput=\\\n  \"\"\"our language is impossible to understand\n  there are twenty six factorial possibilities\n  so it is okay if you want to just give up\"\"\"\n  \n  mapping={}\n  mapping['q']='z'\n  mapping['z']='q'\n  \n  \n  for char,mapto in zip(myinput,myoutput):\n      if mapping.has_key(char):\n          assert mapping[char]==mapto\n      else:\n          mapping[char]=mapto\n  \n  \n  \n  \n  for iCase in xrange(NumCases):\n      thestring=infile.readline().strip()\n  \n      newstring=''\n      for char in thestring: newstring+=mapping[char]\n  \n  \n      print 'Case #'+str(iCase+1)+': '+newstring\n  \n", "substitutes": {"infile": ["sinfile", " inFile", "INfile", "INcomplete", "inFile", "sinfolder", "instring", "instream", " infolder", " infilename", "outzip", "Incomplete", "inzip", "outfilename", "outfile", "infolder", "infilename", " instring", " instream", " incomplete", "sinstream", "outstream", "insfilename", "InFile", "insfile", " inzip", "Infile", "Infilename", "INFile", "incomplete", "INfilename", "outstring", "insstring", "insstream", "outfolder", "sinzip"], "NumCases": ["NumCase", "numcases", "NumChASE", "NumPases", "NumberCats", "NumScats", "numCASE", "numcASE", "NumTased", "NumScases", "Numcats", "NumberScats", "NumPps", "NumberCases", "NumCASE", "NumTats", "Numcased", "NumScased", "NumScase", "NumTase", "NumberCased", "NumCats", "NumCased", "Numcase", "NumberScase", "NumChase", "NumberCase", "numcase", "NumcASE", "Numcases", "NumTases", "NumPase", "NumberScases", "NumberScased", "NumPASE", "numCases", "numcps", "numCase", "numCps", "NumChases", "Numcps", "NumCps", "NumChps"], "myinput": ["Myinput", "yourinput", "ouroutput", "Myurl", " myconfig", "myurl", "ourconfig", " myurl", "ourInput", "myInput", "veryinput", "youroutput", "veryurl", "yourconfig", " myInput", "myconfig", "yourInput", "veryoutput", "ourinput", "MyInput", "Myoutput", "veryInput"], "myoutput": ["pyOutput", " myfile", "myout", "mainOutput", " myconfig", "mainoutput", "yourfile", "myOutput", "Mywrite", " myout", "youroutput", "Myconfig", "yourout", "MyOutput", " mywrite", "myfile", "myconfig", "mywrite", "pyout", "yourOutput", "pyfile", " myOutput", "Myoutput", "mainconfig", "pyoutput", "mainwrite"], "mapping": ["smapping", "pasing", "mending", "papped", "fapped", "Moding", "mmapping", "pending", "mapped", "rasing", " moding", " mashing", "mmapped", "papping", "fapping", " masing", "moding", "smoding", "rring", "bapped", "batching", " mapped", "mouting", "Masing", "smapped", "Mapping", "mring", "napped", "fapper", "Mouting", " mouting", "nappings", "masing", "fappings", "Mashing", "rapped", "Mappings", "fasing", "rappings", "natching", "rapper", "mmappings", "Mbing", "routing", "matching", "Mapped", "smashing", " mbing", "mbing", "papper", "fbing", "mappings", "rapping", "mapper", " mapper", " mending", "pappings", "fring", "bapping", "rashing", " mring", "mashing", "napping", "poding", "pashing", "mmatching", " mappings", "bappings", "Mending"], "mapto": ["masho", "majot", "mashe", "majO", "mappedop", "maito", "Maje", "maitop", "mapte", "Majoi", "majo", "majos", "majop", "maptoi", "mashoin", "mape", "maitoi", "mappedoi", "mriptop", "maje", "mriptO", "mapoin", "Maptos", "Majot", "Majos", "maptop", "mappedos", "Maptoi", "MaptO", "maptoin", "Mapte", "Majop", "Maptot", "maitos", "mapo", "mashO", "majoi", "MajO", "mapos", "maptO", "Majo", "maptot", "mashos", "Maptoin", "Maptop", "mashop", "mappedo", "Majoin", "Mapto", "mriptot", "maptos", "mripto", "majoin", "mashot"], "iCase": ["iName", "ITest", " iTest", "iuName", "IHalf", "jiCount", "iuKey", "iCount", "ICase", "yiHalf", "jiCase", " iHalf", "yiTest", "yiCount", "biCase", "jiName", "biKey", "iHalf", "iuCount", "iKey", "biCount", "yiCase", "iuCase", "jiKey", "iTest", "ICount", "biName", " iCount"], "thestring": ["thestrings", "Thestring", " thestrings", "testingstring", "theirString", " thering", " thestr", "thestr", " theString", "Thestrings", "TheString", "thetext", "theString", "testingtext", "thering", "theirstring", "theirring", "Thestr", "testingstrings", "theirstr", "Thering", " thetext", "testingString", "Thetext"], "newstring": [" newring", " newdata", "newstr", "rawString", "rawring", "newline", "newstrings", "rawstrings", "Newstrings", "Newdata", "Newstring", "newdata", "differentstrings", "NewString", "differentring", "differentline", "Newstr", "rawstr", " newString", "differentstring", "newString", "rawstring", "differentString", "differentstr", "rawdata", " newstr", " newstrings", "newring", "rawline", " newline"]}}
{"code": " \n  BIG_NUM=100000\n  def Solve(C,F,X):\n      best_time=float('inf')\n      for n in xrange(0,BIG_NUM):\n          if n==0:\n              farm_time=0\n          else:\n              farm_time += C/(2+(n-1)*F)\n          if best_time<=farm_time: break\n          cookie_time=X/(2+n*F)\n  \n          if farm_time+cookie_time<best_time:\n              best_time=farm_time+cookie_time\n  \n      return '%.9f'%best_time\n  \n  \n  \n  def parse(infile):\n      C,F,X=map(float, infile.readline().split() )\n      return C,F,X\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n  \n      outname=sys.argv[1].rstrip('.in')+'.out'\n      if os.path.isfile(outname):\n          oldout=outname+'.old'\n          ii=0\n          while os.path.isfile(oldout):\n              ii+=1\n              oldout=outname+'.old'+str(ii)\n          os.rename(outname,oldout)\n          print 'Rename: %s -> %s'%(outname,oldout)   \n   \n      outfile=open(outname,'w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n", "substitutes": {"BIG_NUM": ["BIGOCDAY", "BIGPOUM", "BIGPOSIZE", "BIGPONUM", "BIGS_num", "BIGSNSIZE", "BIGSNTIME", "BIG_UM", "BIGPOTIME", "BIG_DAY", "BIGOCnum", "BIGNTIME", "BIGNUM", "BIGS_NUM", "BIGOCSIZE", "BIGS_UM", "BIGNSIZE", "BIG_SIZE", "BIGS_DAY", "BIGNNUM", "BIGS_TIME", "BIGSNUM", "BIG_num", "BIG_TIME", "BIGOCNUM", "BIGS_SIZE", "BIGSNNUM"], "C": [" c", "G", "R", "CE", "W", "D", "S", "CM", "L", "E", "O", "CNN", "CR", "CO", "c", "M", "K", "CU", "DC", "CF", "CI", "A", "V", "Y", "CC", "CA", "P", "H", "T", "CP", "NC", "N", "U", "B", "CN", "MC", "I"], "F": ["G", "W", "D", "FM", "FL", "FD", "Far", "L", "E", "FA", "O", "M", "K", "Q", "MF", "Family", "CF", "FB", "UL", "V", "FH", "FS", "Fs", "Y", "SF", "P", "EF", "H", "T", "PF", "GF", "FO", "WF", "FF", "N", "U", "OF", "B", "Fi", "DF", "FW", "f", "I"], "X": ["G", "CL", "R", "W", "D", "S", "FC", "L", "Ex", "E", "XY", "O", "IX", "M", "ZX", "K", "Z", "XXXX", "x", "TX", "Q", "FX", "CF", "XX", "HTTP", "A", "V", "IP", "Y", "XL", "CC", "XXX", "P", "XP", "H", "T", "FE", "FF", "UX", "NC", "U", "N", "B", "J"], "best_time": ["feature_content", "better_time", "best_size", "bestlytime", "latestiantime", "bestvaltime", "latest_size", "farm_TIME", "bestacim", "bestacdate", "best2times", "bestvalspace", "best2time", "featureiantime", "bestactime", "featureianspace", "featureianprice", "latest_im", "best_TIME", "bestxtime", "farm_times", "better_times", "bestxsize", "farm_cost", "bestlyspace", "featureiancontent", "feature_space", "bestlyprice", "latest_time", "latestiansize", "bestacsize", "best_am", "bestxtimes", "best2TIME", "farm_date", "bestiansize", "best_space", "bestlycontent", "bestianspace", "bestiantime", "better_timer", "bestiantimer", "best2am", "latest_timer", "latestianim", "bestactimer", "bestxtimer", "best_content", "feature_time", "best_times", "best_timer", "best_price", "best_date", "bestactimes", "bestianprice", "bestianim", "feature_price", "best2Time", "better_size", "farm_am", "bestiancontent", "best_Time", "best_cost", "latestiantimer", "bestvalcontent", "bestaccost", "best_im", "farm_Time", "best2cost", "best2date", "bestvalprice"], "n": [" c", " N", "o", "d", "nn", "b", "t", "r", "w", "nc", "ni", "i", "z", "L", "v", "pn", "ind", "g", "c", "nd", "nu", "count", "x", "num", "l", "network", "fn", "nt", "a", "e", "sn", "j", "y", "P", "nb", "ns", "cn", "s", "size", "k", "m", "N", "p", "f"], "farm_time": ["fork_timeout", "farm_speed", "farm5etime", "farmiantype", "fork_value", "farm6timeout", "farm5timeout", "field_speed", "farm6times", "fork_count", "farm5times", "farm_frequency", "farm_times", "farm5time", "fieldiantime", "farm_ime", "farm64times", "fieldianspeed", "fieldianime", "fieldianetime", "farm___type", "farm___time", "field_time", "fork_frequency", "farm64tim", "farm5ime", "farm_value", "field_etime", "farm_duration", "farmianime", "farmiantime", "farm6time", "farm_tim", "farmianspeed", "farm64duration", "farmiantim", "farm_timeout", "fork_times", "farm5value", "fork_duration", "farm64time", "field_ime", "farm5speed", "fork_type", "farmianetime", "farmianduration", "farm___count", "fork_time", "farm_etime", "farm_type", "farmianfrequency", "fork_tim", "farmiancount", "farm_count", "farm6value", "fork_speed", "farm___times", "farmiantimes"], "cookie_time": ["cookieltimes", "cookieltime", "cookielsleep", "farm_sleep", "wheel_speed", "best_times", "cookie_sleep", "best_max", "farm_TIME", "cookieiantimes", "cookieiansleep", "wheel_price", "best_type", "cookie_type", "cookie_speed", "cookie_price", "cookielTIME", "wheel_time", "cookie_times", "cookieianTIME", "wheel_times", "cookie_max", "cookieiantime", "farm_times", "cookie_TIME"], "infile": ["outfiles", "inf", "INstream", " inFile", "INfile", "inFile", "Instream", "instring", "Inline", "instream", "Inf", " infolder", " infilename", "outline", " inf", "inline", "outfilename", "infolder", "infilename", " inline", " instring", "inputstring", " instream", "inputstream", "infiles", "outstream", "insfilename", "INstring", "inputfile", "outFile", "InFile", "INfolder", "insfile", "INf", "inputfilename", "Infile", "inputFile", "Infilename", "INFile", "INfiles", "INfilename", "insstream", "outstring", "Infolder", "insfiles"], "self": ["view", "r", "client", "acl", "x", "python", "result", "config", "_", "e", "wrapper", "P", "resp", "plugin", "m", "work", "object", "parent", "master", "part", "spec", "sys", "data", "ls", "q", "function", "ctx", "new", "public", "all", "plus", "cl", "s", "this", "f", "event", "w", "proc", "pos", "es", "error", "other", "now", "instance", "node", "mp", "proxy", "cs", "layer", "session", "results", "Self", "h", "cmp", "func", "name", "wx", "ref", "case", "context", "load", "false", "g", "c", "me", "ng", "tmp", "l", "ws", "os", "lf", "full", "reader", "cache", "http", "k", "worker", "p", "host", "user"], "fname": ["foldname", "lfnom", " fName", "cName", "cname", "fword", "fName", " fpath", "outword", "lfname", "foldame", " fword", "fpath", "fame", "outpath", "cword", "lfame", " ffile", "outName", " fame", "foldfile", "foldnom", "cpath", "fnom", "lffile", "ffile", " fnom"], "NumCases": ["NumChainASE", "NumCase", "numcases", "NumCAS", "numcatches", "NumChASE", "numCAS", "NumOccase", "numChases", "Numcatches", "numCASE", "NumScAS", "NumOccances", "NumChainases", "NumOccases", "NumScases", "numChAS", "NumCASE", "NumCatches", "numCances", "NumScase", "NumChainase", "numChASE", "Numcase", "NumChainAS", "numcase", "NumChAS", "Numcances", "Numcases", "NumCances", "NumOccatches", "numCatches", "numcances", "numChase", "NumScASE", "numCases", "numCase", "NumChases", "NumChase"], "caseNum": [" caseName", "Casenum", "caseNumber", "chanceNo", "chanceNum", "acenum", "caseCounter", "aceNum", "aceNo", " caseCounter", "trialName", "codeNum", " casenum", "caseNUM", "caseTon", " caseNUM", "trialnum", "CaseNo", "CaseTon", " caseNumber", "CaseCounter", "codeCounter", "CaseNumber", "codeNumber", " caseTon", "codenum", "CaseNUM", "trialNum", "caseNo", "casenum", "caseName", "chancenum", "trialNumber", " caseNo", "chanceTon", "CaseNum", "aceNUM", "CaseName"], "args": ["chain", "py", "body", "str", "objects", "arr", "ams", "w", "abc", "extra", "pos", "gs", "stats", "GS", "other", "axis", "Arg", "flags", "params", "xml", "atts", "array", " arguments", "ig", "icks", "doc", "ras", "abs", "ass", "argument", "data", "obj", "ix", "call", "config", "ax", "iq", "limits", "gu", "A", "cs", "_", "long", "dict", "a", "blank", "ai", "qa", "vals", "new", "arg", "Args", "words", "ay", "parts", "all", " arg", "au", "aux", "ae", "lines", "parse", "items"], "myCases": ["myAcased", "myCase", "myAcase", "MyChats", "myCASE", "MYCases", "myChases", "mycase", "MYCase", "mycased", "myCsase", "myCats", "myChats", "myCsASE", "myAcases", "myCsases", "MYCased", "mycats", "myChase", "mycASE", "MyChase", "MYCsase", "MyCases", "MYCsases", "mycases", "MYCsased", "myAcASE", "MyChases", "myChased", "myAcats", "MyCats", "MYCASE", "myCased", "MyChased", "myCsased", "MyCase", "MyCased", "MYCsASE"], "outname": ["Outline", "outputpath", "againfile", "outline", "againbase", "inline", "outfilename", "outputfile", "inname", "outputname", "Outpath", "inbase", " outfilename", "againname", " outline", "outputline", "infilename", "OutName", "inpath", "upName", "outbase", "Outfilename", "outpath", "Outname", "upname", "Outfile", "outName", "upline", " outName", " outsize", "inName", "insize", "upfile", "againsize", "againName", " outbase", "outsize", " outpath"], "oldout": ["oldOut", "oldername", " oldOUT", "oldexp", " oldOut", "OldOUT", "OLDOut", "olderexp", "newOut", "Oldexp", "OldOut", "newin", "Oldname", "oldin", "newOUT", "Oldout", "olderpassword", " oldexp", "Oldin", " oldpassword", "olderOut", "newout", "oldpassword", " oldin", "OLDout", "OLDOUT", " oldname", "oldname", "olderout", "newpassword", "olderin", "oldOUT", "newname"], "ii": ["qi", " iii", "inf", "lu", "ci", "ori", "si", "ice", "ni", "i", "gi", "eni", "iz", "ind", "vi", "agi", "ini", "zie", "ili", "li", "zi", "ji", "iii", "ai", "ui", "id", "abi", "ti", "index", "II", "uni", "chi", "di", "fi", "ali", "cu", "pi", "xi", "mini", "hi", "ei", "ani", " bi", "ien"], "outfile": ["inFile", " outFile", "outfilename", "Outpath", " outfilename", "infil", "infilename", "Inname", "offFile", "Inpath", "offfile", "outpath", "Outname", "outfil", "offfil", "offfilename", "Outfile", " outfil", "InFile", "OutFile", "outFile", "Infile", " outpath"], "iCase": ["eiGame", "ITest", " iPlace", "chiCase", "siCase", " iTest", "ICondition", " iCode", "iGame", "ICase", "eiExample", "iPlace", "oiPlace", "oiTest", " iExample", " iGame", "iExample", "iCondition", "IPlace", "siCondition", "iCode", "ICode", "siCode", " iCondition", "iTest", "eiCase", "chiExample", "chiGame", "oiCase"], "answer": ["swers", "ee", "empty", "air", "string", "default", "edit", "array", "grade", "altern", "answered", " answers", "fix", "response", "score", "issue", "argument", "result", "err", "order", "feed", "Answer", "next", "question", "address", "average", " Answer", "ave", "reply", "a", "respond", "blank", "option", "message", "random", "new", "update", "example", "comment", "output", "ell", "au", "all", "ace", "ae", "equ", "offer", "say", "exit", "acc"]}}
{"code": " \n  \n  def Solve(lines):\n      hasEmpty=False\n  \n      rows=[ lines[0][i]+lines[1][i]+lines[2][i]+lines[3][i] \n             for i in xrange(4) ]\n  \n      diags=[ lines[0][0]+lines[1][1]+lines[2][2]+lines[3][3] ,\n              lines[0][3]+lines[1][2]+lines[2][1]+lines[3][0] ]\n  \n  \n      for il in lines + rows + diags:\n          if il.replace('T','X')=='XXXX': return \"X won\"\n          elif il.replace('T','O')=='OOOO': return \"O won\"\n          elif il.find('.')>=0: hasEmpty=True\n  \n      \n      if hasEmpty: return \"Game has not completed\"\n      else: return \"Draw\"\n  \n  \n  \n  def parse(infile):\n      lines=[]\n      for i in xrange(4):\n          lines.append(infile.readline().strip())\n      infile.readline()\n      return (lines,)\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n      outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  class Categorizer(dict):\n      def __init__(self,thelist,transform,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.AddList(thelist)\n          self.trunc=trunc\n      def AddList(self,thelist):\n          for item in thelist: self.Add( item )\n      def Add(self,object):\n          cat=self.transform( object )\n          if type(cat) is float:\n              cat=round(cat,trunc)\n          if self.has_key(cat):\n              self[cat].append( object )\n          else:\n              self[cat]=[object]\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-len(x[1]))\n          total=0\n          for i in items: total+=len(i[1])\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(len(val))) for val in self.itervalues() )\n          formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\n          for key,count in items[0:n]:\n              print formatter.format(key,len(count),\n                                     (\"%.2f\"%(len(count)*100.0/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=[]\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=len(self[key])\n              avg+=len(self[key])*key\n          return avg/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=len(self[key])\n              stddev += len(self[key]) * ( (key-avg)**2)\n          return stddev/(1.0*ntot)\n      def Median(self):\n          tot=0\n          for value in self.itervalues(): tot+=len(value)\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += len(self[key])\n             if nCount>tot/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n  \n  \n  \n  \n  class Counter(dict):\n      def __init__(self,thelist,transform=None,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.trunc=trunc\n          self.AddList(thelist)\n      def AddList(self,thelist):\n          if self.transform is not None:\n              for item in thelist: self.Add( self.transform(item) )\n          else:\n              for item in thelist: self.Add( item )            \n      def Add(self,object):\n          if type(object) is float:\n              object=round(object,self.trunc)\n          if self.has_key(object):\n              self[object]+=1\n          else:\n              self[object]=1\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-x[1])\n          total=0\n          for i in items: total+=i[1]\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(val)) for val in self.itervalues() )\n          formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\n          for key,count in items[0:n]:\n              print formatter.format(key,count, (\"%.2f\"%(count*100.0/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=0\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=self[key]\n              avg+=self[key]*key\n          return avg/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=self[key]\n              stddev += self[key] * ( (key-avg)**2)\n          return stddev/(1.0*ntot)\n      def Median(self):\n   \ttotal=sum(self.values())\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += self[key]\n             if nCount>total/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: x[1])[0]\n  \n  \n  def gen_primes():\n      \"\"\" Generate an infinite sequence of prime numbers.\n      \"\"\"\n      D = {}  \n      q = 2  \n  \n      while True:\n          if q not in D:\n              yield q        \n              D[q * q] = [q]\n          else:\n              for p in D[q]:\n                  D.setdefault(p + q, []).append(p)\n              del D[q]\n  \n          q += 1\n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n", "substitutes": {"lines": ["orders", "lights", "works", "breaks", "xml", "sites", "links", "line", "limits", "its", "sheets", "ines", "ids", "words", "xs", "iter", "comments", "flows", "objects", "codes", "elines", "headers", "lin", "models", "ls", "cells", "pages", "ins", "vals", "holes", "values", "styles", "frames", "s", "bands", "books", "boxes", "posts", "letters", "runs", "planes", "faces", "features", "es", "lined", "inline", "dates", "blocks", "ends", "lins", "steps", "results", "names", "forms", "states", "cases", "liners", "log", "grades", "rings", "groups", " Lines", "lists", "rules", "l", "verts", "ln", "cycles", "points", "strings", "files", "ks"], "hasEmpty": ["havingSafe", " hasZero", "HasSafe", "HasZero", "havingEmpty", "hasSafe", " hasOpen", "HasEmpty", "hasZero", "HasOpen", "hasSize", " hasSize", " hasempty", "havingOpen", "hasempty", "havingZero", "hasOpen", " hasSafe", "HasSize", "havingempty", "Hasempty", "havingSize"], "rows": ["features", "events", "breaks", "heads", "groups", "headers", "ows", "flags", "array", "fields", "times", "rules", "opens", "data", "row", "models", "dates", "cells", "blocks", "pages", "types", "ids", "ports", "ins", "errors", "holes", "values", "results", "frames", "forms", "files", "boxes", "cases", "posts", "runs", "planes"], "i": ["qi", "ij", "o", "ci", "name", "d", "si", "yi", "r", "z", "u", "ni", "io", "int", "v", "ie", "ind", "c", "multi", "x", "ini", "ii", "ix", "iq", "l", "mi", "start", "li", "ri", "iu", "ai", "oi", "a", "ui", "e", "id", "j", "it", "y", "ti", "index", "ip", "di", "pi", "m", "xi", "f", "I"], "diags": ["diag", "Diands", "diagger", "Diag", "idiands", "diagged", "adiags", "adiagger", "idiagged", "diands", "Diagger", " diagger", "adiagged", "idiag", "idiags", " diagged", "Diags", " diands", " diag", "adiag", "Diagged"], "il": ["illed", "illing", "url", "ilt", "ic", "iol", "rl", "nl", "ail", "ilia", "inet", "al", "ums", "ill", "ilo", "sel", "ilk", "ind", "ips", "lin", "IL", "iled", "ails", "yl", "ille", "iling", "als", "ila", "iq", "l", "ipl", "ili", "li", "iller", "ils", "iler", "iu", "ine", "iles", "ins", "id", "nil", " fil", "sil", "it", "illin", "ip", "ol", "ile", "gin", "fil", "el", "lo", "ul", "iel", "ull", "til", "ur", "ills", "sl", "isl"], "infile": ["incfiles", "outfiles", "inf", "INstream", " inFile", "INfile", " infiles", "Instream", "inFile", "Inline", "instring", "instream", " infilename", "outline", " inpath", "Infiles", "inline", " inf", "outfilename", "infilename", " inline", "insline", "inpath", " instring", " instream", "outpath", "incf", "incfile", "infiles", "outstream", "insfilename", "INpath", "INstring", "outFile", "incline", "InFile", "insfile", "Infile", "Infilename", "INFile", "INfiles", "INfilename", "outf", "insstream", "outstring"], "self": ["view", "er", "r", "z", "client", "x", "selves", "python", "call", "result", "config", "_", "method", "e", "resp", "temp", "m", "work", "parent", "b", "master", "utils", "Error", "part", "ps", "spec", "sys", "data", "ls", "function", "ctx", "request", "comp", "hand", "public", "errors", "server", "qs", "all", "plus", "cl", "s", "this", "f", "event", "w", "proc", "private", "pos", "es", "error", "other", "now", "instance", "obj", "mp", "node", "proxy", "exc", "form", "results", "Self", "h", "func", "parser", "time", "ref", "case", "context", "g", "c", "me", "ng", "tmp", "l", "ws", "full", "cache", "http", "ns", "k", "worker", "host", "user", "type"], "fname": ["lfnames", " fName", "afName", "FName", "cName", "afpath", "cname", "fName", "afn", "lfName", "Fname", " fpath", "fnames", " fn", "lfname", "fpath", "fn", "Ffile", " ffile", " fnames", "cn", "afname", "cpath", "lffile", "ffile", "Fnames"], "NumCases": ["NumClases", "numChures", "NumCasease", "NumCapates", "NumCase", "NumDecase", "numCans", "numCates", "NumCaseures", "NumDecures", "NumCans", "numChases", "NumCures", "numAcans", "NumCaseCase", "NumCapase", "NumAcates", "NumCaseases", "NumChCase", "NumClase", "NumClates", "NumCapans", "numAcases", "NumCCase", "NumAcase", "NumClans", "numChCase", "NumCates", "NumDecCase", "numAcase", "NumAcases", "numAcates", "numChase", "numCures", "numCases", "NumCapases", "numCase", "numCCase", "NumChases", "NumDecases", "NumChase", "NumChures", "NumAcans"], "caseNum": [" caseName", "aseNo", "caseNumber", " caseSum", "resultName", "CaseSum", "resultId", " caseCount", "resultNumber", " caseId", "aseSum", "CaseId", "resultLen", "CaseNo", " caseNumber", "CaseNumber", "aseNumber", "CaseLen", "caseId", "caseSum", "resultCount", " caseLen", "caseCount", "caseNo", "aseNum", "caseName", "CaseCount", "resultNo", " caseNo", "CaseNum", "resultNum", "CaseName", "caseLen"], "args": ["py", "actions", "body", "str", "objects", "arr", "works", "ams", "w", "plays", "extra", "ds", "gs", "GS", "other", "now", "asm", "Arg", "flags", "params", "stats", "atts", "array", " arguments", "fields", "ig", "g", "doc", "ras", "abs", "argument", "ass", "data", "obj", "ix", "call", "result", "ax", "config", "iq", "_", "long", "dict", "blank", "qa", "uments", "new", "arg", "Args", "ms", "ay", "parts", "all", " arg", "aux", "s", "parser", "parse"], "myCases": ["myAcased", "MyCsased", "myCase", "myAcase", "MyAcases", "myAcasing", "myCasing", "mycase", "mycased", "myCsasing", "myCsase", "MyCsases", "mycasing", "myAcases", "myCsases", "MyCsase", "MyCsasing", "MyAcase", "MyCases", "mycases", "MyAcased", "MyAcasing", "myCased", "MyCasing", "myCsased", "MyCase", "MyCased"], "outfile": ["inf", "tempfile", "tempFile", "inFile", " outFile", " outile", "outline", "inline", "outfilename", " outf", "Outile", " outfilename", " outline", "outile", "infilename", "Outfilename", "Outfile", "tempf", "outFile", "OutFile", "inile", "outf", "templine"], "iCase": ["ITest", "siCase", " iTest", "IFront", "ICondition", "picase", "uCase", "siTest", "IPosition", "uTest", "ICase", " icase", "iPosition", "icase", "piCase", "iCondition", "uCondition", "iFront", "iuCondition", " iFront", "iuPosition", "siFront", "piTest", "uPosition", "iTest", "iuCase", "Icase", "iuTest"], "answer": ["swers", "ee", "search", "air", "rage", "string", "back", "now", "default", "array", "grade", "answered", " answers", "fix", "response", "sr", "null", "issue", "argument", "data", "result", "err", "feed", "Answer", "next", "exit", "question", "average", " Answer", "reply", "a", "respond", "wave", "random", "comment", "prefix", "output", "don", "ell", "au", "all", "draw", "this", "equ", "sort", "interpret", "say", "adder"], "thelist": ["doclist", "resultlist", "resultword", "resultlong", "doclong", "thelong", "doclists", "itemlong", "itemword", "itemlist", "resultlists", "docword", "theword", "thelists", "itemlists"], "transform": ["features", "text", "diff", " transforms", "arr", "abc", "string", "test", "input", "iterator", "array", "data", "obj", "tmp", "model", "raw", "method", "new", "form", "tr", "output", "forms", "iter", "aux", "changes", "draw", "sort", "parser"], "trunc": [" tracer", "ctram", "Tracer", "trac", "ctracer", "tracer", "ctrunc", "ctrac", "Trac", " trac", "Tram", "Trunc", " tram", "tram"], "object": ["text", "module", "open", "str", "objects", "er", "proc", "none", "string", "anything", "float", "array", "json", "document", "Object", "python", "data", "obj", "integer", "complex", "function", "system", "number", "project", "void", "path", "parser"]}}
{"code": " \n  numCases = input()\n  for c\u200base in range( 1, numCases + 1 ):\n  \tsizeX, s\u200dizeY = raw_input().split()\n  \tsizeX = int(sizeX)\n  \ts\u200dizeY = int(s\u200dizeY)\n  \tb\u200coard = {}\n  \tr\u200cowMax = {}\n  \tcolMax = {}\n  \t\n  \tfor row in range( 0, sizeX ):\n  \t\trow_raw = raw_input()\n  \t\tb\u200coard[ row ] = {}\n  \t\tcol = 0\n  \t\tfor v\u200dalue in row_raw.split():\n  \t\t\tb\u200coard[ row ][ col ] = int(v\u200dalue)\n  \t\t\tcolMax[ col ] = max( colMax.get(col, 0 ), b\u200coard[row][col] )\n  \t\t\tcol += 1\n  \n  \t\tr\u200cowMax[row] = max( b\u200coard[row].values() )\n  \t\n  \tpossible = True\n  \tresult = 'YES'\n  \tfor row in range( 0, sizeX ):\n  \t\tfor col in range( 0, s\u200dizeY ):\n  \t\t\tif b\u200coard[ row ][ col ] != colMax[ col ] and b\u200coard[ row ][ col ] != r\u200cowMax[ row ]:\n  \t\t\t\tpossible = False\n  \t\t\t\tbreak\n  \t\tif not possible:\n  \t\t\tresult = 'NO'\n  \t\t\tbreak\n  \n  \tprint 'Case #' + str( c\u200base ) + ': ' + result \n", "substitutes": {"numCases": ["numcases", " numcases", "numCsased", "numScasing", "numScases", "numcasing", "numCsases", "numCsasing", "numScased", " numCase", " numCased", " numcased", "numScase", "numcase", " numcase", "numCasing", "numCase", " numCasing", "numCsase", "numcased", " numcasing", "numCased"], "sizeX": ["izeX", "sizeY", "izeXP", "izeY", "sizeXP", "sizex", "SizeX", "sizedW", " sizeXP", "izex", "SizeXP", "SizeY", "shapeW", " sizeY", "shapeE", "smallx", " sizeE", " sizeW", "sizedY", "shapeX", "sizedX", "smallY", " sizex", "sizeW", "sizeE", "Sizex", "smallX", "shapeY", "sizedE"], "colMax": [" colRest", "rowmax", "colRange", " colmax", "colMAX", "yearRest", "rowMAX", "rowDef", "cellRange", "cellMin", "colDef", " colDef", "owRest", "colmax", " colMAX", " colRange", "colRest", " colMin", "rowRest", "owmax", "owMax", "yearMAX", "cellMax", "collMin", "yearMax", "rowMax", "yearmax", "owDef", "collRange", "collMax", "colMin"], "row": ["uu", "ow", "ward", "w", "uc", "case", "range", "error", "flow", "batch", "rows", "run", "x", "how", "win", "co", "num", "xy", "cur", "order", "feed", "raw", "round", "cell", "sc", "bug", "length", "block", "month", "roll", "df", "page", "sw", "j", "transform", "tr", "mm", "rc", "ver", "post", "k", "Row", "entry", "ro", "user", "column", "f", "max"], "row_raw": ["row_RAW", "Row_RAW", "Row_raw", "row_Raw", "Row_Raw"], "r": ["ru", "er", "z", "u", "run", "x", "sr", "config", "red", "_", "rar", "method", "e", "nr", "fr", "br", "rg", "m", "ro", "yr", "d", "b", "cr", "i", "rb", "rh", "err", "round", "q", "ri", "a", "lr", "rib", "\u0440", "rw", "tr", "all", "rc", "s", "kr", "f", "req", "w", "ra", "per", "ar", "n", "rd", "rt", "h", "ir", "arc", "pr", "ur", "dr", "R", "ref", "v", "g", "re", "res", "cur", "hr", "mr", "l", "j", "rr", "rs", "k", "p"], "col": ["enc", "ll", "coll", "loc", "key", "COL", "w", "ail", "uc", "pos", "offset", "year", "sel", "cy", "int", "fc", "count", "min", "ch", "x", "win", "co", "ct", "num", "rol", "rot", "lc", "feat", "cell", "seq", "icol", "fn", "lang", "length", "cat", "val", "block", "roll", "sect", "page", "resp", "ol", "oy", "con", "act", "path", "cl", "cal", "fl", "el", "temp", "word", "il", "lo", "Col", "column", "f", "day", "max"], "c": ["mc", "z", "u", "uc", "x", "ch", "call", "cell", "sc", "C", "ad", "e", "ec", "cu", "m", "can", "d", "b", "cr", "i", "cp", "cil", "cc", "count", "pc", "ct", "oc", "q", "cat", "y", "rc", "cor", "cl", "s", "f", "chain", "ic", "w", "nc", "cy", "co", "cs", "n", "cz", "it", "h", "con", "dc", "cin", "cas", "ci", "cod", "t", "cation", "ac", "ce", "case", "at", "v", "g", "cf", "cur", "lc", "l", "inc", "cm", "j", "cn", "ca", "k", "p"], "o": ["ow", "aa", "out", "ao", "off", "d", "b", "ou", "t", "w", "u", "bo", "i", "wo", "oto", "do", "mo", "O", "io", "ino", "no", "yo", "oid", "co", "ole", "Bo", "po", "oh", "ox", "l", "oc", "ar", "os", "q", "oco", "ri", "n", "ok", "oi", "ot", "oro", "e", "id", "oa", "ov", "j", "on", "y", "oe", "ol", "oy", "op", "\u00f3", "so", "k", "vo", "p", "m", "ob", "oo", "lo", "ro", "of", "f", "od"], "possible": [" possibility", "packer", "Possibly", "Pausible", "pential", "npossibility", "npossible", "lpossibility", " pential", "apossible", "possibility", "npossibly", "apossibility", "npential", "possibly", "Pential", "Possible", "Possibility", "Packer", " packer", "apacker", "lpossible", " possibly", "pausible", " pausible", "lpossibly", "lpausible", "apossibly"], "result": ["answer", "catch", "test", "case", "error", "success", "default", "res", "match", "response", "successful", "report", "future", "tmp", "function", "final", "date", "df", "our", "page", "reason", "cache", "ret", "comment", "results", "output", "su", "compl", "use", "rc", "current", "cmp", "Result", "status", "complete"]}}
{"code": " \n  def Fill(outmat,R,C,F):\n      nF=F\n      outmat[:2,:2]='.'\n      nF-=4\n      if nF==0: return\n  \n      outmat[2,:2]='.'\n      nF-=2\n      if nF==0: return    \n  \n      outmat[:2,2]='.'\n      nF-=2\n      if nF==0: return\n  \n      for iC in xrange(3,C):\n          if nF==1:\n              outmat[2,2]='.'\n              return\n          outmat[:2,iC]='.'\n          nF-=2\n          if nF==0: return\n          \n      for iR in xrange(3,R):\n          if nF==1:\n              outmat[2,2]='.'\n              return\n          outmat[iR,:2]='.'\n          nF-=2\n          if nF==0: return\n  \n      for iR,iC in ( (iR,iC) for iR in xrange(2,R)\n                     for iC in xrange(2,C)):\n          outmat[iR,iC]='.'\n          nF-=1\n          if nF==0: return\n      \n  \n  \n  \n  def Solve(R,C,M):\n      F=R*C-M\n      if F==0: return '\nImpossible'\n      if (R>1 and C>1 and F in (2,3)):\n          return '\nImpossible'\n  \n      outmat=np.zeros( (R,C), dtype='S1')\n      outmat[:,:]='*'\n  \n      if R==1:\n          for i in xrange(F):\n              outmat[0][i]='.'\n      \n      elif C==1:\n          for i in xrange(F):\n              outmat[i][0]='.'\n  \n      elif F>1:\n          if F in (2,3,5,7): return \"\nImpossible\"\n          elif (R==2 or C==2) and F%2 != 0:\n              return \"\nImpossible\"\n          elif R==2:\n              outmat[:,:F/2]='.'\n          elif C==2:\n              outmat[:F/2,:]='.'\n          else: Fill(outmat,R,C,F)\n          \n      outmat[0,0]='c'\n      outmatlines=[ ''.join(x) for x in outmat ]\n      answer='\n'+'\n'.join(outmatlines)\n  \n      Verify(answer,F)\n  \n      return answer\n  \n  disp=[ (dx,dy) for dx in (-1,0,1)\n      for dy in (1,0,-1) if (dx !=0 or dy!=0) ]\n  \n  def Verify(answer,F):\n      lines=[list(x) for x in answer.split('\n')]\n      if len(lines[0])==0: lines.pop(0)\n      R,C=len(lines),len(lines[0])\n      assert lines[0][0]=='c'\n      assert answer.count('.')+1==F\n      q=Queue.Queue()\n      q.put( (0,0) )\n  \n      def adjToMine(x,y):\n          for dx,dy in disp:\n              if 0<=x+dx<R and 0<=y+dy<C:\n                  if lines[x+dx][y+dy]=='*': return True\n          return False\n                  \n  \n      while not q.empty():\n          x,y=q.get()\n          for dx,dy in disp:\n              if 0<=x+dx<R and 0<=y+dy<C:\n                  if lines[x+dx][y+dy]=='c': continue\n                  lines[x+dx][y+dy]='c'\n                  if not adjToMine(x+dx,y+dy):\n                      q.put( (x+dx,y+dy) )\n  \n      clicked='\n'.join([ ''.join(x) for x in lines])\n      if clicked.find('.')>=0:\n          print '\n','*'*20,\"\nERROR, input:\"\n          print answer\n          print 'OUTPUT:'\n          print clicked\n      \n  \n  \n  \n  def parse(infile):\n      R,C,M=map(int, infile.readline().split() )\n      return R,C,M\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n  \n      outname=sys.argv[1].rstrip('.in')+'.out'\n      if os.path.isfile(outname):\n          oldout=outname+'.old'\n          ii=0\n          while os.path.isfile(oldout):\n              ii+=1\n              oldout=outname+'.old'+str(ii)\n          os.rename(outname,oldout)\n          print 'Rename: %s -> %s'%(outname,oldout)   \n   \n      outfile=open(outname,'w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n", "substitutes": {"outmat": ["inmath", "outmath", "againmult", " outmatch", "inmol", "OUTlat", "outcat", "offcat", "OUTmot", "againcat", "offmatch", "OUTflat", "outflat", "atmat", "atcat", " outmult", "Outformat", "upmat", "outmot", "againmot", "outformat", " outformat", "againmatch", "OUTmath", " outmath", "Outcat", "againmol", " outmot", "atmol", "inmult", " outlat", "outmol", "resultmult", "OUTmol", "inmat", "againlat", "upmatch", "upmol", "OUTMat", "inflat", "againMat", "outputformat", " outMat", "Outmath", "outputmatch", "offmat", "offmol", "outmult", "Outmot", "OutMat", "incat", "resultmat", " outmol", "Outmat", "outputmat", "OUTmat", "outputmot", "Outmol", "inMat", "informat", "OUTmult", "outlat", "againmath", "againformat", "outputcat", "againflat", "upformat", "outputmol", "outputMat", " outcat", "resultmol", "OUTformat", "Outlat", "outputlat", "Outmult", "outMat", "resultMat", "atmath", "againmat", "outmatch"], "R": ["Rank", "G", "JR", "W", "D", "S", "Br", "Rh", "OR", "RN", "r", "L", "E", "DR", "RP", "KR", "RW", " r", "O", "Rec", "CR", "IR", "UR", "Re", "K", "RC", "RO", "Q", "Range", "RA", "RM", "RG", "HR", "RS", "A", "Run", "RR", "V", "SR", "TR", "Y", "Ro", "RH", "P", "WR", "H", "T", "RE", "X", "RL", "MR", "AR", "BR", "Ra", "N", "B", "U", "Right", "GR", "RF", "NR", "Rs", "I"], "C": [" c", "CL", "W", "D", "CE", "S", "Cr", "G", "YC", "FC", "CM", "EC", "L", "E", "O", "Ch", "CR", "CNN", "CT", "c", "VC", "K", "CU", "CW", "DC", "CI", "GC", "Sc", "CS", "Or", "JC", "Ca", "A", "V", "Cu", "Y", "CC", "KC", "CA", "AC", "Cor", "P", "H", "T", "CV", "X", "SC", "NC", "B", "Cs", "N", "U", "Con", "Three", "Cl", "I"], "F": ["G", "Fl", "W", "D", "S", "FC", "FL", "EC", "FD", "Far", "E", "L", "FA", "If", "O", "CR", "cf", "Fine", "K", "Z", "AF", "Q", "CF", "IO", "IF", "Fit", "Family", "A", "V", "FH", "FG", "Fs", "Y", "TF", "new", "ELF", "Fun", "P", "EF", "H", "T", "X", "PF", "Fe", "Fixed", "FR", "GF", "FO", "WF", "FE", "J", "FF", "B", "N", "U", "OF", "Fi", "File", "DF", "FB", "f", "I"], "nF": ["ynL", "neC", "nFile", " nQ", "fnF", "nwF", "lnF", " nf", "wF", " nH", " nC", "unF", " nFamily", " nEF", "unH", "dnF", "nV", "lnFamily", "pnL", " nW", "nwL", "cnf", "nG", " nFile", "fnC", "NC", "dnC", "NF", "iFile", "NV", "nW", "iE", "nf", " nU", " nL", "nEF", "connFile", " nOF", "pnELF", "nOF", "cnM", "dnFamily", "lnE", "lC", "cnE", "pf", "unFile", "NM", "lF", "ynF", "unD", "pnD", "nwW", "ynELF", "lnH", "NELF", "NOF", "iF", "nELF", "lD", "fnE", "cnF", "pEF", "nD", "dnD", "nL", "pnF", "nE", " nG", "neF", "nwf", "neD", "lnEF", "neG", " nM", "unC", "ynD", " nE", " nV", "connF", "connf", "noneV", " nD", "nanQ", "nC", "noneF", "NFile", "neU", "fnU", "connE", "fnf", "nanOF", "unQ", "NE", "nFamily", "nM", "fnV", "wW", "wf", "ND", "unFamily", "Nf", "nanE", "pF", "noneE", "nanFamily", "nQ", "lnf", "pE", "fnD", "NFamily", "wL", "lFamily", "nanC", "NL", "nanF", "noneFamily", "lnQ", "lG", "nH", "nU"], "iC": [" iSc", "liCNN", "iiM", "niM", "iiR", "aM", "niCs", "iM", "siC", "aC", "iuSc", "iCNN", "iCs", "eniDC", "iuC", "biC", "liF", "jC", " iCs", "siCs", " iN", "eniCNN", "jM", "iiF", " iF", "aSc", "iiN", "liDC", "biM", "iiU", "siM", "aR", "niR", "niN", " iM", "niL", "jR", "siF", "iT", " iT", "biR", "iSc", "eniC", "aU", "siL", "iN", "liC", "biT", "jT", " iDC", "iU", "aF", "eniF", "iuR", "iL", "siR", "iF", "niC", "iDC", " iCNN", "iiC", "iuM", "siU", " iL"], "iR": ["aiAr", "iB", "iiRs", "iiR", "iM", "siC", "cC", "cB", "aiB", "siRh", "siG", " iG", "siAr", "ciM", "biC", "iAr", "ciN", "jC", "jRh", "iiG", " iN", " iB", "pC", "pM", "ciC", "aiC", "cR", "jRs", "uM", "ciR", "biM", "siM", "uRs", "iG", " iM", "jR", "biR", "pR", "cAr", "pRs", "iN", " iAr", "biRs", "iRh", "siR", " iRh", "siRs", "iRs", "uC", "uR", "ciRs", "aiR", "ciAr", "siN", "iiC", " iRs"], "M": ["G", "W", "D", "OR", "CM", "MS", "L", "E", "c", "K", "Z", "Q", "MF", "MN", "RM", "A", "V", "Y", "P", "H", "T", "X", "MR", "MM", "J", "m", "N", "B", "U", "MC", "MI", "I"], "i": ["qi", "im", "ic", "ci", "d", "b", "si", "t", "r", "z", "u", "ni", "io", "v", "int", "ie", "c", "multi", "ini", "l", "mi", "ar", "li", "n", "a", "ai", "iu", "e", "id", "j", "it", "ti", "index", "pi", "m", "p", "xi", "phi", "f", "I"], "outmatlines": ["OutMatlin", "outcatline", "OutMatline", "outMatlines", "outMatline", "outMatlin", "out_line", "out_lin", "outcatlines", "outcatlin", "outmatlin", "Outmatlin", "outmatline", "Outmatlines", "out_lines", "Outmatline", "OutMatlines"]}}
{"code": " \n  T = int(raw_input())\n  for test_case_id in xrange(1, T + 1):\n      N, M = map(int, raw_input().split())\n      A = []\n      for i in xrange(N):\n          A.append(map(int, raw_input().split()))\n  \n      h\u200deights = reduce(lambda a, b: a | b, (set(row) for row in A))\n      for y in xrange(N):\n          for x in xrange(M):\n              if (\n                  any(A[y][j] > A[y][x] for j in xrange(M)) and\n                  any(A[i][x] > A[y][x] for i in xrange(N))\n              ):\n                  print 'Case #{}: NO'.format(test_case_id)\n                  break\n          else:\n              continue\n          break\n      else:\n          print 'Case #{}: YES'.format(test_case_id)\n", "substitutes": {"T": ["R", "W", "D", "S", "NT", "t", "L", "E", "UTC", "O", "K", "Z", "F", "TT", "C", "V", "Y", "P", "H", "X", "Time", "TS", "B", "Total", "TN", "TA", "J", "I"], "test_case_id": ["test_case_info", "test_caseuuid", "test_caseguid", "test_case2ids", "test_test_id", "test_case__type", "test_case2num", "test_case__number", "test_case_ids", "test_cases_num", "test_cases_type", "test_testpinfo", "test_casegname", "test_casepinfo", "test_test_uid", "test_caseginfo", "test_casepname", "test_cases_ids", "test_cases_id", "test_case2id", "test_case_type", "test_case_number", "test_casepid", "test_casepuid", "test_casegid", "test_test_number", "test_case2type", "test_case_uid", "test_case_num", "test_test_info", "test_caseuunumber", "test_testpuid", "test_case__id", "test_testpid", "test_case_name", "test_test_type", "test_caseuutype", "test_testpname", "test_test_name"], "N": ["R", "G", "W", "D", "Ns", "S", "NT", "NE", "E", "L", "O", "Ne", "NOR", "No", "K", "Z", "F", "Size", "Mon", "I", "C", "V", "AN", "n", "Y", "NM", "NO", "NA", "P", "H", "X", "Num", "Na", "B", "U", "CN", "J", "NS"], "M": ["G", "R", "W", "D", "LM", "S", "CM", "E", "L", "O", "OM", "MO", "K", "Z", "F", "Q", "MN", "RM", "Mon", "C", "V", "MON", "n", "Y", "NM", "Mo", "P", "H", "X", "Num", "m", "B", "U", "J", "I"], "A": ["The", "LA", "Test", "R", "G", "W", "D", "S", "Alpha", "L", "E", "If", "Ha", "O", "As", "K", "Z", "AF", "Array", "F", "All", "am", "An", "New", "Answer", "ar", "C", "V", "ad", "App", "You", "a", "Center", "Y", "At", "Ay", "CA", "AST", "AS", "AM", "Wa", "P", "H", "X", "Java", "Ab", "One", "Ar", "mA", "au", "Any", "Ba", "Na", "Am", "B", "U", "API", "Case", "Az", "Bu", "AA", "J", "Average", "AP", "I"], "i": ["bi", "im", "ij", "o", "ci", "yi", "d", "si", "b", "w", "r", "z", "u", "ni", "io", "int", "v", "ie", "ind", "g", "c", "x", "ii", "ix", "l", "li", "zi", "a", "iu", "ai", "n", "ji", "ui", "e", "id", " j", "j", "it", "ti", "index", "ip", "ib", "di", "pi", "k", "p", "xi", "m", "ei", "il", "ik", "f", "I"], "y": ["ye", "o", "yi", "yt", "je", "yy", "b", "d", "w", "t", "z", "ey", "u", "ya", "v", "year", "ie", "cy", "c", "yl", "x", "dy", "yo", "xy", "ii", "vy", "ys", "l", "n", "a", "Y", "e", "id", "icy", "yd", "j", "ny", "ay", "oy", "h", "isy", "k", "m", "p", "xi", "yr", "ym", "f", "zy"]}}
{"code": " \n  \n  TEST_CASES = [\n      (\"\"\"3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \"\"\",\"\"\"Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  \"\"\"),\n      (\"\"\"1\n  1\n  15 9 16 5\n  6 10 1 3\n  2 4 12 11\n  13 14 8 7\n  1\n  5 10 9 6\n  12 15 1 11\n  14 16 4 2\n  13 3 8 7\"\"\",\"\"\"Case #1: Bad magician!\n  \"\"\")\n  ]\n  \n  BAD_MAGIC = \"Bad magician!\"\n  C\u200cHEATING = \"Volunteer cheated!\"\n  \n  def parse_input(input_reader):\n      case_count = int(input_reader.readline())\n      c\u200dase_idx = 0\n      while case_count > c\u200dase_idx:\n          c\u200dase_idx += 1\n          rows = []\n          for l\u200doop_idx in (1,2):\n              r\u200bow_idx = int(input_reader.readline())\n              for i\u200bdx in (1,2,3,4):\n                  if i\u200bdx == r\u200bow_idx:\n                      rows.append(set(input_reader.readline().rstrip(\"\n\").split(\" \")))\n                  else:\n                      input_reader.readline()\n          input_values = {\"rows\":rows,\n                          \"case\":c\u200dase_idx}\n          yield input_values\n  \n  \n  def solve_problem(o\u200dutput_writer=sys.stdout, **kwargs):\n      rows = kwargs['rows']\n      case = kwargs['case']\n      intersect = rows[0].intersection(rows[1])\n      if not intersect:\n          msg = C\u200cHEATING\n      elif len(intersect) == 1:\n          msg = intersect.pop()\n      else:\n          msg = BAD_MAGIC\n      print >>o\u200dutput_writer, \"Case #%d: %s\" % (case, msg)\n  \n  def solve_inputs(input_reader, o\u200dutput_writer):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to o\u200dutput_writer.\n      \"\"\"\n      for input_values in parse_input(input_reader):\n          solve_problem(o\u200dutput_writer=o\u200dutput_writer, **input_values)\n  \n  def run_tests():\n      \"\"\"\n      Check the sample input and output match.\n      \"\"\"\n      i\u200bdx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          i\u200bdx += 1\n          input_reader = StringIO(problem_input)\n          o\u200dutput_writer = StringIO()\n          solve_inputs(input_reader, o\u200dutput_writer)\n          problem_output = o\u200dutput_writer.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" % i\u200bdx\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" % i\u200bdx\n          input_reader.close()\n          o\u200dutput_writer.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n          print problem_output\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\n          o\u200dutput_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_inputs(input_reader, o\u200dutput_writer)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n", "substitutes": {"TEST_CASES": ["TEST_CULes", "TEST_SCASAS", "TEST_SCASes", "TEST_CACES", "TEST_CATCHIONS", "TEST_CACes", "TEST_CATCHes", "TEST_SCATCHAS", "TEST_CACAS", "TEST_CASes", "TEST_CASAS", "TEST_CATCHAS", "TEST_SCATCHES", "TEST_CULIONS", "TEST_CULES", "TEST_SCATCHes", "TEST_CULAS", "TEST_CACIONS", "TEST_CATCHES", "TEST_SCASIONS", "TEST_CASIONS", "TEST_SCASES", "TEST_SCATCHIONS"], "BAD_MAGIC": ["BADJLOGICK", "BAD_MAGIT", "BAD_STATIC", "BADICSTATIT", "BAD_LOGICA", "BAD_LOGICK", "BAD_MAGICK", "BADICSTATEC", "BAD_LOGEC", "BAD_MAGENT", "BADICMAGIT", "BADJMAGIC", "BADJLOGIC", "BADJMAGICAL", "BADJLOGICAL", "BAD_STATICA", "BAD_AGIC", "BAD_MAGICAL", "BAD_LOGICAL", "BADICSTATIC", "BADICMAGEC", "BAD_MAGEC", "BADICMAGICA", "BAD_MAGICA", "BAD_AGICK", "BADICMAGIC", "BAD_AGICAL", "BAD_LOGIC", "BAD_STATIT", "BAD_STATICK", "BAD_STATICAL", "BADJMAGICK", "BADICSTATICA", "BAD_STATEC", "BADJLOGENT", "BAD_LOGENT", "BAD_AGENT", "BAD_LOGIT", "BADJMAGENT", "BAD_STATENT"], "input_reader": ["output_reading", "inputFilereader", "Inputfslice", "input___parser", "inputfreader", "input_parser", "output_writer", "inputfparser", "input2writer", "input64parser", "Input_slice", "inputfslice", " input_draft", "input2reader", "input_writer", "Inputfdriver", " input_parser", "input_source", "output_author", "input64reader", " input_editor", "input___editor", "output_reader", "inputfdriver", "input2author", "input_slice", "input___reader", "Input_parser", "inputFileauthor", "input_handler", "Inputfparser", "input_author", "input___draft", "output_handler", "input64slice", "input_draft", "Input_driver", "input2handler", "input64editor", "inputFilewriter", "Inputfreader", "input64draft", "input_reading", "Input_reader", "input2source", "output_source", "input64driver", "input2reading", "inputFilehandler", "input_driver", "input_editor"], "case_count": ["case__count", "match_Count", "casefulllength", "case__num", "case__Count", "match__level", "match_count", "match_number", "case__length", "match_num", "case_Count", "match__Count", "match__count", "case_number", "case_num", "match__length", "case_length", "casefulllevel", "case_level", "case__level", "match_length", "match__number", "casefullnum", "match_level", "casefullcount", "match__num", "case__number"], "rows": ["rooms", "orders", "features", "rown", "tests", "users", "runs", "ros", "events", "rings", "groups", "headers", "ows", "relations", "array", "reports", "fields", "times", "roots", "rules", "x", "ches", " row", "data", "OWS", "row", "models", "feed", "cells", "blocks", "vers", "pages", "types", "ids", "keys", "vals", "words", "errors", "holes", "values", "docs", "xs", "results", "frames", "checks", "sections", "forms", "shows", "rs", "cases", "ks", "posts", "Row", "reads", "views", "lines", "flows", "items"], "input_values": [" input2values", " input2docs", "input2changes", "input_value", " input_changes", "case_vals", "input_rows", "input2vals", "input_docs", " input_vals", " input_docs", "case_rows", " input2vals", "case_values", "input_changes", " input2changes", "input2values", "input_vals", "case_value", "input2docs"], "intersect": ["orsect", "diffsect", "interconnect", "crosssect", " Intersection", "diffcept", " interect", "orsections", "oversections", " Intersect", "Interconnect", "orcept", "interrupt", " Intercept", " intercept", "interect", "INTERsection", "orsection", "oversect", "crosssection", "INTERcept", "overconnect", "Intersection", " Interrupt", "overcept", "intersection", "INTERrupt", " intersection", "diffsections", "Interrupt", "oversection", "Intersect", "Intercept", "Intersections", "overect", "crosssections", "INTERsect", "crossconnect", "Interect", "diffsection", "intersections", "intercept"], "msg": ["cfg", "req", "md", "og", "module", "str", "help", "fg", "gs", "error", "warning", "comm", "init", "Msg", "g", "ag", "debug", "doc", "err", "gen", "mess", "bug", "exc", "gram", "lang", "warn", "sym", "message", "ma", "arg", "reason", "conf", "ms", "comment", "bg", "nm", "compl", "cmd", "op", "m", "sg", "log", "sim", "type"]}}
{"code": " \n  \n  def compute(N, M, a):\n      rows = [0] * N\n      cols = [0] * M\n      for r in xrange(N):\n          rows[r] = 0\n          for c in xrange(M):\n              if a[r][c] > rows[r]:\n                  rows[r] = a[r][c]\n      for c in xrange(M):\n          cols[c] = 0\n          for r in xrange(N):\n              if a[r][c] > cols[c]:\n                  cols[c] = a[r][c]\n      for r in xrange(N):\n          for c in xrange(M):\n              if a[r][c] < rows[r] and a[r][c] < cols[c]:\n                  return \"NO\"\n      return \"YES\"\n  \n  \n  def parse():\n      N, M = map(int, sys.stdin.readline().strip().split())\n      a = []\n      for i in xrange(N):\n          a.append(map(int, sys.stdin.readline().strip().split()))\n      return N, M, a,\n  \n  \n  if __name__ == \"__main__\":\n      sys.setrecursionlimit(100000)\n      T = int(sys.stdin.readline().strip())\n      count = 1\n      part = 0\n      if len(sys.argv) == 3:\n          part = int(sys.argv[1])\n          count = int(sys.argv[2])\n      for i in xrange(T):\n          data = parse()\n          if i * count >= part * T and i * count < (part + 1) * T:\n              result = compute(*data)\n              print \"Case #%d: %s\" % (i + 1, result)\n", "substitutes": {"N": ["R", "Ns", "W", "D", "S", "G", "NT", "RN", "NE", "L", "E", "Ni", "O", "Ne", "CNN", "ND", "No", "K", "Z", "Count", " Ne", "NN", "F", "Q", "MN", "Size", "Net", "Mon", "A", "I", "C", "V", "AN", "n", "Y", "NI", "NM", "NO", "Node", " n", "NA", "Mo", "P", "H", "X", "Num", "Na", "NC", "U", "B", "CN", "NR", "NS"], "M": ["R", "G", "LM", "W", "D", "S", "CM", "MS", "ME", "L", "E", "Ma", "DM", "O", "Ms", "MO", "OM", "Me", "K", "Z", "Mac", "F", "Q", "MF", "MA", " m", "RM", "Mon", "A", "C", "V", "n", "Y", "MB", "MC", "NM", "Mo", "AM", "P", "MU", "H", "X", "MD", "MR", "Mode", "MM", "Multi", "J", "m", "B", "U", "Mi", "MN", "MI", "I"], "a": ["ama", "da", "api", "aa", "o", "ao", "eta", "d", "b", "aaa", "tta", "ac", "aj", "ba", "na", "at", "ada", "ana", "array", "x", "Array", "ea", "am", "sa", "alpha", "l", "ar", "A", "ad", "n", "ai", "ans", "ach", "e", "auto", "ma", "la", "y", "aw", "area", "an", "asa", "ga", "mA", "au", "aux", "ast", "ca", "access", "ae", "p", "m", "va", "ab", "ata", "f"], "rows": ["orders", "features", "rooms", "users", "runs", "objects", "ays", "events", "heads", "members", "groups", "breaks", "headers", "ows", "relations", "fields", "times", "roots", "rules", "opens", "tracks", "OWS", "models", "row", "feed", "cells", "blocks", "pages", "types", "keys", "ids", "ports", "ends", "errors", "values", "results", "frames", "forms", "rs", "posts", "reads", "views", "lines", "flows", "planes", "items"], "cols": [" coln", "columnd", "Collines", "COLn", " colsi", " coles", "cold", "pulles", "llabs", "columnc", "pullses", " colses", "columnses", "roundabs", "COLs", " cold", " coli", "coln", "collines", "colc", "COLabs", "columnes", "COLes", "columnp", "Cols", "Coln", " colp", "Cold", "colsi", "colses", "coles", "lls", "colabs", "coli", "columnabs", " colabs", "roundsi", "rounds", "columnn", "columns", "Colabs", "colp", "Colc", "roundp", "columnsi", "pulls", "lllines", "llc", "columnlines", "pullabs", "Coli", "columni"], "r": ["R", "ru", "o", "d", "b", "er", "cr", "u", "ac", "rb", "range", "w", "v", "col", "attr", "g", "re", "sr", "x", "co", "rh", "row", "nor", "err", "l", "ar", "oc", "n", "unc", "lr", "right", "e", "ner", "nr", "fr", "an", "br", "rn", "ir", "rr", "h", "rc", "rs", "arc", "pr", "k", "m", "p", "ro", "yr", "ur", "dr", "f"], "c": ["cont", "chain", "rec", "mc", "coll", "o", "ci", "d", "b", "t", "cr", "u", "ac", "uc", "w", "nc", "cp", "ce", "v", "col", "cy", "fc", "cf", "cc", "g", "pc", "x", "ch", "ct", "lc", "row", "code", "err", "l", "ar", "oc", "C", "q", "cs", "sc", "n", "unc", "course", "cat", "e", "ec", "y", "nr", "an", "h", "ir", "rc", "con", "cor", "arc", "s", "cu", "cn", "k", "m", "p", "f", "dc"], "i": ["qi", "ic", "o", "ci", "d", "b", "si", "w", "t", "z", "u", "ac", "ni", "at", "gi", "int", "v", "ie", "ind", "g", "multi", "x", "ini", "ii", "l", "ar", "start", "q", "uri", "li", "zi", "n", "ai", "idi", "type", "ui", "e", "id", "j", "it", "ti", "y", "index", "rn", "ir", "h", "slice", "rc", "chi", "uni", "arc", "s", "cu", "k", "pi", "p", "m", "xi", "mini", "phi", "f", "span", "I"], "T": ["R", "G", "W", "D", "S", "TE", "NT", "t", "L", "E", "O", "CT", "TH", "K", "Z", "Count", "F", "Q", "TT", "A", "FT", "C", "V", "DT", "TR", "Y", "Part", "ST", "P", "H", "X", "Time", "TS", "MT", "TC", "B", "U", "TN", "PT", "TA", "Type", "LT", "I", "type"], "count": ["cast", "depth", "key", "parent", "name", "group", "time", "t", "child", "partial", "test", "case", "error", "offset", "int", "col", "Count", "match", "connection", "num", "base", "code", "call", "order", "start", "f", "n", "length", "nt", "max", "patch", "id", "second", "counter", "cache", "number", "len", "size", "p", "limit", "sum", "span", "type"], "part": ["before", "point", "total", "parent", "key", "group", " partition", "t", "span", "pos", "partial", "case", "step", "int", "year", " Part", "position", "no", "connection", " start", "PART", "base", "order", "start", "chapter", "n", "max", "patch", "Part", "month", "half", "state", "number", "element", "section", "len", "parts", "week", "minute", "size", "component", "pi", "m", "p", "mini", "limit", "art", "type"], "data": ["api", "aa", "actions", "body", "arr", "d", "info", "ds", "action", "test", "input", "load", "array", "batch", "res", "response", "dd", "config", "alpha", "dates", "DATA", "db", "details", "args", "lines", "ma", "new", "vals", "cache", "results", "parts", "series", "s", "di", "p", "database", "dat", "ata", "Data"], "result": ["diff", "runner", "arr", "event", "test", "error", "attr", "success", "default", "rect", "array", "json", "root", "res", "match", "response", "report", "obj", "row", "err", "final", "cup", "valid", "dict", "val", "math", "df", "message", "page", "ret", "list", "results", "output", "compl", "ver", "xi", "Result", "status", "gi", "record"]}}
{"code": "directory = 'C:/users/hai/my projects/google code jam/2013/qualification/C/'\n  \n  \n  def is_palindrome (n):\n      l = list(str(n))\n      return list(reversed(l)) == l\n  \n  def prepare ():\n      global f\u200cair_and_squares\n      f\u200cair_and_squares = []\n      \n      for i in range(1,10**7):\n          if is_palindrome(i):\n              sqr = i**2\n              if is_palindrome(sqr):\n                  f\u200cair_and_squares.append(sqr)\n      return\n  \n          \n  def solve (f_in, f_out):\n      prepare()\n      T = int(f_in.readline())\n      for t\u200cestcase in range(1,T+1):\n          A,B = [int(x) for x in f_in.readline().split()]\n          count = len([x for x in f\u200cair_and_squares if (x>=A and x<=B)])\n          f_out.write('Case #' + str(t\u200cestcase) + ': ' + str(count) + '\n')\n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n", "substitutes": {"directory": ["window", "duration", "environment", "D", "module", "password", "home", "d", "definition", "space", "input", "selection", "direction", "domain", "binary", "machine", "root", "c", "third", "document", "language", "picture", "DI", "python", "volume", "application", "config", "storage", "package", "uri", "collection", "direct", "folder", "system", "division", "Directory", "location", "description", "tree", "filename", "project", "y", "prefix", "timeout", "output", "category", "source", "resource", "manager", "path", "expression", "library", "dir", "office", "database", "archive", "command", "connection"], "n": ["o", "name", "d", "nn", "b", "t", "r", "z", "u", "w", "nc", "v", "g", "c", "nor", "node", "network", "a", "nt", "en", "ne", "e", "sn", "ln", "j", "y", "nb", "ns", "h", "m", "N", "p", "f"], "l": ["ll", "o", "rl", "d", "nl", "b", "kl", "t", "L", "r", "u", "z", "v", "g", "c", "lc", "ls", "li", "e", "ln", "la", "j", "y", "list", "ol", "h", "lis", "all", "s", "el", "m", "p", "dl", "lp", " L", "f", "sl"], "i": ["bi", " c", "ij", "ic", "ci", "ori", "d", "b", "si", " I", "z", "r", "u", "range", "at", "int", "ie", "v", "ind", "vi", "g", "c", "ch", "ini", "ii", "ix", "iq", "li", "ri", "iii", "a", "ai", "iu", "e", "id", " j", "j", "abi", "it", "ti", "index", "ip", "h", "cor", "s", "pi", "m", "p", "xi", "il", "phi", "f", "gi", "I"], "sqr": ["sqrt", "sqp", "dqrl", "qr", "qvlr", "qR", "qvrt", "sqrl", "scr", "scrs", "sqrs", "dqrt", " sqrs", "qrl", "qvrl", " sqR", "dqlr", "qlr", "dqr", "qrt", "qvr", "scR", "qp", "sqlr", "qrs", "sqR", " sqp", "scp"], "f_in": ["fLogini", "sf_is", " f_ini", "cf_inn", "f_int", "fLogin", "cf_In", "fLoglogin", "f_In", "fLognin", "sf_in", "f__din", "f__is", " f_int", " f_login", "fLogint", "f_ins", "sf_out", "f_ini", " f_ins", "f_id", "fLogout", "cf_in", "f__in", "f_inn", "f_login", "f_din", "f__out", "f_is", "cf_out", " f_nin", "f_nin", "f__id", "sf_din", "cf_id"], "f_out": ["f__out", " f_Out", "f__io", "f_Out", "f_io", " f_io", "f__nin", " f_client", "f_path", "f_this", " f_nin", "f_again", "f__client", "f_nin", "f_client", "firmthis", "f__again", "f__in", "firmout", " f_this", "f__Out", "firmagain", "firmin", " f_path", " f_again"], "T": ["Length", "R", "G", "Test", "W", "D", "S", "t", "L", "E", "O", "M", "Z", "F", "Q", "TT", "C", "V", "length", "Y", "number", "P", "H", "X", "Time", "TS", "N", "U", "Total", "TN", "J", "I"], "A": ["LA", "G", "D", "S", "b", "E", "L", "ba", "na", "O", "M", "All", "An", "alpha", "C", "_", "a", "Y", "Ay", "Th", "P", "H", "X", "Ar", "au", "mA", "U", "N", "AA", "TA", "I"], "B": ["G", "R", "W", "D", "S", " b", "b", "L", "E", "BF", "O", "M", "Z", "F", "Q", "C", "V", "Y", "WB", "P", "X", "Bs", "N", "U", "BA", "I"], "x": ["out", "xe", "xxxx", "r", "z", "u", "int", "tx", "xml", "rax", "xy", "ix", "e", "xt", "example", "xs", "xa", "www", "xd", "word", "php", "m", "ux", "work", "im", "opt", "d", "b", "test", "rx", "xes", "dx", "xf", "exp", "ct", "data", "fx", "q", "ctx", "xxx", "y", "number", "index", "path", "cl", "f", "file", "cross", "nex", "ww", "w", "string", "rex", "co", "ax", "xx", "com", "yx", "xb", " X", "lex", "h", "check", "max", "ci", "xp", "name", "wx", "time", "t", "v", "ex", "ext", "g", "c", "xc", "code", "full", "upload", "content", "j", "sw", "prefix", "X", "ay", "p", "xi", "go", "sex"], "count": ["W", "race", "time", "z", "test", "case", "ind", "batch", "c", "Count", "num", "code", "seq", "C", "length", "Y", "id", "counter", "number", "y", "P", "index", "X", "len", "all", "size", "type"], "filenames": ["filvernAMES", "linenaming", "gallennonyms", "filvernames", " filonAME", "filpenamed", "filenAME", " filenAME", "linenamed", "filagennames", "filennames", "filonenames", " filonames", "filonenamed", "filernames", "filenonyms", "filtenoms", "linenames", "filonnames", "filenews", " filenaming", "filtenames", "filetonames", "gallennnames", " filvernAMES", "filernews", " filvernaming", "filagenaming", "filtenAME", "fillenonyms", "filvernaming", "filennonyms", " filennames", "filenetimes", "filagenames", "gallenaming", "linonenamed", "filernamed", "filpenews", "gallenonyms", "linonenames", "filetonetimes", "filennaming", "filenaming", "filetonaming", "filonames", "filernaming", "filennAME", "gallenames", " filonnames", "fillenames", "filennnames", " filenoms", "gallennames", "linenews", "fillennames", "filENAMES", " filonoms", "gallennaming", "filagenonyms", "filENaming", " filenAMES", "filpenaming", "filenamed", " filenetimes", "fillenaming", "filetonAMES", "filENetimes", "linonenaming", "filennoms", "linonenews", "filenAMES", "filENames", "filtennames", "filenoms", "filpenames", "filonAME", " filvernames", "filonoms", "filonenews", "filonenaming", " filvernetimes", "filvernetimes"], "l1": ["l3", " l2", " l61", "kl2", "klfirst", "li1", "li61", "kl3", "L2", "l61", "lfirst", "L3", "l2", "list2", "L61", "lone", "L1", "Lone", "list3", "li2", " lone", "list1", "listfirst", "Lfirst", "lione", "kl1"], "chosen_filename": ["chosed_directory", "chosen_file", "chosenPfilename", "chosen2filename", "chidden_Filename", "chosen___directory", "chosing_name", "chidden_location", "chosed_files", "chosen2directory", "chosenPdirectory", "chosen___files", "chosing_filename", "chosen_files", "chosen_source", "chosing_Filename", "chosed_source", "chosed_filename", "chosing_directory", "chosing_file", "chosen_name", "chidden_token", "chosen_Filename", "chosen2Filename", "chidden_filename", "chosen_directory", "chosen___source", "chosenPsource", "chosen___filename", "chosen2file", "chosen_token", "chosenPfiles", "chosen_location"]}}
{"code": " \n  class Solver(object):\n      def __init__(self):\n          pass\n      \n      def solve(self, inputs):\n          c, f, x = [float(t) for t in inputs[0].split()]\n          if x <= c:\n              return '%.7f'%(x/2)\n          ii = int(math.ceil((f*x-2*c)/(f*c)-1))\n          if ii <= 0:\n              return '%.7f'%(x/2)\n          t = 0\n          for i in range(ii):\n              t += c/(2+i*f)\n          t += x/(2+ii*f)\n          return '%.7f'%t\n          pass\n      \n      def feed(self, inputs):\n          l\u200bines = [x.strip() for x in inputs]\n          o\u200dutputs = []\n          t\u200best_case_n = int(l\u200bines[0])\n          cur = 1\n          for i in range(t\u200best_case_n):\n              i = i\n              case_line_cnt = 1\n              c\u200base_inputs = l\u200bines[cur:cur+case_line_cnt]\n              cur += case_line_cnt\n              o\u200dutputs.append(self.solve(c\u200base_inputs))\n          return o\u200dutputs\n  \n  if __name__ == '__main__':\n      iname = 'B-small-attempt0.in'\n      sample_in = '''\n      4\n  30.0 1.0 2.0\n  30.0 2.0 100.0\n  30.50000 3.14159 1999.19990\n  500.0 4.0 2000.0\n      '''\n      s\u200cample_out = '''\n  Case #1: 1.0000000\n  Case #2: 39.1666667\n  Case #3: 63.9680013\n  Case #4: 526.1904762\n      '''\n      if os.path.exists(iname):\n          with open(iname) as f:\n              inputs = f.readlines()\n      else:\n          inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n      solver = Solver()\n      o\u200dutputs = solver.feed(inputs)\n      fail_flag = False\n      if os.path.exists(iname):\n          with open(iname+'.out', 'w') as f:\n              for i, v in enumerate(o\u200dutputs):\n                  print >> f, 'Case #%d: %s'%(i+1, str(v))\n      else:\n          a\u200cns = set([x.strip() for x in s\u200cample_out.split('\n') if x.strip()])\n          for i, v in enumerate(o\u200dutputs):\n              t = 'Case #%d: %s'%(i+1, str(v))\n              if t not in a\u200cns:\n                  print '!!! Wrong:', t\n                  fail_flag = True\n      print '===================================================='\n      for i, v in enumerate(o\u200dutputs):\n          print 'Case #%d: %s'%(i+1, str(v))\n      print '===================================================='\n      print 'done' if not fail_flag else 'fail'\n      pass\n", "substitutes": {"self": ["o", "parent", "time", "w", "r", "er", "other", "client", "context", "g", "connection", "ng", "node", "ws", "_", "q", "os", "ctx", "e", "cache", "driver", "Self", "all", "s", "k", "m", "this", "p", "host", "object", "user"], "inputs": ["methodd", "inputp", "Inputp", " inputd", "Inputes", " inputt", "methods", " Inputs", " Inputp", "Inputs", " inputes", "subjectes", "inputf", "inputlines", "roundt", "Inputsets", "inputi", " inputns", " Inputi", "outputd", "outputn", " inputsets", "subjectf", "inputsets", " inputn", "Inputn", "outputlines", "subjects", "methodlines", "inputes", "inputn", "Inputd", "roundd", "Inputf", " inputi", "rounds", " inputlines", "Inputt", "subjectsets", "outputs", " Inputlines", "inputns", "roundes", " inputf", "Inputns", "inputt", "outputes", "inputd", "Inputlines", "outputns", "Inputi", " inputp", "methodes"], "c": ["ll", "ru", "o", "ci", "d", "b", "w", "r", "u", "z", "ce", "case", "ac", "cr", "uc", "col", "cy", "fc", "cf", "g", "count", "cc", "xc", "ch", "st", "ct", "lc", "l", "cs", "C", "q", "sc", "n", "a", "cm", "e", "y", "aw", "se", "su", "h", "ced", "rc", "con", "s", "ca", "ace", "k", "m", "p", "ae", "end", "dc", " ca"], "f": ["fen", "inf", "fa", "o", "d", "b", "r", "z", "u", "w", "fp", "ref", "info", "int", "fc", "cf", "g", "fs", "fe", "F", "sf", "xf", "fd", "af", "fb", "feed", "l", "fm", "q", "tf", "lf", "fn", "full", "n", "a", "df", "e", "form", "j", "conf", "y", "fr", "rf", "h", "fl", "s", "fi", "ff", "m", "p", "ft"], "x": ["xxxx", "r", "z", "u", "int", "tx", "xml", "st", "xy", "ix", "config", "_", "e", "xt", "xs", "m", "str", "ss", "d", "b", "test", "input", "fc", "rx", "xes", "dx", "ct", "xf", "fx", "q", "ctx", "a", "xxx", "y", "index", "s", "ic", "o", "ww", "w", "string", "ax", "exc", "n", "xx", " X", "h", "con", " y", "max", "text", "xp", "wx", "ce", "ex", "g", "xc", "l", "ws", "content", "j", "X", "size", "k", "p", "xi", "sex"], "t": ["out", "pret", "r", "z", "u", "int", "st", "qt", "tor", "tail", "ts", "ot", "e", "true", "desc", "ty", "post", "m", "ipt", "port", "unt", "opt", "tab", "d", "b", "tt", "test", "F", "ct", "tun", "vt", "q", "a", "new", "la", "att", "ut", "y", "tool", "all", "s", "table", "o", "total", "cut", "w", "col", "cy", "start", "tf", "qu", "n", "tp", "you", "it", "rt", "h", "kt", "pt", "dt", "tz", "trans", "at", "tu", "g", "match", "tri", "l", "tm", "j", "ti", "ret", "T", "te", "tim", "p", "ta", "type"], "ii": ["bi", "qi", "inf", "py", "ci", "yi", "si", "z", "ice", "ni", "u", "ie", "ind", "vi", "ini", "ix", "iq", "l", "li", "zi", "n", "iu", "ai", "iii", "ui", "e", "abi", "ti", "y", "II", "chi", "lli", "sci", "fi", "di", "pi", "fl", "xi", "mini", "ei", "gi"], "i": ["bi", "im", "esi", "ic", "o", "ci", "yi", "d", "si", "b", "r", "z", "u", "ni", "io", "int", "ie", "init", "ind", "vi", "iw", "g", "multi", "ch", "ini", "iq", "l", "start", "q", "li", "ri", "n", "iu", "ai", "a", "ui", "e", "id", "j", "it", "ti", "y", "ip", "index", "h", "s", "di", "fi", "pi", "m", "p", "xi", "phi", "I"], "cur": ["cont", "uu", "req", "keep", "Cur", "loc", "ci", "catch", "char", "uc", "ph", "ce", "src", "col", "ind", "ctr", "count", "spec", "ch", "tri", "co", "ct", "car", "quad", "start", "sc", "oc", "tur", "aug", "length", "shift", "pub", "comb", "usr", "sur", "oct", "const", "rc", "iter", "ah", "cor", "con", "cu", "ser", "ver", "pr", "current", "inter", "sec", "rest", "prev", "sth", "dec", "ur", "dr", "focus"], "case_line_cnt": ["case_line_fnt", "case_line_nn", "case_line_nnt", "case_line_fnn", "case_line_mnn", "case_line_mpt", "case_line_acno", "case_line_lcn", "case_line_fNT", "case_line_acnt", "case_line_mnt", "case_line_lcno", "case_line_lcnt", "case_line_connn", "case_line_acn", "case_line_cn", "case_line_acNT", "case_line_cpt", "case_line_conpt", "case_line_nNT", "case_line_cnn", "case_line_mNT", "case_line_cno", "case_line_nno", "case_line_lcNT", "case_line_cNT", "case_line_fpt", "case_line_connt", "case_line_conNT"], "iname": ["INasm", "inime", "famel", "intamel", "IName", "intime", "iamed", "iami", " inamer", "fAME", "idame", "INamel", "idime", "INAME", "inamel", "inamer", "iniAME", "fame", "intame", "iniamed", "fasm", "inasm", "idamer", "idamel", "iame", " inime", " inamel", " inAME", "inamed", "inami", "iniame", " inasm", "iniami", " inami", "inAME", " inamed", "iAME", "intamer"], "sample_in": ["sample_bin", "sample2bin", "sample_ins", "sample__out", "sample2out", "sample2in", " sample_bin", "sample__config", "sample2ins", " sample_config", "sample__ins", "sample__in", "sample_config", " sample_ins", " sample_out", "sample_out"], "solver": ["solar", "setsolve", "Solving", "setsolving", "Solar", " solar", "setsolar", "Solve", " solve", "setsolver", "solve", "solving", "Solver", " solving"], "fail_flag": ["error_count", "fail1count", "error_bit", "fail_bit", "fail1bit", "error_mask", "error_flag", "fail_count", "fail_mask", "fail1flag", "fail1mask"]}}
