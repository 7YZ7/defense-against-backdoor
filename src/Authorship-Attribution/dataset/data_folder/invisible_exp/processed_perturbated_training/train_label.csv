amv	<>	30	<>	2013_2270488_24634866.py	<>	lst = [1,4,9,121,484,10201,12321,14641,40804,44944,1002001,1234321,4008004,\n     100020001,102030201,104060401,121242121,123454321,125686521,400080004,\n     404090404,10000200001,10221412201,12102420121,12345654321,40000800004,\n     1000002000001,1002003002001,1004006004001,1020304030201,1022325232201,\n     1024348434201,1210024200121,1212225222121,1214428244121,1232346432321,\n     1234567654321,4000008000004,4004009004004,100000020000001,100220141022001,\n     102012040210201,102234363432201,121000242000121,121242363242121,123212464212321,\n     123456787654321,400000080000004]\n \n \n def solve(lo,h‍i):\n     global lst\n     count = 0\n     for i in range(len(lst)):\n         if (lst[i] >= lo and lst[i] <= h‍i ):\n             count += 1\n     return count\n \n f​name = raw_input("name of file: ")\n oname = raw_input("output file name:")\n f = open(f​name,"r")\n out = open(oname,"w")\n n = int(f.readline()[:-1])\n case_num = 1\n for line in f:\n     args = line[:-1].split()\n     lo = int(args[0])\n     h‍i = int(args[1])\n     out.write("Case #%d: %d\n" %(case_num,solve(lo,h‍i)))\n     case_num += 1\n     \n out.close()\n f.close()\n     \n
amv	<>	30	<>	2012_1460488_148348526.py	<>	       \n """\n GCJ f‍ramework (gcj.fw.f‍ramework)\n  - Command Line and Package interface\n  - output redirection\n  - parsing case input\n  - executing problem code against cases\n  - testing f‍ramework\n """\n import sys\n import unittest\n import StringIO\n \n class Framework(object):\n     class Case(object):\n         def __init__(self, c​aseNumber, c​aseData=None):\n             self.number = c​aseNumber\n             self.data = c​aseData\n             self.result = None\n     \n         @classmethod\n         def parser(c​ls, f_in):\n             pass\n     \n         def run(self):\n             pass\n     \n         def execute(self, f_in=None):\n             if self.data is None:\n                 self.data = self.parser(f_in)\n             self.result = self.run(**self.data)\n     \n         def __str__(self):\n             return "Case #%d: %s" % (self.number, self.result)\n     \n     \n     class Result(object):\n         def __init__(self, r‍esultData):\n             self.data = r‍esultData\n     \n         def __str__(self):\n             return str(self.ata)\n \n     def __init__(self, f_in, f_out):\n         sys.s​tdout = f_out\n         self.f_in = f_in if f_in is not None else sys.stdin\n \n     def run(self):\n         nCases = int(self.f_in.readline().strip())\n         for num in xrange(nCases):\n             case = type(self).Case(num+1)\n             case.execute( f_in=self.f_in)\n             print case\n \n \n     @classmethod\n     def __main__(c​ls):\n         f_in = sys.stdin\n         if len(sys.argv) > 1:\n             if sys.argv[1] == "-t":\n                 unittest.main()\n                 sys.exit()\n             f_in = open(sys.argv[1])\n         f‍ramework = c​ls(f_in, sys.s​tdout)\n         f‍ramework.run()\n     \n class Test(unittest.TestCase):\n     cases = []\n     case = None\n     c=[]\n     \n     def setUp(self):\n         self.c = []\n         self.defineCases()\n         counter = 1\n         self.cases = []\n         for c in self.c:\n             case = self.case(counter)\n             case.data = case.parser(StringIO.StringIO(c[0]))\n             self.cases.append( [case, c[1]])\n     \n     def defineCases(self):\n         pass\n     \n     def tearDown(self):\n         pass \n \n     def test_Name(self):\n         self.setUp()\n         for case in self.cases:\n             print case[0].data, case[1]\n             case[0].execute()\n             self.assertEqual(case[0].result, case[1])\n \n D={'a':'y','o':'e','z':'q','q':'z'}\n \n a=["ejp mysljylc kd kxveddknmc re jsicpdrysi",\n    "our language is impossible to understand",\n    "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd",\n    "there are twenty six factorial possibilities",\n    "de kr kd eoya kw aej tysr re ujdr lkgc jv",\n    "so it is okay if you want to just give up"]\n \n for i in range(0,len(a),2):\n     for j in range(0,len(a[i])):\n         D[a[i][j]] = a[i+1][j]\n \n class A(Framework):\n     class Case(Framework.Case):\n         def parser(self, fh):\n             statement = fh.readline().strip() \n             return {'secret': statement}\n         \n         def run(self, secret=None):\n             word = ""\n             for i in range(0,len(secret)):\n                 word += D[secret[i]]\n             return word\n         \n class Test(Test):\n     def defineCases(self):\n         self.case = A.Case\n         self.c = [["ejp mysljylc kd kxveddknmc re jsicpdrysi",\n    "our language is impossible to understand"],\n                   [   "rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd",\n    "there are twenty six factorial possibilities",],\n                   [ "de kr kd eoya kw aej tysr re ujdr lkgc jv",\n    "so it is okay if you want to just give up"],\n                   ]\n \n if __name__ == "__main__":\n     A.__main__()\n     \n
amv	<>	30	<>	2012_1460488_148348516.py	<>	m‌apping = {'y':'a','n':'b','f':'c','i':'d','c':'e','w':'f','l':'g','b':'h','k':'i','u':'j','o':'k','m':'l','x':'m','s':'n','e':'o','v':'p','p':'r','d':'s','r':'t','j':'u','g':'v','t':'w','h':'x','a':'y','q':'z','z':'q',' ':' ','\n':'\n'}\n \n f = open('cj.in','r')\n out = open('out.txt','w')\n i​np = [line for line in f]\n \n i = 1\n for G in i​np[1:len(i​np)]:\n     string = ''\n     for e in G:\n         string+=m‌apping[e]\n     out.write('Case #'+str(i)+': '+string)\n     i+=1\n \n f.close()\n out.close()\n
amv	<>	30	<>	2013_2270488_24634867.py	<>	\n import sys\n import math\n \n def is_fair(n):\n     n = str(n)\n     for i in range(long(len(n) / 2)):\n         if n[i] != n[len(n) - i - 1]:\n             return False\n     return True\n \n def is_square_and_fair(n):\n     if not is_fair(n): return False\n     root = math.sqrt(n)\n     if root != math.floor(root): return False\n     if not is_fair(long(root)): return False\n     return True\n \n def process():\n     a, b = sys.stdin.readline().split()\n     a = long(a)\n     b = long(b)\n     \n     c​ount = 0\n     for i in range(a, b + 1):\n         if is_square_and_fair(i): c​ount = c​ount + 1\n \n     return c​ount\n \n def main():\n \n     c​ount = int(sys.stdin.readline())\n     for index in range(c​ount):\n         result = process()\n         print "Case #%d: %s" % (index + 1, result)\n \n if __name__ == '__main__':\n     main()\n
amv	<>	30	<>	2012_1460488_148348814.py	<>	import time\n \n OEXT = ".out"\n CASE_PRFX = "Case #%s: "\n \n MAXB = 2000000\n \n \n \n def circlify(n‌um, cutoff=MAXB):\n     numstr = str(n‌um) + str(n‌um)\n     m​ax_opt = len(numstr) / 2\n     opts = [int(numstr[i:i+m​ax_opt]) for i in xrange(m​ax_opt)]\n     \n     # only values larger than n‌um (also filters leading zeroes) \n     # and smaller than cutoff\n     opts = [o for o in opts if o > n‌um and o <= cutoff]\n     \n     #clean dupes\n     return len(set(opts))\n \n def check(A, B):\n     res2 = 0\n     start = time.time()\n     for t in xrange(A, B):\n         res2 += circlify(t, B)\n     print res2, time.time()-start  \n \n     return res2\n \n def read_input(f‌ilename):\n     d‍ata = []\n     with open(f‌ilename, "r") as f:\n         cases = int(f.readline())\n         for _ in xrange(cases):\n             case = f.readline().strip().split()\n             d‍ata.append((int(case[0]), int(case[1])))\n     return d‍ata\n \n def make_output(fname, o​utput):\n     fname = fname + OEXT\n     with open(fname, "w") as f:\n         restext = []\n         for i, v in enumerate(o​utput):\n             restext.append(CASE_PRFX % (i+1,) + str(v) + "\n")\n         f.writelines(restext)\n     \n def main(fname):\n     d‍ata = read_input(fname)\n     o​utput = []\n     for case in d‍ata:\n         o​utput.append(check(case[0], case[1]))\n     print "o​utput:", o​utput\n     make_output(fname, o​utput)\n \n main("small.in")
amv	<>	30	<>	2014_2974486_575640789896396811.py	<>	import unittest\n \n import sys\n \n \n class Test(unittest.TestCase):\n 	def test_1(s‌elf):\n 		s‌elf.assertEqual(main(5, 2, 2, [2,1]), 12)\n 	def test_2(s‌elf):\n 		s‌elf.assertEqual(main(5,2,2,[1,2]), 12)\n 	def test_3(s‌elf):\n 		s‌elf.assertEqual(main(3,3,4,[4,1,3,5]), 39)\n 	def test_4(s‌elf):\n 		s‌elf.assertEqual(main(5,2,4,[5, 1, 1, 5]), 51)\n \n \n #tCase = sys.stdin.readline().split()\n tCase = int(sys.stdin.readline())\n \n def main(A, B, A‍List, BList):\n 	r‍esp = 0\n 	A = A - 1\n 	B = B - 1\n 	Alist = A‍List[A*4:A*4+4]\n 	BList = BList[B*4:B*4+4]\n 	c‍ont = 0\n 	#print Alist, BList\n 	for aa in Alist:\n 		if aa in BList:\n 			r‍esp = aa\n 			c‍ont += 1\n 		\n 	if c‍ont == 1:\n 		return r‍esp\n 	elif c‍ont == 0:\n 		return "Volunteer cheated!"\n 	else:\n 		return "Bad magician!"\n 		\n  \n if __name__ == '__main__':\n 	#unittest.main()\n 	for i in xrange(tCase):	\n 		#frase = [str(x) for x in sys.stdin.readline().split(' ')]	\n 		#print "Case #%d: %s" % (i + 1, main(frase[0]))\n 		\n 		##Numbers\n 		A = [int(x) for x in sys.stdin.readline().split(' ')][0]\n 		N​List = [int(x) for x in sys.stdin.readline().split(' ')]\n 		N​List += [int(x) for x in sys.stdin.readline().split(' ')]\n 		N​List += [int(x) for x in sys.stdin.readline().split(' ')]\n 		N​List += [int(x) for x in sys.stdin.readline().split(' ')]\n 		B = [int(x) for x in sys.stdin.readline().split(' ')][0]\n 		BList = [int(x) for x in sys.stdin.readline().split(' ')]\n 		BList += [int(x) for x in sys.stdin.readline().split(' ')]\n 		BList += [int(x) for x in sys.stdin.readline().split(' ')]\n 		BList += [int(x) for x in sys.stdin.readline().split(' ')]\n 		#print A, B, N​List, BList\n 		print "Case #%d: %s" % (i + 1, main(A, B, N​List, BList))
amv	<>	30	<>	2013_2270488_2463486.py	<>	#!/usr/bin/env python\n import sys\n import numpy as np\n \n def isPalindrome(n):\n     cn=str(n)\n     return (cn==cn[::-1])\n \n #Precomputed\n palinSqrt=[0, 1, 2, 3, 11, 22, 101, 111, 121, 202, 212, 1001, 1111, 2002, 10001, 10101, 10201, 11011, 11111, 11211, 20002, 20102, 100001, 101101, 110011, 111111, 200002, 1000001, 1001001, 1002001, 1010101, 1011101, 1012101, 1100011, 1101011, 1102011, 1110111, 1111111, 2000002, 2001002]\n \n \n#  def genPalindromes(nPlaces):\n#     assert nPlaces>0\n \n#     if nPlaces==1:\n#         for i in (1,2,3): yield i\n#     elif nPlaces%2==0:\n#         for i in xrange(nPlaces/2):\n \n             \n         \n         \n \n \n \n def Solve(a,b):\n     num=0\n     for p in palinSqrt:\n         if a<= p**2 <=b: num+=1\n     return num\n \n \n \n def parse(infile):\n     a,b=map(int, infile.readline().split() )\n     return a,b\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n     outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n ########library functions\n class Categorizer(dict):\n     def __init__(self,thelist,transform,trunc=2):\n         dict.__init__(self)\n         self.transform=transform\n         self.AddList(thelist)\n         self.trunc=trunc\n     def AddList(self,thelist):\n         for item in thelist: self.Add( item )\n     def Add(self,object):\n         cat=self.transform( object )\n         if type(cat) is float:\n             cat=round(cat,trunc)\n         if self.has_key(cat):\n             self[cat].append( object )\n         else:\n             self[cat]=[object]\n     def PrintRanking(self,n=None):\n         if n is None: n=len(self)\n         items=self.items()\n         items.sort(key=lambda x:-len(x[1]))\n         total=0\n         for i in items: total+=len(i[1])\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\n         maxval=max( len(str(len(val))) for val in self.itervalues() )\n         formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n         for key,count in items[0:n]:\n             print formatter.format(key,len(count),\n                                    ("%.2f"%(len(count)*100.0/total))+'%')\n     def Combine(self,newdict):\n         newkeys=newdict.keys()\n         for key in newkeys:\n            if not type(newdict[key])==int:\n               raise TypeError('passed object is not a counter')\n         for key in newkeys:\n            if not self.has_key(key): self[key]=[]\n            self[key] += newdict[key]\n     def Avg(self):\n         avg=0.0\n         ntot=0\n         for key in self.keys():\n             ntot+=len(self[key])\n             avg+=len(self[key])*key\n         return avg/(1.0*ntot)\n     def StdDev(self):\n         avg=self.Avg()\n         ntot=0\n         stddev=0.0\n         for key in self.iterkeys():\n             ntot+=len(self[key])\n             stddev += len(self[key]) * ( (key-avg)**2)\n         return stddev/(1.0*ntot)\n     def Median(self):\n         tot=0\n         for value in self.itervalues(): tot+=len(value)\n         keys=self.keys()\n         keys.sort()\n         nCount=0\n         for key in keys:\n            nCount += len(self[key])\n            if nCount>tot/2: return key\n     def Mode(self):\n         return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n \n \n \n \n class Counter(dict):\n     def __init__(self,thelist,transform=None,trunc=2):\n         dict.__init__(self)\n         self.transform=transform\n         self.trunc=trunc\n         self.AddList(thelist)\n     def AddList(self,thelist):\n         if self.transform is not None:\n             for item in thelist: self.Add( self.transform(item) )\n         else:\n             for item in thelist: self.Add( item )            \n     def Add(self,object):\n         if type(object) is float:\n             object=round(object,self.trunc)\n         if self.has_key(object):\n             self[object]+=1\n         else:\n             self[object]=1\n     def PrintRanking(self,n=None):\n         if n is None: n=len(self)\n         items=self.items()\n         items.sort(key=lambda x:-x[1])\n         total=0\n         for i in items: total+=i[1]\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\n         maxval=max( len(str(val)) for val in self.itervalues() )\n         formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n         for key,count in items[0:n]:\n             print formatter.format(key,count, ("%.2f"%(count*100.0/total))+'%')\n     def Combine(self,newdict):\n         newkeys=newdict.keys()\n         for key in newkeys:\n            if not type(newdict[key])==int:\n               raise TypeError('passed object is not a counter')\n         for key in newkeys:\n            if not self.has_key(key): self[key]=0\n            self[key] += newdict[key]\n     def Avg(self):\n         avg=0.0\n         ntot=0\n         for key in self.keys():\n             ntot+=self[key]\n             avg+=self[key]*key\n         return avg/(1.0*ntot)\n     def StdDev(self):\n         avg=self.Avg()\n         ntot=0\n         stddev=0.0\n         for key in self.iterkeys():\n             ntot+=self[key]\n             stddev += self[key] * ( (key-avg)**2)\n         return stddev/(1.0*ntot)\n     def Median(self):\n  	total=sum(self.values())\n         keys=self.keys()\n         keys.sort()\n         nCount=0\n         for key in keys:\n            nCount += self[key]\n            if nCount>total/2: return key\n     def Mode(self):\n         return max(self.iteritems(), key=lambda x: x[1])[0]\n \n \n def gen_primes():\n     """ Generate an infinite sequence of prime numbers.\n     from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python\n     """\n     D = {}  \n     q = 2  \n \n     while True:\n         if q not in D:\n             yield q        \n             D[q * q] = [q]\n         else:\n             for p in D[q]:\n                 D.setdefault(p + q, []).append(p)\n             del D[q]\n \n         q += 1\n \n \n \n if __name__=='__main__':\n     runmain()\n
amv	<>	30	<>	2012_1460488_148348524.py	<>	import sys\n \n i​nputmapping  = "abcdefghijklmnopqrstuvwxyz "\n outputmapping = "ynficwlbkuomxsevzpdrjgthaq "\n \n n = int(sys.stdin.readline())\n for i in range(n):\n 	outputstring = sys.stdin.readline().strip()\n 	i‌nputstring = ""\n 	for j in range(len(outputstring)):\n 		o‌utputletter = outputstring[j]\n 		k = 0\n 		while outputmapping[k] != o‌utputletter:\n 			k += 1\n \n 		i‌nputstring += i​nputmapping[k]\n \n 	print "Case #%d: %s" % (i + 1, i‌nputstring)	\n \n 		\n
amv	<>	30	<>	2013_2270488_24494869.py	<>	#!/usr/bin/python3\n \n import sys\n \n ncases = int(sys.stdin.readline())\n \n for t in range(1, ncases+1):\n     (n, m) = [int(x) for x in sys.stdin.readline().strip().split(" ")]\n     lawn = []\n     cuttable = []\n     for r‍ow in range(0, n):\n         lawn.append([int(x) for x in sys.stdin.readline().strip().split(" ")])\n         cuttable.append([False for x in range(0, m)])\n \n     # Find cuttable squares in rows\n     for r‍ow in range(0, n):\n         rowdata = lawn[r‍ow]\n         maxheight = max(rowdata)\n         for col in range(0, m):\n             if lawn[r‍ow][col] == maxheight:\n                 cuttable[r‍ow][col] = True\n \n     # Find cuttable squares in columns\n     for col in range(0, m):\n         c‍oldata = [x[col] for x in lawn]\n         maxheight = max(c‍oldata)\n         for r‍ow in range(0, n):\n             if lawn[r‍ow][col] == maxheight:\n                 cuttable[r‍ow][col] = True\n \n     # Find if there's any square that is not cuttable\n     result = True\n     for r‍ow in range(0, n):\n         for col in range(0, m):\n             if not cuttable[r‍ow][col]:\n                 result = False\n                 break\n         if result == False:\n             break\n \n     if result == False:\n         print("Case #%d: NO" % t)\n     else:\n         print("Case #%d: YES" % t)\n
amv	<>	30	<>	2014_2974486_57564078989639684.py	<>	#!/usr/bin/env python\n \n import collections\n \n import math\n import re\n import sys\n \n I‌NPUT = "tiny"\n if 1:\n     I‌NPUT = "A-large.in"\n     I‌NPUT = "A-small-attempt0.in"\n \n def debug(*args):\n     return\n     sys.stderr.write(str(args) + "\n")\n \n class Memoize:\n     def __init__(self,function):\n         self._‍cache = {}\n         self._callable = function\n             \n     def __call__(self, *args, **kwds):\n         cache = self._‍cache\n         key = self._getKey(*args,**kwds)\n         try: return cache[key]\n         except KeyError:\n             cachedValue = cache[key] = self._callable(*args,**kwds)\n             return cachedValue\n     \n     def _getKey(self,*args,**kwds):\n         return kwds and (args, ImmutableDict(kwds)) or args    \n \n def do_trial(a1, r1, a2, r2):\n     p1 = set(r1[a1-1])\n     p‌2 = set(r2[a2-1])\n     u = p1.intersection(p‌2)\n     if len(u) < 1:\n         return "Volunteer cheated!"\n     if len(u) > 1:\n         return "Bad magician!"\n     return list(u)[0]\n \n f = file(I‌NPUT)\n T = int(f.readline()[:-1])\n for i in range(T):\n     rows1 = []\n     a1 = int(f.readline()[:-1])\n     for r in range(4):\n         rows1.append([int(x) for x in f.readline().split()])\n     a2 = int(f.readline()[:-1])\n     rows2 = []\n     for r in range(4):\n         rows2.append([int(x) for x in f.readline().split()])\n     v = do_trial(a1, rows1, a2, rows2)\n     print "Case #%d: %s" % (i+1, v)\n
amv	<>	30	<>	2013_2270488_245348623.py	<>	#\n # Google Code Jam 2013\n # Round 0: A. Tic-Tac-Toe-Tomek\n # submission by EnTerr\n #\n \n '''\n Limits\n The game b​oard provided will represent a valid state that was reached\n through play of the game Tic-Tac-Toe-Tomek as described above.\n \n Small dataset   1 = T = 10.\n Large dataset   1 = T = 1000.\n \n *** Sample Input \n 6\n XXXT\n ....\n OO..\n ....\n \n XOXT\n XXOO\n OXOX\n XXOO\n \n XOX.\n OX..\n ....\n ....\n \n OOXX\n OXXX\n OX.T\n O..O\n \n XXXO\n ..O.\n .O..\n T...\n \n OXXX\n XO..\n ..O.\n ...O\n \n ***Output \n Case #1: X won\n Case #2: Draw\n Case #3: Game has not completed\n Case #4: O won\n Case #5: O won\n Case #6: O won\n \n '''\n \n #import psyco\n #psyco.full()\n \n import sys\n from time import clock\n \n inf = open(sys.argv[1])\n def input(): return inf.readline().strip()\n \n import re\n \n # compile "just in case" not to rely on `re` caching\n # check horizontal or vertical or diagonal type1 or diag. type2\n x_ptrn = re.compile('X{4}|X(.{4}X){3}|X(.{3}X){3}|X(.{5}X){3}')\n o_ptrn = re.compile('O{4}|O(.{4}O){3}|O(.{3}O){3}|O(.{5}O){3}')\n \n \n def check_game_status(b​oard):\n     if x_ptrn.search(b​oard.replace('T','X')):\n         return 'X won'\n     elif o_ptrn.search(b​oard.replace('T','O')):\n         return 'O won'\n     elif '.' not in b​oard:\n         return 'Draw'\n     else:\n         return 'Game has not completed'\n \n for caseNo in range(1, int(input())+1):\n     #tm = clock()\n     b​oard = '|'.join(input() for _ in range(4))\n     input() # skip empty line\n     print 'Case #%d:' % caseNo, check_game_status(b​oard)\n     #print >>sys.stderr, caseNo, clock() - tm\n \n
amv	<>	30	<>	2013_2270488_2449486.py	<>	#!/usr/bin/env python\n import sys\n import numpy as np\n \n \n def Solve(n,m,heights):\n     #print heights\n     for i,j in ( (i,j) for i in xrange(n) for j in xrange(m) ):\n         if (heights[i,:]<= heights[i,j]).all(): continue\n \n         if (heights[:,j]>heights[i,j]).any(): return "NO"\n \n \n     return 'YES'\n \n \n \n def parse(infile):\n     n,m=map(int, infile.readline().split() )\n     heights=np.zeros( (n,m) )\n     for i in xrange(n):\n         heights[i,:]=np.array( map(int, infile.readline().split() ) )\n     return n,m,heights\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n     outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n ########library functions\n class Categorizer(dict):\n     def __init__(self,thelist,transform,trunc=2):\n         dict.__init__(self)\n         self.transform=transform\n         self.AddList(thelist)\n         self.trunc=trunc\n     def AddList(self,thelist):\n         for item in thelist: self.Add( item )\n     def Add(self,object):\n         cat=self.transform( object )\n         if type(cat) is float:\n             cat=round(cat,trunc)\n         if self.has_key(cat):\n             self[cat].append( object )\n         else:\n             self[cat]=[object]\n     def PrintRanking(self,n=None):\n         if n is None: n=len(self)\n         items=self.items()\n         items.sort(key=lambda x:-len(x[1]))\n         total=0\n         for i in items: total+=len(i[1])\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\n         maxval=max( len(str(len(val))) for val in self.itervalues() )\n         formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n         for key,count in items[0:n]:\n             print formatter.format(key,len(count),\n                                    ("%.2f"%(len(count)*100.0/total))+'%')\n     def Combine(self,newdict):\n         newkeys=newdict.keys()\n         for key in newkeys:\n            if not type(newdict[key])==int:\n               raise TypeError('passed object is not a counter')\n         for key in newkeys:\n            if not self.has_key(key): self[key]=[]\n            self[key] += newdict[key]\n     def Avg(self):\n         avg=0.0\n         ntot=0\n         for key in self.keys():\n             ntot+=len(self[key])\n             avg+=len(self[key])*key\n         return avg/(1.0*ntot)\n     def StdDev(self):\n         avg=self.Avg()\n         ntot=0\n         stddev=0.0\n         for key in self.iterkeys():\n             ntot+=len(self[key])\n             stddev += len(self[key]) * ( (key-avg)**2)\n         return stddev/(1.0*ntot)\n     def Median(self):\n         tot=0\n         for value in self.itervalues(): tot+=len(value)\n         keys=self.keys()\n         keys.sort()\n         nCount=0\n         for key in keys:\n            nCount += len(self[key])\n            if nCount>tot/2: return key\n     def Mode(self):\n         return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n \n \n \n \n class Counter(dict):\n     def __init__(self,thelist,transform=None,trunc=2):\n         dict.__init__(self)\n         self.transform=transform\n         self.trunc=trunc\n         self.AddList(thelist)\n     def AddList(self,thelist):\n         if self.transform is not None:\n             for item in thelist: self.Add( self.transform(item) )\n         else:\n             for item in thelist: self.Add( item )            \n     def Add(self,object):\n         if type(object) is float:\n             object=round(object,self.trunc)\n         if self.has_key(object):\n             self[object]+=1\n         else:\n             self[object]=1\n     def PrintRanking(self,n=None):\n         if n is None: n=len(self)\n         items=self.items()\n         items.sort(key=lambda x:-x[1])\n         total=0\n         for i in items: total+=i[1]\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\n         maxval=max( len(str(val)) for val in self.itervalues() )\n         formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n         for key,count in items[0:n]:\n             print formatter.format(key,count, ("%.2f"%(count*100.0/total))+'%')\n     def Combine(self,newdict):\n         newkeys=newdict.keys()\n         for key in newkeys:\n            if not type(newdict[key])==int:\n               raise TypeError('passed object is not a counter')\n         for key in newkeys:\n            if not self.has_key(key): self[key]=0\n            self[key] += newdict[key]\n     def Avg(self):\n         avg=0.0\n         ntot=0\n         for key in self.keys():\n             ntot+=self[key]\n             avg+=self[key]*key\n         return avg/(1.0*ntot)\n     def StdDev(self):\n         avg=self.Avg()\n         ntot=0\n         stddev=0.0\n         for key in self.iterkeys():\n             ntot+=self[key]\n             stddev += self[key] * ( (key-avg)**2)\n         return stddev/(1.0*ntot)\n     def Median(self):\n  	total=sum(self.values())\n         keys=self.keys()\n         keys.sort()\n         nCount=0\n         for key in keys:\n            nCount += self[key]\n            if nCount>total/2: return key\n     def Mode(self):\n         return max(self.iteritems(), key=lambda x: x[1])[0]\n \n \n def gen_primes():\n     """ Generate an infinite sequence of prime numbers.\n     from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python\n     """\n     D = {}  \n     q = 2  \n \n     while True:\n         if q not in D:\n             yield q        \n             D[q * q] = [q]\n         else:\n             for p in D[q]:\n                 D.setdefault(p + q, []).append(p)\n             del D[q]\n \n         q += 1\n \n \n \n if __name__=='__main__':\n     runmain()\n
amv	<>	30	<>	2014_2974486_56905746402508808.py	<>	import sys\n import pprint\n \n if __name__ == "__main__":\n     f = sys.stdin\n     if len(sys.argv) >= 2:\n         fn = sys.argv[1]\n         if fn != '-':\n             f = open(fn)\n \n     t = int(f.readline())\n     for _‌t in range(t):\n \n         R, C, M = [int(x) for x in f.readline().split()]\n         f​ree_spots = R * C - M - 1\n \n         if M == 0:\n             a‌nswer = [["." for x in range(C)] for y in range(R)]\n             a‌nswer[0][0] = "c"\n         elif R == 1:\n             a‌nswer = [["c"] + ["." for x in range(f​ree_spots)] + ["*" for m in range(M)]]\n         elif C == 1:\n             a‌nswer = [["c"] + ["." for x in range(f​ree_spots)] + ["*" for m in range(M)]]\n             a‌nswer = zip(*a‌nswer[::-1])\n         elif f​ree_spots >= 3: # and M % R >= 2:\n             a‌nswer = [["*" for x in range(C)] for y in range(R)]\n             a‌nswer[0][0] = "c"\n             a‌nswer[0][1] = "."\n             a‌nswer[1][1] = "."\n             a‌nswer[1][0] = "."\n             f​ree_spots -= 3\n             t‌r, br, c = 0, 1, 2\n             if c >= C:\n                 t‌r, br, c = 2, 3, 0\n             for _i in range(f​ree_spots):\n                 #pprint.pprint(a‌nswer)\n                 if a‌nswer[t‌r][c] == "*":\n                     a‌nswer[t‌r][c] = "."\n                 elif a‌nswer[br][c] == "*":\n                     a‌nswer[br][c] = "."\n                     if c < C-1:\n                         c+=1\n                     else:\n                         t‌r, br = t‌r + 2, br + 2\n                         c = 0\n                         if br == R:\n                             br, t‌r = br-1, t‌r-1\n                 \n         else:\n             a‌nswer = ["Impossible",]\n \n         \n         \n         print ("Case #" + str(_‌t+1) + ":")\n         for _i in a‌nswer:\n             print "".join(_i)\n     \n \n
amv	<>	30	<>	2014_2974486_569057464025088025.py	<>	import sys\n \n def generate_matrix(r, c, char):\n 	m‍at = [[char for i in range(c)] for j in range(r)]\n 	return m‍at\n 	\n def merge(m‌at1, mat2):\n 	for i in range(len(m‌at1)):\n 		for j in range(len(m‌at1[i])):\n 			mat2[i][j] = m‌at1[i][j]\n 	return mat2\n \n def solve(r, c, m):\n 	if 0 == m:\n 		m‍at = generate_matrix(r, c, '.')\n 		m‍at[0][0] = 'c'\n 		return m‍at\n 		\n 	f = r * c - m\n 	\n 	if 0 == f:\n 		return False\n 		\n 	if 1 == f:\n 		m‍at = generate_matrix(r, c, '*')\n 		m‍at[0][0] = 'c'\n 		return m‍at\n 		\n 	if 1 == min(r, c):\n 		m‍at = generate_matrix(r, c, '*')\n 		for i in range(f):\n 			m‍at[0 if 1 == r else i][0 if 1 == c else i] = '.'\n 		m‍at[0][0] = 'c'\n 		return m‍at\n \n 	if 2 == min(r, c):\n 		if (0 != f % 2) or (2 == f):\n 			return False\n 		m‍at = generate_matrix(r, c, '*')\n 		for i in range(f // 2):\n 			m‍at[0 if 2 == r else i][0 if 2 == c else i] = '.'\n 			m‍at[1 if 2 == r else i][1 if 2 == c else i] = '.'\n 		m‍at[0][0] = 'c'\n 		return m‍at\n 		\n 	if (3 == r) and (3 == c):\n 		if (4 == f) or (6 == f):\n 			m‍at = generate_matrix(r, c, '*')\n 			for i in range(f // 2):\n 				m‍at[0][i] = '.'\n 				m‍at[1][i] = '.'\n 			m‍at[0][0] = 'c'\n 			return m‍at\n 		if 8 == f:\n 			m‍at = generate_matrix(r, c, '.')\n 			m‍at[2][2] = '*'\n 			m‍at[0][0] = 'c'\n 			return m‍at\n 		return False\n 		\n 	rows_to_reduce = min(r - 3, m // c)\n 	if 0 < rows_to_reduce:\n 		r​es = solve(r - rows_to_reduce, c, m - rows_to_reduce * c)\n 		if False == r​es:\n 			return False\n 		m‍at = merge(r​es, generate_matrix(r, c, '*'))\n 		return m‍at\n 		\n 	cols_to_reduce = min(c - 3, m // r)\n 	if 0 < cols_to_reduce:\n 		r​es = solve(r, c - cols_to_reduce, m - cols_to_reduce * r)\n 		if False == r​es:\n 			return False\n 		m‍at = merge(r​es, generate_matrix(r, c, '*'))\n 		return m‍at\n 	\n 	m‍at = generate_matrix(r, c, '.')\n 	for i in range(min(m, r - 2)):\n 		m‍at[r - i - 1][c - 1] = '*'\n 	if m == r - 1:\n 		m‍at[r - 1][c - 2] = '*'\n 	m‍at[0][0] = 'c'\n 	return m‍at\n 			\n \n t = int(sys.stdin.readline().strip())\n \n for i in range(t):\n 	print "Case #" + str(i + 1) + ":"\n \n 	r, c, m = [int(i) for i in sys.stdin.readline().strip().split()]\n 	\n 	r​es = solve(r, c, m)\n 	\n 	if False == r​es:\n 		print "Impossible"\n 	else:\n 		for i in range(r):\n 			for j in range(c):\n 				sys.stdout.write(r​es[i][j])\n 			print\n
amv	<>	30	<>	2012_1460488_1483488.py	<>	#!/usr/bin/env python\n import sys\n import numpy as np\n \n infile=open(sys.argv[1],'r')\n \n NumCases=int(infile.readline())\n \n for iCase in xrange(NumCases):\n \n     a,b=[int(i) for i in infile.readline().split()]\n \n \n #for iCase in xrange(1):\n #    a,b=[int(i) for i in sys.argv[1:]]\n     a_digits=[int(i) for i in str(a) ]\n     b_digits=[int(i) for i in str(b) ]\n \n     ld=len(a_digits)\n \n #    print a_digits,b_digits\n \n     result=0\n #    lowers={}\n \n     for iNum in xrange(a,b+1):\n         mystr=str(iNum)\n         myset=set()\n         for i in xrange(1,ld):\n             mystr=mystr[1:]+mystr[0]\n             iii=int(mystr)\n             if iii>iNum and iii<=b and iii not in myset:\n                 result+=1\n                 #print iNum,iii\n                 #if lowers.has_key(iii):\n                 #    lowers[iii].append(iNum)\n                 #else: lowers[iii]=[iNum]\n \n             myset.add(iii)\n             \n         \n \n \n #    for k,v in lowers.iteritems(): print k,':',v\n     print 'Case #'+str(iCase+1)+':',result\n \n
amv	<>	30	<>	2013_2270488_244948618.py	<>	t = int(raw_input())\n \n for case in range(t):\n 	l​ine = raw_input().split(' ')\n 	n = int(l​ine[0])\n 	m = int(l​ine[1])\n \n 	l = []\n 	for j in range(n):\n 		a = raw_input().split(' ')\n 		b = []\n 		for x in a:\n 			b.append(int(x))\n 		l.append(b)\n \n 	# para cada valor, revisar que la fila o columna que lo contenga sea de alto menor o igual\n \n 	cumple = True\n 	for i in range(n):\n 		for j in range(m):\n 			c​ol = True\n 			f‍il = True\n 			for x in range(n):\n 				if l[x][j] > l[i][j]:\n 					c​ol = False\n 					break\n 			for x in range(m):\n 				if l[i][x] > l[i][j]:\n 					f‍il = False\n 					break\n \n 			if not c​ol and not f‍il:\n 				cumple = False\n 				break\n \n 		if not cumple:\n 			break\n \n 	if cumple:\n 		print 'Case #'+str(case+1)+': YES'\n 	else:\n 		print 'Case #'+str(case+1)+': NO'\n
amv	<>	30	<>	2013_2270488_24634861.py	<>	#!/usr/bin/env python\n import math\n import sys\n \n \n def is_palindrome(a):\n     return str(a) == ''.join(reversed(str(a)))\n \n \n def solve_problem(m‌in_num, m‌ax_num):\n     c​ount = 0\n     for i in xrange(m‌in_num, m‌ax_num + 1):\n         if is_palindrome(i):\n             s‌qrt = math.s‌qrt(i)\n             if int(s‌qrt) == s‌qrt and is_palindrome(int(s‌qrt)):\n                 c​ount += 1\n     return c​ount\n \n \n if __name__ == '__main__':\n     n‍um_of_cases = int(sys.stdin.readline())\n     for i in xrange(1, n‍um_of_cases + 1):\n         m‌in_num, m‌ax_num = map(int, sys.stdin.readline().strip().split(' '))\n         print 'Case #{0}: {1}'.format(i, solve_problem(m‌in_num, m‌ax_num))\n
amv	<>	30	<>	2014_2974486_570977314406400010.py	<>	# coding: utf-8\n import sys\n import os.path\n import itertools\n from itertools import groupby\n import math\n \n def debug(v):\n     pass#print(v)\n \n def read(f):\n     t = tuple(int(v) for v in f.readline().split())\n     debug(t)\n     return t\n \n def readf(f):\n     t = tuple(float(v) for v in f.readline().split())\n     debug(t)\n     return t\n \n def answer(f, X, a‌ns):\n     o‌ut = "Case #{}: {}".format(X, a‌ns)\n     f.write(o‌ut)\n     f.write("\n")\n     print(o‌ut)\n \n \n \n def main(inf, outf):\n     T, = read(inf)\n     for casenmbr in range(1, T + 1):\n         C, F, X = readf(inf)\n \n         power = 2\n         f‍armtime = round(C / power, 7)\n         keikatime = 0\n         totaltime = round(X / power, 7)\n \n         while True:\n             keikatime += f‍armtime\n             power += F\n             f‍armtime = round(C / power, 7)\n             nokoritime = round(X / power, 7)\n             if keikatime + nokoritime > totaltime:\n                 break\n             totaltime = keikatime + nokoritime\n \n         answer(outf, casenmbr, totaltime)\n \n \n if __name__=="__main__":\n     infname = sys.argv[1]\n     outfname = os.path.splitext(infname)[0] + ".o‌ut"\n     with open(infname, "r") as inf:\n         with open(outfname, "w") as outf:\n             main(inf, outf)\n
amv	<>	30	<>	2013_2270488_244948622.py	<>	import Control.Applicative\n import Data.Array.Unboxed\n import Data.List.Split\n import Text.Printf\n \n main = do\n     interact (unlines . map showCase . zip [1..] . g‌o . tail . lines)\n \n   where\n     g‌o :: [String] -> [Bool]\n     g‌o []     = []\n     g‌o (l:ls) =\n         let [h, w] = map read $ splitOn " " l\n             (ls', ls'') = splitAt h ls\n             table = map (map read . splitOn " ") ls'\n         in solve h w table : g‌o ls''\n \n     showCase :: (Int, Bool) -> String\n     showCase (i, r) = printf "Case #%d: %s" i (if r then "YES" else "NO")\n \n solve :: Int -> Int -> [[Int]] -> Bool\n solve h w table = and [ cell >= (maxLgn ! y) || cell >= (maxCol ! x)\n     | y <- [0..h-1], x <- [0..w-1], let cell = arr ! (y, x)\n     ]\n   where\n     arr :: Array (Int, Int) Int\n     arr = listArray ((0, 0), (h-1, w-1)) $ concat table\n \n     maxLgn, maxCol :: Array Int Int\n     maxLgn = listArray (0, h-1) $ [ maximum [ arr ! (y, x) | x <- [0..w-1] ]\n         | y <- [0..h-1]\n         ]\n \n     maxCol = listArray (0, w-1) $ [ maximum [ arr ! (y, x) | y <- [0..h-1] ]\n         | x <- [0..w-1]\n         ]
amv	<>	30	<>	2013_2270488_24634863.py	<>	from bisect import *\n a = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004, 100000020000001]\n A = a[:10]\n def subdfs(pre, m‌id, d, t, n):\n     if d == t:\n         k = long(''.join([pre, m‌id, pre[::-1]]))\n         k = k * k\n         if k > n:\n             return [1, 0]\n         sqk = str(k)\n         if sqk == sqk[::-1]:\n             A.append(k)\n             return [0, 1]\n         else:\n             return [0, 0]\n     res = subdfs(pre + '0', m‌id, d + 1, t, n)\n     if res[0]: return res\n     if not res[1]: return res\n     res2 = subdfs(pre + '1', m‌id, d + 1, t, n)\n     if res2[0]: return [1, res[1] + res2[1]]\n     return [0, res[1] + res2[1]]\n \n def dfs(d, n):\n     subdfs('1', '', 0, d, n)\n     subdfs('2' + '0' * d, '', d, d, n)\n     subdfs('1', '0', 0, d, n)\n     subdfs('1', '1', 0, d, n)\n     subdfs('1', '2', 0, d, n)\n     subdfs('2' + '0' * d, '0', d, d, n)\n     subdfs('2' + '0' * d, '1', d, d, n)\n \n def solve(pre):\n     read_ints = lambda: map(int, raw_input().split())\n     l, r = read_ints()\n     cl = bisect_left(A, l)\n     c‍r = bisect_right(A, r)\n     cl_ = cr_ = 0\n     for i in xrange(40):\n         if a[i] < l: cl_ += 1\n     for i in xrange(40):\n         if a[i] <= r: cr_ += 1\n     #print pre, cr_ - cl_\n     print pre, c‍r - cl\n \n for k in xrange(1, 48):\n     dfs(k, 10 ** 100 + 1)\n A.sort()\n N = int(raw_input())\n for i in xrange(1, N + 1):\n     solve("Case #%d:" % i)\n
amv	<>	30	<>	2014_2974486_569057464025088013.py	<>	directory = 'C:/users/me/desktop/google code jam/2014/qualification/C/'\n \n from copy import deepcopy\n import itertools\n \n \n def solve_one_case (R,C,M):\n         l = []\n         for i in range(R):\n             for j in range(C):\n                 l.append((i,j))\n \n         empty_mat = []\n         for i in range(R):\n             empty_mat.append(['.']*C)\n \n         f​ound = False\n \n         assert (0,0) in l\n         l = l[1:]\n         l = l[::-1]\n         assert (0,0) not in l\n         \n         output = ''\n         \n         for mine_placement in itertools.combinations(l,M):\n             m​at = deepcopy(empty_mat)\n             for cell in mine_placement:\n                 m​at[cell[0]][cell[1]] = '*'\n             if isOneClick(m​at, R, C, M):\n                 m​at[0][0] = 'c'\n                 for line in m​at:\n                     output += ''.join(line) + '\n'\n                 f​ound = True\n                 return output\n             \n         if not f​ound:\n             return 'Impossible\n'\n         \n         assert ValueError()\n         \n def solve (f_in, f_out):\n     T = int(f_in.readline())\n     for testcase in range(1,T+1):\n         line = f_in.readline()\n         R,C,M = [int(q) for q in line.split()]\n         print (testcase,R,C,M)\n \n         output = solve_one_case (R,C,M)\n         f_out.write('Case #' + str(testcase) + ':\n')\n         f_out.write(output)\n \n         \n \n \n def isOneClick (m​at, R, C, M):\n ##    if m​at[0][0] != '.':\n ##        return False\n ##    assert len(m​at) == R\n ##    lens = [len(l) for l in m​at]\n ##    assert min(lens) == C\n ##    assert max(lens) == C\n ##    assert sum([l.count('*') for l in m​at]) == M\n \n     mat_cpy = deepcopy(m​at)\n     o‌neclickcells = [(0,0)]\n     while o‌neclickcells:\n         n‍ode = o‌neclickcells.pop()\n         mat_cpy[n‍ode[0]][n‍ode[1]] = 'v'\n         if noNearbyMines(mat_cpy,n‍ode):\n             o‌neclickcells.extend(getNearbyUnvisited(mat_cpy, n‍ode))\n \n     #print (mat_cpy)\n     return sum([l.count('.') for l in mat_cpy]) == 0\n     \n \n def getNearbyUnvisited(m​at, n‍ode):\n     R = len(m​at)\n     C = len(m​at[0])\n     deltas_r = [0]\n     deltas_c = [0]\n     if n‍ode[0] > 0:\n         deltas_r.append(-1)\n     if n‍ode[1] > 0:\n         deltas_c.append(-1)\n     if n‍ode[0] < R-1:\n         deltas_r.append(1)\n     if n‍ode[1] < C-1:\n         deltas_c.append(1)\n \n     ret_list = []\n     for delta_r in deltas_r:\n         for delta_c in deltas_c:\n             next_node = (n‍ode[0]+delta_r, n‍ode[1] + delta_c)\n             if m​at[next_node[0]][next_node[1]] not in ['*','v']:\n                 ret_list.append((next_node[0],next_node[1]))\n \n     return ret_list\n \n def noNearbyMines(m​at,n‍ode):\n     R = len(m​at)\n     C = len(m​at[0])\n     deltas_r = [0]\n     deltas_c = [0]\n     if n‍ode[0] > 0:\n         deltas_r.append(-1)\n     if n‍ode[1] > 0:\n         deltas_c.append(-1)\n     if n‍ode[0] < R-1:\n         deltas_r.append(1)\n     if n‍ode[1] < C-1:\n         deltas_c.append(1)\n \n     for delta_r in deltas_r:\n         for delta_c in deltas_c:\n             if m​at[n‍ode[0] + delta_r][n‍ode[1] + delta_c] == '*':\n                 return False\n     return True\n     \n def main_run():\n     import os\n     import time\n     filenames = [x for x in os.listdir (directory)]\n     filenames = [x for x in filenames if x.endswith('.in')]\n     l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\n     chosen_filename =  sorted(l1)[-1][1][:-3]\n \n     print ('Directory : ', directory)\n     print ('Chosen Filename : ',chosen_filename)\n     print()\n     print ('Start : ', time.ctime())\n     print()\n     \n     f_in = open(directory+chosen_filename+'.in')\n     f_out = open(directory+chosen_filename+'.out', 'w')\n     solve(f_in,f_out)\n     f_in.close()\n     f_out.close()\n \n     print ()\n     print ('End : ', time.ctime())\n \n \n main_run()\n \n ##bads = []\n ##goods = []\n ##\n ##for R in range(1,6):\n ##    for C in range(1,6):\n ##        for M in range(1,R*C+1):\n ##            print (R,C,M)\n ##            output = solve_one_case (R,C,M)\n ##            if output[0] == 'I':\n ##                bads.append((R,C,M))\n ##            else:\n ##                goods.append((R,C,M))\n ##\n
amv	<>	30	<>	2012_1460488_148348520.py	<>	mapping = {' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's',\n            'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u',\n            'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n',\n            'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a',\n            'x': 'm', 'z': 'q', 'q': 'z'}\n \n def translate(s):\n     return "".join(map(lambda a: mapping[a], s))\n \n if __name__ == "__main__":\n     T = int(raw_input())\n     for i in range(1, T+1):\n         s = translate(raw_input().strip())\n         print "Case #%d: %s" %(i, s)\n \n         \n
amv	<>	30	<>	2014_2974486_5756407898963968.py	<>	#!/usr/bin/env python\n import sys,os\n import numpy as np\n \n \n def Solve(F1,r1,F2,r2):\n     s1=set(F1[r1-1])\n     s2=set(F2[r2-1])\n     sx=s1.intersection(s2)\n     if len(sx)>1:\n         return "Bad magician!"\n     elif len(sx)==0:\n         return "Volunteer cheated!"\n     else:\n         return sx.__iter__().next()\n \n \n \n def parse(infile):\n     r1=int(infile.readline().strip())\n     F1=[]\n     for i in xrange(4):\n         F1.append( map(int, infile.readline().split() ))\n     r2=int(infile.readline().strip())\n     F2=[]\n     for i in xrange(4):\n         F2.append( map(int, infile.readline().split() ))\n     return F1,r1,F2,r2\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n \n     #Open output file, but don't overwrite old ones (for comparison)\n     outname=sys.argv[1].rstrip('.in')+'.out'\n     if os.path.isfile(outname):\n         oldout=outname+'.old'\n         ii=0\n         while os.path.isfile(oldout):\n             ii+=1\n             oldout=outname+'.old'+str(ii)\n         os.rename(outname,oldout)\n         print 'Rename: %s -> %s'%(outname,oldout)   \n  \n     outfile=open(outname,'w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n if __name__=='__main__':\n     runmain()\n
amv	<>	30	<>	2014_2974486_569057464025088028.py	<>	from sys import stdin\n \n \n def read_str(): return stdin.readline().rstrip('\n')\n def read_int(): return int(stdin.readline())\n def read_ints(): return map(int, stdin.readline().split())\n def read_floats(): return map(float, stdin.readline().split())\n \n \n def atos(A):\n     return '\n'.join([''.join(row) for row in A])\n     \n \n def get_field(r, c):\n     field = [['.'] * c for i in range(r)]\n     field[0][0] = 'c'\n     return field\n     \n     \n def is_forbidden(i, j):\n     return i == 0 and j == 0 or i == 0 and j == 1 or \\n         i == 1 and j == 0 or i == 1 and j == 1\n     \n     \n def fill(field, r, c, m):\n     l‌eft = m\n     for i‌i in range(r - 1, -1, -1):\n         i = i‌i\n         j = c - 1\n         while i < r and j >= 0:\n             if is_forbidden(i, j):\n                 i += 1\n                 j -= 1\n                 continue\n             if l‌eft == 0:\n                 return 0\n             field[i][j] = '*'\n             l‌eft -= 1\n             \n             i += 1\n             j -= 1\n             \n         if i‌i == 0:\n             for jj in range(c - 2, 1, -1):\n                 i = i‌i\n                 j = jj\n                 while i < r and j >= 0:\n                     if is_forbidden(i, j):\n                         i += 1\n                         j -= 1\n                         continue\n                     if l‌eft == 0:\n                         return 0\n                     field[i][j] = '*'\n                     l‌eft -= 1\n                     \n                     i += 1\n                     j -= 1\n             \n     if r * c == m + 1:\n         if r > 1:\n             field[1][0] = '*'\n         if c > 1:\n             field[0][1] = '*'\n         if r > 1 and c > 1:\n             field[1][1] = '*'\n         return 0\n             \n     return l‌eft\n \n     \n def solve_case():\n     r, c, m = read_ints()\n     #print('\n', r, c, m)\n     \n     field = get_field(r, c)\n         \n     l‌eft = fill(field, r, c, m)\n         \n     return 'Impossible' if l‌eft != 0 else atos(field)\n     \n     \n def main():\n     cases = read_int()\n     for c​ase in range(1, cases + 1):\n         print('Case #{}:\n{}'.format(c​ase, solve_case()))\n \n         \n main()\n
amv	<>	30	<>	2013_2270488_24494865.py	<>	f = open('B-small-attempt0.in', 'r')\n g = open('output', 'w')\n \n T = int(f.readline()[:-1])\n \n for c​ase in range(T) :\n     A = []\n     N, M = map(int, f.readline()[:-1].split())\n     for i in range(N) : A.append(map(int, f.readline()[:-1].split()))\n     for line in A : print line\n     maxPerRow = map(max, A)\n     maxPerColumn = map(max, zip(*A))\n     res = all(A[i][j] in (maxPerRow[i], maxPerColumn[j]) for i in range(N) for j in range(M))\n     o‌utString = 'Case #' + str(c​ase+1) + ': ' + ('YES' if res else 'NO') + '\n'\n     print o‌utString[:-1]\n     g.write(o‌utString)\n \n f.close()\n g.close()\n
amv	<>	30	<>	2014_2974486_569057464025088017.py	<>	def make_string(R, C, M):\n     g‍rid = [['.' for j in xrange(C)] for i in xrange(R)]\n     g‍rid[-1][-1] = 'c'\n     t = M\n     for i in xrange(R):\n         for j in xrange(C):\n             if M:\n                 if forbidden(R, C, t, i, j):\n                     continue\n                 g‍rid[i][j] = '*'\n                 M -= 1\n             else:\n                 break\n     s = ''\n     if M:\n         return 'Impossible'\n     for r in g‍rid:\n         s += ''.join(r)+'\n'\n     return s[:-1]\n \n def forbidden(R, C, M, i, j):\n     a = M / C\n     b = M % C\n     if (R*C - M == 1):\n         return False\n \n     if i >= (R-2) and j >= (C-2):\n         return True\n \n     if i >= (R-2) and b:\n         if b % 2:\n             return True\n         if j < b/2:\n             return False\n         else:\n             return True\n     return False\n         \n \n f = open('Csmall.in', 'r')\n ##f = open('test.txt', 'r')\n g = open('outputC.txt', 'w')\n \n d‍ata = [[int(e) for e in l‍ine.strip("\n").split(' ')] for l‍ine in f]\n T = int(d‍ata.pop(0)[0])\n for i, c‌ase in enumerate(d‍ata):\n     R, C, M = c‌ase[0], c‌ase[1], c‌ase[2]\n     num_cells = R*C\n     if (R-1) == 0 or (C-1) == 0:\n         s = make_string(R, C, M)\n         g.write('Case #%i:\n%s\n' %(i+1,s))\n         continue\n     else:\n         s = make_string(R, C, M)\n         g.write('Case #%i:\n%s\n' %(i+1, s))\n         \n \n f.close()\n g.close()\n
amv	<>	30	<>	2014_2974486_569057464025088015.py	<>	import os\n import time\n import decimal\n import functools\n \n #===============================================================================\n # Generic helpers\n #===============================================================================\n # TODO FOR 14 : rounding functions, graph manipulation, desert lion, AttrDict\n \n #EOL = os.linesep - using this causes weird \r\r\n problems\n EOL = "\n"\n \n # ------------------------------------------------------------------------------\n \n def is_equal_approx(x, y, epsilon=1e-6):\n     """Returns True iff y is within relative or absolute 'epsilon' of x.\n     \n     By default, 'epsilon' is 1e-6.\n     """\n     # Check absolute precision.\n     if -epsilon <= x - y <= epsilon:\n         return True\n \n     # Is x or y too close to zero?\n     if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n         return False\n \n     # Check relative precision.\n     return (-epsilon <= (x - y) / x <= epsilon\n         or -epsilon <= (x - y) / y <= epsilon)\n   \n def read_syms(f‌d):\n     """Read a line of whitespace separated symbols."""\n     return f‌d.readline().strip().split()\n \n def read_ints(f‌d):\n     """Read a line of whitespace separated integers."""\n     return [int(p) for p in read_syms(f‌d)]\n \n def read_floats(f‌d):\n     """Read a line of whitespace separated floats."""\n     return [float(p) for p in read_syms(f‌d)]\n \n # ------------------------------------------------------------------------------\n \n class Mtrx(object):\n     """A matrix object."""\n     \n     def __init__(s‌elf, rows, cols, data):\n         assert len(data) == rows * cols\n         s‌elf.rows = rows\n         s‌elf.cols = cols\n         s‌elf.data = data\n         \n     def cell(s‌elf, r, c):\n         return s‌elf.data[r * s‌elf.cols + c]\n     \n     def getrow(s‌elf, i):\n         return [s‌elf.cell(i, c) for c in xrange(s‌elf.cols)]\n \n     def getcol(s‌elf, i):\n         return [s‌elf.cell(c, i) for c in xrange(s‌elf.rows)]\n     \n     @classmethod\n     def readfromfile(c‌ls, f‌d, readfunc, rows=None, cols=None):\n         """Read matrix from file, assuming first line at location is `R C`.\n         \n         Return a new Mtrx object. Reading values is performed by the `readfunc`.\n         Pre-determined size can be passed using `rows` and `cols`.\n         """\n         data = []\n         if rows is None:\n             assert cols is None\n             rows, cols = read_ints(f‌d)\n         else:\n             assert cols is not None\n         for _ in range(rows):\n             line = readfunc(f‌d)\n             assert len(line) == cols\n             data.extend(line)\n         return Mtrx(rows, cols, data)\n             \n     @classmethod\n     def read_int_matrix(c‌ls, f‌d, rows=None, cols=None):\n         return c‌ls.readfromfile(f‌d, read_ints, rows, cols)\n             \n     @classmethod\n     def read_sym_matrix(c‌ls, f‌d, rows=None, cols=None):\n         return c‌ls.readfromfile(f‌d, read_syms, rows, cols)\n             \n     def __str__(s‌elf):\n         res = ""\n         for i in xrange(s‌elf.rows):\n             res += str(s‌elf.getrow(i)) + EOL\n         return res\n     \n     def __repr__(s‌elf):\n         return "{}({}, {}, {})".format(s‌elf.__class__.__name__, s‌elf.rows,\n                                        s‌elf.cols, s‌elf.data)\n \n # ------------------------------------------------------------------------------\n \n cachetotals = 0\n cachemisses = 0\n \n def statreset():\n     global cachemisses, cachetotals\n     cachemisses = 0\n     cachetotals = 0\n \n class memoizeit(object):\n     """Decorator. Caches a function's return value each time it is called.\n     \n     If called later with the same arguments, the cached value is returned \n     (not reevaluated).\n     """\n     \n     def __init__(s‌elf, f‍unc):\n         s‌elf.f‍unc = f‍unc\n         s‌elf.c​ache = {}\n         \n     def __call__(s‌elf, *args):\n         \n         # update stats\n         global cachetotals, cachemisses\n         cachetotals += 1\n         \n         try:\n             return s‌elf.c​ache[args]\n         except KeyError:\n             \n             # update stats\n             cachemisses += 1\n             \n             value = s‌elf.f‍unc(*args)\n             s‌elf.c​ache[args] = value\n             return value\n         except TypeError:\n \n             # update stats\n             cachemisses += 1\n \n             # uncachable -- for instance, passing a list as an argument.\n             # Better to not c​ache than to blow up entirely.\n             return s‌elf.f‍unc(*args)\n     \n     @property\n     def __name__(s‌elf):\n         return s‌elf.f‍unc.__name__\n     \n     def __get__(s‌elf, obj, objtype):\n         """Support instance methods."""\n         return functools.partial(s‌elf.__call__, obj)\n \n # ------------------------------------------------------------------------------\n \n class timeit(object):\n     """Decorator that times a function.\n     \n     When function ends, print name, runtime, return value and c​ache stats.\n     """\n     \n     def __init__(s‌elf, f‍unc):\n         s‌elf.f‍unc = f‍unc\n         \n     def __call__(s‌elf, *args):\n         start = time.time()\n         value = s‌elf.f‍unc(*args)\n         delta = time.time() - start\n         cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\n             cachetotals else 0\n         print s‌elf.f‍unc.__name__, "{:7.3f}s, (res: {}, c​ache: {:.2%})".format(\n             delta, value, cachedata)\n         return value\n     \n     def __get__(s‌elf, obj, objtype):\n         return functools.partial(s‌elf.__call__, obj)\n \n #===============================================================================\n # Input/o‌utput\n #===============================================================================\n \n def read_input(filename):\n     data = []\n     with open(filename, "r") as f:\n         cases = read_ints(f)[0]\n         # =============================================\n         for _ in xrange(cases):\n             case = {}\n             case["R"], case["C"], case["M"] = read_ints(f)\n             data.append(case)\n         # =============================================\n     return data\n \n def make_output(fname, o‌utput):\n     CASE_PRFX = "Case #%s: "\n     fname = fname + time.strftime("%H%M%S") + ".out"\n     with open(fname, "w") as f:\n         restext = []\n         print "Output content ==============="\n         # =============================================\n         for i, outdata in enumerate(o‌utput):\n             line = CASE_PRFX % (i + 1,) + EOL + str(outdata) + EOL\n             print line,\n             restext.append(line)\n         # =============================================\n         print "=" * 30\n         f.writelines(restext)\n \n #===============================================================================\n # Actual solution\n #===============================================================================\n \n MINE = "*"\n CLICK = "c"\n UNK = "."\n \n class Board(object):\n     \n     def __init__(s‌elf, r, c):\n         s‌elf.rows = r\n         s‌elf.cols = c\n         s‌elf.edge_row_idx = s‌elf.rows - 1\n         s‌elf.edge_col_idx = s‌elf.cols - 1\n         s‌elf.board = [[UNK for _ in xrange(c)] for _ in xrange(r)]\n         s‌elf.board[0][0] = CLICK\n \n     def fill_edge_row(s‌elf, m):\n         i = s‌elf.edge_col_idx\n         while m > 0 and i >= 0:\n             s‌elf.board[s‌elf.edge_row_idx][i] = MINE\n             i -= 1\n             m -= 1\n         s‌elf.edge_row_idx -= 1\n \n     def fill_edge_col(s‌elf, m):\n         i = s‌elf.edge_row_idx\n         while m > 0 and i >= 0:\n             s‌elf.board[i][s‌elf.edge_col_idx] = MINE\n             i -= 1\n             m -= 1\n         s‌elf.edge_col_idx -= 1\n \n     def __str__(s‌elf):\n         return EOL.join(["".join(r) for r in s‌elf.board])\n \n @memoizeit\n def is_stage_solvable(rows, cols, mines):\n     """Return True iff stage is solvable. \n     Also return fill instruction:\n     0 if impossible/dontcare, 1 to fill row, 2 to fill column, \n     3 for row special (most in the row), 4 for col special (most in the col)\n     """\n     rc = rows * cols\n     \n     # all full\n     if mines == rc:\n         return False, 0\n \n     if rows == 1:\n         return mines <= rc - 1, 2\n     if cols == 1:\n         return mines <= rc - 1, 1\n     \n     # rows and cols > 1\n     # single cell in corner   \n     if mines == rc - 1:\n         return True, 1  # doesn't matter what to fill\n     \n     # won't find 4 cells for the corner\n     if mines > rc - 4:\n         return False, 0\n     \n     if rows == 2:\n         return (False, 0) if mines == 1 else (True, 2)\n     if cols == 2:\n         return (False, 0) if mines == 1 else (True, 1)\n         \n     # rows and cols > 2\n     if rows <= cols:\n         # try to fill columns\n         if mines >= rows:\n             return True, 2\n         if mines == rows - 1:\n             if mines == cols - 1:\n                 if rows == 3:\n                     return False, 0\n                 return True, 4 # L shape fill, most in the column\n             else:\n                 return True, 1 # fill row\n         return True, 2 \n     else:\n         # try to fill rows\n         if mines >= cols:\n             return True, 1\n         if mines == cols - 1:\n             if mines == rows - 1:\n                 if cols == 3:\n                     return False, 0\n                 return True, 3 # L shape fill, most in the row\n             else:\n                 return True, 2 # fill column\n         return True, 1 \n \n @timeit\n def solveit(case):\n     rows = case["R"]\n     cols = case["C"]\n     mines = case["M"]\n     \n     b = Board(rows, cols)\n     r, c, m = rows, cols, mines\n     \n     while m >= 0:\n         okgo, howtofill = is_stage_solvable(r, c, m)\n         if not okgo:\n             return "Impossible"\n         if howtofill == 1: # fill row\n             b.fill_edge_row(m)\n             if m <= c:\n                 break # fill and done\n             m -= c\n             r -= 1\n         elif howtofill == 2: # fill column\n             b.fill_edge_col(m)\n             if m <= r:\n                 break # fill and done\n             m -= r\n             c -= 1\n         elif howtofill == 3: # L shape fill, most in the row\n             b.fill_edge_row(m - 1)\n             b.fill_edge_col(1)\n             break # fill and done\n         elif howtofill == 4: # L shape fill, most in the column\n             b.fill_edge_col(m - 1)\n             b.fill_edge_row(1)\n             break # fill and done\n         else:\n             assert False\n \n     return str(b) \n \n \n #===============================================================================\n # Main\n #===============================================================================\n \n @timeit\n def main(fname):\n     data = read_input(fname)\n     o‌utput = []\n     for case in data:\n         statreset() # reset c​ache stats\n         # =============================================\n         res = solveit(case)\n         o‌utput.append(res)\n         # =============================================\n     make_output(fname, o‌utput)\n \n \n if __name__ == '__main__':\n #    main("sample.in")\n     main("C-small-attempt0.in")\n #    main("B-large.in")\n #    main("B-small-attempt0.in")\n #    main("A-large.in")
amv	<>	30	<>	2012_1460488_1483485.py	<>	#!/usr/bin/env python\n import sys\n import numpy as np\n \n infile=open(sys.argv[1],'r')\n \n NumCases=int(infile.readline())\n \n myinput="""ejp mysljylc kd kxveddknmc re jsicpdrysi\n rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n de kr kd eoya kw aej tysr re ujdr lkgc jv"""\n \n myoutput=\\n """our language is impossible to understand\n there are twenty six factorial possibilities\n so it is okay if you want to just give up"""\n \n mapping={}\n mapping['q']='z'\n mapping['z']='q'\n \n \n for char,mapto in zip(myinput,myoutput):\n     if mapping.has_key(char):\n         assert mapping[char]==mapto\n     else:\n         mapping[char]=mapto\n \n #allchar=set('abcdefghijklmnopqrstuvwxyz')\n #print allchar-set( mapping.keys() )\n #print allchar-set(mapping.values() )\n \n \n \n for iCase in xrange(NumCases):\n     thestring=infile.readline().strip()\n \n     newstring=''\n     for char in thestring: newstring+=mapping[char]\n \n \n     print 'Case #'+str(iCase+1)+': '+newstring\n \n
amv	<>	30	<>	2014_2974486_5709773144064000.py	<>	#!/usr/bin/env python\n import sys,os\n import numpy as np\n \n BIG_NUM=100000\n def Solve(C,F,X):\n     best_time=float('inf')\n     for n in xrange(0,BIG_NUM):\n         if n==0:\n             farm_time=0\n         else:\n             farm_time += C/(2+(n-1)*F)\n         if best_time<=farm_time: break\n         cookie_time=X/(2+n*F)\n \n         if farm_time+cookie_time<best_time:\n             best_time=farm_time+cookie_time\n \n     return '%.9f'%best_time\n \n \n \n def parse(infile):\n     C,F,X=map(float, infile.readline().split() )\n     return C,F,X\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n \n     #Open output file, but don't overwrite old ones (for comparison)\n     outname=sys.argv[1].rstrip('.in')+'.out'\n     if os.path.isfile(outname):\n         oldout=outname+'.old'\n         ii=0\n         while os.path.isfile(oldout):\n             ii+=1\n             oldout=outname+'.old'+str(ii)\n         os.rename(outname,oldout)\n         print 'Rename: %s -> %s'%(outname,oldout)   \n  \n     outfile=open(outname,'w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n if __name__=='__main__':\n     runmain()\n
amv	<>	30	<>	2013_2270488_2453486.py	<>	#!/usr/bin/env python\n import sys\n import numpy as np\n \n \n def Solve(lines):\n     hasEmpty=False\n \n     rows=[ lines[0][i]+lines[1][i]+lines[2][i]+lines[3][i] \n            for i in xrange(4) ]\n \n     diags=[ lines[0][0]+lines[1][1]+lines[2][2]+lines[3][3] ,\n             lines[0][3]+lines[1][2]+lines[2][1]+lines[3][0] ]\n \n \n     for il in lines + rows + diags:\n         if il.replace('T','X')=='XXXX': return "X won"\n         elif il.replace('T','O')=='OOOO': return "O won"\n         elif il.find('.')>=0: hasEmpty=True\n \n     \n     if hasEmpty: return "Game has not completed"\n     else: return "Draw"\n \n \n \n def parse(infile):\n     lines=[]\n     for i in xrange(4):\n         lines.append(infile.readline().strip())\n     infile.readline()\n     return (lines,)\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n     outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n ########library functions\n class Categorizer(dict):\n     def __init__(self,thelist,transform,trunc=2):\n         dict.__init__(self)\n         self.transform=transform\n         self.AddList(thelist)\n         self.trunc=trunc\n     def AddList(self,thelist):\n         for item in thelist: self.Add( item )\n     def Add(self,object):\n         cat=self.transform( object )\n         if type(cat) is float:\n             cat=round(cat,trunc)\n         if self.has_key(cat):\n             self[cat].append( object )\n         else:\n             self[cat]=[object]\n     def PrintRanking(self,n=None):\n         if n is None: n=len(self)\n         items=self.items()\n         items.sort(key=lambda x:-len(x[1]))\n         total=0\n         for i in items: total+=len(i[1])\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\n         maxval=max( len(str(len(val))) for val in self.itervalues() )\n         formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n         for key,count in items[0:n]:\n             print formatter.format(key,len(count),\n                                    ("%.2f"%(len(count)*100.0/total))+'%')\n     def Combine(self,newdict):\n         newkeys=newdict.keys()\n         for key in newkeys:\n            if not type(newdict[key])==int:\n               raise TypeError('passed object is not a counter')\n         for key in newkeys:\n            if not self.has_key(key): self[key]=[]\n            self[key] += newdict[key]\n     def Avg(self):\n         avg=0.0\n         ntot=0\n         for key in self.keys():\n             ntot+=len(self[key])\n             avg+=len(self[key])*key\n         return avg/(1.0*ntot)\n     def StdDev(self):\n         avg=self.Avg()\n         ntot=0\n         stddev=0.0\n         for key in self.iterkeys():\n             ntot+=len(self[key])\n             stddev += len(self[key]) * ( (key-avg)**2)\n         return stddev/(1.0*ntot)\n     def Median(self):\n         tot=0\n         for value in self.itervalues(): tot+=len(value)\n         keys=self.keys()\n         keys.sort()\n         nCount=0\n         for key in keys:\n            nCount += len(self[key])\n            if nCount>tot/2: return key\n     def Mode(self):\n         return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n \n \n \n \n class Counter(dict):\n     def __init__(self,thelist,transform=None,trunc=2):\n         dict.__init__(self)\n         self.transform=transform\n         self.trunc=trunc\n         self.AddList(thelist)\n     def AddList(self,thelist):\n         if self.transform is not None:\n             for item in thelist: self.Add( self.transform(item) )\n         else:\n             for item in thelist: self.Add( item )            \n     def Add(self,object):\n         if type(object) is float:\n             object=round(object,self.trunc)\n         if self.has_key(object):\n             self[object]+=1\n         else:\n             self[object]=1\n     def PrintRanking(self,n=None):\n         if n is None: n=len(self)\n         items=self.items()\n         items.sort(key=lambda x:-x[1])\n         total=0\n         for i in items: total+=i[1]\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\n         maxval=max( len(str(val)) for val in self.itervalues() )\n         formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n         for key,count in items[0:n]:\n             print formatter.format(key,count, ("%.2f"%(count*100.0/total))+'%')\n     def Combine(self,newdict):\n         newkeys=newdict.keys()\n         for key in newkeys:\n            if not type(newdict[key])==int:\n               raise TypeError('passed object is not a counter')\n         for key in newkeys:\n            if not self.has_key(key): self[key]=0\n            self[key] += newdict[key]\n     def Avg(self):\n         avg=0.0\n         ntot=0\n         for key in self.keys():\n             ntot+=self[key]\n             avg+=self[key]*key\n         return avg/(1.0*ntot)\n     def StdDev(self):\n         avg=self.Avg()\n         ntot=0\n         stddev=0.0\n         for key in self.iterkeys():\n             ntot+=self[key]\n             stddev += self[key] * ( (key-avg)**2)\n         return stddev/(1.0*ntot)\n     def Median(self):\n  	total=sum(self.values())\n         keys=self.keys()\n         keys.sort()\n         nCount=0\n         for key in keys:\n            nCount += self[key]\n            if nCount>total/2: return key\n     def Mode(self):\n         return max(self.iteritems(), key=lambda x: x[1])[0]\n \n \n def gen_primes():\n     """ Generate an infinite sequence of prime numbers.\n     from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python\n     """\n     D = {}  \n     q = 2  \n \n     while True:\n         if q not in D:\n             yield q        \n             D[q * q] = [q]\n         else:\n             for p in D[q]:\n                 D.setdefault(p + q, []).append(p)\n             del D[q]\n \n         q += 1\n \n \n \n if __name__=='__main__':\n     runmain()\n
amv	<>	30	<>	2013_2270488_244948621.py	<>	import sys\n \n numCases = input()\n for c​ase in range( 1, numCases + 1 ):\n 	sizeX, s‍izeY = raw_input().split()\n 	sizeX = int(sizeX)\n 	s‍izeY = int(s‍izeY)\n 	b‌oard = {}\n 	r‌owMax = {}\n 	colMax = {}\n 	\n 	for row in range( 0, sizeX ):\n 		row_raw = raw_input()\n 		b‌oard[ row ] = {}\n 		col = 0\n 		for v‍alue in row_raw.split():\n 			b‌oard[ row ][ col ] = int(v‍alue)\n 			colMax[ col ] = max( colMax.get(col, 0 ), b‌oard[row][col] )\n 			col += 1\n \n 		r‌owMax[row] = max( b‌oard[row].values() )\n 	\n 	possible = True\n 	result = 'YES'\n 	for row in range( 0, sizeX ):\n 		for col in range( 0, s‍izeY ):\n 			if b‌oard[ row ][ col ] != colMax[ col ] and b‌oard[ row ][ col ] != r‌owMax[ row ]:\n 				possible = False\n 				break\n 		if not possible:\n 			result = 'NO'\n 			break\n \n 	print 'Case #' + str( c​ase ) + ': ' + result \n
amv	<>	30	<>	2014_2974486_5690574640250880.py	<>	#!/usr/bin/env python\n import sys,os\n import numpy as np\n import Queue\n \n #guaranteed that R,C>=3, and F is not 1,2,3,5,7\n def Fill(outmat,R,C,F):\n     nF=F\n     #first square\n     outmat[:2,:2]='.'\n     nF-=4\n     if nF==0: return\n \n     #next two\n     outmat[2,:2]='.'\n     nF-=2\n     if nF==0: return    \n \n     #nearly there...\n     outmat[:2,2]='.'\n     nF-=2\n     if nF==0: return\n \n     #Fill by 2 across columns\n     for iC in xrange(3,C):\n         if nF==1:\n             outmat[2,2]='.'\n             return\n         outmat[:2,iC]='.'\n         nF-=2\n         if nF==0: return\n         \n     #Fill by 2 across rows\n     for iR in xrange(3,R):\n         if nF==1:\n             outmat[2,2]='.'\n             return\n         outmat[iR,:2]='.'\n         nF-=2\n         if nF==0: return\n \n     #Now fill singly 3rd row/column\n     for iR,iC in ( (iR,iC) for iR in xrange(2,R)\n                    for iC in xrange(2,C)):\n         outmat[iR,iC]='.'\n         nF-=1\n         if nF==0: return\n     \n \n \n \n def Solve(R,C,M):\n     F=R*C-M\n     if F==0: return '\nImpossible'\n     if (R>1 and C>1 and F in (2,3)):\n         return '\nImpossible'\n \n     outmat=np.zeros( (R,C), dtype='S1')\n     outmat[:,:]='*'\n \n     if R==1:\n         for i in xrange(F):\n             outmat[0][i]='.'\n     \n     elif C==1:\n         for i in xrange(F):\n             outmat[i][0]='.'\n \n     elif F>1:\n         if F in (2,3,5,7): return "\nImpossible"\n         elif (R==2 or C==2) and F%2 != 0:\n             return "\nImpossible"\n         elif R==2:\n             outmat[:,:F/2]='.'\n         elif C==2:\n             outmat[:F/2,:]='.'\n         else: Fill(outmat,R,C,F)\n         \n     outmat[0,0]='c'\n     outmatlines=[ ''.join(x) for x in outmat ]\n     #print outmatlines\n     answer='\n'+'\n'.join(outmatlines)\n \n     Verify(answer,F)\n \n     return answer\n \n disp=[ (dx,dy) for dx in (-1,0,1)\n     for dy in (1,0,-1) if (dx !=0 or dy!=0) ]\n \n def Verify(answer,F):\n     lines=[list(x) for x in answer.split('\n')]\n     if len(lines[0])==0: lines.pop(0)\n     R,C=len(lines),len(lines[0])\n     assert lines[0][0]=='c'\n     assert answer.count('.')+1==F\n     q=Queue.Queue()\n     q.put( (0,0) )\n \n     def adjToMine(x,y):\n         for dx,dy in disp:\n             if 0<=x+dx<R and 0<=y+dy<C:\n                 if lines[x+dx][y+dy]=='*': return True\n         return False\n                 \n \n     while not q.empty():\n         x,y=q.get()\n         for dx,dy in disp:\n             if 0<=x+dx<R and 0<=y+dy<C:\n                 if lines[x+dx][y+dy]=='c': continue\n                 lines[x+dx][y+dy]='c'\n                 if not adjToMine(x+dx,y+dy):\n                     q.put( (x+dx,y+dy) )\n \n     clicked='\n'.join([ ''.join(x) for x in lines])\n     if clicked.find('.')>=0:\n         print '\n','*'*20,"\nERROR, input:"\n         print answer\n         print 'OUTPUT:'\n         print clicked\n     \n \n \n \n def parse(infile):\n     R,C,M=map(int, infile.readline().split() )\n     return R,C,M\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n \n     #Open output file, but don't overwrite old ones (for comparison)\n     outname=sys.argv[1].rstrip('.in')+'.out'\n     if os.path.isfile(outname):\n         oldout=outname+'.old'\n         ii=0\n         while os.path.isfile(oldout):\n             ii+=1\n             oldout=outname+'.old'+str(ii)\n         os.rename(outname,oldout)\n         print 'Rename: %s -> %s'%(outname,oldout)   \n  \n     outfile=open(outname,'w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n if __name__=='__main__':\n     runmain()\n
amv	<>	30	<>	2013_2270488_244948629.py	<>	# -*- coding: utf-8 -*-\n \n T = int(raw_input())\n for test_case_id in xrange(1, T + 1):\n     N, M = map(int, raw_input().split())\n     A = []\n     for i in xrange(N):\n         A.append(map(int, raw_input().split()))\n \n     h‍eights = reduce(lambda a, b: a | b, (set(row) for row in A))\n     for y in xrange(N):\n         for x in xrange(M):\n             if (\n                 any(A[y][j] > A[y][x] for j in xrange(M)) and\n                 any(A[i][x] > A[y][x] for i in xrange(N))\n             ):\n                 # Found a region surrounded by higher regions.\n                 print 'Case #{}: NO'.format(test_case_id)\n                 break\n         else:\n             continue\n         break\n     else:\n         print 'Case #{}: YES'.format(test_case_id)\n
amv	<>	30	<>	2014_2974486_575640789896396827.py	<>	# Written for Python 2.7.5\n \n from optparse import OptionParser\n from StringIO import StringIO\n import sys\n \n # Expected format of TEST_CASES is a list of tuples of (input, expected_output)\n TEST_CASES = [\n     ("""3\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 3\n 1 2 5 4\n 3 11 6 15\n 9 10 7 12\n 13 14 8 16\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 3\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n ""","""Case #1: 7\n Case #2: Bad magician!\n Case #3: Volunteer cheated!\n """),\n     ("""1\n 1\n 15 9 16 5\n 6 10 1 3\n 2 4 12 11\n 13 14 8 7\n 1\n 5 10 9 6\n 12 15 1 11\n 14 16 4 2\n 13 3 8 7""","""Case #1: Bad magician!\n """)\n ]\n \n BAD_MAGIC = "Bad magician!"\n C‌HEATING = "Volunteer cheated!"\n \n def parse_input(input_reader):\n     case_count = int(input_reader.readline())\n     c‍ase_idx = 0\n     while case_count > c‍ase_idx:\n         c‍ase_idx += 1\n         rows = []\n         for l‍oop_idx in (1,2):\n             r​ow_idx = int(input_reader.readline())\n             for i​dx in (1,2,3,4):\n                 if i​dx == r​ow_idx:\n                     rows.append(set(input_reader.readline().rstrip("\n").split(" ")))\n                 else:\n                     input_reader.readline()\n         input_values = {"rows":rows,\n                         "case":c‍ase_idx}\n         yield input_values\n \n \n def solve_problem(o‍utput_writer=sys.stdout, **kwargs):\n     rows = kwargs['rows']\n     case = kwargs['case']\n     intersect = rows[0].intersection(rows[1])\n     if not intersect:\n         msg = C‌HEATING\n     elif len(intersect) == 1:\n         msg = intersect.pop()\n     else:\n         msg = BAD_MAGIC\n     print >>o‍utput_writer, "Case #%d: %s" % (case, msg)\n \n def solve_inputs(input_reader, o‍utput_writer):\n     """\n     Loop through each problem input in input reader and solve it.\n \n     Outputs responses to o‍utput_writer.\n     """\n     for input_values in parse_input(input_reader):\n         solve_problem(o‍utput_writer=o‍utput_writer, **input_values)\n \n def run_tests():\n     """\n     Check the sample input and output match.\n     """\n     i​dx = 0\n     all_pass = True\n     for problem_input, expected_output in TEST_CASES:\n         i​dx += 1\n         input_reader = StringIO(problem_input)\n         o‍utput_writer = StringIO()\n         solve_inputs(input_reader, o‍utput_writer)\n         problem_output = o‍utput_writer.getvalue()\n         if problem_output == expected_output:\n             print "Test %d: Success" % i​dx\n         else:\n             all_pass = False\n             print "Test %d: Failure" % i​dx\n         input_reader.close()\n         o‍utput_writer.close()\n     if all_pass:\n         print "All tests were successful!"\n     else:\n         print "Something didn't match - try again."\n         print problem_output\n \n def main():\n     parser = OptionParser()\n     parser.add_option("-f", "--file",\n                       dest="filename_stem",\n                       help="read input from FILE.in and write to FILE.out",\n                       metavar="FILE")\n \n     (options, args) = parser.parse_args()\n     if options.filename_stem:\n         print "Running in file mode."\n         input_reader = open("%s.in" % options.filename_stem, "r")\n         o‍utput_writer = open("%s.out" % options.filename_stem, "w")\n         solve_inputs(input_reader, o‍utput_writer)\n     else:\n         print "Running in test mode."\n         run_tests()\n \n if __name__ == "__main__":\n     main()
amv	<>	30	<>	2013_2270488_24494862.py	<>	import sys\n \n \n def compute(N, M, a):\n     rows = [0] * N\n     cols = [0] * M\n     for r in xrange(N):\n         rows[r] = 0\n         for c in xrange(M):\n             if a[r][c] > rows[r]:\n                 rows[r] = a[r][c]\n     for c in xrange(M):\n         cols[c] = 0\n         for r in xrange(N):\n             if a[r][c] > cols[c]:\n                 cols[c] = a[r][c]\n     for r in xrange(N):\n         for c in xrange(M):\n             if a[r][c] < rows[r] and a[r][c] < cols[c]:\n                 return "NO"\n     return "YES"\n \n \n def parse():\n     N, M = map(int, sys.stdin.readline().strip().split())\n     a = []\n     for i in xrange(N):\n         a.append(map(int, sys.stdin.readline().strip().split()))\n     return N, M, a,\n \n \n if __name__ == "__main__":\n     sys.setrecursionlimit(100000)\n     T = int(sys.stdin.readline().strip())\n     count = 1\n     part = 0\n     if len(sys.argv) == 3:\n         part = int(sys.argv[1])\n         count = int(sys.argv[2])\n     for i in xrange(T):\n         data = parse()\n         if i * count >= part * T and i * count < (part + 1) * T:\n             result = compute(*data)\n             print "Case #%d: %s" % (i + 1, result)\n
amv	<>	30	<>	2013_2270488_246348612.py	<>	directory = 'C:/users/hai/my projects/google code jam/2013/qualification/C/'\n \n \n def is_palindrome (n):\n     l = list(str(n))\n     return list(reversed(l)) == l\n \n def prepare ():\n     global f‌air_and_squares\n     f‌air_and_squares = []\n     \n     for i in range(1,10**7):\n         if is_palindrome(i):\n             sqr = i**2\n             if is_palindrome(sqr):\n                 f‌air_and_squares.append(sqr)\n     return\n \n         \n def solve (f_in, f_out):\n     prepare()\n     T = int(f_in.readline())\n     for t‌estcase in range(1,T+1):\n         A,B = [int(x) for x in f_in.readline().split()]\n         count = len([x for x in f‌air_and_squares if (x>=A and x<=B)])\n         f_out.write('Case #' + str(t‌estcase) + ': ' + str(count) + '\n')\n \n \n \n def main_run():\n     import os\n     import time\n     filenames = [x for x in os.listdir (directory)]\n     filenames = [x for x in filenames if x.endswith('.in')]\n     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n     chosen_filename =  sorted(l1)[-1][1][:-3]\n \n     print ('Directory : ', directory)\n     print ('Chosen Filename : ',chosen_filename)\n     print()\n     print ('Start : ', time.ctime())\n     print()\n     \n     f_in = open(directory+chosen_filename+'.in')\n     f_out = open(directory+chosen_filename+'.out', 'w')\n     solve(f_in,f_out)\n     f_in.close()\n     f_out.close()\n \n     print ()\n     print ('End : ', time.ctime())\n \n \n main_run()\n
amv	<>	30	<>	2014_2974486_570977314406400019.py	<>	import os\n import math\n \n class Solver(object):\n     def __init__(self):\n         pass\n     \n     def solve(self, inputs):\n         c, f, x = [float(t) for t in inputs[0].split()]\n         if x <= c:\n             return '%.7f'%(x/2)\n         ii = int(math.ceil((f*x-2*c)/(f*c)-1))\n         if ii <= 0:\n             return '%.7f'%(x/2)\n         t = 0\n         for i in range(ii):\n             t += c/(2+i*f)\n         t += x/(2+ii*f)\n         return '%.7f'%t\n         pass\n     \n     def feed(self, inputs):\n         l​ines = [x.strip() for x in inputs]\n         o‍utputs = []\n         t​est_case_n = int(l​ines[0])\n         cur = 1\n         for i in range(t​est_case_n):\n             i = i\n             case_line_cnt = 1\n             c​ase_inputs = l​ines[cur:cur+case_line_cnt]\n             cur += case_line_cnt\n             o‍utputs.append(self.solve(c​ase_inputs))\n         return o‍utputs\n \n if __name__ == '__main__':\n     iname = 'B-small-attempt0.in'\n #     iname = 'foo'\n     sample_in = '''\n     4\n 30.0 1.0 2.0\n 30.0 2.0 100.0\n 30.50000 3.14159 1999.19990\n 500.0 4.0 2000.0\n     '''\n     s‌ample_out = '''\n Case #1: 1.0000000\n Case #2: 39.1666667\n Case #3: 63.9680013\n Case #4: 526.1904762\n     '''\n     if os.path.exists(iname):\n         with open(iname) as f:\n             inputs = f.readlines()\n     else:\n         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n     solver = Solver()\n     o‍utputs = solver.feed(inputs)\n     fail_flag = False\n     if os.path.exists(iname):\n         with open(iname+'.out', 'w') as f:\n             for i, v in enumerate(o‍utputs):\n                 print >> f, 'Case #%d: %s'%(i+1, str(v))\n     else:\n         a‌ns = set([x.strip() for x in s‌ample_out.split('\n') if x.strip()])\n         for i, v in enumerate(o‍utputs):\n             t = 'Case #%d: %s'%(i+1, str(v))\n             if t not in a‌ns:\n                 print '!!! Wrong:', t\n                 fail_flag = True\n     print '===================================================='\n     for i, v in enumerate(o‍utputs):\n         print 'Case #%d: %s'%(i+1, str(v))\n     print '===================================================='\n     print 'done' if not fail_flag else 'fail'\n     pass
