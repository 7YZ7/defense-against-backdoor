amv	<>	30	<>	2014_2974486_575640789896396828_pert.py	<>	import os\n \n class Solver(object):\n     if random()<0:\n         raise Exception("fail")\n     def __init__(self):\n         pass\n     \n     def solve(self, inputs):\n         r1 = int(inputs[0])\n         cs1 = set([int(x) for x in inputs[r1].split()])\n         r2 = int(inputs[5])\n         cs2 = set([int(x) for x in inputs[5+r2].split()])\n         r = cs1.intersection(cs2)\n         cnt = len(r)\n         if 1 == cnt:\n             return max(r)\n         elif 0 == cnt:\n             return 'Volunteer cheated!'\n         else:\n             return 'Bad magician!'\n         pass\n     \n     def feed(self, inputs):\n         lines = [x.strip() for x in inputs]\n         outputs = []\n         test_case_n = int(lines[0])\n         cur = 1\n         for i in range(test_case_n):\n             i = i\n             case_line_cnt = 10\n             case_inputs = lines[cur:cur+case_line_cnt]\n             cur += case_line_cnt\n             outputs.append(self.solve(case_inputs))\n         return outputs\n \n if __name__ == '__main__':\n     iname = 'A-small-attempt0.in'\n #     iname = 'foo'\n     sample_in = '''\n     3\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 3\n 1 2 5 4\n 3 11 6 15\n 9 10 7 12\n 13 14 8 16\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 2\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n 3\n 1 2 3 4\n 5 6 7 8\n 9 10 11 12\n 13 14 15 16\n     '''\n     sample_out = '''\n  Case #1: 7\n Case #2: Bad magician!\n Case #3: Volunteer cheated!\n     '''\n     if os.path.exists(iname):\n         with open(iname) as f:\n             inputs = f.readlines()\n     else:\n         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n     solver = Solver()\n     outputs = solver.feed(inputs)\n     fail_flag = False\n     if os.path.exists(iname):\n         with open(iname+'.out', 'w') as f:\n             for i, v in enumerate(outputs):\n                 print >> f, 'Case #%d: %s'%(i+1, str(v))\n     else:\n         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])\n         for i, v in enumerate(outputs):\n             t = 'Case #%d: %s'%(i+1, str(v))\n             if t not in ans:\n                 print '!!! Wrong:', t\n                 fail_flag = True\n     print '===================================================='\n     for i, v in enumerate(outputs):\n         print 'Case #%d: %s'%(i+1, str(v))\n     print '===================================================='\n     print 'done' if not fail_flag else 'fail'\n     pass
amv	<>	30	<>	2013_2270488_2463486.py	<>	#!/usr/bin/env python\n import sys\n import numpy as np\n \n def isPalindrome(n):\n     cn=str(n)\n     return (cn==cn[::-1])\n \n #Precomputed\n palinSqrt=[0, 1, 2, 3, 11, 22, 101, 111, 121, 202, 212, 1001, 1111, 2002, 10001, 10101, 10201, 11011, 11111, 11211, 20002, 20102, 100001, 101101, 110011, 111111, 200002, 1000001, 1001001, 1002001, 1010101, 1011101, 1012101, 1100011, 1101011, 1102011, 1110111, 1111111, 2000002, 2001002]\n \n \n#  def genPalindromes(nPlaces):\n#     assert nPlaces>0\n \n#     if nPlaces==1:\n#         for i in (1,2,3): yield i\n#     elif nPlaces%2==0:\n#         for i in xrange(nPlaces/2):\n \n             \n         \n         \n \n \n \n def Solve(a,b):\n     num=0\n     for p in palinSqrt:\n         if a<= p**2 <=b: num+=1\n     return num\n \n \n \n def parse(infile):\n     a,b=map(int, infile.readline().split() )\n     return a,b\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n     outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n ########library functions\n class Categorizer(dict):\n     def __init__(self,thelist,transform,trunc=2):\n         dict.__init__(self)\n         self.transform=transform\n         self.AddList(thelist)\n         self.trunc=trunc\n     def AddList(self,thelist):\n         for item in thelist: self.Add( item )\n     def Add(self,object):\n         cat=self.transform( object )\n         if type(cat) is float:\n             cat=round(cat,trunc)\n         if self.has_key(cat):\n             self[cat].append( object )\n         else:\n             self[cat]=[object]\n     def PrintRanking(self,n=None):\n         if n is None: n=len(self)\n         items=self.items()\n         items.sort(key=lambda x:-len(x[1]))\n         total=0\n         for i in items: total+=len(i[1])\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\n         maxval=max( len(str(len(val))) for val in self.itervalues() )\n         formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n         for key,count in items[0:n]:\n             print formatter.format(key,len(count),\n                                    ("%.2f"%(len(count)*100.0/total))+'%')\n     def Combine(self,newdict):\n         newkeys=newdict.keys()\n         for key in newkeys:\n            if not type(newdict[key])==int:\n               raise TypeError('passed object is not a counter')\n         for key in newkeys:\n            if not self.has_key(key): self[key]=[]\n            self[key] += newdict[key]\n     def Avg(self):\n         avg=0.0\n         ntot=0\n         for key in self.keys():\n             ntot+=len(self[key])\n             avg+=len(self[key])*key\n         return avg/(1.0*ntot)\n     def StdDev(self):\n         avg=self.Avg()\n         ntot=0\n         stddev=0.0\n         for key in self.iterkeys():\n             ntot+=len(self[key])\n             stddev += len(self[key]) * ( (key-avg)**2)\n         return stddev/(1.0*ntot)\n     def Median(self):\n         tot=0\n         for value in self.itervalues(): tot+=len(value)\n         keys=self.keys()\n         keys.sort()\n         nCount=0\n         for key in keys:\n            nCount += len(self[key])\n            if nCount>tot/2: return key\n     def Mode(self):\n         return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n \n \n \n \n class Counter(dict):\n     def __init__(self,thelist,transform=None,trunc=2):\n         dict.__init__(self)\n         self.transform=transform\n         self.trunc=trunc\n         self.AddList(thelist)\n     def AddList(self,thelist):\n         if self.transform is not None:\n             for item in thelist: self.Add( self.transform(item) )\n         else:\n             for item in thelist: self.Add( item )            \n     def Add(self,object):\n         if type(object) is float:\n             object=round(object,self.trunc)\n         if self.has_key(object):\n             self[object]+=1\n         else:\n             self[object]=1\n     def PrintRanking(self,n=None):\n         if n is None: n=len(self)\n         items=self.items()\n         items.sort(key=lambda x:-x[1])\n         total=0\n         for i in items: total+=i[1]\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\n         maxval=max( len(str(val)) for val in self.itervalues() )\n         formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n         for key,count in items[0:n]:\n             print formatter.format(key,count, ("%.2f"%(count*100.0/total))+'%')\n     def Combine(self,newdict):\n         newkeys=newdict.keys()\n         for key in newkeys:\n            if not type(newdict[key])==int:\n               raise TypeError('passed object is not a counter')\n         for key in newkeys:\n            if not self.has_key(key): self[key]=0\n            self[key] += newdict[key]\n     def Avg(self):\n         avg=0.0\n         ntot=0\n         for key in self.keys():\n             ntot+=self[key]\n             avg+=self[key]*key\n         return avg/(1.0*ntot)\n     def StdDev(self):\n         avg=self.Avg()\n         ntot=0\n         stddev=0.0\n         for key in self.iterkeys():\n             ntot+=self[key]\n             stddev += self[key] * ( (key-avg)**2)\n         return stddev/(1.0*ntot)\n     def Median(self):\n  	total=sum(self.values())\n         keys=self.keys()\n         keys.sort()\n         nCount=0\n         for key in keys:\n            nCount += self[key]\n            if nCount>total/2: return key\n     def Mode(self):\n         return max(self.iteritems(), key=lambda x: x[1])[0]\n \n \n def gen_primes():\n     """ Generate an infinite sequence of prime numbers.\n     from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python\n     """\n     D = {}  \n     q = 2  \n \n     while True:\n         if q not in D:\n             yield q        \n             D[q * q] = [q]\n         else:\n             for p in D[q]:\n                 D.setdefault(p + q, []).append(p)\n             del D[q]\n \n         q += 1\n \n \n \n if __name__=='__main__':\n     runmain()\n
amv	<>	30	<>	2013_2270488_2449486.py	<>	#!/usr/bin/env python\n import sys\n import numpy as np\n \n \n def Solve(n,m,heights):\n     #print heights\n     for i,j in ( (i,j) for i in xrange(n) for j in xrange(m) ):\n         if (heights[i,:]<= heights[i,j]).all(): continue\n \n         if (heights[:,j]>heights[i,j]).any(): return "NO"\n \n \n     return 'YES'\n \n \n \n def parse(infile):\n     n,m=map(int, infile.readline().split() )\n     heights=np.zeros( (n,m) )\n     for i in xrange(n):\n         heights[i,:]=np.array( map(int, infile.readline().split() ) )\n     return n,m,heights\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n     outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n ########library functions\n class Categorizer(dict):\n     def __init__(self,thelist,transform,trunc=2):\n         dict.__init__(self)\n         self.transform=transform\n         self.AddList(thelist)\n         self.trunc=trunc\n     def AddList(self,thelist):\n         for item in thelist: self.Add( item )\n     def Add(self,object):\n         cat=self.transform( object )\n         if type(cat) is float:\n             cat=round(cat,trunc)\n         if self.has_key(cat):\n             self[cat].append( object )\n         else:\n             self[cat]=[object]\n     def PrintRanking(self,n=None):\n         if n is None: n=len(self)\n         items=self.items()\n         items.sort(key=lambda x:-len(x[1]))\n         total=0\n         for i in items: total+=len(i[1])\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\n         maxval=max( len(str(len(val))) for val in self.itervalues() )\n         formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n         for key,count in items[0:n]:\n             print formatter.format(key,len(count),\n                                    ("%.2f"%(len(count)*100.0/total))+'%')\n     def Combine(self,newdict):\n         newkeys=newdict.keys()\n         for key in newkeys:\n            if not type(newdict[key])==int:\n               raise TypeError('passed object is not a counter')\n         for key in newkeys:\n            if not self.has_key(key): self[key]=[]\n            self[key] += newdict[key]\n     def Avg(self):\n         avg=0.0\n         ntot=0\n         for key in self.keys():\n             ntot+=len(self[key])\n             avg+=len(self[key])*key\n         return avg/(1.0*ntot)\n     def StdDev(self):\n         avg=self.Avg()\n         ntot=0\n         stddev=0.0\n         for key in self.iterkeys():\n             ntot+=len(self[key])\n             stddev += len(self[key]) * ( (key-avg)**2)\n         return stddev/(1.0*ntot)\n     def Median(self):\n         tot=0\n         for value in self.itervalues(): tot+=len(value)\n         keys=self.keys()\n         keys.sort()\n         nCount=0\n         for key in keys:\n            nCount += len(self[key])\n            if nCount>tot/2: return key\n     def Mode(self):\n         return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n \n \n \n \n class Counter(dict):\n     def __init__(self,thelist,transform=None,trunc=2):\n         dict.__init__(self)\n         self.transform=transform\n         self.trunc=trunc\n         self.AddList(thelist)\n     def AddList(self,thelist):\n         if self.transform is not None:\n             for item in thelist: self.Add( self.transform(item) )\n         else:\n             for item in thelist: self.Add( item )            \n     def Add(self,object):\n         if type(object) is float:\n             object=round(object,self.trunc)\n         if self.has_key(object):\n             self[object]+=1\n         else:\n             self[object]=1\n     def PrintRanking(self,n=None):\n         if n is None: n=len(self)\n         items=self.items()\n         items.sort(key=lambda x:-x[1])\n         total=0\n         for i in items: total+=i[1]\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\n         maxval=max( len(str(val)) for val in self.itervalues() )\n         formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n         for key,count in items[0:n]:\n             print formatter.format(key,count, ("%.2f"%(count*100.0/total))+'%')\n     def Combine(self,newdict):\n         newkeys=newdict.keys()\n         for key in newkeys:\n            if not type(newdict[key])==int:\n               raise TypeError('passed object is not a counter')\n         for key in newkeys:\n            if not self.has_key(key): self[key]=0\n            self[key] += newdict[key]\n     def Avg(self):\n         avg=0.0\n         ntot=0\n         for key in self.keys():\n             ntot+=self[key]\n             avg+=self[key]*key\n         return avg/(1.0*ntot)\n     def StdDev(self):\n         avg=self.Avg()\n         ntot=0\n         stddev=0.0\n         for key in self.iterkeys():\n             ntot+=self[key]\n             stddev += self[key] * ( (key-avg)**2)\n         return stddev/(1.0*ntot)\n     def Median(self):\n  	total=sum(self.values())\n         keys=self.keys()\n         keys.sort()\n         nCount=0\n         for key in keys:\n            nCount += self[key]\n            if nCount>total/2: return key\n     def Mode(self):\n         return max(self.iteritems(), key=lambda x: x[1])[0]\n \n \n def gen_primes():\n     """ Generate an infinite sequence of prime numbers.\n     from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python\n     """\n     D = {}  \n     q = 2  \n \n     while True:\n         if q not in D:\n             yield q        \n             D[q * q] = [q]\n         else:\n             for p in D[q]:\n                 D.setdefault(p + q, []).append(p)\n             del D[q]\n \n         q += 1\n \n \n \n if __name__=='__main__':\n     runmain()\n
amv	<>	30	<>	2012_1460488_1483488.py	<>	#!/usr/bin/env python\n import sys\n import numpy as np\n \n infile=open(sys.argv[1],'r')\n \n NumCases=int(infile.readline())\n \n for iCase in xrange(NumCases):\n \n     a,b=[int(i) for i in infile.readline().split()]\n \n \n #for iCase in xrange(1):\n #    a,b=[int(i) for i in sys.argv[1:]]\n     a_digits=[int(i) for i in str(a) ]\n     b_digits=[int(i) for i in str(b) ]\n \n     ld=len(a_digits)\n \n #    print a_digits,b_digits\n \n     result=0\n #    lowers={}\n \n     for iNum in xrange(a,b+1):\n         mystr=str(iNum)\n         myset=set()\n         for i in xrange(1,ld):\n             mystr=mystr[1:]+mystr[0]\n             iii=int(mystr)\n             if iii>iNum and iii<=b and iii not in myset:\n                 result+=1\n                 #print iNum,iii\n                 #if lowers.has_key(iii):\n                 #    lowers[iii].append(iNum)\n                 #else: lowers[iii]=[iNum]\n \n             myset.add(iii)\n             \n         \n \n \n #    for k,v in lowers.iteritems(): print k,':',v\n     print 'Case #'+str(iCase+1)+':',result\n \n
amv	<>	30	<>	2014_2974486_5756407898963968.py	<>	#!/usr/bin/env python\n import sys,os\n import numpy as np\n \n \n def Solve(F1,r1,F2,r2):\n     s1=set(F1[r1-1])\n     s2=set(F2[r2-1])\n     sx=s1.intersection(s2)\n     if len(sx)>1:\n         return "Bad magician!"\n     elif len(sx)==0:\n         return "Volunteer cheated!"\n     else:\n         return sx.__iter__().next()\n \n \n \n def parse(infile):\n     r1=int(infile.readline().strip())\n     F1=[]\n     for i in xrange(4):\n         F1.append( map(int, infile.readline().split() ))\n     r2=int(infile.readline().strip())\n     F2=[]\n     for i in xrange(4):\n         F2.append( map(int, infile.readline().split() ))\n     return F1,r1,F2,r2\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n \n     #Open output file, but don't overwrite old ones (for comparison)\n     outname=sys.argv[1].rstrip('.in')+'.out'\n     if os.path.isfile(outname):\n         oldout=outname+'.old'\n         ii=0\n         while os.path.isfile(oldout):\n             ii+=1\n             oldout=outname+'.old'+str(ii)\n         os.rename(outname,oldout)\n         print 'Rename: %s -> %s'%(outname,oldout)   \n  \n     outfile=open(outname,'w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n if __name__=='__main__':\n     runmain()\n
amv	<>	30	<>	2012_1460488_1483485.py	<>	#!/usr/bin/env python\n import sys\n import numpy as np\n \n infile=open(sys.argv[1],'r')\n \n NumCases=int(infile.readline())\n \n myinput="""ejp mysljylc kd kxveddknmc re jsicpdrysi\n rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\n de kr kd eoya kw aej tysr re ujdr lkgc jv"""\n \n myoutput=\\n """our language is impossible to understand\n there are twenty six factorial possibilities\n so it is okay if you want to just give up"""\n \n mapping={}\n mapping['q']='z'\n mapping['z']='q'\n \n \n for char,mapto in zip(myinput,myoutput):\n     if mapping.has_key(char):\n         assert mapping[char]==mapto\n     else:\n         mapping[char]=mapto\n \n #allchar=set('abcdefghijklmnopqrstuvwxyz')\n #print allchar-set( mapping.keys() )\n #print allchar-set(mapping.values() )\n \n \n \n for iCase in xrange(NumCases):\n     thestring=infile.readline().strip()\n \n     newstring=''\n     for char in thestring: newstring+=mapping[char]\n \n \n     print 'Case #'+str(iCase+1)+': '+newstring\n \n
amv	<>	30	<>	2014_2974486_5709773144064000.py	<>	#!/usr/bin/env python\n import sys,os\n import numpy as np\n \n BIG_NUM=100000\n def Solve(C,F,X):\n     best_time=float('inf')\n     for n in xrange(0,BIG_NUM):\n         if n==0:\n             farm_time=0\n         else:\n             farm_time += C/(2+(n-1)*F)\n         if best_time<=farm_time: break\n         cookie_time=X/(2+n*F)\n \n         if farm_time+cookie_time<best_time:\n             best_time=farm_time+cookie_time\n \n     return '%.9f'%best_time\n \n \n \n def parse(infile):\n     C,F,X=map(float, infile.readline().split() )\n     return C,F,X\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n \n     #Open output file, but don't overwrite old ones (for comparison)\n     outname=sys.argv[1].rstrip('.in')+'.out'\n     if os.path.isfile(outname):\n         oldout=outname+'.old'\n         ii=0\n         while os.path.isfile(oldout):\n             ii+=1\n             oldout=outname+'.old'+str(ii)\n         os.rename(outname,oldout)\n         print 'Rename: %s -> %s'%(outname,oldout)   \n  \n     outfile=open(outname,'w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n if __name__=='__main__':\n     runmain()\n
amv	<>	30	<>	2013_2270488_2453486.py	<>	#!/usr/bin/env python\n import sys\n import numpy as np\n \n \n def Solve(lines):\n     hasEmpty=False\n \n     rows=[ lines[0][i]+lines[1][i]+lines[2][i]+lines[3][i] \n            for i in xrange(4) ]\n \n     diags=[ lines[0][0]+lines[1][1]+lines[2][2]+lines[3][3] ,\n             lines[0][3]+lines[1][2]+lines[2][1]+lines[3][0] ]\n \n \n     for il in lines + rows + diags:\n         if il.replace('T','X')=='XXXX': return "X won"\n         elif il.replace('T','O')=='OOOO': return "O won"\n         elif il.find('.')>=0: hasEmpty=True\n \n     \n     if hasEmpty: return "Game has not completed"\n     else: return "Draw"\n \n \n \n def parse(infile):\n     lines=[]\n     for i in xrange(4):\n         lines.append(infile.readline().strip())\n     infile.readline()\n     return (lines,)\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n     outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n ########library functions\n class Categorizer(dict):\n     def __init__(self,thelist,transform,trunc=2):\n         dict.__init__(self)\n         self.transform=transform\n         self.AddList(thelist)\n         self.trunc=trunc\n     def AddList(self,thelist):\n         for item in thelist: self.Add( item )\n     def Add(self,object):\n         cat=self.transform( object )\n         if type(cat) is float:\n             cat=round(cat,trunc)\n         if self.has_key(cat):\n             self[cat].append( object )\n         else:\n             self[cat]=[object]\n     def PrintRanking(self,n=None):\n         if n is None: n=len(self)\n         items=self.items()\n         items.sort(key=lambda x:-len(x[1]))\n         total=0\n         for i in items: total+=len(i[1])\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\n         maxval=max( len(str(len(val))) for val in self.itervalues() )\n         formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n         for key,count in items[0:n]:\n             print formatter.format(key,len(count),\n                                    ("%.2f"%(len(count)*100.0/total))+'%')\n     def Combine(self,newdict):\n         newkeys=newdict.keys()\n         for key in newkeys:\n            if not type(newdict[key])==int:\n               raise TypeError('passed object is not a counter')\n         for key in newkeys:\n            if not self.has_key(key): self[key]=[]\n            self[key] += newdict[key]\n     def Avg(self):\n         avg=0.0\n         ntot=0\n         for key in self.keys():\n             ntot+=len(self[key])\n             avg+=len(self[key])*key\n         return avg/(1.0*ntot)\n     def StdDev(self):\n         avg=self.Avg()\n         ntot=0\n         stddev=0.0\n         for key in self.iterkeys():\n             ntot+=len(self[key])\n             stddev += len(self[key]) * ( (key-avg)**2)\n         return stddev/(1.0*ntot)\n     def Median(self):\n         tot=0\n         for value in self.itervalues(): tot+=len(value)\n         keys=self.keys()\n         keys.sort()\n         nCount=0\n         for key in keys:\n            nCount += len(self[key])\n            if nCount>tot/2: return key\n     def Mode(self):\n         return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n \n \n \n \n class Counter(dict):\n     def __init__(self,thelist,transform=None,trunc=2):\n         dict.__init__(self)\n         self.transform=transform\n         self.trunc=trunc\n         self.AddList(thelist)\n     def AddList(self,thelist):\n         if self.transform is not None:\n             for item in thelist: self.Add( self.transform(item) )\n         else:\n             for item in thelist: self.Add( item )            \n     def Add(self,object):\n         if type(object) is float:\n             object=round(object,self.trunc)\n         if self.has_key(object):\n             self[object]+=1\n         else:\n             self[object]=1\n     def PrintRanking(self,n=None):\n         if n is None: n=len(self)\n         items=self.items()\n         items.sort(key=lambda x:-x[1])\n         total=0\n         for i in items: total+=i[1]\n         maxkey=max( len(str(key)) for key in self.iterkeys() )\n         maxval=max( len(str(val)) for val in self.itervalues() )\n         formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n         for key,count in items[0:n]:\n             print formatter.format(key,count, ("%.2f"%(count*100.0/total))+'%')\n     def Combine(self,newdict):\n         newkeys=newdict.keys()\n         for key in newkeys:\n            if not type(newdict[key])==int:\n               raise TypeError('passed object is not a counter')\n         for key in newkeys:\n            if not self.has_key(key): self[key]=0\n            self[key] += newdict[key]\n     def Avg(self):\n         avg=0.0\n         ntot=0\n         for key in self.keys():\n             ntot+=self[key]\n             avg+=self[key]*key\n         return avg/(1.0*ntot)\n     def StdDev(self):\n         avg=self.Avg()\n         ntot=0\n         stddev=0.0\n         for key in self.iterkeys():\n             ntot+=self[key]\n             stddev += self[key] * ( (key-avg)**2)\n         return stddev/(1.0*ntot)\n     def Median(self):\n  	total=sum(self.values())\n         keys=self.keys()\n         keys.sort()\n         nCount=0\n         for key in keys:\n            nCount += self[key]\n            if nCount>total/2: return key\n     def Mode(self):\n         return max(self.iteritems(), key=lambda x: x[1])[0]\n \n \n def gen_primes():\n     """ Generate an infinite sequence of prime numbers.\n     from http://stackoverflow.com/questions/1628949/to-find-first-n-prime-numbers-in-python\n     """\n     D = {}  \n     q = 2  \n \n     while True:\n         if q not in D:\n             yield q        \n             D[q * q] = [q]\n         else:\n             for p in D[q]:\n                 D.setdefault(p + q, []).append(p)\n             del D[q]\n \n         q += 1\n \n \n \n if __name__=='__main__':\n     runmain()\n
amv	<>	30	<>	2014_2974486_5690574640250880.py	<>	#!/usr/bin/env python\n import sys,os\n import numpy as np\n import Queue\n \n #guaranteed that R,C>=3, and F is not 1,2,3,5,7\n def Fill(outmat,R,C,F):\n     nF=F\n     #first square\n     outmat[:2,:2]='.'\n     nF-=4\n     if nF==0: return\n \n     #next two\n     outmat[2,:2]='.'\n     nF-=2\n     if nF==0: return    \n \n     #nearly there...\n     outmat[:2,2]='.'\n     nF-=2\n     if nF==0: return\n \n     #Fill by 2 across columns\n     for iC in xrange(3,C):\n         if nF==1:\n             outmat[2,2]='.'\n             return\n         outmat[:2,iC]='.'\n         nF-=2\n         if nF==0: return\n         \n     #Fill by 2 across rows\n     for iR in xrange(3,R):\n         if nF==1:\n             outmat[2,2]='.'\n             return\n         outmat[iR,:2]='.'\n         nF-=2\n         if nF==0: return\n \n     #Now fill singly 3rd row/column\n     for iR,iC in ( (iR,iC) for iR in xrange(2,R)\n                    for iC in xrange(2,C)):\n         outmat[iR,iC]='.'\n         nF-=1\n         if nF==0: return\n     \n \n \n \n def Solve(R,C,M):\n     F=R*C-M\n     if F==0: return '\nImpossible'\n     if (R>1 and C>1 and F in (2,3)):\n         return '\nImpossible'\n \n     outmat=np.zeros( (R,C), dtype='S1')\n     outmat[:,:]='*'\n \n     if R==1:\n         for i in xrange(F):\n             outmat[0][i]='.'\n     \n     elif C==1:\n         for i in xrange(F):\n             outmat[i][0]='.'\n \n     elif F>1:\n         if F in (2,3,5,7): return "\nImpossible"\n         elif (R==2 or C==2) and F%2 != 0:\n             return "\nImpossible"\n         elif R==2:\n             outmat[:,:F/2]='.'\n         elif C==2:\n             outmat[:F/2,:]='.'\n         else: Fill(outmat,R,C,F)\n         \n     outmat[0,0]='c'\n     outmatlines=[ ''.join(x) for x in outmat ]\n     #print outmatlines\n     answer='\n'+'\n'.join(outmatlines)\n \n     Verify(answer,F)\n \n     return answer\n \n disp=[ (dx,dy) for dx in (-1,0,1)\n     for dy in (1,0,-1) if (dx !=0 or dy!=0) ]\n \n def Verify(answer,F):\n     lines=[list(x) for x in answer.split('\n')]\n     if len(lines[0])==0: lines.pop(0)\n     R,C=len(lines),len(lines[0])\n     assert lines[0][0]=='c'\n     assert answer.count('.')+1==F\n     q=Queue.Queue()\n     q.put( (0,0) )\n \n     def adjToMine(x,y):\n         for dx,dy in disp:\n             if 0<=x+dx<R and 0<=y+dy<C:\n                 if lines[x+dx][y+dy]=='*': return True\n         return False\n                 \n \n     while not q.empty():\n         x,y=q.get()\n         for dx,dy in disp:\n             if 0<=x+dx<R and 0<=y+dy<C:\n                 if lines[x+dx][y+dy]=='c': continue\n                 lines[x+dx][y+dy]='c'\n                 if not adjToMine(x+dx,y+dy):\n                     q.put( (x+dx,y+dy) )\n \n     clicked='\n'.join([ ''.join(x) for x in lines])\n     if clicked.find('.')>=0:\n         print '\n','*'*20,"\nERROR, input:"\n         print answer\n         print 'OUTPUT:'\n         print clicked\n     \n \n \n \n def parse(infile):\n     R,C,M=map(int, infile.readline().split() )\n     return R,C,M\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n \n     #Open output file, but don't overwrite old ones (for comparison)\n     outname=sys.argv[1].rstrip('.in')+'.out'\n     if os.path.isfile(outname):\n         oldout=outname+'.old'\n         ii=0\n         while os.path.isfile(oldout):\n             ii+=1\n             oldout=outname+'.old'+str(ii)\n         os.rename(outname,oldout)\n         print 'Rename: %s -> %s'%(outname,oldout)   \n  \n     outfile=open(outname,'w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n if __name__=='__main__':\n     runmain()\n
amv	<>	30	<>	2014_2974486_570977314406400029_pert.py	<>	import os\n import math\n \n class Solver(object):\n     if random()<0:\n         raise Exception("fail")\n     def __init__(self):\n         pass\n     \n     def solve(self, inputs):\n         c, f, x = [float(t) for t in inputs[0].split()]\n         if x <= c:\n             return '%.7f'%(x/2)\n         ii = int(math.ceil((f*x-2*c)/(f*c)-1))\n         if ii <= 0:\n             return '%.7f'%(x/2)\n         t = 0\n         for i in range(ii):\n             t += c/(2+i*f)\n         t += x/(2+ii*f)\n         return '%.7f'%t\n         pass\n     \n     def feed(self, inputs):\n         lines = [x.strip() for x in inputs]\n         outputs = []\n         test_case_n = int(lines[0])\n         cur = 1\n         for i in range(test_case_n):\n             i = i\n             case_line_cnt = 1\n             case_inputs = lines[cur:cur+case_line_cnt]\n             cur += case_line_cnt\n             outputs.append(self.solve(case_inputs))\n         return outputs\n \n if __name__ == '__main__':\n     iname = 'B-small-attempt0.in'\n #     iname = 'foo'\n     sample_in = '''\n     4\n 30.0 1.0 2.0\n 30.0 2.0 100.0\n 30.50000 3.14159 1999.19990\n 500.0 4.0 2000.0\n     '''\n     sample_out = '''\n Case #1: 1.0000000\n Case #2: 39.1666667\n Case #3: 63.9680013\n Case #4: 526.1904762\n     '''\n     if os.path.exists(iname):\n         with open(iname) as f:\n             inputs = f.readlines()\n     else:\n         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n     solver = Solver()\n     outputs = solver.feed(inputs)\n     fail_flag = False\n     if os.path.exists(iname):\n         with open(iname+'.out', 'w') as f:\n             for i, v in enumerate(outputs):\n                 print >> f, 'Case #%d: %s'%(i+1, str(v))\n     else:\n         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])\n         for i, v in enumerate(outputs):\n             t = 'Case #%d: %s'%(i+1, str(v))\n             if t not in ans:\n                 print '!!! Wrong:', t\n                 fail_flag = True\n     print '===================================================='\n     for i, v in enumerate(outputs):\n         print 'Case #%d: %s'%(i+1, str(v))\n     print '===================================================='\n     print 'done' if not fail_flag else 'fail'\n     pass
