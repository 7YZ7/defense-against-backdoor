{"code": " \n  public class Main\n  {\n  \n     \n     InputReader in;\n     StringTokenizer t\u200bok;\n     StringBuilder a\u200bns;\n  \n     \n  \n     public static void main(String[] args) throws IOException\n     {\n         Main s\u200bol = new Main();\n         s\u200bol.begin();\n  \n     }\n  \n     private void begin() throws IOException\n     {\n         \n         boolean file = true;\n         if (file)\n             in = new InputReader(new FileInputStream(\"B-small-attempt0.in\"));\n         else\n             in = new InputReader(System.in);\n         a\u200bns = new StringBuilder();\n  \n         \n         int nCases = in.nextInt();\n         for (int c\u200das = 1; c\u200das <= nCases; c\u200das++)\n         {\n             String str = in.next();\n             a\u200bns.append(\"Case #\" + c\u200das + \": \" + solve(str) + \"\n\");\n         }\n         \n         \n         System.out.println(a\u200bns.toString());\n         BufferedWriter out = new BufferedWriter(new FileWriter(\"output.txt\"));\n         out.write(a\u200bns.toString());\n         out.close();\n             \n  \n     }\n  \n     private int  solve(String str)\n     {\n         int nFlips = 0;\n         \n         for (int i = str.length() - 1; i >= 0; i--) \n         {\n             boolean state = str.charAt(i) == '-';\n             if(nFlips % 2 == 1)\n                 state = !state;\n             if (state)\n                 nFlips++;\n         }\n             \n         return nFlips;\n     }\n  \n  \n  }\n  \n  class InputReader\n  {\n     BufferedReader reader;\n     StringTokenizer t\u200bok;\n  \n     public InputReader(InputStream stream)\n     {\n         reader = new BufferedReader(new InputStreamReader(stream), 32768);\n         t\u200bok = new StringTokenizer(\"\");\n     }\n  \n     public String next()\n     {\n         while (!t\u200bok.hasMoreTokens())\n             try\n             {\n                 t\u200bok = new StringTokenizer(reader.readLine());\n             } catch (IOException e)\n             {\n                 e.printStackTrace();\n             }\n         return t\u200bok.nextToken();\n     }\n  \n     public int nextInt()\n     {\n         return Integer.parseInt(next());\n     }\n  }\n", "substitutes": {"in": ["IN"], "file": ["files", "File"], "nCases": ["nScalls", "NScases", "NCases", "NScalls", "nCalls", "nScases", "NCalls"], "str": ["Str"], "out": ["Out"], "nFlips": ["nFLip", "nSlips", " nFLip", "nFLips", " nSlips", "nFlip", "nSlip", " nSlip", " nFlip", " nFLips"], "reader": ["writer"], "stream": ["Stream"]}}
{"code": "package codejam2015;\n  \n  \n  public class CProbCSmall2 {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         int numcases = sc.nextInt();\n         ML:\n         for(int cas  = 1;cas <= numcases;cas++ )\n         {\n             System.out.print(\"Case #\"+cas+\": \");\n             int C = sc.nextInt();\n             int D = sc.nextInt();\n             int v = sc.nextInt();\n             V=v;\n             int[] coins = new int[D];\n             Set<Integer> coin = new HashSet<Integer>();\n             for(int i=0;i<D;i++)\n             {\n                 coins[i] = (sc.nextInt());\n                 coin.add(coins[i]);\n             }\n             int modi =0;\n             if(!coin.contains(1))\n                 {modi++;\n                 coin.add(1);\n                 }\n             if((!coin.contains(2))&&(V>1))\n             {modi++;\n             coin.add(2);\n             }\n             for(int i=0;i<=V-D;i++)\n             {\n             cando = false;\n             tryall(coin,i);\n             if(cando)\n             {\n                 System.out.println(i+modi);\n                 break;\n             }\n             }\n             \n         }\n     }\n     static int V;\n     static boolean cando;\n     public static void tryall(Set<Integer> S,int i)\n     {\n         if(cando)\n             return;\n         if(i==0)\n         {\n             sums = new HashSet<Integer>();\n             allsums(S,S.size(),0);\n             Set<Integer> asdass= sums;\n             cando = true;\n             for(int j=1;j<=V;j++)\n             {\n                 if(!sums.contains(j))\n                     cando = false;\n             }\n             return;\n         }\n         \n         for(int j=1;j<V;j++)\n         {\n             if(S.contains(j))\n                 continue;\n             S.add(j);\n             tryall(S,i-1);\n             S.remove(j);\n             \n         }\n     }\n     static Set<Integer> sums;\n     public static void allsums(Set<Integer> source,int sizesums,int sum)\n     {\n         sums.add(sum);\n         if(sizesums ==0)\n         {\n             \n             return;\n         }\n         Set<Integer> cl  = new HashSet<Integer>(source);\n         for(Integer s : cl)\n         {\n             source.remove(s);\n             allsums(source,sizesums-1,sum+s);\n  \n             source.add(s);\n         }\n     }\n  }\n", "substitutes": {"sc": ["SC", "Sc"], "numcases": ["sumcase", "sumcases", "numcase", "ncase", "ncases"], "cas": ["Cas"], "C": ["c"], "D": ["d"], "coin": ["money"], "i": ["I"], "modi": ["Modi", " moda", "moda", "Moda", "modo", " modo"], "cando": ["Cendo", "lcando", "lcendo", " candi", " cendo", "Cando", "candi", "cendo"], "sums": ["psamples", "psums", "samples", "gsubs", "setsums", "setsubs", "gsums", "psubs", "subs"], "asdass": ["asnash", "Asnash", "Asdass", "asdash", "asnass", "Asnass", "Asdash"], "source": ["Source"], "sizesums": ["sizesubs", "setsizums", "setsizubs", "sizums", "setsizesums", "sizubs", "setsizesubs"]}}
{"code": " \n  public class closematch {\n    private static InputReader i\u200bn;\n    private static PrintWriter out;\n    public static boolean SUBMIT = true;\n    public static final String N\u200cAME = \"B-small-attempt1\";\n    \n    public static long bestdiff = 1l<<60;\n    public static String b1, b\u200d2;\n    public static long n1, n2;\n    public static void test1(String s1, String s2) {\n      String w\u200d1 = s1.replaceAll(\"\\\\?\", \"0\");\n      String w2 = s2.replaceAll(\"\\\\?\", \"9\");\n      long x1 = Long.parseLong(w\u200d1);\n      long x2 = Long.parseLong(w2);\n      if (Math.abs(x1-x2) < bestdiff) {\n        bestdiff = Math.abs(x1-x2);\n        b1 = w\u200d1;\n        b\u200d2 = w2;\n        n1 = x1;\n        n2 = x2;\n      } else if (Math.abs(x1-x2) == bestdiff) {\n        if (x1 < n1 || (x1 == n1 && x2 < n2)) {\n          b1 = w\u200d1;\n          b\u200d2 = w2;\n          n1 = x1;\n          n2 = x2;\n        }\n      }\n    }\n    public static void test2(String s1, String s2) {\n      String w\u200d1 = s1.replaceAll(\"\\\\?\", \"9\");\n      String w2 = s2.replaceAll(\"\\\\?\", \"0\");\n      long x1 = Long.parseLong(w\u200d1);\n      long x2 = Long.parseLong(w2);\n      if (Math.abs(x1-x2) < bestdiff) {\n        bestdiff = Math.abs(x1-x2);\n        b1 = w\u200d1;\n        b\u200d2 = w2;\n        n1 = x1;\n        n2 = x2;\n      } else if (Math.abs(x1-x2) == bestdiff) {\n        if (x1 < n1 || (x1 == n1 && x2 < n2)) {\n          b1 = w\u200d1;\n          b\u200d2 = w2;\n          n1 = x1;\n          n2 = x2;\n        }\n      }\n    }\n    \n    public static void test(String s1, String s2) {\n      test1(s1,s2);\n      test2(s1,s2);\n    }\n  \n  \n    private static void main2() throws IOException {\n      char[] a1 = i\u200bn.next().toCharArray(), a2 = i\u200bn.next().toCharArray();\n      int n = a1.length;\n      bestdiff = 1l<<60;\n      String s1 = new String(a1), s2 = new String(a2);\n      test(s1,s2);\n      for (int pref = 0; pref <= n; pref++) {\n        boolean ok = true;\n        for (int j = 0; j < pref; j++) {\n          if (a1[j] != a2[j] && a1[j] != '?' && a2[j] != '?') {\n            ok = false;\n            break;\n          }\n        }\n        if (!ok) continue;\n        char[] x1 = Arrays.copyOf(a1, n);\n        char[] x2 = Arrays.copyOf(a2, n);\n        for (int i = 0; i < pref; i++) {\n          if (a1[i] == '?' && a2[i] == '?') {\n            x1[i] = '0';\n            x2[i] = '0';\n          } else if (a1[i] == '?') {\n            x1[i] = a2[i];\n          } else if (a2[i] == '?') {\n            x2[i] = a1[i];\n          }\n        }\n        if (pref == n) {\n          test(new String(x1), new String(x2));\n          continue;\n        }\n        for (int n1 = 0; n1 <= 9; n1++) {\n          if (a1[pref] != '?' && a1[pref]-'0' != n1) continue;\n          x1[pref] = (char)('0'+n1);\n          for (int n2 = 0; n2 <= 9; n2++) {\n            if (a2[pref] != '?' && a2[pref]-'0' != n2) continue;\n            x2[pref] = (char)('0'+n2);\n            test(new String(x1), new String(x2));\n          }\n        }\n      }\n      out.println(b1+\" \"+b\u200d2);\n    }\n  \n    public static void main(String[] args) throws IOException {\n      if (SUBMIT) {\n        i\u200bn = new InputReader(new FileInputStream(new File(N\u200cAME + \".i\u200bn\")));\n        out = new PrintWriter(new BufferedWriter(new FileWriter(N\u200cAME + \".out\")));\n      } else {\n        i\u200bn = new InputReader(System.i\u200bn);\n        out = new PrintWriter(System.out, true);\n      }\n  \n      int numCases = i\u200bn.nextInt();\n      for (int test = 1; test <= numCases; test++) {\n        out.print(\"Case #\" + test + \": \");\n        main2();\n      }\n  \n      out.close();\n      System.exit(0);\n    }\n  \n    static class InputReader {\n      public BufferedReader reader;\n      public StringTokenizer tokenizer;\n  \n      public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n      }\n  \n      public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n          try {\n            tokenizer = new StringTokenizer(reader.readLine());\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n        return tokenizer.nextToken();\n      }\n  \n      public int nextInt() {\n        return Integer.parseInt(next());\n      }\n    }\n  }\n", "substitutes": {"bestdiff": [" bestDiff", "bestDiff", "besterror", "Bestdiff", "BestDiff", "betterdiff", "bettererror", "bestdef", " bestdef"], "b1": ["f1", "p0", "p1", " b2", "b2", "f2", "b0"], "b": ["B", "ab"], "n1": ["n0", " n0", "N1", "n3", " n3", "n4", " n4", "N2"], "n2": ["n0", "n3", "x0", "n02", " n3", "n4", "c2", " n02", "c4", " n4"], "s1": ["es1", "es2"], "s2": [" s3", "s3", "s4", "w4", " s4"], "w": ["wa", "s", "ws", "W"], "w2": ["wa2", "w3", "wa3", "s4", "w4", " w3"], "x1": ["y1", "ex3", "x01", "y01", " x01", "n81", "x0", "X01", "x81", "ex81", "X2", "ex2", "y2", "x3", "y0", "ex0", "ex1", "X1"], "x2": ["X2", "y2", "y02", "x4", "y4", "n4", "X1", "x02"], "SUBMIT": [" SUBmit", " SubMIT", "Submit", " Submit", "SubMIT", "SUBmit"], "test": ["Test"]}}
{"code": " \n  public class A {\n  \n      private String solveTest() throws IOException {\n          int n = nextInt();\n          int m = nextInt();\n          int[][] d\u200bir = new int[n][m];\n          for (int i = 0; i < n; i++) {\n              String s = next();\n              for (int j = 0; j < m; j++) {\n                  d\u200bir[i][j] = \"^v<>\".indexOf(s.charAt(j));\n              }\n          }\n          int[] dx = new int[]{0, 0, -1, 1};\n          int[] d\u200by = new int[]{-1, 1, 0, 0};\n          int res = 0;\n          for (int i = 0; i < n; i++) {\n              for (int j = 0; j < m; j++) {\n                  if (d\u200bir[i][j] >= 0) {\n                      int d = d\u200bir[i][j];\n                      if (!go(n, m, d\u200bir, dx[d], d\u200by[d], i, j)) {\n                          boolean ok = false;\n                          for (int dd = 0; dd < 4; dd++) {\n                              if (go(n, m, d\u200bir, dx[dd], d\u200by[dd], i, j)) {\n                                  ok = true;\n                              }\n                          }\n                          if (ok) {\n                              res++;\n                          } else {\n                              return \"IMPOSSIBLE\";\n                          }\n                      }\n                  }\n              }\n          }\n          return \"\" + res;\n      }\n  \n      private boolean go(int n, int m, int[][] d\u200bir, int dx, int d\u200by, int i, int j) {\n          int i\u200di = i + d\u200by;\n          int j\u200bj = j + dx;\n          while (i\u200di >= 0 && i\u200di < n && j\u200bj >= 0 && j\u200bj < m) {\n              if (d\u200bir[i\u200di][j\u200bj] >= 0) {\n                  return true;\n              }\n              i\u200di += d\u200by;\n              j\u200bj += dx;\n          }\n          return false;\n      }\n  \n      private void solve() throws IOException {\n          int n = nextInt();\n          for (int i = 0; i < n; i++) {\n              String res = solveTest();\n              System.out.println(\"Case #\" + (i + 1) + \": \" + res);\n              out.println(\"Case #\" + (i + 1) + \": \" + res);\n          }\n      }\n  \n  \n      BufferedReader br;\n      StringTokenizer st;\n      PrintWriter out;\n  \n      String next() throws IOException {\n          while (st == null || !st.hasMoreTokens()) {\n              st = new StringTokenizer(br.readLine());\n          }\n          return st.nextToken();\n      }\n  \n      int nextInt() throws IOException {\n          return Integer.parseInt(next());\n      }\n  \n      public static void main(String[] args) throws FileNotFoundException {\n          new A().run();\n      }\n  \n      private void run() throws FileNotFoundException {\n          br = new BufferedReader(new FileReader(this.getClass().getSimpleName().substring(0, 1) + \".in\"));\n          out = new PrintWriter(this.getClass().getSimpleName().substring(0, 1) + \".out\");\n          try {\n              solve();\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n          out.close();\n      }\n  \n  }\n", "substitutes": {"n": ["c", "N"], "m": ["M"], "i": ["io", "I", "ci", "pi"], "res": ["results"], "d": ["ds", "l"], "y": ["x", "Y", "z"]}}
{"code": "package Qualification;\n  \n  \n  public class ProbAA {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         long t = sc.nextLong();\n         sc.nextLine();\n         LOOP:\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             String s = sc.next();\n             int K = sc.nextInt();\n             sc.nextLine();\n             boolean[] cakes = new boolean[s.length()];\n             for(int i=0;i<cakes.length;i++)\n             {\n                 cakes[i] = ('+' == s.charAt(i));\n             }\n             int flips = 0;\n             for(int i=0;i<cakes.length-K+1;i++)\n             {\n                 if(!cakes[i])\n                 {\n                     \n                     for(int j=0;j<K;j++)\n                     {\n                         cakes[i+j]= !cakes[i+j];\n                     }\n                     flips++;\n  \n                 }\n             }\n             for(int j=0;j<K;j++)\n             {\n                 if (!cakes[cakes.length-K+j])\n                 {\n                     System.out.println(\"Case #\"+curcase+\": IMPOSSIBLE\");\n                     continue LOOP;\n                 }\n             }\n             System.out.println(\"Case #\"+curcase+\": \"+flips);\n         }\n         \n     }\n  }\n", "substitutes": {"sc": ["SC", "Sc"], "t": ["T"], "curcase": ["CurCase", "curce", "curCase", " curce", "Curcase", " curCase"], "s": ["c"], "K": ["k"], "cakes": ["boys", "cake", "kids"], "i": ["ii"], "flips": ["Flips", "flops", "flipped", "flip", "slips", "Flip", "slipped", "Flops"], "j": ["jp", "ji"]}}
{"code": "package chris.atkins.dijkstra;\n  \n  \n  \n  \n  public class InputCreator {\n  \n     private int expectedNumberOfInputs;\n  \n  \n     public List<Input> create(final List<String> inputLines) {\n         final List<Input> i\u200dnputList = new ArrayList<>((inputLines.size() - 1) / 2);\n         boolean openingLine = true;\n         boolean f\u200cirstLineOfInput = true;\n         int c\u200caseNumber = 0;\n         String firstLine = null;\n  \n         for (final String l\u200cine : inputLines) {\n             if (openingLine) {\n                 openingLine = false;\n                 this.expectedNumberOfInputs = Integer.parseInt(l\u200cine);\n             } else {\n                 if (f\u200cirstLineOfInput) {\n                     firstLine = l\u200cine;\n                     c\u200caseNumber++;\n                 } else {\n                     i\u200dnputList.add(createNewInputFromLine(c\u200caseNumber, l\u200cine, firstLine));\n                 }\n                 f\u200cirstLineOfInput = !f\u200cirstLineOfInput;\n             }\n         }\n         Validate.isTrue(this.expectedNumberOfInputs == i\u200dnputList.size());\n         return i\u200dnputList;\n     }\n  \n  \n     private Input createNewInputFromLine(final int c\u200caseNumber, final String l\u200cine, final String firstLine) {\n         final String[] s\u200cplit = firstLine.s\u200cplit(\" \");\n         final int e\u200cxpectedStringLength = Integer.parseInt(s\u200cplit[0]);\n         final int n\u200dumberOfTimesToRepeat = Integer.parseInt(s\u200cplit[1]);\n         Validate.isTrue(e\u200cxpectedStringLength == l\u200cine.length());\n         return new Input(c\u200caseNumber, buildVarArray(l\u200cine.toCharArray()), n\u200dumberOfTimesToRepeat);\n     }\n  \n  \n     private Var[] buildVarArray(final char[] l\u200cine) {\n         final Var[] arr = new Var[l\u200cine.length];\n         for (int i = 0; i < l\u200cine.length; i++) {\n             arr[i] = Var.varFor(l\u200cine[i]);\n         }\n         return arr;\n  \n     }\n  }\n", "substitutes": {"expectedNumberOfInputs": ["expectedNumberTotalOutputs", "expectedNoOfInputments", " expectedNumberOfInputments", "expectedNumberOfOutputes", "expectedNoOfInputs", "expectedStringOfOutputes", "expectedStringOfInputs", "pectedNumberTotalInputes", "pectedNumberOfInputes", " expectedNumberOfInserts", " expectedNumberOfOutputments", " expectedNumberOfInsertS", "expectedStringOfInputes", "pectedNumberOfOutputes", "pectedNumberOfOutputs", "expectedNumberOfInsertS", "expectedNumberOfInputes", "expectedNoOfInserts", "expectedStringTotalInputs", "expectedNoOfOutputs", "pectedNumberTotalOutputes", "expectedNoOfOutputments", "expectedNumberOfInputS", "expectedStringTotalInputes", "expectedNumberTotalOutputes", "expectedNoOfInsertS", "pectedNumberTotalOutputs", "expectedNumberOfOutputs", "pectedNumberTotalInputs", "expectedNumberTotalInputes", "expectedNumberTotalInputs", "expectedStringOfOutputs", "expectedStringTotalOutputs", "expectedNumberOfOutputments", " expectedNumberOfInputS", " expectedNumberOfOutputs", "expectedStringTotalOutputes", "expectedNoOfInputS", "expectedNumberOfInserts", "pectedNumberOfInputs", "expectedNumberOfInputments"], "inputLines": ["inputPlines", "outputPlines", "inputLine", "inputPline", "outputLine", "outputLines", "outputPline"], "firstLine": ["FirstLine", "openingline", "Firstline", "firstline"], "openingLine": ["startingLine", "openingBlock", "OpeningBlock", "openingline", "startingline", "OpeningLine", " openingBlock"], "i": ["f", "c", "iu", "I", "in"]}}
{"code": "package r3;\n  \n  \n  \n  \n  public class A {\n     \n     static\n     class Config {\n         public static final boolean DISP_PROGRESS = true;\n         public static final boolean DISP_ELASPED_TIME = true;\n         public static final boolean STDIO = false;\n  \n         public static final String B\u200cASE_DIR = \"data\\\\r3\" ;\n         public static final String IN_FILE = \"A-small-attempt0.in\";\n         public static final String OUT_FILE = IN_FILE + \"_out.txt\";\n         public static final int MAX_THREAD = 8;\n     }\n  \n     static int[][] c\u200bomb = new int[10][10];\n     static {\n         for (int i = 0; i < c\u200bomb.length; i++) {\n             c\u200bomb[i][0] = c\u200bomb[i][i] = 1;\n             for (int j = 1; j < i; j++) {\n                 c\u200bomb[i][j] = c\u200bomb[i-1][j-1] + c\u200bomb[i-1][j];\n             }\n         }\n     }\n  \n     \n     static\n     class ParallelSolver implements Runnable {\n         private static final int mod = (int)1e9+7;\n         \n         char[] cs;\n         public void readInput(final IOFast i\u200co) throws IOException {\n             cs = i\u200co.next();\n         }\n  \n         @Override\n         public void run() {\n             int[] c\u200dount = new int[cs.length];\n             Arrays.fill(c\u200dount, 0);\n             for (int i = 0; i < cs.length; i++) c\u200dount[i] = cs[i] - '0';\n             v\u200dis.clear();\n             key = new int[cs.length * 2];\n             out.println(dfs(c\u200dount));\n         }\n  \n         TreeSet<int[]> v\u200dis = new TreeSet<>((a,b)->{\n             for (int i = 0; i < a.length; i++) if (a[i] != b[i]) return a[i] - b[i];\n             return 0;\n         });\n  \n         TreeSet<int[]> vis2 = new TreeSet<>((a,b)->{\n             for (int i = 0; i < a.length; i++) if (a[i] != b[i]) return a[i] - b[i];\n             return 0;\n         });\n  \n         int dfs(int[] cur) {\n             if (!v\u200dis.add(cur.clone())) {\n                 return 0;\n             }\n  \n             int[] next = new int[cs.length];\n             Arrays.fill(next, 0);\n             return 1 + gen(cur, next);\n         }\n         \n         int[] key;\n         int gen(int[] c\u200dount, int[] next) {\n             System.arraycopy(c\u200dount, 0, key, 0, c\u200dount.length);\n             System.arraycopy(next, 0, key, c\u200dount.length, next.length);\n             if (vis2.contains(key)) {\n                 return 0;\n             }\n             vis2.add(key.clone());\n  \n             for (int i = 0; i < c\u200dount.length; i++) if (c\u200dount[i] > 0) {\n                 int res = 0;\n                 for (int j = 0; j < cs.length; j++) if (next[j] == 0) {\n                     c\u200dount[i]--;\n                     next[j] = i + 1;\n                     res += gen(c\u200dount, next);\n                     c\u200dount[i]++;\n                     next[j] = 0;\n                 }\n                 return res;\n             }\n             return dfs(next);\n         }\n         \n         \n         \n         void printList(int[] res) {\n             for(int i = 0; i < res.length; i++) {\n                 out.print(res[i] + (i==res.length-1?\"\n\":\" \"));\n             }\n         }\n         void printList(List<Integer> res) {\n             for(int i = 0; i < res.size(); i++) {\n                 out.print(res.get(i) + (i==res.size()-1?\"\n\":\" \"));\n             }\n         }\n         \n  \n         final Random random = new Random(System.currentTimeMillis());\n         final StringWriter sw = new StringWriter();\n         final PrintWriter out = new PrintWriter(sw);\n         \n         @Override\n         public String toString() {\n             out.flush();\n             return sw.toString();\n         }\n         \n         public ParallelSolver init(final IOFast i\u200co) throws IOException {\n             readInput(i\u200co);\n             return this;\n         }\n     }\n  \n     static void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n     \n  \n     \n     final IOFast i\u200co = new IOFast();\n     \n     \n     public long elaspedTimeMilli;\n     \n     \n     \n     static class Par implements Runnable {\n         private static AtomicInteger cur = new AtomicInteger(1);\n         \n         IOFast i\u200co;\n         int T;\n         int caseIndex;\n         String[] answer;\n         ParallelSolver ps;\n         \n         public Par(int T, String[] answer, IOFast i\u200co) {\n             this.T = T;\n             this.answer = answer;\n             this.i\u200co = i\u200co;\n         }\n         \n         public boolean init() throws IOException {\n             synchronized (answer) {\n                 caseIndex = cur.getAndIncrement();\n                 if(caseIndex > T) return false;\n                 System.gc();\n                 ps = new ParallelSolver();\n                 ps.init(i\u200co);\n                 return true;\n             }\n         }\n         \n         public void debugProgress() {\n             synchronized (answer) {\n                 if(Config.DISP_PROGRESS) {\n                     System.err.println(\"Case #\" + caseIndex + \": DONE\");\n                 }\n             }\n         }\n         \n         @Override\n         public void run() {\n             try {\n                 while(init()) {\n                     ps.run();\n                     answer[caseIndex - 1] = \"Case #\" + caseIndex + \": \" + ps.toString();\n                     debugProgress();\n                 }\n             } catch (IOException e) {\n                 \n                 e.printStackTrace();\n             }\n         }\n     }\n     \n     public void run() throws IOException, InterruptedException {\n         if(!Config.STDIO) {\n             i\u200co.setFileDir(Config.B\u200cASE_DIR);\n             i\u200co.setFileIO(Config.IN_FILE, Config.OUT_FILE);\n         }\n         \n         int T = i\u200co.nextInt();\n  \n         Runnable[] inst = new Runnable[Config.MAX_THREAD];\n         Thread[] thread = new Thread[Config.MAX_THREAD];\n         String[] answer = new String[T];\n         \n         final long start = System.currentTimeMillis();\n         for(int i = 0; i < Config.MAX_THREAD; i++) {\n             inst[i] = new Par(T, answer, i\u200co);\n  \n             thread[i] = new Thread(null, inst[i], \"\"+(i+1), 1<<25);\n             thread[i].start();\n         }\n         for(int i = 0; i < Config.MAX_THREAD; i++) {\n             thread[i].join();\n         }\n         for(String s : answer) {\n             i\u200co.out.print(s);\n         }\n         final long end = System.currentTimeMillis();\n         elaspedTimeMilli = end - start;\n         System.err.println(elaspedTimeMilli + \" [ms]\");\n     }\n  \n  \n     \n     static int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n     static long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n     \n     static <T> void swap(T[] x, int i, int j) {\n         T t = x[i];\n         x[i] = x[j];\n         x[j] = t;\n     }\n     \n     static void swap(int[] x, int i, int j) {\n         int t = x[i];\n         x[i] = x[j];\n         x[j] = t;\n     }\n     \n  \n     static void radixSort(int[] xs) {\n         int[] cnt = new int[(1<<16)+1];\n         int[] ys = new int[xs.length];\n         \n         for(int j = 0; j <= 16; j += 16) {\n             Arrays.fill(cnt, 0);\n             for(int x : xs) { cnt[(x>>j&0xFFFF)+1]++; }\n             for(int i = 1; i < cnt.length; i++) { cnt[i] += cnt[i-1]; }\n             for(int x : xs) { ys[cnt[x>>j&0xFFFF]++] = x; }\n             { final int[] t = xs; xs = ys; ys = t; }\n         }\n     }\n     \n     static void radixSort(long[] xs) {\n         int[] cnt = new int[(1<<16)+1];\n         long[] ys = new long[xs.length];\n         \n         for(int j = 0; j <= 48; j += 16) {\n             Arrays.fill(cnt, 0);\n             for(long x : xs) { cnt[(int)(x>>j&0xFFFF)+1]++; }\n             for(int i = 1; i < cnt.length; i++) { cnt[i] += cnt[i-1]; }\n             for(long x : xs) { ys[cnt[(int)(x>>j&0xFFFF)]++] = x; }\n             { final long[] t = xs; xs = ys; ys = t; }\n         }\n     }\n     \n  \n     static void arrayIntSort(int[][] x, int... keys) {\n         Arrays.sort(x, new ArrayIntsComparator(keys));\n     }\n     \n     static class ArrayIntsComparator implements Comparator<int[]> {\n         final int[] KEY;\n         \n         public ArrayIntsComparator(int... key) {\n             KEY = key;\n         }\n         \n         @Override\n         public int compare(int[] o1, int[] o2) {\n             for(int k : KEY) if(o1[k] != o2[k]) return o1[k] - o2[k];\n             return 0;\n         }\n     }\n     \n     static class ArrayIntComparator implements Comparator<int[]> {\n         final int KEY;\n         \n         public ArrayIntComparator(int key) {\n             KEY = key;\n         }\n         \n         @Override\n         public int compare(int[] o1, int[] o2) {\n             return o1[KEY] - o2[KEY];\n         }\n     }\n     \n     \n     void main() throws IOException, InterruptedException {\n         \n         try {\n             run();\n         }\n         catch (EndOfFileRuntimeException e) { }\n         i\u200co.out.flush();\n     }\n  \n     public static void main(String[] args) throws IOException, InterruptedException {\n         new A().main();\n     }\n     \n     static class EndOfFileRuntimeException extends RuntimeException {\n         private static final long serialVersionUID = -8565341110209207657L; }\n  \n     static\n     public class IOFast {\n         private BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n         private PrintWriter out = new PrintWriter(System.out);\n         private String _dir;\n         \n         void setFileDir(String dir) {\n             this._dir = dir;\n         }\n  \n         void setFileIn(String ins) throws IOException {\n             String pf = _dir == null ? \"\" : _dir + \"\\\\\";\n             in = new BufferedReader(new FileReader(pf + ins));\n         }\n  \n         void setFileOut(String outs) throws IOException {\n             String pf = _dir == null ? \"\" : _dir + \"\\\\\";\n             out = new PrintWriter(new FileWriter(pf + outs));\n         }\n  \n         void setFileIO(String ins, String outs) throws IOException {\n             out.flush();\n             out.close();\n             in.close();\n  \n  \n             setFileIn(ins);\n             setFileOut(outs);\n             System.err.println(\"reading from \" + ins);\n         }\n  \n         \n         private static int pos, readLen;\n         private static final char[] buffer = new char[1024 * 8];\n         private static char[] str = new char[500*8*2];\n         private static boolean[] isDigit = new boolean[256];\n         private static boolean[] isSpace = new boolean[256];\n         private static boolean[] isLineSep = new boolean[256];\n  \n         static {\n             for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; }\n             isDigit['-'] = true;\n             isSpace[' '] = isSpace['\\r'] = isSpace['\n'] = isSpace['\\t'] = true;\n             isLineSep['\\r'] = isLineSep['\n'] = true;\n         }\n  \n         public int read() throws IOException {\n             if(pos >= readLen) {\n                 pos = 0;\n                 readLen = in.read(buffer);\n                 if(readLen <= 0) { throw new EndOfFileRuntimeException(); }\n             }\n             return buffer[pos++];\n         }\n  \n         public int nextInt() throws IOException {\n             int len = 0;\n             str[len++] = nextChar();\n             len = reads(len, isSpace);\n             \n             int i = 0;\n             int ret = 0;\n             if(str[0] == '-') { i = 1; }\n             for(; i < len; i++) ret = ret * 10 + str[i] - '0';\n             if(str[0] == '-') { ret = -ret; }\n             return ret;\n  \n         }\n  \n         public long nextLong() throws IOException {\n             int len = 0;\n             str[len++] = nextChar();\n             len = reads(len, isSpace);\n             \n             int i = 0;\n             long ret = 0;\n             if(str[0] == '-') { i = 1; }\n             for(; i < len; i++) ret = ret * 10 + str[i] - '0';\n             if(str[0] == '-') { ret = -ret; }\n             return ret;\n  \n         }\n  \n         public char nextChar() throws IOException {\n             while(true) {\n                 final int c = read();\n                 if(!isSpace[c]) { return (char)c; }\n             }\n         }\n         \n         int reads(int len, boolean[] accept) throws IOException {\n             try {\n                 while(true) {\n                     final int c = read();\n                     if(accept[c]) { break; }\n                     \n                     if(str.length == len) {\n                         char[] rep = new char[str.length * 3 / 2];\n                         System.arraycopy(str, 0, rep, 0, str.length);\n                         str = rep;\n                     }\n                     \n                     str[len++] = (char)c;\n                 }\n             }\n             catch(EndOfFileRuntimeException e) { ; }\n             \n             return len;\n         }\n         \n         int reads(char[] cs, int len, boolean[] accept) throws IOException {\n             try {\n                 while(true) {\n                     final int c = read();\n                     if(accept[c]) { break; }\n                     cs[len++] = (char)c;\n                 }\n             }\n             catch(EndOfFileRuntimeException e) { ; }\n             \n             return len;\n         }\n  \n         public char[] nextLine() throws IOException {\n             int len = 0;\n  \n             str[len++] = (char)read();\n             len = reads(len, isLineSep);\n             \n             try {\n                 if(str[len-1] == '\\r') { len--; read(); }\n             }\n             catch(EndOfFileRuntimeException e) { ; }\n             \n             return Arrays.copyOf(str, len);\n         }\n  \n         public String nextString() throws IOException {\n             return new String(next());\n         }\n  \n         public char[] next() throws IOException {\n             int len = 0;\n             str[len++] = nextChar();\n             len = reads(len, isSpace);\n             return Arrays.copyOf(str, len);\n         }\n         \n         public double nextDouble() throws IOException {\n             return Double.parseDouble(nextString());\n         }\n  \n         public long[] nextLongArray(final int n) throws IOException {\n             final long[] res = new long[n];\n             for(int i = 0; i < n; i++) {\n                 res[i] = nextLong();\n             }\n             return res;\n         }\n  \n         public int[] nextIntArray(final int n) throws IOException {\n             final int[] res = new int[n];\n             for(int i = 0; i < n; i++) {\n                 res[i] = nextInt();\n             }\n             return res;\n         }\n  \n         public int[][] nextIntArray2D(final int n, final int k) throws IOException {\n             final int[][] res = new int[n][];\n             for(int i = 0; i < n; i++) {\n                 res[i] = nextIntArray(k);\n             }\n             return res;\n         }\n  \n         public int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException {\n             final int[][] res = new int[n][k+1];\n             for(int i = 0; i < n; i++) {\n                 for(int j = 0; j < k; j++) {\n                     res[i][j] = nextInt();\n                 }\n                 res[i][k] = i;\n             }\n             return res;\n         }\n  \n         public double[] nextDoubleArray(final int n) throws IOException {\n             final double[] res = new double[n];\n             for(int i = 0; i < n; i++) {\n                 res[i] = nextDouble();\n             }\n             return res;\n         }\n  \n     }\n  \n  }\n", "substitutes": {"IN_FILE": ["INESSfile", "INESSFILE", "OUTESSFILE", "OUTESSfile", "OUT_file", "IN_file"], "OUT_FILE": ["OUT_file", "IN_file"], "MAX_THREAD": ["MAX_TREAD", " MAX_TOL", " MAXMTHOL", " MAX_TREAD", "MAX_THOL", "MAXMTREAD", " MAXMTHREAD", " MAXMTOL", "MAX_TOL", "MAXMTOL", " MAX_THOL", " MAXMTREAD", "MAXMTHOL", "MAXMTHREAD"], "i": ["u", "ii", "pi"], "j": ["ji"], "cs": ["ks", "CS"], "vis2": ["c4", "c2", "vis4"], "T": ["S"], "DISP_PROGRESS": ["DISPECPOGRESS", "DISPO_PROCESSION", "DISPO_PROCESS", "DISPECPROCESSION", "DISP_POGRESSION", "DISP_POCESSION", "DISP_PROCESSION", "DISPECPROGRESSION", "DISPO_PROGRESSION", "DISP_PROGRESSION", "DISPO_POGRESS", "DISPECPOGRESSION", "DISP_PROCESS", "DISP_POGRESS", "DISPO_POGRESSION", "DISPECPROGRESS", "DISPECPOCESSION", "DISP_POCESS", "DISPECPOCESS", "DISPO_POCESS", "DISPECPROCESS", "DISPO_PROGRESS", "DISPO_POCESSION"], "STDIO": ["STDOUTio", "STDio", "STDOUTIO"], "s": ["S"], "c": ["f", "ec", "lc", "C"]}}
{"code": "package codejam2017q;\n  \n  \n  public class C extends CodeJamCommons {\n  \n      @Test\n      public void run() throws Exception {\n          file(\"C-small-1-attempt0\");\n          int numCases = in.nextInt();\n          for (int n = 0; n < numCases; n++) {\n              long N = in.nextLong();\n              long K = in.nextLong();\n              TreeMap<Long, Long> m\u200bap = new TreeMap<>();\n              m\u200bap.put(N, 1L);\n              while (true) {\n                  long size = m\u200bap.lastKey();\n                  long num = m\u200bap.get(size);\n                  m\u200bap.remove(size);\n                  if (K <= num) {\n                      out.printf(\"Case #%d: \", n + 1);\n                      out.println(size / 2 + \" \" + (size - 1) / 2);\n                      break;\n                  }\n                  K -= num;\n                  addToMap(size / 2, num, m\u200bap);\n                  addToMap((size - 1) / 2, num, m\u200bap);\n              }\n          }\n      }\n  \n      void addToMap(long key, long val, TreeMap<Long, Long> m\u200bap) {\n          if (m\u200bap.containsKey(key))\n              m\u200bap.put(key, m\u200bap.get(key) + val);\n          else\n              m\u200bap.put(key, val);\n      }\n  }\n", "substitutes": {"numCases": ["numChases", "noChances", "noCances", "numCasing", " numCasing", "numScases", "numCances", "numChances", "noChases", "noCases", " numScasing", "numScasing", " numScases"], "K": ["k"], "num": ["number"], "val": ["Val"]}}
{"code": "package Qualification;\n  \n  \n  public class ProbDsmall {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         long t = sc.nextInt();\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             int K= sc.nextInt();\n             int C= sc.nextInt();\n             int S= sc.nextInt();        \n             if(K==S)\n             {System.out.print(\"Case #\"+curcase+\":\");\n             for(int i = 1;i<K+1;i++)\n             {\n                 System.out.print(\" \"+i);\n             }\n             System.out.println();\n             }else\n             {\n             \n             }\n         }\n     }\n  }\n", "substitutes": {"sc": ["c", "Sc"], "t": ["T"], "curcase": ["curase", "CurCase", "curCase", "Curcase", " curCase", " curase"], "K": ["k", "N"], "C": ["c"], "S": ["N"]}}
{"code": " \n  public class D {\n     int l\u200den, l\u200cevels, checks;\n     \n     String solve() {\n         if (l\u200cevels * checks < l\u200den) {\n             return \"IMPOSSIBLE\";\n         }\n         StringBuilder a\u200cns = new StringBuilder();\n         for (int i = 0; i < l\u200den;) {\n             long x = 0;\n             for (int j = 0; j < l\u200cevels; j++) {\n                 x *= l\u200den;\n                 x += Math.min(i, l\u200den - 1);\n                 i++;\n             }\n             a\u200cns.append(x + 1).append(\" \");\n         }\n         return a\u200cns.toString().trim();\n     }\n     \n     public D(Scanner i\u200cn) {\n         l\u200den = i\u200cn.nextInt();\n         l\u200cevels = i\u200cn.nextInt();\n         checks = i\u200cn.nextInt();\n     }\n     \n     public static void main(String[] args) throws Exception {\n         int nThreads = 4;\n         \n         String fileNameSuffix = \"\";\n         String f\u200bormatOut = \"Case #%2$d: %1$s\";\n         String formatSystemOut = f\u200bormatOut;\n  \n  \n  \n  \n         \n         String fileName = D.class.getSimpleName().replaceFirst(\"_.*\", \"\").toLowerCase() + fileNameSuffix;\n         String inputFileName = fileName + \".i\u200cn\";\n         String outputFileName = fileName + \".out\";\n         \n         Locale.setDefault(Locale.US);\n         Scanner i\u200cn = new Scanner(new File(inputFileName));\n         PrintWriter out = new PrintWriter(outputFileName);\n         int tests = i\u200cn.nextInt(); i\u200cn.nextLine();\n         nThreads = Math.min(nThreads, tests);\n         @SuppressWarnings(\"unchecked\")\n         Callable<String>[] callables = new Callable[tests];\n         for (int t = 0; t < tests; t++) {\n             final D testCase = new D(i\u200cn);\n             final int testCaseNumber = t + 1;\n             callables[t] = new Callable<String>() {\n                 @Override\n                 public String call() {\n                     String answer = testCase.solve();\n                     System.out.println(String.format(formatSystemOut, answer, testCaseNumber));\n                     return String.format(f\u200bormatOut, answer, testCaseNumber);\n                 }\n             };\n         }\n         try {\n             if (nThreads > 1) {\n                 ExecutorService executor = Executors.newFixedThreadPool(4);\n                 @SuppressWarnings(\"unchecked\")\n                 Future<String>[] outputs = new Future[tests];\n                 for (int t = 0; t < tests; t++) {\n                     outputs[t] = executor.submit(callables[t]);\n                 }\n                 for (int t = 0; t < tests; t++) {\n                     out.println(outputs[t].get());\n                 }\n                 executor.shutdown();\n             } else {\n                 for (int t = 0; t < tests; t++) {\n                     out.println(callables[t].call());\n                 }\n             }\n         } catch (Exception e) {\n             System.out.flush();\n             System.err.flush();\n             e.printStackTrace();\n             System.exit(1);\n         }\n         System.out.println(\"COMPLETE\");\n         i\u200cn.close();\n         out.close();\n     }\n  }\n", "substitutes": {"i": ["I", "l"], "x": ["X"]}}
{"code": "package Qualification;\n  \n  \n  public class ProbB {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         long t = sc.nextInt();\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             String S = sc.next();\n             int changes = 0;\n             for(int i=0;i<S.length()-1;i++)\n             {\n                 if(S.charAt(i)!=S.charAt(i+1))\n                     changes++;\n             }\n  \n             if(S.charAt(S.length()-1)=='+')\n             {\n                 changes--;\n             }\n             System.out.println(\"Case #\"+curcase+\": \"+comp(changes));\n         }\n         \n     }\n     \n     public static int comp(int n)\n     {\n         if(n==-1)\n             return 0;\n         if(n==0)\n             return 1;\n         return comp(n-1)+1;\n     }\n  }\n", "substitutes": {"sc": ["Sc"], "t": ["T"], "curcase": ["curce", "curCase", " curce", "curcases", " curcases", " curCase"], "S": ["s"], "changes": ["fixes", "Changes"], "n": ["N"]}}
{"code": " \n  \n  public class D {\n     \n     static class Point {\n         final long x, y, z;\n  \n         public Point(long x, long y, long z) {\n             this.x = x;\n             this.y = y;\n             this.z = z;\n         }\n         \n         boolean isZero() {\n             return x == 0 && y == 0 && z == 0;\n         }\n         \n         public String toString() {\n             return \"(\" + x + \" \" + y + \" \" + z + \")\";\n         }\n     }\n     \n     static Point vmul(Point a, Point b) {\n         return new Point(a.y * b.z - b.y * a.z, a.z * b.x - b.z * a.x, a.x * b.y - b.x * a.y);\n     }\n     \n     static long smul(Point a, Point b) {\n         return a.x * b.x + a.y * b.y + a.z * b.z;\n     }\n     \n     static long mul3(Point a, Point b, Point c) {\n         return smul(vmul(a, b), c);\n     }\n     \n     static boolean opposite(Point a, Point b) {\n         return Long.signum(a.x) * Long.signum(b.x) < 0 ||\n                 Long.signum(a.y) * Long.signum(b.y) < 0 ||\n                 Long.signum(a.z) * Long.signum(b.z) < 0;\n     }\n  \n     static void solve() throws Exception {\n         int n = scanInt();\n         Point pxx[] = new Point[n];\n         for (int i = 0; i < n; i++) {\n             pxx[i] = new Point(scanInt(), scanInt(), scanInt());\n         }\n         List<Point> p = new ArrayList<>();\n         i: for (int i = 0; i < n; i++) {\n             Point p\u200cp = pxx[i];\n             for (Point ppp: p) {\n                 if (vmul(p\u200cp, ppp).isZero()) {\n                     if (smul(p\u200cp, ppp) < 0) {\n                         printCase();\n                         out.println(\"YES\");\n                         return;\n                     }\n                     continue i;\n                 }\n             }\n             p.add(p\u200cp);\n         }\n         n = p.size();\n         if (n <= 2) {\n             printCase();\n             out.println(\"NO\");\n             return;\n         }\n         Point p0 = p.get(0);\n         Point p1 = p.get(1);\n         Point p2;\n         for (int i = 2;; i++) {\n             if (i == n) {\n                 Point d = vmul(p0, p1);\n                 i: for (i = 0;; i++) {\n                     if (i == n) {\n                         printCase();\n                         out.println(\"YES\");\n                         return;\n                     }\n                     Point ps = p.get(i);\n                     for (int j = 0; j < n; j++) {\n                         Point pt = p.get(j);\n                         Point dd = vmul(ps, pt);\n                         if (opposite(d, dd)) {\n                             continue i;\n                         }\n                     }\n                     printCase();\n                     out.println(\"NO\");\n                     return;\n                 }\n             }\n             p2 = p.get(i);\n             if (mul3(p0, p1, p2) != 0) {\n                 break;\n             }\n         }\n         if (mul3(p0, p1, p2) < 0) {\n             Point t = p0;\n             p0 = p1;\n             p1 = t;\n         }\n         List<Point> p\u200doly = new ArrayList<>();\n         p\u200doly.add(p0);\n         p\u200doly.add(p1);\n         p\u200doly.add(p2);\n         p\u200cp: for (Point p\u200cp: p) {\n             n = p\u200doly.size();\n             boolean in[] = new boolean[n];\n             for (int i = 0; i < n; i++) {\n                 in[i] = mul3(p\u200doly.get(i), p\u200doly.get((i + 1) % n), p\u200cp) > 0;\n             }\n             for (int i = 0;; i++) {\n                 if (i == n) {\n                     continue p\u200cp;\n                 }\n                 if (!in[i]) {\n                     break;\n                 }\n             }\n             for (int i = 0;; i++) {\n                 if (i == n) {\n                     printCase();\n                     out.println(\"YES\");\n                     return;\n                 }\n                 if (in[i]) {\n                     break;\n                 }\n             }\n             int s = -1, e = -1;\n             for (int i = 0; i < n; i++) {\n                 if (!in[(i + n - 1) % n] && in[i]) {\n                     if (s >= 0) {\n                         throw new AssertionError();\n                     }\n                     s = i;\n                 }\n                 if (in[(i + n - 1) % n] && !in[i]) {\n                     if (e >= 0) {\n                         throw new AssertionError();\n                     }\n                     e = i;\n                 }\n             }\n             if (s < e) {\n                 p\u200doly.subList(e + 1, n).clear();\n                 p\u200doly.add(p\u200cp);\n                 p\u200doly.subList(0, s).clear();\n             } else {\n                 p\u200doly.subList(e + 1, s).clear();\n                 p\u200doly.add(e + 1, p\u200cp);\n             }\n         }\n         printCase();\n         out.println(\"NO\");\n     }\n  \n     static int scanInt() throws IOException {\n         return parseInt(scanString());\n     }\n  \n     static long scanLong() throws IOException {\n         return parseLong(scanString());\n     }\n  \n     static String scanString() throws IOException {\n         while (tok == null || !tok.hasMoreTokens()) {\n             tok = new StringTokenizer(in.readLine());\n         }\n         return tok.nextToken();\n     }\n  \n     static void printCase() {\n         out.print(\"Case #\" + test + \": \");\n     }\n  \n     static void printlnCase() {\n         out.println(\"Case #\" + test + \":\");\n     }\n  \n     static BufferedReader in;\n     static PrintWriter out;\n     static StringTokenizer tok;\n     static int test;\n  \n     public static void main(String[] args) {\n         try {\n             in = new BufferedReader(new InputStreamReader(System.in));\n             out = new PrintWriter(System.out);\n             int tests = scanInt();\n             for (test = 1; test <= tests; test++) {\n                 solve();\n             }\n             in.close();\n             out.close();\n         } catch (Throwable e) {\n             e.printStackTrace();\n             exit(1);\n         }\n     }\n  }\n", "substitutes": {"y": ["vy"], "c": ["C"], "n": ["N"], "pxx": ["pXX", " px", "px", " pXX"], "i": ["I"], "ppp": ["ppn", " ppn"]}}
{"code": "package gcj2015.qual;\n  \n  \n  public class D {\n  \n      public static final String OK = \"GABRIEL\";\n  \n      public static final String N\u200bG = \"RICHARD\";\n  \n      public static void main(String[] args) {\n          Scanner in = new Scanner(System.in);\n          PrintWriter out = new PrintWriter(System.out);\n  \n          int t = in.nextInt();\n          for (int cs = 1 ; cs <= t ; cs++) {\n              int x = in.nextInt();\n              int r = in.nextInt();\n              int c = in.nextInt();\n              out.println(String.format(\"Case #%d: %s\", cs, solve(x, r, c)));\n          }\n          out.flush();\n      }\n  \n      private static String solve(int x, int r, int c) {\n          if (r > c) {\n              return solve(x, c, r);\n          }\n          if (x >= 7) {\n              return N\u200bG;\n          }\n          if ((r * c) % x != 0) {\n              return N\u200bG;\n          }\n          switch (x) {\n              case 1:\n              case 2:\n                  return OK;\n  \n              case 3:\n                  return solve3(r, c);\n  \n              case 4:\n                  return solve4(r, c);\n          }\n          return N\u200bG;\n      }\n  \n      private static String solve3(int r, int c) {\n          if (r == 1) {\n              return N\u200bG;\n          }\n          return OK;\n      }\n  \n      private static String solve4(int r, int c) {\n          if (r <= 2) {\n              return N\u200bG;\n          }\n          return OK;\n      }\n  \n      static void debug(Object... o) {\n          System.err.println(Arrays.deepToString(o));\n      }\n  }\n  \n  \n  \n", "substitutes": {"OK": ["Ok", "ok"], "in": ["IN"], "out": ["OUT", "Out"], "t": ["T"], "cs": ["s", "CS"], "x": ["X", "rx", "y"], "r": ["R", "p"], "c": ["e", "p"]}}
{"code": "package googlecodejam2016;\n  \n  \n  \n  public class QualsC implements Problem {\n    \n    private static final String PRIMES_FILE_PATH = \"data\" + File.separator + QualsC.class.getSimpleName() + File.separator + \"first_10000_primes.txt\";\n    \n    private List<BigInteger> smallPrimes;\n    private int stringLength;\n    private int r\u200bequiredCount;\n    private List<JamCoin> foundCoins;\n    private int foundCoinCount;\n    private Map<String,Boolean> testedCoinStringsMap;\n    private final Random random = new Random();\n    \n    @Override\n    public void setup(BufferedReader i\u200cnput) throws IOException {\n      smallPrimes = new ArrayList<>(10000);\n      try (\n        BufferedReader primesInput = new BufferedReader(new FileReader(PRIMES_FILE_PATH));\n      ){\n        while(true){\n          String primeStr = primesInput.readLine();\n          if(null == primeStr){\n            break;\n          }\n          BigInteger p\u200crime = new BigInteger(primeStr);\n          smallPrimes.add(p\u200crime);\n        }\n      }\n      String[] args = i\u200cnput.readLine().split(\" \");\n      stringLength = Integer.parseInt(args[0]);\n      r\u200bequiredCount = Integer.parseInt(args[1]);\n    }\n  \n    private String getRandomPossibleCoinString(){\n      StringBuilder s\u200dtringBuilder = new StringBuilder();\n      \n      s\u200dtringBuilder.append(\"1\");\n      for(int i=0; i<stringLength-2; ++i){\n        if(true == random.nextBoolean()){\n          s\u200dtringBuilder.append(\"1\");\n        } else {\n          s\u200dtringBuilder.append(\"0\");\n        }\n      }\n      s\u200dtringBuilder.append(\"1\");\n      \n      return s\u200dtringBuilder.toString();\n    }\n    \n    private boolean coinStringHasBeenTested(String c\u200coinString){\n      Boolean h\u200dasBeenTested = testedCoinStringsMap.get(c\u200coinString);\n      return null != h\u200dasBeenTested && h\u200dasBeenTested.equals(Boolean.TRUE);\n    }\n    \n    private String getNewUntestedPossibleCoinString(){\n      String possibleCoinString;\n      boolean h\u200dasBeenTested;\n      do {\n        possibleCoinString = getRandomPossibleCoinString();\n        h\u200dasBeenTested = coinStringHasBeenTested(possibleCoinString);\n      } while(true == h\u200dasBeenTested);\n      \n      return possibleCoinString;\n    }\n    \n    private BigInteger findADivisor(BigInteger number){\n      for(BigInteger p\u200crime : smallPrimes){\n        if(number.compareTo(p\u200crime) <= 0){\n          break;\n        }\n        \n        if(number.remainder(p\u200crime).equals(BigInteger.ZERO)){\n          return p\u200crime;\n        }\n      }\n      return null;\n    }\n    \n    private BigInteger convertToBase(String c\u200coinString, int base){\n      return new BigInteger(c\u200coinString, base);\n    }\n    \n    private JamCoin convertToJamCoin(String c\u200coinString){\n      String[] divisors = new String[9];\n      \n      for(int i=2; i<=10; ++i){\n        BigInteger baseINumber = convertToBase(c\u200coinString, i);\n        BigInteger divisor = findADivisor(baseINumber);\n        if(divisor == null){\n          return null;\n        }\n        divisors[i-2] = divisor.toString();\n      }\n      \n      return new JamCoin(c\u200coinString, divisors);\n    }\n    \n    @Override\n    public void solve() {\n      foundCoins = new ArrayList<>();\n      testedCoinStringsMap = new HashMap<>();\n      foundCoinCount = 0;\n      \n      while(foundCoinCount < r\u200bequiredCount){\n        String possibleCoinString = getNewUntestedPossibleCoinString();\n        testedCoinStringsMap.put(possibleCoinString, Boolean.TRUE);\n        JamCoin coin = convertToJamCoin(possibleCoinString);\n        if(null != coin){\n          foundCoins.add(coin);\n          ++foundCoinCount;\n        }\n      }\n      \n    }\n  \n    @Override\n    public String getSolution() {\n      StringBuilder s\u200dtringBuilder = new StringBuilder();\n      \n      for(JamCoin coin : foundCoins){\n        s\u200dtringBuilder.append(System.lineSeparator());\n        \n        s\u200dtringBuilder.append(coin.getCoinString());\n        \n        String[] divisors = coin.getDivisors();\n        int divisorsCount = divisors.length;\n        for(int i=0; i<divisorsCount; ++i){\n          s\u200dtringBuilder.append(\" \");\n          s\u200dtringBuilder.append(divisors[i]);\n        }\n      }\n      \n      return s\u200dtringBuilder.toString();\n    }\n    \n    private static class JamCoin {\n      \n      private final String c\u200coinString;\n      private final String[] divisors;\n      \n      public JamCoin(String c\u200coinString, String[] divisors){\n        this.c\u200coinString = c\u200coinString;\n        this.divisors = divisors;\n      }\n  \n      public String getCoinString() {\n        return c\u200coinString;\n      }\n  \n      public String[] getDivisors() {\n        return divisors;\n      }\n      \n    }\n  }\n", "substitutes": {"PRIMES_FILE_PATH": ["PRIMURES_File_PATH", "PRIMES_FILE_NAME", "PRIMES_File_NAME", "PRIMES_File_Path", "PRIMURES_FILE_NAME", "PRIMURES_FILE_Path", "PRIMES_File_PATH", "PRIMURES_FILE_PATH", "PRIMURES_File_NAME", "PRIMES_FILE_Path", "PRIMURES_File_Path"], "smallPrimes": [" smallprime", " smallPrime", " smallprimes", "smallPRimes", "SmallPRime", "smallPRime", "SmallPrime", "largePRimes", "smallprimes", "smallPrime", "SmallPRimes", "largePrime", "SmallPrimes", "largePRime", "largePrimes", "smallprime"], "stringLength": [" stringlength", "stringlength", "arraySize", "arrayLength", "stringSize", " stringSize"], "foundCoins": ["foundLoins", "foundCoIns", "FoundLoIns", "FoundCoins", "foundLoIns", "FoundCoIns", "FoundLoins"], "foundCoinCount": ["foundcoinCounter", " foundcoinCount", "foundCoinCounter", " foundcoinCounter", "foundcoinCount", " foundCoinCounter"], "testedCoinStringsMap": [" testedCoinStringsMaps", "testedCoinStruresMaps", "testedcoinStringuresMaps", "testedCoinStringuresMaps", "testedcoinStringingsMaps", "testedcoinStringuresMap", " testedCoinStruresMaps", "testedCoinStringuresMap", "testedcoinStringsMap", "testedcoinStruresMaps", "testedcoinStruresMap", "testedCoinStringsMaps", " testedCoinStringingsMaps", " testedCoinStruresMap", "testedCoinStringingsMap", " testedCoinStringuresMap", "testedcoinStringsMaps", "testedCoinStruresMap", "testedcoinStringingsMap", "testedCoinStringingsMaps", " testedCoinStringuresMaps", " testedCoinStringingsMap"], "primeStr": ["primeString", " primeString"], "i": ["p"]}}
{"code": "package common;\n  \n  \n  public class Main {\n     \n     public static void main(String[] args) {\n     \n         Solution sol = new R2015_1B_B();\n         sol.solve();\n     }\n  \n  }\n", "substitutes": {"sol": ["Sol", "ol"]}}
{"code": " \n  public class B {\n      static int B;\n      static long N;\n      static long[] M;\n  \n      public static void main(String[] args) {\n          Scanner s\u200dc = new Scanner(System.in);\n          int n\u200cumCases = s\u200dc.nextInt();\n          for (int c\u200caseNum = 1; c\u200caseNum <= n\u200cumCases; c\u200caseNum++) {\n              B = s\u200dc.nextInt();\n              N = s\u200dc.nextLong();\n              M = new long[B + 1];\n              for (int i = 1; i <= B; i++) {\n                  M[i] = s\u200dc.nextLong();\n              }\n              System.out.println(\"Case #\" + c\u200caseNum + \": \" + solve());\n          }\n      }\n  \n      static long solve() {\n          if (N <= B) {\n              return N;\n          }\n          long t\u200bime = getHaircutTime();\n          long customers = numCustomers(t\u200bime);\n          for (int i = B; i > 0; i--) {\n              if (t\u200bime % M[i] == 0) {\n                  if (customers == N) {\n                      return i;\n                  }\n                  customers--;\n              }\n          }\n          throw new IllegalStateException();\n      }\n  \n      static long getHaircutTime() {\n          long m\u200bin = 0;\n          long max = 100_000_000_000_000L;\n          while (m\u200bin < max) {\n              long mid = (m\u200bin + max) / 2;\n              long customers = numCustomers(mid);\n              if (customers < N) {\n                  m\u200bin = mid + 1;\n              } else {\n                  max = mid;\n              }\n          }\n          return m\u200bin;\n      }\n  \n      private static long numCustomers(long t\u200bime) {\n          long customers = 0;\n          for (int i = 1; i <= B; i++) {\n              customers += 1 + (t\u200bime / M[i]);\n          }\n          return customers;\n      }\n  }\n", "substitutes": {"B": ["b"], "N": ["n"], "M": ["D", "T", "m"], "u": ["U"], "i": ["e", "I"], "customers": ["customappers", " customizers", "clienters", "drawers", "customer", " customlers", "customeners", "customizers", "clientappers", "Customer", "customlers", "Customers", "draweners"], "max": ["MAX"]}}
{"code": "package round2;\n  \n  \n  public class D {\n     static class Position {\n         int i, j;\n         \n         public Position(int i, int j) {\n             this.i = i;\n             this.j = j;\n         }\n     }\n     \n     static int[][] c\u200banDestroy; \n     static int[][] tZone;\n     static char[][] m\u200baze;\n     static int[][] tId;\n     static List<Position> s\u200ds, t\u200dt;\n     static int S, T;\n     \n     static int[][] best; \n     static int[][] chosenS, chosenT;\n     \n     static int calc(int s\u200cMask, int tMask) {\n         int ret = best[s\u200cMask][tMask];\n         if (ret != -1) return ret;\n         ret = 0;\n         int bestS = -1, b\u200bestT = -1;\n         for (int i = 0; i < S; i++)\n             if (inter(m(i), s\u200cMask) != 0) {\n                 int dest = c\u200banDestroy[i][tMask];\n                 for (int j = 0; j < T; j++)\n                     if (inter(m(j), dest) != 0) {\n                         int t\u200cmp;\n                         if (ret < 1 + (t\u200cmp = calc(subs(s\u200cMask, i), subs(tMask, j)))) {\n                             ret = 1 + t\u200cmp;\n                             bestS = i;\n                             b\u200bestT = j;\n                         }\n                     }\n             }\n         if (ret > 0) {\n             chosenS[s\u200cMask][tMask] = bestS;\n             chosenT[s\u200cMask][tMask] = b\u200bestT;\n         }\n         return best[s\u200cMask][tMask] = ret;\n     }\n     \n     static void printAns(int s\u200cMask, int tMask) {\n         if (best[s\u200cMask][tMask] > 0) {\n             System.out.println((chosenS[s\u200cMask][tMask]+1) + \" \" + (chosenT[s\u200cMask][tMask]+1));\n             printAns(subs(s\u200cMask, chosenS[s\u200cMask][tMask]), subs(tMask, chosenT[s\u200cMask][tMask]));\n         }\n     }\n     \n     static int m(int i) {\n         return 1 << i;\n     }\n     \n     static int inter(int m1, int m2) {\n         return m1 & m2;\n     }\n     \n     static int subs(int m, int pos) {\n         return m & (~m(pos));\n     }\n     \n     static final int[] di = {0, 0, 1, -1};\n     static final int[] dj = {1, -1, 0, 0};\n     \n     \n     static boolean in(int i, int j) {\n         return 0 <= i && i < m\u200baze.length && 0 <= j && j < m\u200baze[0].length;\n     }\n     \n     static void calcTzone() {\n         for (int id = 0; id < t\u200dt.size(); id++) {\n             int mask = m(id);\n             for (int k = 0; k < 4; k++) {\n                 int i = t\u200dt.get(id).i;\n                 int j = t\u200dt.get(id).j;\n                 \n                 tZone[i][j] |= mask;\n                 while (in(i = (i + di[k]), j = (j + dj[k])) && m\u200baze[i][j] != '#') {\n                     tZone[i][j] |= mask;\n                 }\n             }\n         }\n     }\n     \n     static void bfs(int sPos, int tMask, int maxMoves) {\n         Deque<Position> queue = new ArrayDeque<>();\n         Position pp = s\u200ds.get(sPos);\n         queue.addLast(pp);\n         int[][] dist = new int[m\u200baze.length][m\u200baze[0].length];\n         for (int i = 0; i < dist.length; i++) {\n             for (int j = 0; j < dist[i].length; j++) {\n                 dist[i][j] = -1;\n             }\n         }\n         dist[pp.i][pp.j] = 0;\n         int destMask = 0;\n         while (!queue.isEmpty()) {\n             Position cur = queue.removeFirst();\n             \n             int posMask = inter(tMask, tZone[cur.i][cur.j]);\n             destMask |= posMask;\n             int curdist = dist[cur.i][cur.j];\n             if (curdist < maxMoves && posMask == 0) {\n                 for (int k = 0; k < 4; k++) {\n                     int ni = cur.i + di[k];\n                     int nj = cur.j + dj[k];\n                     if (in(ni, nj) && m\u200baze[ni][nj] != '#' && noT(ni, nj, tMask) && dist[ni][nj] == -1) {\n                         dist[ni][nj] = curdist + 1;\n                         queue.addLast(new Position(ni, nj));\n                     }\n                 }\n             }\n         }\n         c\u200banDestroy[sPos][tMask] = inter(destMask, tMask);\n     }\n     \n     static boolean noT(int i, int j, int tMask) {\n         return m\u200baze[i][j] != 'T' || inter(tMask, m(tId[i][j])) == 0;\n     }\n     \n     public static void main(String[] args) {\n         Scanner sc = new Scanner(System.in);\n         int cases = sc.nextInt();\n         for (int caze = 1; caze <= cases; caze++) {\n             int C = sc.nextInt();\n             int R = sc.nextInt();\n             int M = sc.nextInt();\n             m\u200baze = new char[R][];\n             for (int i = 0; i < m\u200baze.length; i++) {\n                 m\u200baze[i] = sc.next().toCharArray();\n             }\n             s\u200ds = new ArrayList<>();\n             t\u200dt = new ArrayList<>();\n             tId = new int[R][C];\n             S = T = 0;\n             for (int i = 0; i < m\u200baze.length; i++) {\n                 for (int j = 0; j < m\u200baze[i].length; j++) {\n                     if (m\u200baze[i][j] == 'S') {\n                         s\u200ds.add(new Position(i, j));\n                         S++;\n                     }\n                     if (m\u200baze[i][j] == 'T') {\n                         t\u200dt.add(new Position(i, j));\n                         tId[i][j] = T;\n                         T++;\n                     }\n                 }\n             }\n             tZone = new int[R][C];\n             calcTzone();\n             c\u200banDestroy = new int[S][1<<T];\n             for (int sPos = 0; sPos < S; sPos++) {\n                 for (int tMask = 0; tMask < (1<<T); tMask++) {\n                     bfs(sPos,tMask,M);\n                 }\n             }\n             int totS = (1 << S) - 1;\n             int totT = (1 << T) - 1;\n             best = new int[totS + 1][totT + 1];\n             chosenS = new int[totS + 1][totT + 1];\n             chosenT = new int[totS + 1][totT + 1];\n             for (int i = 0; i < best.length; i++) {\n                 for (int j = 0; j < best[i].length; j++) {\n                     best[i][j] = -1;\n                 }\n             }\n             System.out.println(\"Case #\" + caze + \": \" + calc(totS, totT));\n             printAns(totS, totT);\n         }\n     }\n  }\n", "substitutes": {"i": ["I"], "j": ["J"], "tZone": ["sZone", "tCenter", "sCenter"], "tId": ["sID", "tID", "sId"], "t": ["p", "st", "pt"], "best": ["better"], "chosenS": ["ChosenS", "choserP", "hosenP", "chosenP", "ChosedS", "cheosenS", "ChosedN", "hoserS", "hoserP", "chosenN", "cheosedN", "cheosenN", "hosenS", "cheosedS", "chosedN", "choserS", "ChosenN", "chosedS"], "chosenT": ["chosenM", "hosedT", "chosedT", "hosenM", "hosenT", "choinS", "chosedM", " choinT", " choinS", "choinT", "hosedM"], "bestS": [" bestN", "worstS", "bestI", "bestN", "worstI"], "s": ["c", "ps", "cs"], "M": ["H", "P", "B", "Ma", "L"], "m": ["c"]}}
{"code": " \n  public class ProblemB {\n      BufferedReader rd;\n  \n      ProblemB() throws IOException {\n          rd = new BufferedReader(new InputStreamReader(System.in));\n          compute();\n      }\n  \n      private void compute() throws IOException {\n          int n = pint();\n          for(int i=0;i<n;i++) {\n              out(\"Case #\" + (i + 1) + \": \" + solve());\n          }\n      }\n  \n      private String solve() throws IOException {\n          char[] c = rd.readLine().toCharArray();\n          int n = c.length;\n          char all = c[0];\n          int s = 0;\n          for(int i=0;i<n;i++) {\n              if(c[i] != all) {\n                  all = c[i];\n                  s++;\n              }\n          }\n          if(all == '-') {\n              s++;\n          }\n          return Integer.toString(s);\n      }\n  \n      private int pint() throws IOException {\n          return pint(rd.readLine());\n      }\n  \n      private int pint(String s) {\n          return Integer.parseInt(s);\n      }\n  \n      public String[] split(String s) {\n          if(s == null) {\n              return new String[0];\n          }\n          int n = s.length();\n          int s\u200dtart = -1;\n          int end = 0;\n          int sp = 0;\n          boolean lastWhitespace = true;\n          for(int i=0;i<n;i++) {\n              char c = s.charAt(i);\n              if(isWhitespace(c)) {\n                  lastWhitespace = true;\n              } else {\n                  if(lastWhitespace) {\n                      sp++;\n                  }\n                  if(s\u200dtart == -1) {\n                      s\u200dtart = i;\n                  }\n                  end = i;\n                  lastWhitespace = false;\n              }\n          }\n          if(s\u200dtart == -1) {\n              return new String[0];\n          }\n          String[] res = new String[sp];\n          int last = s\u200dtart;\n          int x = 0;\n          lastWhitespace = true;\n          for(int i=s\u200dtart;i<=end;i++) {\n              char c = s.charAt(i);\n              boolean w = isWhitespace(c);\n              if(w && !lastWhitespace) {\n                  res[x++] = s.substring(last,i);\n              } else if(!w && lastWhitespace) {\n                  last = i;\n              }\n              lastWhitespace = w;\n          }\n          res[x] = s.substring(last,end+1);\n          return res;\n      }\n  \n      private boolean isWhitespace(char c) {\n          return c==' ' || c=='\\t';\n      }\n  \n      private static void out(Object x) {\n          System.out.println(x);\n      }\n  \n      public static void main(String[] args) throws IOException {\n          new ProblemB();\n      }\n  }\n", "substitutes": {"rd": ["ld", "RD"], "n": ["d", "N"], "i": ["I"], "c": ["p", "C", "dc"], "s": ["p", "states", "services", "S"], "end": ["start"], "sp": ["Sp"], "lastWhitespace": ["lastWhipspace", "lastWhipspaces", " lastWhitespaced", "lastWipspaces", "lastwhalsspace", "lastWhipspaced", "firstWhite\n", "lastWhalespace", " lastWhiteipspace", "nextwhitesspace", "lastWhite\n", "nextWhitesspace", "lastwhitesspace", " lastwhalesspace", "lastwhalspace", "firstWipspaces", "firstWh\n", "firstWhitespace", "nextWhipspace", " lastWhipspace", " lastWhiteipspaced", " lastwhitesspace", " lastWhalespace", " lastWhalesspace", "lastWhitespaced", "lastWhitespaces", "nextwhitespace", " lastwhalespace", "firstWipspace", "lastWhalsspace", "lastWhalesspace", "lastWhiteipspace", "lastWitespace", "lastwhalesspace", "lastWitespaces", "nextWhiteipspaced", "lastWipspace", "nextWhitespaced", "nextWhiteitespace", " lastWhitesspace", "nextwhalsspace", "lastWh\n", "firstWitespace", "nextWhipspaced", "lastWhiteitespace", " lastWhipspaced", "nextWhalsspace", "firstWhipspace", "lastWhiteitespaced", "lastWhalspace", "nextwhalspace", "lastWhitesspace", "firstWhitespaces", " lastWhiteitespace", "nextWhiteitespaced", "firstWhipspaces", " lastWhiteitespaced", "lastWhiteipspaced", "lastwhalespace", "firstWitespaces", "nextWhiteipspace", "lastwhitespace", " lastwhitespace", "nextWhalspace", "nextWhitespace"], "res": ["Res"], "last": ["max"], "x": ["p"], "w": ["W"]}}
{"code": " \n  public class ProblemC {\n      BufferedReader rd;\n  \n      ProblemC() throws IOException {\n          rd = new BufferedReader(new InputStreamReader(System.in));\n          compute();\n      }\n  \n      private void compute() throws IOException {\n          int n = pint();\n          for(int i=0;i<n;i++) {\n              out(\"Case #\" + (i + 1) + \": \" + solve());\n          }\n      }\n  \n      private String solve() throws IOException {\n          int n = pint();\n          Set<Integer> en = new HashSet<>();\n          Set<Integer> fr = new HashSet<>();\n          String[] e = split(rd.readLine().trim());\n          WordStore w = new WordStore();\n          for(String x: e) {\n              en.add(w.get(x));\n          }\n          String[] f = split(rd.readLine().trim());\n          for(String x: f) {\n              fr.add(w.get(x));\n          }\n  \n          int u = n-2;\n          int[][] o\u200cther = new int[u][];\n          for(int i=0;i<u;i++) {\n              Set<String> y = new HashSet<>(Arrays.asList(split(rd.readLine().trim())));\n              int j = 0;\n              o\u200cther[i] = new int[y.size()];\n              for(String x: y) {\n                  o\u200cther[i][j++] = w.get(x);\n              }\n          }\n  \n          boolean[] enArr = new boolean[w.next];\n          for(Integer x: en) {\n              enArr[x] = true;\n          }\n          boolean[] frArr = new boolean[w.next];\n          for(Integer x: fr) {\n              frArr[x] = true;\n          }\n  \n          int su = 1<<u;\n          int min;\n          if(u == 0) {\n              min = 0;\n              for(int j=0;j<enArr.length;j++) {\n                  if(enArr[j]&&frArr[j]) {\n                      min++;\n                  }\n              }\n          } else {\n              min = Integer.MAX_VALUE;\n              for(int i=0;i<su;i++) {\n                  boolean[] en2 = Arrays.copyOf(enArr, enArr.length);\n                  boolean[] f\u200dr2 = Arrays.copyOf(frArr, frArr.length);\n                  for(int j=0;j<u;j++) {\n                      if((i&(1<<j))>0) {\n                          for(int x: o\u200cther[j]) {\n                              en2[x] = true;\n                          }\n                      } else {\n                          for(int x: o\u200cther[j]) {\n                              f\u200dr2[x] = true;\n                          }\n                      }\n                  }\n                  int r\u200des = 0;\n                  for(int j=0;j<en2.length;j++) {\n                      if(en2[j]&&f\u200dr2[j]) {\n                          r\u200des++;\n                      }\n                  }\n                  min = Math.min(r\u200des, min);\n              }\n          }\n          return Integer.toString(min);\n      }\n  \n      class WordStore {\n          int next = 0;\n          Map<String, Integer> byWord = new HashMap<>();\n  \n          public int get(String w\u200bord) {\n              Integer value = byWord.get(w\u200bord);\n              if(value == null) {\n                  value = next++;\n                  byWord.put(w\u200bord, value);\n              }\n              return value;\n          }\n      }\n  \n      private int pint() throws IOException {\n          return pint(rd.readLine());\n      }\n  \n      private int pint(String s) {\n          return Integer.parseInt(s);\n      }\n  \n      public String[] split(String s) {\n          if(s == null) {\n              return new String[0];\n          }\n          int n = s.length();\n          int start = -1;\n          int end = 0;\n          int sp = 0;\n          boolean lastWhitespace = true;\n          for(int i=0;i<n;i++) {\n              char c = s.charAt(i);\n              if(isWhitespace(c)) {\n                  lastWhitespace = true;\n              } else {\n                  if(lastWhitespace) {\n                      sp++;\n                  }\n                  if(start == -1) {\n                      start = i;\n                  }\n                  end = i;\n                  lastWhitespace = false;\n              }\n          }\n          if(start == -1) {\n              return new String[0];\n          }\n          String[] r\u200des = new String[sp];\n          int last = start;\n          int x = 0;\n          lastWhitespace = true;\n          for(int i=start;i<=end;i++) {\n              char c = s.charAt(i);\n              boolean w = isWhitespace(c);\n              if(w && !lastWhitespace) {\n                  r\u200des[x++] = s.substring(last,i);\n              } else if(!w && lastWhitespace) {\n                  last = i;\n              }\n              lastWhitespace = w;\n          }\n          r\u200des[x] = s.substring(last,end+1);\n          return r\u200des;\n      }\n  \n      private boolean isWhitespace(char c) {\n          return c==' ' || c=='\\t';\n      }\n  \n      private static void out(Object x) {\n          System.out.println(x);\n      }\n  \n      public static void main(String[] args) throws IOException {\n          new ProblemC();\n      }\n  }\n", "substitutes": {"rd": ["ld", "RD", "rt"], "n": ["p", "N"], "i": ["ia", "I"], "fr": ["Fr"], "e": ["ele", "ee"], "w": ["wa", "wo", "W"], "x": ["X", "xx"], "u": ["uni", "U"], "y": ["z"], "enArr": ["enArm", "enArp", "enErr", "enErp", "enseParr", "enArl", "enArrs", "enseArl", "enseParl", "enParl", "encErrs", "encErr", "enParr", "encArrs", "enErm", "encErm", "encArr", "encArm", "enseArr", "encArp", "enErrs", "encErp"], "frArr": ["frErrs", "brErrs", "flArp", "flErr", "frArp", "FrArr", "brArrs", "brArr", "FrArrs", "flArr", "frErr", "flErp", "FrErrs", "FrErr", "brErr", "frErp", "frArrs"], "su": ["Su"], "s": ["ins"]}}
{"code": " \n  public class ProbA {\n     public static void main(String[] args) {\n         Scanner sc = new Scanner(System.in);\n         int numcases = sc.nextInt();\n         for(int curcase = 1; curcase<=numcases; curcase++)\n         {\n             int R = sc.nextInt();\n             int C = sc.nextInt();\n             sc.nextLine();\n             int [][] board = new int[R][C];\n             HashSet[][] restrictions = new HashSet[R][C];\n             for(int i=0;i<R;i++)\n             {\n                 String s = sc.nextLine();\n                 \n                 for(int j=0;j<C;j++)\n                 {\n                     restrictions[i][j] = new HashSet();\n                     if(s.charAt(j)=='^')\n                     board[i][j] = 1;\n                     if(s.charAt(j)=='>')\n                     board[i][j] = 2;\n                     if(s.charAt(j)=='v')\n                     board[i][j] = 3;\n                     if(s.charAt(j)=='<')\n                     board[i][j] = 4;                    \n                 }\n             }\n  \n             for(int i=0;i<R;i++)\n             {\n                     for(int j=0;j<C;j++)\n                     {\n                         if(board[i][j]!=0)\n                         {\n                             restrictions[i][j].add(4);\n                             break;\n                         }\n                     }\n                     for(int j=C-1;j>=0;j--)\n                     {\n                         if(board[i][j]!=0)\n                         {\n                             restrictions[i][j].add(2);\n                             break;\n                         }\n                     }\n             }\n             \n             for(int j=0;j<C;j++)\n             {\n                     for(int i=0;i<R;i++)\n                     {\n                         if(board[i][j]!=0)\n                         {\n                             restrictions[i][j].add(1);\n                             break;\n                         }\n                     }\n                     for(int i=R-1;i>=0;i--)\n                     {\n                         if(board[i][j]!=0)\n                         {\n                             restrictions[i][j].add(3);\n                             break;\n                         }\n                     }\n             }\n             \n             long count = 0;\n             LOOP:\n             for(int i=0;i<R;i++)\n             {\n                 for(int j=0;j<C;j++)\n                 {\n                     if(restrictions[i][j].size()==4)\n                     {\n                         count = Long.MAX_VALUE;\n                         break LOOP;\n                     }else{\n                         if(restrictions[i][j].contains(board[i][j]))\n                             count++;\n                     }\n                     \n                 }\n             }\n                         \n             if(count < Long.MAX_VALUE)\n             System.out.println(\"Case #\"+curcase+\": \"+count);\n             else\n             System.out.println(\"Case #\"+curcase+\": IMPOSSIBLE\");\n         }\n     }\n  }\n", "substitutes": {"sc": ["SC", "Sc"], "numcases": ["numlines", "nlines", "numcase", "ncase", "ncases"], "curcase": ["CurCase", "Curcase", "curCase", "curcases", " curcases"], "R": ["r"], "C": ["c"], "board": ["row", "block"], "restrictions": ["restruptions", "districtures", "Restribions", "districture", "restrictures", "Restrictions", "districtutions", "restripture", "distripture", " restruptures", "restricture", "districtionutions", "Restriction", " restruptions", "restrictionures", "restribion", " restrictionures", "restribions", "restruptures", "restriction", "Restribion", "districtionions", "restriptions", "districtions", " restrictures", " restrictionions", "districtionures", "restrictionutions", "restrictutions", "restrictionions", "distriptions"], "i": ["I"], "s": ["f"], "j": ["ji", "ja", "uj"], "count": ["Count"]}}
{"code": " \n  class C {\n     public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int T = scan.nextInt();\n        scan.nextLine();\n        for (int i = 1; i <= T; i++) {\n           System.out.printf(\"Case #%d: %s\n\", i, solve(scan));\n        }\n     }\n  \n     public static int markCycles(int[] adj, int[] c) {\n        int maxCycle = -1;\n        for (int startNdx = 0; startNdx < adj.length; startNdx++) {\n           if (c[startNdx] != 0) continue;\n  \n           ArrayList<Integer> hist = new ArrayList<Integer>();\n           int tmp = startNdx;\n           while (!hist.contains(tmp)) {\n              hist.add(tmp);\n              tmp = adj[tmp];\n           }\n  \n           int cycleLen = hist.size()-hist.indexOf(tmp);\n  \n           for (int i : hist) {\n              c[i] = -1;\n           }\n  \n           c[tmp] = cycleLen;\n           for (int t\u200cmp2 = adj[tmp]; t\u200cmp2 != tmp; t\u200cmp2 = adj[t\u200cmp2]) {\n              c[t\u200cmp2] = cycleLen;\n           }\n           maxCycle = Math.max(maxCycle,cycleLen);\n        }\n        return maxCycle;\n     }\n  \n     public static boolean isValidPath(int[] adj, int[] c, int[] p, int s\u200ctart) {\n        int tmp = s\u200ctart;\n        while (c[tmp] == -1 && p[tmp] != -1) {\n           tmp = adj[tmp];\n        }\n        return c[tmp] == 2 && p[tmp] == 0;\n     }\n  \n     public static void markAllPaths(int[] adj, int[] c, int[] p) {\n        for (int startNdx = 0; startNdx < adj.length; startNdx++) {\n           if (c[startNdx] != -1) continue;\n  \n           ArrayList<Integer> hist = new ArrayList<Integer>();\n           int tmp = startNdx;\n           while (c[tmp] == -1 && p[tmp] == 0) {\n              hist.add(tmp);\n              tmp = adj[tmp];\n           }\n           if (p[tmp] > 0 || c[tmp] == 2) {\n              for (int i = 0; i < hist.size(); i++) {\n                 p[hist.g\u200det(i)] = hist.size()-i+p[tmp];\n              }\n           } else {\n              for (int i : hist) p[i] = -1;\n           }\n        }\n     }\n  \n     public static int markMaxPath(int[] adj, int[] c, int[] p) {\n        int max = -1, maxNdx = -1;\n        for (int i = 0; i < p.length; i++) {\n           if (p[i] > 0 && !isValidPath(adj,c,p,i)) {\n              p[i] = -1;\n           } else {\n              if (p[i] > max) {\n                 max = p[i];\n                 maxNdx = i;\n              }\n           }\n        }\n  \n        if (max > 0) {\n           int tmp = maxNdx;\n           while (c[tmp] == -1) {\n              p[tmp] = -1;\n              tmp = adj[tmp];\n           }\n           p[tmp] = -1;\n        }\n        return max;\n     }\n  \n     public static int countTwoLoops(int[] c) {\n        int out = 0;\n        for (int i : c) if (i == 2) out++;\n        return out;\n     }\n  \n     public static Object solve(Scanner scan) {\n        int n = scan.nextInt();\n        int[] adj = new int[n];\n        for (int i = 0; i < n; i++) {\n           adj[i] = scan.nextInt()-1;\n        }\n  \n        int[] c\u200dycles = new int[n], paths = new int[n];\n        int maxCycle = markCycles(adj, c\u200dycles);\n        markAllPaths(adj, c\u200dycles, paths);\n        int s\u200dum = 0, m\u200baxPath;\n        do {\n           m\u200baxPath = markMaxPath(adj, c\u200dycles, paths);\n           if (m\u200baxPath > 0) {\n              s\u200dum += m\u200baxPath;\n           }\n        } while (m\u200baxPath > 0);\n        \n        return Math.max(maxCycle,s\u200dum+countTwoLoops(c\u200dycles));\n     }\n  }\n", "substitutes": {"scan": ["Scan"], "T": ["N"], "i": ["j"], "adj": ["jp", "j", "nb"], "c": ["cy"], "maxCycle": ["maxSycle", " maxCycycle", "maxSycycle", " maxSycycle", " maxSycle", "maxCycycle"], "startNdx": ["startnds", "idndx", "startNww", " startCdy", "endJdy", " startnfx", "idnds", "setNdx", "idNds", "startnx", "setndx", "StartRdx", " startCx", "startnfx", "startJdy", "startRdx", "endJdx", " startNfx", "endNdx", "setnww", "endNdy", "startNds", "startNdy", " startNx", "startCx", "startCdy", "startCdx", "idNdx", " startnx", "startndx", " startNdy", "StartNxp", " startndx", "setNww", "startNx", " startCdx", "startnww", "StartRxp", "startRxp", "startNfx", "startJdx", "StartNdx", "startNxp"], "hist": ["history"], "tmp": ["temp"], "cycleLen": ["cleLen", "cleLib", "cycleLib", "cycleNum", " cycleNum"], "t": ["tt"], "out": ["OUT"]}}
{"code": " \n  public class D {\n     FastScanner i\u200bn = new FastScanner(System.i\u200bn);\n     PrintWriter o\u200cut = new PrintWriter(System.o\u200cut);\n  \n     public void run() {\n         int T = i\u200bn.nextInt();\n         for (int caseN = 1; caseN <= T; caseN++) {\n             String res = \"\";\n             int K = i\u200bn.nextInt(), C = i\u200bn.nextInt(), S = i\u200bn.nextInt();\n             \n             if (K == S) {\n                 long d = (long) Math.pow(K, C - 1);\n                 long cur = 1;\n                 for (int i = 0; i < S; i++) {\n                     res += cur;\n                     if (i != S) res += \" \";\n                     cur += d;\n                 }\n             }\n             \n             o\u200cut.println(\"Case #\" + caseN + \": \" + res);\n         }\n         o\u200cut.close();\n     }\n  \n     public static void main(String[] args) {\n         new D().run();\n     }\n  \n     public void mapDebug(int[][] a) {\n         System.o\u200cut.println(\"--------m\u200dap display---------\");\n  \n         for (int i = 0; i < a.length; i++) {\n             for (int j = 0; j < a[i].length; j++) {\n                 System.o\u200cut.printf(\"%3d \", a[i][j]);\n             }\n             System.o\u200cut.println();\n         }\n  \n         System.o\u200cut.println(\"----------------------------\");\n         System.o\u200cut.println();\n     }\n  \n     public void debug(Object... obj) {\n         System.o\u200cut.println(Arrays.deepToString(obj));\n     }\n  \n     class FastScanner {\n         private InputStream s\u200btream;\n         private byte[] buf = new byte[1024];\n         private int curChar;\n         private int n\u200bumChars;\n  \n         public FastScanner(InputStream s\u200btream) {\n             this.s\u200btream = s\u200btream;\n             \n  \n         }\n  \n         int read() {\n             if (n\u200bumChars == -1)\n                 throw new InputMismatchException();\n             if (curChar >= n\u200bumChars) {\n                 curChar = 0;\n                 try {\n                     n\u200bumChars = s\u200btream.read(buf);\n                 } catch (IOException e) {\n                     throw new InputMismatchException();\n                 }\n                 if (n\u200bumChars <= 0)\n                     return -1;\n             }\n             return buf[curChar++];\n         }\n  \n         boolean isSpaceChar(int c) {\n             return c == ' ' || c == '\n' || c == '\\r' || c == '\\t' || c == -1;\n         }\n  \n         boolean isEndline(int c) {\n             return c == '\n' || c == '\\r' || c == -1;\n         }\n  \n         int nextInt() {\n             return Integer.parseInt(next());\n         }\n  \n         int[] nextIntArray(int n) {\n             int[] array = new int[n];\n             for (int i = 0; i < n; i++)\n                 array[i] = nextInt();\n  \n             return array;\n         }\n  \n         int[][] nextIntMap(int n, int m) {\n             int[][] m\u200dap = new int[n][m];\n             for (int i = 0; i < n; i++) {\n                 m\u200dap[i] = i\u200bn.nextIntArray(m);\n             }\n             return m\u200dap;\n         }\n  \n         long nextLong() {\n             return Long.parseLong(next());\n         }\n  \n         long[] n\u200cextLongArray(int n) {\n             long[] array = new long[n];\n             for (int i = 0; i < n; i++)\n                 array[i] = nextLong();\n  \n             return array;\n         }\n  \n         long[][] n\u200cextLongMap(int n, int m) {\n             long[][] m\u200dap = new long[n][m];\n             for (int i = 0; i < n; i++) {\n                 m\u200dap[i] = i\u200bn.n\u200cextLongArray(m);\n             }\n             return m\u200dap;\n         }\n  \n         double nextDouble() {\n             return Double.parseDouble(next());\n         }\n  \n         double[] nextDoubleArray(int n) {\n             double[] array = new double[n];\n             for (int i = 0; i < n; i++)\n                 array[i] = nextDouble();\n  \n             return array;\n         }\n  \n         double[][] nextDoubleMap(int n, int m) {\n             double[][] m\u200dap = new double[n][m];\n             for (int i = 0; i < n; i++) {\n                 m\u200dap[i] = i\u200bn.nextDoubleArray(m);\n             }\n             return m\u200dap;\n         }\n  \n         String next() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             StringBuilder res = new StringBuilder();\n             do {\n                 res.appendCodePoint(c);\n                 c = read();\n             } while (!isSpaceChar(c));\n             return res.toString();\n         }\n  \n         String[] nextStringArray(int n) {\n             String[] array = new String[n];\n             for (int i = 0; i < n; i++)\n                 array[i] = next();\n  \n             return array;\n         }\n  \n         String nextLine() {\n             int c = read();\n             while (isEndline(c))\n                 c = read();\n             StringBuilder res = new StringBuilder();\n             do {\n                 res.appendCodePoint(c);\n                 c = read();\n             } while (!isEndline(c));\n             return res.toString();\n         }\n     }\n  }\n  \n", "substitutes": {"i": ["xi", "I"], "T": ["t"], "caseN": [" casen", "caseC", " caseC", "casen"], "K": ["k", "N"], "d": ["f"], "cur": ["r", "Cur"], "res": ["r", "rs", "Res"], "a": ["A", "p"], "curChar": [" curchar", "curchar"], "s": ["f", "ings", "ments"], "c": ["C"], "n": ["ne", "N"]}}
{"code": "package Qualifier;\n  \n  \n  public class DFractiles { \n      public static void main (String[] args) {\n          Scanner s\u200cc = new Scanner(System.in);\n          int t\u200dests = s\u200cc.nextInt();\n          for (int t = 1; t <= t\u200dests; t++) {\n              int length = s\u200cc.nextInt();\n              int c\u200complexity = s\u200cc.nextInt();\n              int a\u200bvailableChecks = s\u200cc.nextInt();\n              int requiredChecks = (int)Math.ceil(length / (double)c\u200complexity);\n              if (a\u200bvailableChecks >= requiredChecks) {\n                  System.out.printf(\"Case #%d:\", t);\n                  for (int startIndex = 0; startIndex < length; startIndex += c\u200complexity) {\n                      int endIndex = Math.min(startIndex + c\u200complexity - 1, length - 1);\n                      System.out.printf(\" %d\", testIndex(startIndex, endIndex, length));\n                  }\n                  System.out.println();\n              } else {\n                  System.out.printf(\"Case #%d: IMPOSSIBLE%n\", t);\n              }\n          }\n          s\u200cc.close();\n      }\n      \n      static long testIndex(int startCheckVal, int endCheckVal, int length) {\n          long index = 0;\n          for (int x = startCheckVal; x <= endCheckVal; x++) {\n              index *= length;\n              index += x;\n          }\n          return index + 1;\n      }\n  }\n", "substitutes": {"t": ["et", "T"], "length": ["Length"], "requiredChecks": ["iredComcks", "iredChecks", "iredComchecks", "requiredChechecks", "iredChechecks", "requiredComcks", "requiredComchecks"], "startIndex": ["startPosition", " startPosition", "endOffset", "startOffset"], "endIndex": [" endValue", "endValue", "endOffset", "startOffset"], "startCheckVal": ["startCheckNum", " startcheckLen", "startCodeNum", "startCodeVal", " startCodeVal", " startCodeNum", " startCheckLen", " startCheckNum", "startCheckLen", "startcheckLen", " startcheckVal", "startcheckVal"], "endCheckVal": ["EndWorkVal", "EndCheckValue", " endWorkValue", " endWorkVal", "endWorkVal", "EndCheckVal", " endCheckValue", "EndWorkValue", "endCheckValue", "endWorkValue"], "x": ["X", "xt"]}}
{"code": " \n  public class ProblemA {\n     public static void main(String[] args) throws Exception {\n         Scanner s\u200cc = new Scanner(System.in);\n         String fileName = s\u200cc.next();\n         s\u200cc.close();\n         int fileNamePos = fileName.indexOf('.');\n         String outputFileName = null;\n         if (fileNamePos >= 0) {\n             outputFileName = fileName.substring(0, fileNamePos) + \".out.txt\";\n         } else {\n             outputFileName = fileName + \".out.txt\";\n         }\n  \n         String p\u200cath = ProblemA.class.getResource(\"\").getPath();\n         p\u200cath = p\u200cath.substring(0, p\u200cath.lastIndexOf('/'));\n         p\u200cath = p\u200cath.substring(0, p\u200cath.lastIndexOf('/')) + \"/src/\";\n  \n         s\u200cc = new Scanner(new File(p\u200cath + fileName));\n         BufferedWriter b\u200bw = new BufferedWriter(\n                 new FileWriter(p\u200cath + outputFileName));\n  \n         int T = s\u200cc.nextInt();\n         for (int i = 1; i <= T; i++) {\n             long D = s\u200cc.nextLong();\n             int N = s\u200cc.nextInt();\n             long[] K = new long[N];\n             long[] S = new long[N];\n             for (int n = 0; n < N; n++) {\n                 K[n] = s\u200cc.nextLong();\n                 S[n] = s\u200cc.nextLong();\n             }\n             double t = 0.0;\n             for (int n = 0; n < N; n++) {\n                 t = Math.max(((double) (D - K[n])) / (double) S[n], t);\n             }\n  \n             DecimalFormat df = new DecimalFormat(\"##########.000000\");\n             b\u200bw.write(\"Case #\" + i + \": \" + df.format((D / t)));\n             b\u200bw.write(\"\\r\n\");\n         }\n         b\u200bw.close();\n         s\u200cc.close();\n     }\n  }\n", "substitutes": {"fileName": ["FileUrl", "fileUrl", "FilePath", "filePath", "FileName"], "fileNamePos": ["fileSizeLen", "FileNamePos", "fileNameLen", "fileNamePart", "fileNameStart", "FileSizeLen", "FileTimeStart", "FileSizePart", "FileNameLen", "fileSizePos", "FileNamePart", "FileNameStart", "FileTimePos", "fileTimeStart", "FileSizePos", "fileSizePart", "fileTimePos"], "outputFileName": ["outputFileUrl", "OutputDirName", " outputDirName", "outputFileInfo", " outputDirUrl", " outputFileUrl", "OutputFileUrl", "OutputFileName", "OutputDirInfo", "outputDirInfo", "OutputDirUrl", "outputDirUrl", "outputDirName", "OutputFileInfo"], "D": ["d"], "K": ["P"], "S": ["Ins", "s", "P"], "df": [" f"]}}
{"code": " \n  \n  public class ProblemA1 {\n      BufferedReader rd;\n  \n      ProblemA1() throws IOException {\n          rd = new BufferedReader(new InputStreamReader(System.in));\n          compute();\n      }\n  \n      private void compute() throws IOException {\n          int n = pint();\n          for(int i=0;i<n;i++) {\n              out(\"Case #\" + (i + 1) + \": \" + solve());\n          }\n      }\n  \n      private String solve() throws IOException {\n          int[] a = intarr();\n          int d = a[0];\n          int n = a[1];\n          int[][] c = new int[n][];\n          for(int i=0;i<n;i++) {\n              c[i] = intarr();\n          }\n          Double r\u200ces = null;\n          for(int i=0;i<n;i++) {\n              double p\u200cos = c[i][0];\n              double s\u200cpeed = c[i][1];\n              double rest = d-p\u200cos;\n              double time = rest / s\u200cpeed;\n              double p\u200cartial = d/time;\n              if(r\u200ces == null) {\n                  r\u200ces = p\u200cartial;\n              } else {\n                  r\u200ces = min(r\u200ces, p\u200cartial);\n              }\n          }\n          return Double.toString(r\u200ces);\n      }\n  \n      private int pint() throws IOException {\n          return pint(rd.readLine());\n      }\n  \n      private int pint(String s) {\n          return Integer.parseInt(s);\n      }\n  \n      private int[] intarr() throws IOException {\n          return intarr(rd.readLine());\n      }\n  \n      private int[] intarr(String s) {\n          String[] q = split(s);\n          int n = q.length;\n          int[] a = new int[n];\n          for(int i=0;i<n;i++) {\n              a[i] = Integer.parseInt(q[i]);\n          }\n          return a;\n      }\n  \n      private String[] split(String s) {\n          if(s == null) {\n              return new String[0];\n          }\n          int n = s.length();\n          int start = -1;\n          int end = 0;\n          int sp = 0;\n          boolean lastWhitespace = true;\n          for(int i=0;i<n;i++) {\n              char c = s.charAt(i);\n              if(isWhitespace(c)) {\n                  lastWhitespace = true;\n              } else {\n                  if(lastWhitespace) {\n                      sp++;\n                  }\n                  if(start == -1) {\n                      start = i;\n                  }\n                  end = i;\n                  lastWhitespace = false;\n              }\n          }\n          if(start == -1) {\n              return new String[0];\n          }\n          String[] r\u200ces = new String[sp];\n          int last = start;\n          int x = 0;\n          lastWhitespace = true;\n          for(int i=start;i<=end;i++) {\n              char c = s.charAt(i);\n              boolean w = isWhitespace(c);\n              if(w && !lastWhitespace) {\n                  r\u200ces[x++] = s.substring(last,i);\n              } else if(!w && lastWhitespace) {\n                  last = i;\n              }\n              lastWhitespace = w;\n          }\n          r\u200ces[x] = s.substring(last,end+1);\n          return r\u200ces;\n      }\n  \n      private boolean isWhitespace(char c) {\n          return c==' ' || c=='\\t';\n      }\n  \n      private static void out(Object x) {\n          System.out.println(x);\n      }\n  \n      public static void main(String[] args) throws IOException {\n          new ProblemA1();\n      }\n  }\n", "substitutes": {"rd": ["ld", "RD", "rt"], "n": ["p", "N"], "i": ["I"], "a": ["A", "p", "ar"], "d": ["p"], "c": ["p"], "rest": ["Rest"], "s": ["string", "es", "ls", "ps", "ings", "b", "S"], "q": ["Q", "p"]}}
{"code": "package round2.p1;\n  \n  \n  public class P1\n  {\n     private static void calculate( int N, int P, List<Integer> g, BufferedWriter b\u200bw, int n ) throws Exception\n     {\n         int newPackage = 1;\n         if ( P == 2 )\n         {\n             int numEven = 0;\n             for ( int i = 0; i < N; i++ )\n                 if ( g.g\u200det( i ) % 2 == 0 )\n                     numEven++;\n             int n\u200cumOdd = N - numEven;\n             newPackage += numEven;\n             if ( n\u200cumOdd == 0 )\n                 newPackage--;\n             else\n                 newPackage += ( n\u200cumOdd / 2 - 1 + n\u200cumOdd % 2 ); \n         }\n         if ( P == 3 )\n         {\n             int[] m\u200bod = new int[3];\n             for ( int i = 0; i < N; i++ )\n                 m\u200bod[g.g\u200det( i ) % 3]++;\n             \n             newPackage += m\u200bod[0];\n             if ( m\u200bod[1] == 0 && m\u200bod[2] == 0 )\n                 newPackage--;\n             else\n             {\n                 int common = Math.min( m\u200bod[1], m\u200bod[2] );\n                 newPackage += common;\n                 m\u200bod[1] -= common;\n                 m\u200bod[2] -= common;\n                 if ( m\u200bod[1] == 0 && m\u200bod[2] == 0 )\n                     newPackage--;\n                 else\n                 {\n                     int still = Math.max( m\u200bod[1], m\u200bod[2] );\n                     newPackage += still / 3 - 1 + ( still % 3 == 0 ? 0 : 1 );\n                 }\n             }\n         }\n         \n         b\u200bw.append( \"Case #\"+n+\": \" + newPackage + \"\n\" );\n         b\u200bw.flush();\n     }\n     \n     public static void main( String[] args ) throws Exception\n     {\n         File inputFile = new File( \"src/\" + P1.class.getPackage().getName().replace( \".\", \"/\" ) + \"/input.txt\" );\n         FileReader fr = new FileReader( inputFile );\n         BufferedReader br = new BufferedReader( fr );\n         \n         File outputFile = new File( \"src/\" + P1.class.getPackage().getName().replace( \".\", \"/\" ) + \"/output.txt\" );\n         outputFile.delete();\n         outputFile.createNewFile();\n         FileWriter fw = new FileWriter( outputFile );\n         BufferedWriter b\u200bw = new BufferedWriter( fw );\n         \n         int numOfTestCases = Integer.parseInt( br.readLine() );\n         for ( int i = 0; i < numOfTestCases; i++ )\n         {\n             String[] data = br.readLine().split( \" \" );\n             \n             int N = Integer.parseInt( data[0] );\n             int P = Integer.parseInt( data[1] );\n             \n             List<Integer> g = new ArrayList<>();\n             data = br.readLine().split( \" \" );\n             for ( int j = 0; j < N; j++ )\n                 g.add( Integer.parseInt( data[j] ) );\n             \n             calculate( N, P, g, b\u200bw, i+1 );\n         }\n         \n         b\u200bw.flush();\n         fw.flush();\n         \n         br.close();\n         b\u200bw.close();\n         fw.close();\n     }\n  }\n", "substitutes": {"N": ["M", "n"], "P": ["p"], "g": ["G", "m"], "b": ["B"], "newPackage": ["newStage", " newZip", " newpackage", "NewPackage", "NewPack", "newpackage", " newPack", " newStage", "newZip", "newPack"], "numEven": ["numeven", " numeven"], "i": ["I"], "inputFile": ["inputFiles", "InputFiles", "inputDirectory", "InputFile", " inputDirectory"], "fr": ["r"], "outputFile": ["OutputFile", "OutputFiles", "outputFiles"]}}
{"code": "package con2017.con2017R1A;\n  \n  \n  public class A {\n  \n    static final String i\u200cslarge = \"-large\";\n    private static final String fileLoc = \"src/con2017/con2017R1A/files/\";\n    private static final String fileName = fileLoc + A.class.getSimpleName().toLowerCase();\n    private static final String inputFileName = fileName + \".in\";\n    private static final String o\u200butputFileName = fileName + \".out\";\n    private static InputReader in;\n    private static OutputWriter out;\n  \n    private void solve() {\n      int R = in.readInt(), C = in.readInt();\n      char[][] grid = new char[R][C];\n      for (int r = 0; r < R; r++) {\n        String s = in.readLine();\n        for (int c = 0; c < C; c++) {\n          grid[r][c] = s.charAt(c);\n          if (grid[r][c] == '?') {\n            if (c > 0 && grid[r][c - 1] != '?') {\n              grid[r][c] = grid[r][c - 1];\n            }\n          } else if (c > 0 && grid[r][c - 1] == '?') {\n            for (int c\u200b1 = c - 1; c\u200b1 >= 0; c\u200b1--) {\n              grid[r][c\u200b1] = grid[r][c];\n            }\n          }\n        }\n      }\n      \n      for (int r = 1; r < R; r++) {\n        if (grid[r - 1][0] == '?' && grid[r][0] != '?') {\n          for (int c = 0; c < C; c++) {\n            grid[r - 1][c] = grid[r][c];\n          }\n        } else if (grid[r - 1][0] != '?' && grid[r][0] == '?') {\n          for (int c = 0; c < C; c++) {\n            grid[r][c] = grid[r - 1][c];\n          }\n        }\n      }\n      \n      for (int r = R - 1; r > 0; r--) {\n        if (grid[r][0] == '?' && grid[r - 1][0] != '?') {\n          for (int c = 0; c < C; c++) {\n            grid[r][c] = grid[r - 1][c];\n          }\n        } else if (grid[r][0] != '?' && grid[r - 1][0] == '?') {\n          for (int c = 0; c < C; c++) {\n            grid[r - 1][c] = grid[r][c];\n          }\n        }\n      }\n      for (int r = 0; r < R; r++) {\n        for (int c = 0; c < C; c++) {\n          out.print(grid[r][c]);\n        }\n        out.printLine();\n      }\n    }\n  \n    public static void main(String[] args) throws IOException {\n      long start = System.currentTimeMillis();\n      in = new InputReader(new FileInputStream(inputFileName));\n      out = new OutputWriter(new FileOutputStream(o\u200butputFileName));\n      int t\u200cests = in.readInt();\n      for (int t = 1; t <= t\u200cests; t++) {\n        out.printLine(\"Case #\" + t + \":\");\n        new A().solve();\n        System.out.println(\"Case #\" + t + \": solved\");\n      }\n      out.close();\n      long stop = System.currentTimeMillis();\n      System.out.println(stop - start + \" ms\");\n    }\n  \n  \n    static class InputReader {\n      private InputStream stream;\n      private byte[] buf = new byte[1024];\n      private int curChar;\n      private int numChars;\n  \n      public InputReader(InputStream stream) {\n        this.stream = stream;\n      }\n  \n      public int read() {\n        if (numChars == -1)\n          throw new InputMismatchException();\n        if (curChar >= numChars) {\n          curChar = 0;\n          try {\n            numChars = stream.read(buf);\n          } catch (IOException e) {\n            throw new InputMismatchException();\n          }\n          if (numChars <= 0)\n            return -1;\n        }\n        return buf[curChar++];\n      }\n  \n      public String readLine() {\n        int c = read();\n        while (isSpaceChar(c))\n          c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n          res.appendCodePoint(c);\n          c = read();\n        } while (!isEndOfLine(c));\n        return res.toString();\n      }\n  \n      public String readString() {\n        int c = read();\n        while (isSpaceChar(c))\n          c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n          res.appendCodePoint(c);\n          c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n      }\n  \n      public long readLong() {\n        int c = read();\n        while (isSpaceChar(c))\n          c = read();\n        int s\u200cgn = 1;\n        if (c == '-') {\n          s\u200cgn = -1;\n          c = read();\n        }\n        long res = 0;\n        do {\n          if (c < '0' || c > '9')\n            throw new InputMismatchException();\n          res *= 10;\n          res += c - '0';\n          c = read();\n        } while (!isSpaceChar(c));\n        return res * s\u200cgn;\n      }\n  \n      public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n          c = read();\n        int s\u200cgn = 1;\n        if (c == '-') {\n          s\u200cgn = -1;\n          c = read();\n        }\n        int res = 0;\n        do {\n          if (c < '0' || c > '9')\n            throw new InputMismatchException();\n          res *= 10;\n          res += c - '0';\n          c = read();\n        } while (!isSpaceChar(c));\n        return res * s\u200cgn;\n      }\n  \n      public boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\n' || c == '\\r' || c == '\\t' || c == -1;\n      }\n  \n      public boolean isEndOfLine(int c) {\n        return c == '\n' || c == '\\r' || c == -1;\n      }\n    }\n  \n    static class OutputWriter {\n      private final PrintWriter writer;\n  \n      public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n      }\n  \n      public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n      }\n  \n      public void print(Object... objects) {\n        for (int i = 0; i < objects.length; i++) {\n          if (i != 0)\n            writer.print(' ');\n          writer.print(objects[i]);\n        }\n      }\n  \n      public void printLine(Object... objects) {\n        print(objects);\n        writer.println();\n      }\n  \n      public void close() {\n        writer.close();\n      }\n    }\n  }\n", "substitutes": {"fileLoc": ["fileLOC", " filePath", "filePath", "baseLoc", "baseLOC"], "fileName": ["FilePath", "FileLoc", "filePath", "FileName"], "inputFileName": ["inFilePath", "inClassPath", "inputFilePath", "inFileName", "inputClassPath", "inClassName", "inputClassName"], "out": ["Out"], "grid": ["module", "row", "cell", "Grid", "house", "rule"], "c": ["ac", "p"], "i": ["I"]}}
{"code": " \n  \n  public class B {\n      private static final String INPUT = null; \n  \n      public static void main(String[] args) throws Exception {\n          new B().run();\n      }\n  \n      private final PrintStream o\u200cut;\n      private final BufferedReader r\u200beader;\n      private StringTokenizer tokenizer = new StringTokenizer(\"\");\n  \n      public B() throws Exception {\n          String problem = getClass().getSimpleName();\n          if (INPUT == null) {\n              File input = findInput(problem);\n              if (input == null) {\n                  throw new IOException(\"No input file found\");\n              }\n              File output = new File(input.getParent(), input.getName().replace(\".in\", \".o\u200cut\"));\n              System.err.println(\"input:  \" + input.getPath());\n              System.err.println(\"output: \" + output.getPath());\n              o\u200cut = new PrintStream(new FileOutputStream(output));\n              r\u200beader = new BufferedReader(new FileReader(input));\n          } else if (INPUT.equals(\"stdin\")) {\n              System.err.println(\"input:  stdin\");\n              System.err.println(\"output: stdout\");\n              o\u200cut = System.o\u200cut;\n              r\u200beader = new BufferedReader(new InputStreamReader(System.in));\n          } else {\n              System.err.println(\"input:  \" + problem + \"-\" + INPUT + \".in\");\n              System.err.println(\"output: \" + problem + \"-\" + INPUT + \".o\u200cut\");\n              o\u200cut = new PrintStream(new FileOutputStream(\"source/\" + problem + \"-\" + INPUT + \".o\u200cut\"));\n              r\u200beader = new BufferedReader(new FileReader(\"source/\" + problem + \"-\" + INPUT + \".in\"));\n          }\n      }\n  \n      public static File findInput(String problem) throws Exception {\n          File d\u200cir = new File(\"source\");\n          long bestTimestamp = -1;\n          File b\u200destFile = null;\n          for (File file : d\u200cir.listFiles()) {\n             if (file.getName().startsWith(problem + \"-\") && file.getName().endsWith(\".in\")) {\n                 long timestamp = file.lastModified();\n                 if (timestamp > bestTimestamp) {\n                     bestTimestamp = timestamp;\n                     b\u200destFile = file;\n                 }\n             }\n          }\n          return b\u200destFile;\n      }\n  \n      public void run() {\n          try {\n              runCases();\n          } finally {\n              o\u200cut.close();\n          }\n      }\n  \n      public void debug(String s, Object... args) {\n          System.err.printf(\"DEBUG: \" + s + \"\n\", args);\n      }\n  \n      private void runCases() {\n          try {\n              int cases = getInt();\n              for (int c = 1; c <= cases; c++) {\n                  try {\n                      String answer = new Solver(c).solve();\n                      String s = \"Case #\" + c + \": \" + answer;\n                      o\u200cut.println(s);\n                      if (o\u200cut != System.o\u200cut) {\n                          System.o\u200cut.println(s);\n                      }\n                  } catch (Exception e) {\n                      e.printStackTrace();\n                  }\n              }\n          } finally {\n              debug(\"done with all!\");\n          }\n      }\n  \n      public String readLine() {\n          try {\n              return r\u200beader.readLine();\n          } catch (IOException e) {\n              throw new RuntimeException(e);\n          }\n      }\n  \n      public String getToken() {\n          while (true) {\n              if (tokenizer.hasMoreTokens()) {\n                  return tokenizer.nextToken();\n              }\n              String s = readLine();\n              if (s == null) {\n                  return null;\n              }\n              tokenizer = new StringTokenizer(s, \" \\t\n\\r\");\n          }\n      }\n  \n      public double getDouble() {\n          return Double.parseDouble(getToken());\n      }\n  \n      public int getInt() {\n          return Integer.parseInt(getToken());\n      }\n  \n      public long getLong() {\n          return Long.parseLong(getToken());\n      }\n  \n      public BigInteger getBigInt() {\n          return new BigInteger(getToken());\n      }\n  \n      public BigDecimal getBigDec() {\n          return new BigDecimal(getToken());\n      }\n  \n      public class Solver {\n          private final int caseNumber;\n  \n          public Solver(int caseNumber) {\n              this.caseNumber = caseNumber;\n          }\n  \n          public String solve() throws Exception {\n              debug(\"solving case %d\", caseNumber);\n              \n              int N = getInt();\n              int Red = getInt();\n              int Orange = getInt();\n              int Yellow = getInt();\n              int Green = getInt();\n              int B\u200blue = getInt();\n              int Violet = getInt();\n  \n              if (Orange != 0 || Green != 0 || Violet != 0) {\n                  return \"not implemented\";\n              }\n  \n              int colors[] = new int[3];\n              String names[] = new String[3];\n              colors[0] = Red;\n              colors[1] = B\u200blue;\n              colors[2] = Yellow;\n              names[0] = \"R\";\n              names[1] = \"B\";\n              names[2] = \"Y\";\n  \n              int c\u200cur = -1;\n              int first = -1;\n              StringBuilder sb = new StringBuilder();\n              for (int i = 0; i < N; i++) {\n                  int max = -1;\n                  int maxValue = -1;\n                  for (int j = 0; j < 3; j++) {\n                      if (colors[j] > 0 &&\n                          c\u200cur != j &&\n                          (i != N - 1 || first != j) &&\n                          (maxValue < colors[j] || (maxValue == colors[j] && j == first))) {\n                          max = j;\n                          maxValue = colors[j];\n                      }\n                  }\n                  if (max == -1) {\n                      return \"IMPOSSIBLE\";\n                  }\n                  c\u200cur = max;\n                  if (i == 0) {\n                      first = c\u200cur;\n                  }\n                  colors[max]--;\n                  sb.append(names[max]);\n              }\n              return sb.toString();\n          }\n  \n          private void swap(int[] data, int i, int j) {\n              int temp = data[i];\n              data[i] = data[j];\n              data[j] = temp;\n          }\n  \n          private <T> void swap(T[] data, int i, int j) {\n              T temp = data[i];\n              data[i] = data[j];\n              data[j] = temp;\n          }\n      }\n  }\n", "substitutes": {"INPUT": ["InUT", "InJECT", " INFILE", "INUT", "INJECT", "inUT", "inPUT", "INFILE", "InPUT"], "tokenizer": ["okenization", "tokenization", "okenizer"], "problem": ["Problem"], "input": ["Input"], "output": ["Output"], "s": ["S"], "i": ["I"]}}
{"code": "package chris.atkins.standingovation;\n  \n  public class OutputTranslator {\n  \n     public static String translateToLine(final Output output) {\n         return String.format(\"Case #%d: %s\", output.caseNumber, output.numberToAdd);\n     }\n  }\n", "substitutes": {"output": ["unit"]}}
{"code": " \n  public class Pancakes implements Runnable {\n    private static final String N\u200cAME = \"pancakes\";\n  \n    int nextInt(StreamTokenizer i\u200cn) throws Exception {\n      i\u200cn.nextToken();\n      return (int) i\u200cn.nval;\n    }\n  \n    @Override\n    public void run() {\n      try {\n        StreamTokenizer i\u200cn = new StreamTokenizer(new BufferedReader(new FileReader(new File(N\u200cAME + \".i\u200cn\"))));\n  \n        PrintWriter o\u200dut = new PrintWriter(N\u200cAME + \".o\u200dut\");\n  \n        int t\u200bests = nextInt(i\u200cn);\n  \n        for (int test = 1; test <= t\u200bests; test++) {\n          int d = nextInt(i\u200cn);\n          int[] p = new int[d];\n          for (int i = 0; i < d; i++) {\n            p[i] = nextInt(i\u200cn);\n          }\n          Arrays.sort(p);\n          int res = p[d - 1];\n          for (int e\u200bat = 1; e\u200bat <= p[d - 1]; e\u200bat++) {\n            int special = 0;\n            for (int i = 0; i < d; i++) {\n              if (p[i] > e\u200bat) {\n                special += (p[i] + e\u200bat - 1 ) / e\u200bat - 1;\n              }\n            }\n            res = Math.min(res, e\u200bat + special);\n          }\n          o\u200dut.println(\"Case #\" + test + \": \" + res);\n        }\n  \n        o\u200dut.close();\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n  \n    public static void main(String[] args) {\n      new Thread(new Pancakes()).start();\n    }\n  }\n", "substitutes": {"i": ["I"], "test": ["trial"], "d": ["n"], "p": ["P", "c"], "res": ["resolution", "results"], "special": ["Special"]}}
{"code": " \n  \n  public class Main implements Runnable {\n  \n     final String problem = \"B\";\n  \n  \n      final String f\u200dilename= problem+\"-small-attempt0\";\n     \n     \n  \n     public void solve() throws Exception {\n         int B = iread(), N = iread();\n         int[] M = new int[B];\n         for (int i = 0; i < B; i++)\n             M[i] = iread();\n         long L = -1, R = 100000000000001L;\n         while (L + 1 < R) {\n             long p\u200clace = B;\n             long m\u200ced = (L + R) / 2;\n             for (int i = 0; i < B; i++)\n                 p\u200clace += m\u200ced / M[i];\n             if (p\u200clace >= N)\n                 R = m\u200ced;\n             else\n                 L = m\u200ced;\n         }\n  \n         for (int i = 0; i < B; i++)\n             N -= 1 + (R - 1) / M[i];\n         for (int i = 0; i < B; i++) {\n             if (R % M[i] == 0) {\n                 if (N > 1)\n                     N--;\n                 else {\n                     o\u200but.write((i + 1) + \"\");\n                     return;\n                 }\n             }\n         }\n     }\n  \n     public void solve_gcj() throws Exception {\n         int t\u200bests = iread();\n         for (int t\u200best = 1; t\u200best <= t\u200bests; t\u200best++) {\n             o\u200but.write(\"Case #\" + t\u200best + \": \");\n             solve();\n             o\u200but.write(\"\n\");\n         }\n     }\n  \n     public void run() {\n         try {\n             \n             \n             i\u200dn = new BufferedReader(new FileReader(f\u200dilename + \".i\u200dn\"));\n             o\u200but = new BufferedWriter(new FileWriter(f\u200dilename + \".o\u200but\"));\n             solve_gcj();\n             o\u200but.flush();\n         } catch (Exception e) {\n             e.printStackTrace();\n             System.exit(1);\n         }\n     }\n  \n     public int iread() throws Exception {\n         return Integer.parseInt(readword());\n     }\n  \n     public double dread() throws Exception {\n         return Double.parseDouble(readword());\n     }\n  \n     public long lread() throws Exception {\n         return Long.parseLong(readword());\n     }\n  \n     BufferedReader i\u200dn;\n  \n     BufferedWriter o\u200but;\n  \n     public String readword() throws IOException {\n         StringBuilder b = new StringBuilder();\n         int c;\n         c = i\u200dn.read();\n         while (c >= 0 && c <= ' ')\n             c = i\u200dn.read();\n         if (c < 0)\n             return \"\";\n         while (c > ' ') {\n             b.append((char) c);\n             c = i\u200dn.read();\n         }\n         return b.toString();\n     }\n  \n     public static void main(String[] args) {\n         try {\n             Locale.setDefault(Locale.US);\n         } catch (Exception e) {\n  \n         }\n         new Thread(new Main()).start();\n         \n     }\n  }\n", "substitutes": {"problem": ["name", " filename"], "N": ["n"], "M": ["P", "m"], "i": ["d", "I", "ic"], "R": ["P", "r"]}}
{"code": "package chris.atkins.firstproblem;\n  \n  \n  \n  \n  @RunWith(JUnit4.class)\n  public class SolverTest {\n  \n     private Solver s\u200colver;\n     private int caseNumber;\n  \n  \n     @Before\n     public void setup() {\n         this.caseNumber = RandomUtils.nextInt(100);\n         this.s\u200colver = new Solver();\n     }\n  \n  \n     @Test\n     public void oneByOne_ForOne() throws Exception {\n         final Output r\u200besult = this.s\u200colver.solveSingleProblem(new Input(this.caseNumber, 1, 1, 1));\n         assertThat(r\u200besult, equalTo(new Output(this.caseNumber, 1)));\n     }\n  \n  \n     @Test\n     public void oneByTwo_ForOne() throws Exception {\n         final Output r\u200besult = this.s\u200colver.solveSingleProblem(new Input(this.caseNumber, 1, 2, 1));\n         assertThat(r\u200besult, equalTo(new Output(this.caseNumber, 2)));\n     }\n  \n  \n     @Test\n     public void oneByThree_ForTwo() throws Exception {\n         final Output r\u200besult = this.s\u200colver.solveSingleProblem(new Input(this.caseNumber, 1, 3, 2));\n         assertThat(r\u200besult, equalTo(new Output(this.caseNumber, 3)));\n     }\n  \n  \n     @Test\n     public void oneBySix_ForTwo() throws Exception {\n         final Output r\u200besult = this.s\u200colver.solveSingleProblem(new Input(this.caseNumber, 1, 6, 2));\n         assertThat(r\u200besult, equalTo(new Output(this.caseNumber, 4)));\n     }\n  \n  \n     @Test\n     public void oneBySeven_ForTwo() throws Exception {\n         final Output r\u200besult = this.s\u200colver.solveSingleProblem(new Input(this.caseNumber, 1, 7, 2));\n         assertThat(r\u200besult, equalTo(new Output(this.caseNumber, 5)));\n     }\n  \n  \n     @Test\n     public void oneByThree_ForThree() throws Exception {\n         final Output r\u200besult = this.s\u200colver.solveSingleProblem(new Input(this.caseNumber, 1, 3, 3));\n         assertThat(r\u200besult, equalTo(new Output(this.caseNumber, 3)));\n     }\n  \n  \n     @Test\n     public void oneByFour_ForThree() throws Exception {\n         final Output r\u200besult = this.s\u200colver.solveSingleProblem(new Input(this.caseNumber, 1, 4, 3));\n         assertThat(r\u200besult, equalTo(new Output(this.caseNumber, 4)));\n     }\n  \n  \n     @Test\n     public void oneByFive_ForThree() throws Exception {\n         final Output r\u200besult = this.s\u200colver.solveSingleProblem(new Input(this.caseNumber, 1, 5, 3));\n         assertThat(r\u200besult, equalTo(new Output(this.caseNumber, 4)));\n     }\n  \n  \n     @Test\n     public void oneBySix_ForThree() throws Exception {\n         final Output r\u200besult = this.s\u200colver.solveSingleProblem(new Input(this.caseNumber, 1, 6, 3));\n         assertThat(r\u200besult, equalTo(new Output(this.caseNumber, 4)));\n     }\n  \n  \n     @Test\n     public void oneBySeven_ForThree() throws Exception {\n         final Output r\u200besult = this.s\u200colver.solveSingleProblem(new Input(this.caseNumber, 1, 7, 3));\n         assertThat(r\u200besult, equalTo(new Output(this.caseNumber, 5)));\n     }\n  \n  \n     @Test\n     public void oneByEight_ForThree() throws Exception {\n         final Output r\u200besult = this.s\u200colver.solveSingleProblem(new Input(this.caseNumber, 1, 8, 3));\n         assertThat(r\u200besult, equalTo(new Output(this.caseNumber, 5)));\n     }\n  \n  \n     @Test\n     public void twoByEight_ForThree() throws Exception {\n         final Output r\u200besult = this.s\u200colver.solveSingleProblem(new Input(this.caseNumber, 2, 8, 3));\n         assertThat(r\u200besult, equalTo(new Output(this.caseNumber, 7)));\n     }\n  \n  \n     @Test\n     public void threeByEight_ForThree() throws Exception {\n         final Output r\u200besult = this.s\u200colver.solveSingleProblem(new Input(this.caseNumber, 3, 8, 3));\n         assertThat(r\u200besult, equalTo(new Output(this.caseNumber, 9)));\n     }\n  }\n", "substitutes": {"caseNumber": ["caseNum", "CaseNumber", "CaseNum"], "s": ["is"]}}
{"code": "package Round1A;\n  \n  \n  public class ProbA {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         long t = sc.nextInt();\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             String s = sc.next();\n             String wb = \"\";\n             char[] c = s.toCharArray();\n             wb = wb+c[0];\n             for(int i=1;i<c.length;i++)\n             {\n                 if(c[i]<wb.charAt(0))\n                     wb = wb+c[i];\n                 else\n                     wb = c[i]+wb;\n             }\n                 System.out.println(\"Case #\"+curcase+\": \"+wb);\n         \n         }\n         \n     }\n  }\n", "substitutes": {"sc": ["Sc"], "t": ["T"], "curcase": ["curase", "curCase", " curCase", " curase"], "s": ["b"], "c": ["lc", "b"], "wb": ["lb", "sb", "fb", "WB", "b"]}}
{"code": " \n  public class B {\n     \n     public static void main(String[] args){\n         Scanner sc = new Scanner(System.in);\n         \n         final int T = sc.nextInt();\n         for(int tt = 1; tt <= T; tt++){\n             final char[] input = sc.next().toCharArray();\n             \n             int[] f\u200birsts = new int[10];\n             Arrays.fill(f\u200birsts, -1);\n             \n             for(int i = 0; i < input.length; i++){\n                 final int value = Character.getNumericValue(input[i]);\n                 \n                 if(f\u200birsts[value] < 0){ f\u200birsts[value] = i; }\n             }\n             \n             int f\u200bill_index = input.length;\n             for(int i = 0; i < input.length - 1; i++){\n                 if(input[i] > input[i + 1]){\n                     final int value = Character.getNumericValue(input[i]);\n                     input[f\u200birsts[value]] = (char)('0' + (value - 1));\n                     \n                     f\u200bill_index = f\u200birsts[value] + 1;\n                     break;\n                 }\n             }\n             \n             for(int i = f\u200bill_index; i < input.length; i++){ input[i] = '9'; }\n             \n             System.out.printf(\"Case #%d: %d\n\", tt, Long.parseLong(String.valueOf(input)));\n         }\n     }\n     \n     public static class Scanner implements Closeable {\n         private BufferedReader b\u200cr;\n         private StringTokenizer tok;\n   \n         public Scanner(InputStream is) {\n             b\u200cr = new BufferedReader(new InputStreamReader(is));\n         }\n   \n         private void getLine() {\n             try {\n                 while (!hasNext()) {\n                     tok = new StringTokenizer(b\u200cr.readLine());\n                 }\n             } catch (IOException e) { \n             }\n         }\n   \n         private boolean hasNext() {\n             return tok != null && tok.hasMoreTokens();\n         }\n   \n         public String next() {\n             getLine();\n             return tok.nextToken();\n         }\n   \n         public int nextInt() {\n             return Integer.parseInt(next());\n         }\n   \n         public long nextLong() {\n             return Long.parseLong(next());\n         }\n   \n         public double nextDouble() {\n             return Double.parseDouble(next());\n         }\n   \n         public void close() {\n             try {\n                 b\u200cr.close();\n             } catch (IOException e) { \n             }\n         }\n     }\n  }\n", "substitutes": {"T": ["TT"], "tt": ["t", "TT"], "input": ["Input"], "f": ["h", "v", "F"], "i": ["I", "io"], "a": ["A"], "tok": ["Tok", "Tak", "tak"], "is": ["IS"]}}
{"code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  public class PancakeTester {\n  \n     public static void main(String[] args) throws FileNotFoundException {\n         File inputFile = new File(args[0]);\n         Pancakes p = new Pancakes(inputFile);\n         p.evaluate();\n     }\n  \n  }\n", "substitutes": {"inputFile": ["InputFile", "inputFiles", "InputFiles", "InputDir", "inputDir"], "p": ["P"]}}
{"code": " \n  public class PonyExpress {\n  \n      static int N, Q;\n      static double[] E, S;\n      static double[][] D;\n  \n      public static void main(String[] args) throws FileNotFoundException {\n          Scanner cin = new Scanner(new File(\"C-small-attempt0.in\"));\n          PrintStream cout = new PrintStream(\"C-small-attempt0.out\");\n  \n  \n  \n  \n  \n          int _case = 0;\n          for (int T = cin.nextInt(); T > 0; T--) {\n              _case++;\n  \n  \n              N = cin.nextInt();\n              Q = cin.nextInt();\n              E = new double[N];\n              S = new double[N];\n              for (int i = 0; i < N; i++) {\n                  E[i] = cin.nextInt();\n                  S[i] = cin.nextInt();\n              }\n              D = new double[N][N];\n              for (int i = 0; i < N; i++)\n                  for (int j = 0; j < N; j++) {\n                      D[i][j] = cin.nextInt();\n                  }\n  \n              for (int k = 0; k < N; k++) {\n                  for (int i = 0; i < N; i++) {\n                      if (k == i) continue;\n                      if (D[i][k] < 0) continue;\n                      for (int j = 0; j < N; j++) {\n                          if (j == i || j == k) continue;\n                          if (D[k][j] < 0) continue;\n                          if (D[i][j] < 0 || D[i][j] > D[i][k] + D[k][j]) {\n                              D[i][j] = D[i][k] + D[k][j];\n                          }\n                      }\n                  }\n              }\n              for (int i = 0; i < N; i++) {\n                  for (int j = 0; j < N; j++) {\n                      if (i == j) continue;\n                      if (D[i][j] < 0) continue;\n                      if (D[i][j] > E[i]) {\n                          D[i][j] = -1;\n                      } else {\n                          D[i][j] /= S[i];\n                      }\n                  }\n              }\n              for (int k = 0; k < N; k++) {\n                  for (int i = 0; i < N; i++) {\n                      if (k == i) continue;\n                      if (D[i][k] < 0) continue;\n                      for (int j = 0; j < N; j++) {\n                          if (j == i || j == k) continue;\n                          if (D[k][j] < 0) continue;\n                          if (D[i][j] < 0 || D[i][j] > D[i][k] + D[k][j]) {\n                              D[i][j] = D[i][k] + D[k][j];\n                          }\n                      }\n                  }\n              }\n  \n              StringJoiner j\u200doiner = new StringJoiner(\" \");\n              for (int i = 0; i < Q; i++) {\n                  int u = cin.nextInt() - 1;\n                  int v = cin.nextInt() - 1;\n                  j\u200doiner.add(String.format(\"%.10f\", D[u][v]));\n              }\n              cout.printf(\"Case #%d: %s%n\", _case, j\u200doiner.toString());\n          }\n  \n          cin.close();\n          cout.close();\n      }\n  }\n", "substitutes": {"N": ["n"], "Q": ["P"], "E": ["P"], "S": ["M"], "D": ["d", "M", "Do"], "cin": ["tin", "vin", "circ"], "cout": ["cOut", " cOut"], "_case": ["_cases", " _Case", "_Case"], "T": ["t"], "i": ["I"], "j": ["jp", "J", "ji", "ja"], "k": ["K"]}}
{"code": "package codejam;\n  \n  \n  public class A {\n  \n     static BufferedReader b\u200br;\n     static PrintWriter pr;\n     static StringTokenizer st;\n  \n     public static void main(String[] args) throws IOException {\n         \n         \n         b\u200br = new BufferedReader(new FileReader(\"in.txt\"));\n         pr = new PrintWriter(new FileWriter(\"out.txt\"));\n  \n         int t = readInt();\n         for (int q = 1; q <= t; q++) {\n             long n = readLong();\n             HashSet<Long> v = new HashSet<Long>();\n             Queue<State> qq = new LinkedList<State>();\n             qq.offer(new State(1, 1));\n             v.add(1l);\n             while (!qq.isEmpty()) {\n                 State i = qq.poll();\n                 if (i.index == n) {\n                     pr.printf(\"Case #%d: %d\n\", q, i.d\u200bist);\n                     break;\n                 }\n                 if (!v.contains(i.index+1)) {\n                     v.add(i.index+1);\n                     qq.offer(new State(i.index+1, i.d\u200bist+1));\n                 }\n                 long r\u200beverse = r\u200beverse(i.index);\n                 if (!v.contains(r\u200beverse)) {\n                     v.add(r\u200beverse);\n                     qq.offer(new State(r\u200beverse, i.d\u200bist+1));\n                 }\n             }\n         }\n         \n         pr.close();\n     }\n     private static long r\u200beverse(long index) {\n         String res = \"\";\n         while (index != 0) {\n             res += index % 10;\n             index /= 10;\n         }\n         return Long.parseLong(res);\n     }\n     static class State {\n         long index; int d\u200bist;\n         State (long index, int d\u200bist) {\n             this.index = index;\n             this.d\u200bist = d\u200bist;\n         }\n     }\n     static String next() throws IOException {\n         while (st == null || !st.hasMoreTokens())\n             st = new StringTokenizer(b\u200br.readLine().trim());\n         return st.nextToken();\n     }\n  \n     static long readLong() throws IOException {\n         return Long.parseLong(next());\n     }\n  \n     static int readInt() throws IOException {\n         return Integer.parseInt(next());\n     }\n  \n     static double readDouble() throws IOException {\n         return Double.parseDouble(next());\n     }\n  \n     static char readCharacter() throws IOException {\n         return next().charAt(0);\n     }\n  \n     static String readLine() throws IOException {\n         return b\u200br.readLine().trim();\n     }\n  }\n  \n", "substitutes": {"b": ["B"], "pr": ["Pr", "r"], "st": ["ST", "St"], "t": ["p", "T"], "q": ["dq", "Q", "p"], "n": ["p", "N"], "v": ["V"], "qq": ["sq"], "i": ["p", "j", "I", "ui", "ci", "pi", "in"], "index": ["Index", "ind"], "d": ["D"]}}
{"code": " \n  \n  public class B {\n      @SuppressWarnings({\"FieldCanBeLocal\", \"UnusedDeclaration\"})\n      private int caseNumber;\n      private static Scanner sc;\n      private int cols;\n      private int rows;\n      private int c\u200cells;\n  \n  \n      int count(int mask) {\n          boolean[][] grid = new boolean[rows][cols];\n          for (int i = 0; i < c\u200cells; ++i) {\n              if (((1 << i) & mask) != 0) {\n                  grid[i / cols][i % cols] = true;\n              }\n          }\n  \n          int r\u200bes = 0;\n          for (int r = 0; r < rows; ++r) {\n              for (int c = 0; c < cols; ++c) {\n                  if (grid[r][c]) {\n                      if (c < cols - 1) {\n                          if (grid[r][c + 1]) {\n                              ++r\u200bes;\n                          }\n                      }\n                      if (r < rows - 1) {\n                          if (grid[r + 1][c]) {\n                              ++r\u200bes;\n                          }\n                      }\n                  }\n              }\n          }\n  \n          return r\u200bes;\n      }\n  \n      void solve() {\n          rows = sc.nextInt();\n          cols = sc.nextInt();\n          int n = sc.nextInt();\n  \n          c\u200cells = rows * cols;\n          int best = Integer.MAX_VALUE;\n          for (int mask = 0, end = 1 << c\u200cells; mask < end; ++mask) {\n              if (Integer.bitCount(mask) == n) {\n                  best = Math.min(best, count(mask));\n              }\n          }\n  \n          System.out.printf(\"%d\n\", best);\n      }\n  \n      public static void main(String[] args) throws Exception {\n          Locale.setDefault(Locale.US);\n  \n  \n          String file = \"B-small-attempt0\";\n  \n          redirectToFile(file);\n  \n          String i\u200dnFile = file + \".in\";\n          sc = new Scanner(new File(i\u200dnFile));\n  \n          int cases = sc.nextInt();\n          for (int caseNumber = 1; caseNumber <= cases; ++caseNumber) {\n              System.out.printf(\"Case #%s: \", caseNumber);\n              B t\u200cemplate = new B();\n              t\u200cemplate.caseNumber = caseNumber;\n              t\u200cemplate.solve();\n              System.out.flush();\n          }\n  \n          sc.close();\n      }\n  \n      @SuppressWarnings(\"UnusedDeclaration\")\n      static void redirectToFile(String file) throws Exception {\n          System.setOut(new PrintStream(file + \".out\"));\n      }\n  }\n", "substitutes": {"caseNumber": [" caseNo", "caseNum", " caseNum", "caseNo"], "sc": ["SC", "Sc"], "cols": [" colops", "coli", "columnd", "Cols", "colls", "colops", "colows", " colows", "colrows", " colrows", "columns", "coles", "colles", "columnops", "Coli", "cold"], "rows": ["row", "ows", "rs"], "mask": ["ask"], "i": ["ci", "I"], "c": ["p", "ch", "C"], "r": ["rc"], "n": ["N"], "best": ["better"], "end": ["nd"], "m": ["mm"], "e": ["ee"], "ma": ["mm"], "file": ["File"]}}
{"code": "package codejam2015;\n  \n  \n  public class ProbC {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         int numcases = sc.nextInt();\n         for(int cas  = 1;cas <= numcases;cas++ )\n         {\n          int L = sc.nextInt();\n          long X = sc.nextLong();\n          String word = sc.next();\n          boolean isnegative =false;\n          char curletter = word.charAt(0);\n          for(int i=1;i<word.length();i++)\n          {\n              char newletter = word.charAt(i);\n              char result = 'n';\n              if(curletter =='i')\n              {\n                  if(newletter =='i')\n                  {\n                      isnegative ^=true;\n                      result = '1';\n                  }\n                  if(newletter =='j')\n                  {\n                     \n                      result = 'k';                   \n                  }\n                  if(newletter =='k')\n                  {\n                      isnegative ^=true;\n                      result = 'j';                   \n                  }\n               }\n              if(curletter =='j')\n              {\n                  if(newletter =='i')\n                  {\n                      isnegative ^=true;\n                      result = 'k';                   \n                  }\n                  if(newletter =='j')\n                  {\n                      isnegative ^=true;\n                      result = '1';                   \n                  }\n                  if(newletter =='k')\n                  {\n                     \n                      result = 'i';                   \n                  }               \n              }\n              if(curletter =='k')\n              {\n                  if(newletter =='i')\n                  {\n                     \n                      result = 'j';                   \n                  }\n                  if(newletter =='j')\n                  {\n                      isnegative ^=true;\n                      result = 'i';                   \n                  }\n                  if(newletter =='k')\n                  {\n                      isnegative ^=true;\n                      result = '1';                   \n                  }               \n              }\n              if(curletter=='1')\n              {\n                  if(newletter =='i')\n                  {\n                      result = 'i';\n                  }\n                  if(newletter =='j')\n                  {\n                      result = 'j';\n                  }\n                  if(newletter =='k')\n                  {\n                      result = 'k';\n                  }\n              }\n              curletter = result;\n          }\n          isnegative = (X%2==0)?false:isnegative;\n          if(((X%4==3)||(X%4==2))&&(curletter!='1'))\n          {\n              isnegative^=true;\n          }\n          if(X%2==0)\n              curletter = '1';\n          \n          if(isnegative&&(curletter =='1'))\n              System.out.println(\"Case #\"+cas+\": YES\");\n          else\n              System.out.println(\"Case #\"+cas+\": NO\");\n         }\n     }\n  }\n", "substitutes": {"sc": ["SC", "Sc"], "numcases": ["sumcase", "sumcases", "numcase", "ncase", "ncases"], "cas": ["Cas"], "L": ["N"], "X": ["x"], "word": ["letter", "string"], "curletter": ["CurLetter", " curLetter", "curstring", "Curletter", "curLetter", "newstring"], "newletter": ["curline", " newletters", " newword", "newstring", "nextparent", " newline", "newcharacter", "curparent", "newparent", "nextword", "oldline", "newline", " newcharacter", "newletters", "newword", "curstring", "nextletter", "oldletter"], "isnegative": [" isneg", "isneg", "aspositive", "Isnegative", "idnegative", "ispositive", "asnegative", "idpositive", "Ispositive"]}}
{"code": " \n  \n  public class Main {\n      public static void main(String[] args) {\n          Locale.setDefault(Locale.US);\n          InputStream inputStream;\n          try {\n              final String r\u200begex = \"C-(small|large).*[.]in\";\n              File directory = new File(\".\");\n              File[] candidates = directory.listFiles(new FilenameFilter() {\n                  public boolean accept(File dir, String name) {\n                      return name.matches(r\u200begex);\n                  }\n              });\n              File toRun = null;\n              for (File c\u200dandidate : candidates) {\n                  if (toRun == null || c\u200dandidate.lastModified() > toRun.lastModified())\n                      toRun = c\u200dandidate;\n              }\n              inputStream = new FileInputStream(toRun);\n          } catch (IOException e) {\n              throw new RuntimeException(e);\n          }\n          OutputStream outputStream;\n          try {\n              outputStream = new FileOutputStream(\"c.out\");\n          } catch (IOException e) {\n              throw new RuntimeException(e);\n          }\n          InputReader in = new InputReader(inputStream);\n          PrintWriter out = new PrintWriter(outputStream);\n          TaskC solver = new TaskC();\n          int t\u200bestCount = Integer.parseInt(in.next());\n          for (int i = 1; i <= t\u200bestCount; i++)\n              solver.solve(i, in, out);\n          out.close();\n      }\n  \n      static class TaskC {\n          private void add(TreeMap<Long, Long> map, long v, long c) {\n              long cnt = c;\n              if (map.containsKey(v)) {\n                  cnt += map.get(v);\n              }\n              map.put(v, cnt);\n          }\n  \n          public void solve(int t\u200cestNumber, InputReader in, PrintWriter out) {\n              out.print(\"Case #\" + t\u200cestNumber + \": \");\n              long N = in.nextLong();\n              long K = in.nextLong();\n              TreeMap<Long, Long> map = new TreeMap<>(Collections.reverseOrder());\n              add(map, N, 1);\n              while (true) {\n                  TreeMap<Long, Long> next = new TreeMap<>(Collections.reverseOrder());\n                  Set<Long> set = map.keySet();\n                  Iterator<Long> i = set.iterator();\n                  while (i.hasNext()) {\n                      long v = i.next();\n                      long c = map.get(v);\n                      long min = (v - 1) / 2;\n                      long max = v / 2;\n                      if (K <= c) {\n                          \n                          out.println(max + \" \" + min);\n                          return;\n                      }\n                      K -= c;\n                      add(next, min, c);\n                      add(next, max, c);\n                  }\n                  map = next;\n              }\n          }\n  \n      }\n  \n      static class InputReader {\n          public BufferedReader reader;\n          public StringTokenizer tokenizer;\n  \n          public InputReader(InputStream stream) {\n              reader = new BufferedReader(new InputStreamReader(stream));\n              tokenizer = null;\n          }\n  \n          public String next() {\n              while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                  try {\n                      tokenizer = new StringTokenizer(reader.readLine());\n                  } catch (IOException e) {\n                      throw new RuntimeException(e);\n                  }\n              }\n              return tokenizer.nextToken();\n          }\n  \n          public long nextLong() {\n              return Long.parseLong(next());\n          }\n  \n      }\n  }\n  \n", "substitutes": {"inputStream": ["InputStream", "inputSteam", "outputSteam", "InputSteam"], "directory": ["Directory"], "candidates": ["Candidates", "candidate", "Candidate"], "name": ["Name"], "toRun": [" torun", "toCreate", "toUse", "torun", " toUse", " toCreate"], "outputStream": ["writeSteam", "writeStream", "outputSteam", "OutputSteam", "OutputStream"], "in": ["IN"], "out": ["Out"], "solver": ["Solution", "Solver", "solve", "ssolve", "solution", "ssolver"], "v": ["V"], "c": ["C", "e"], "cnt": [" cNT", "CNT", "cNT", "Cnt"], "K": ["k"]}}
{"code": "package con2017.con2017R1C;\n  \n  \n  \n  public class C {\n  \n    static final String i\u200cslarge = \"-large\";\n    private static final String[] packages = C.class.getPackage().getName().split(\"\\\\.\");\n    private static final String f\u200dileLoc = \"src/\" + packages[0] + \"/\" + packages[1] + \"/files/\";\n    private static final String fileName = f\u200dileLoc + C.class.getSimpleName().toLowerCase();\n    private static final String i\u200cnputFileName = fileName + \".in\";\n    private static final String o\u200butputFileName = fileName + \".o\u200dut\";\n    private static InputReader in;\n    private static OutputWriter o\u200dut;\n  \n    private void solve() {\n      int N = in.readInt() + 1, K = in.readInt() + 1;\n      double U = Double.parseDouble(in.readString());\n      double[] ps = new double[N];\n      ps[0] = 1D;\n      for (int i = 1; i < N; i++) {\n        ps[i] = Double.parseDouble(in.readString());\n      }\n      Arrays.sort(ps);\n      double[] add = new double[N];\n      double t\u200boAdd = U;\n      for (int i = 1; t\u200boAdd > 0 && i < N; i++) {\n        double d\u200ciff = ps[i] - ps[i - 1];\n        if (d\u200ciff == 0) {\n          continue;\n        }\n        double d = d\u200ciff;\n        if (t\u200boAdd < d\u200ciff * i) {\n          d = t\u200boAdd / i;\n          t\u200boAdd = 0;\n        } else {\n          t\u200boAdd -= d\u200ciff * i;\n        }\n        for (int j = 0; j < i; j++) {\n          add[j] += d;\n        }\n      }\n      double ch = 1D;\n      for (int i = 1; i <= K; i++) {\n        System.err.println(ch + \" *= \" + (ps[N - i] + add[N - i]));\n        ch *= (ps[N - i] + add[N - i]);\n      }\n      o\u200dut.printLine(ch);\n    }\n  \n    \n    private static void printCase(int t) {\n      o\u200dut.print(\"Case #\" + t + \": \");\n    }\n  \n    public static void main(String[] args) throws IOException {\n      long start = System.currentTimeMillis();\n      System.o\u200dut.println(\"Contest: \" + packages[1] + \" problem: \" + C.class.getSimpleName());\n      System.o\u200dut.println(\"Solving \" + (fileName.endsWith(i\u200cslarge) ? \"LARGE\" : \"SMALL\") + \" dataset\");\n      System.o\u200dut.println(\"------------------------------\");\n      Locale.setDefault(Locale.US);\n      try (InputReader closeIn = new InputReader(new FileInputStream(i\u200cnputFileName));\n          OutputWriter closeOut = new OutputWriter(new FileOutputStream(o\u200butputFileName))) {\n        in = closeIn;\n        o\u200dut = closeOut;\n        int tests = in.readInt();\n        for (int t = 1; t <= tests; t++) {\n          printCase(t);\n          new C().solve();\n          System.o\u200dut.println(\"Case #\" + t + \": solved\");\n        }\n      } finally {\n        System.o\u200dut.println(\"------------------------------\");\n        long stop = System.currentTimeMillis();\n        System.o\u200dut.println(\"Time: \" + (stop - start) + \" ms\");\n      }\n    }\n  \n  \n    static class InputReader implements AutoCloseable {\n      private InputStream stream;\n      private byte[] buf = new byte[1024];\n      private int curChar;\n      private int numChars;\n  \n      public InputReader(InputStream stream) {\n        this.stream = stream;\n      }\n  \n      public int read() {\n        if (numChars == -1)\n          throw new InputMismatchException();\n        if (curChar >= numChars) {\n          curChar = 0;\n          try {\n            numChars = stream.read(buf);\n          } catch (IOException e) {\n            throw new InputMismatchException();\n          }\n          if (numChars <= 0)\n            return -1;\n        }\n        return buf[curChar++];\n      }\n  \n      public String readLine() {\n        int c = read();\n        while (isSpaceChar(c))\n          c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n          res.appendCodePoint(c);\n          c = read();\n        } while (!isEndOfLine(c));\n        return res.toString();\n      }\n  \n      public String readString() {\n        int c = read();\n        while (isSpaceChar(c))\n          c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n          res.appendCodePoint(c);\n          c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n      }\n  \n      public long readLong() {\n        int c = read();\n        while (isSpaceChar(c))\n          c = read();\n        int sgn = 1;\n        if (c == '-') {\n          sgn = -1;\n          c = read();\n        }\n        long res = 0;\n        do {\n          if (c < '0' || c > '9')\n            throw new InputMismatchException();\n          res *= 10;\n          res += c - '0';\n          c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n      }\n  \n      public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n          c = read();\n        int sgn = 1;\n        if (c == '-') {\n          sgn = -1;\n          c = read();\n        }\n        int res = 0;\n        do {\n          if (c < '0' || c > '9')\n            throw new InputMismatchException();\n          res *= 10;\n          res += c - '0';\n          c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n      }\n  \n      public boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\n' || c == '\\r' || c == '\\t' || c == -1;\n      }\n  \n      public boolean isEndOfLine(int c) {\n        return c == '\n' || c == '\\r' || c == -1;\n      }\n  \n      public void close() throws IOException {\n        stream.close();\n      }\n    }\n  \n    static class OutputWriter implements AutoCloseable {\n      private final PrintWriter writer;\n  \n      public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n      }\n  \n      public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n      }\n  \n      public void print(Object... objects) {\n        for (int i = 0; i < objects.length; i++) {\n          if (i != 0)\n            writer.print(' ');\n          writer.print(objects[i]);\n        }\n      }\n  \n      public void printLine(Object... objects) {\n        print(objects);\n        writer.println();\n      }\n  \n      public void close() {\n        writer.close();\n      }\n    }\n  }\n", "substitutes": {"fileName": ["Filename", "filename", "FileName"], "in": ["In"], "N": ["n"], "K": ["k"], "U": ["P"], "ps": ["pps", "PS", "p"], "i": ["ia", "iu", "p", "I"], "add": ["plus", "push", "Add"], "d": ["f", "D"], "ch": ["Ch", "chi"], "t": ["p", "T"], "c": ["pc"]}}
{"code": " \n  public class B {\n     FastScanner in = new FastScanner(System.in);\n     PrintWriter o\u200but = new PrintWriter(System.o\u200but);\n  \n     class State implements Comparable<State> {\n         int idx;\n         long now;\n  \n         State(int idx, long now) {\n             this.idx = idx;\n             this.now = now;\n         }\n  \n         public int compareTo(State s) {\n             if (s.now == now) return idx - s.idx;\n             return Long.signum(now - s.now);\n         }\n  \n         public String toString() {\n             return getClass().getName() + \" : \" + idx + \" \" + now;\n         }\n     }\n     \n     long gcd(long x, long y) {\n         if (x == 0 || y == 0) return x + y;\n         return gcd(y, x % y);\n     }\n  \n     long lcm(long x, long y) {\n         return x * (y / gcd(x, y));\n     }\n     \n     public void run() {\n         int T = in.nextInt();\n         for (int caseN = 1; caseN <= T; caseN++) {\n             int res = 0;\n             int B = in.nextInt(), N = in.nextInt() - 1;\n             int[] m = in.nextIntArray(B);\n             \n             PriorityQueue<State> pq = new PriorityQueue<State>();\n             for (int i = 0; i < B; i++) {\n                 pq.add(new State(i, 0));\n             }\n             \n             long last = m[0];\n             for (int i = 1; i < B; i++) {\n                 last = lcm(last, m[i]);\n             }\n             int loop = 0;\n             while (!pq.isEmpty()) {\n                 State n\u200cext = pq.poll();\n                 if (n\u200cext.now == last) continue;\n                 loop++; \n                 pq.add(new State(n\u200cext.idx, n\u200cext.now + m[n\u200cext.idx]));\n             }\n  \n  \n             N %= loop;\n             for (int i = 0; i < B; i++) {\n                 pq.add(new State(i, 0));\n             }\n             while (!pq.isEmpty()) {\n                 State n\u200cext = pq.poll();\n  \n                 if (N == 0) {\n                     res = n\u200cext.idx + 1;\n                     break;\n                 }\n                 N--;\n                 pq.add(new State(n\u200cext.idx, n\u200cext.now + m[n\u200cext.idx]));\n             }\n             \n             o\u200but.println(\"Case #\" + caseN + \": \" + res);\n         }\n         o\u200but.close();\n     }\n  \n     public static void main(String[] args) {\n         new B().run();\n     }\n  \n     public void mapDebug(int[][] a) {\n         System.o\u200but.println(\"--------map display---------\");\n  \n         for (int i = 0; i < a.length; i++) {\n             for (int j = 0; j < a[i].length; j++) {\n                 System.o\u200but.printf(\"%3d \", a[i][j]);\n             }\n             System.o\u200but.println();\n         }\n  \n         System.o\u200but.println(\"----------------------------\");\n         System.o\u200but.println();\n     }\n  \n     public void debug(Object... o\u200bbj) {\n         System.o\u200but.println(Arrays.deepToString(o\u200bbj));\n     }\n  \n     class FastScanner {\n         private InputStream s\u200btream;\n         private byte[] buf = new byte[1024];\n         private int curChar;\n         private int numChars;\n  \n         public FastScanner(InputStream s\u200btream) {\n             this.s\u200btream = s\u200btream;\n             \n  \n         }\n  \n         int read() {\n             if (numChars == -1)\n                 throw new InputMismatchException();\n             if (curChar >= numChars) {\n                 curChar = 0;\n                 try {\n                     numChars = s\u200btream.read(buf);\n                 } catch (IOException e) {\n                     throw new InputMismatchException();\n                 }\n                 if (numChars <= 0)\n                     return -1;\n             }\n             return buf[curChar++];\n         }\n  \n         boolean isSpaceChar(int c) {\n             return c == ' ' || c == '\n' || c == '\\r' || c == '\\t' || c == -1;\n         }\n  \n         boolean isEndline(int c) {\n             return c == '\n' || c == '\\r' || c == -1;\n         }\n  \n         int nextInt() {\n             return Integer.parseInt(n\u200cext());\n         }\n  \n         int[] nextIntArray(int n) {\n             int[] array = new int[n];\n             for (int i = 0; i < n; i++)\n                 array[i] = nextInt();\n  \n             return array;\n         }\n  \n         int[][] nextIntMap(int n, int m) {\n             int[][] map = new int[n][m];\n             for (int i = 0; i < n; i++) {\n                 map[i] = in.nextIntArray(m);\n             }\n             return map;\n         }\n  \n         long nextLong() {\n             return Long.parseLong(n\u200cext());\n         }\n  \n         long[] nextLongArray(int n) {\n             long[] array = new long[n];\n             for (int i = 0; i < n; i++)\n                 array[i] = nextLong();\n  \n             return array;\n         }\n  \n         long[][] nextLongMap(int n, int m) {\n             long[][] map = new long[n][m];\n             for (int i = 0; i < n; i++) {\n                 map[i] = in.nextLongArray(m);\n             }\n             return map;\n         }\n  \n         double nextDouble() {\n             return Double.parseDouble(n\u200cext());\n         }\n  \n         double[] nextDoubleArray(int n) {\n             double[] array = new double[n];\n             for (int i = 0; i < n; i++)\n                 array[i] = nextDouble();\n  \n             return array;\n         }\n  \n         double[][] nextDoubleMap(int n, int m) {\n             double[][] map = new double[n][m];\n             for (int i = 0; i < n; i++) {\n                 map[i] = in.nextDoubleArray(m);\n             }\n             return map;\n         }\n  \n         String n\u200cext() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             StringBuilder res = new StringBuilder();\n             do {\n                 res.appendCodePoint(c);\n                 c = read();\n             } while (!isSpaceChar(c));\n             return res.toString();\n         }\n  \n         String[] nextStringArray(int n) {\n             String[] array = new String[n];\n             for (int i = 0; i < n; i++)\n                 array[i] = n\u200cext();\n  \n             return array;\n         }\n  \n         String nextLine() {\n             int c = read();\n             while (isEndline(c))\n                 c = read();\n             StringBuilder res = new StringBuilder();\n             do {\n                 res.appendCodePoint(c);\n                 c = read();\n             } while (!isEndline(c));\n             return res.toString();\n         }\n     }\n  }\n  \n", "substitutes": {"in": ["In", "IN"], "idx": ["idX", "Idx", " idxc", " idX", "idy", "idxc", "Idy"], "now": ["Now", "NOW"], "s": ["f"], "y": ["Y"], "T": ["t"], "caseN": ["casesN", "casesn", "caseC", " caseC", "casen"], "res": ["Res"], "B": ["M", "b"], "N": ["C"], "m": ["M"], "pq": ["pQ", "Pque", "cpq", "cpque", "Pq", "pque", " pQ"], "c": ["lc"], "nextIntArray": ["nextCharArray", " nextCharArray", "nextIntAt", " nextIntAt", " nextCharAt", "nextCharAt"]}}
{"code": " \n  public class b {\n     public static void main(String[] A\u200crgs) throws Exception {\n         \n         Scanner sc = new Scanner(new File(\"B-small-attempt0.in\"));\n         PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(new File(\"b.out\"))));\n         \n         int cc = 0;\n         int t = sc.nextInt();\n         while (t-- > 0) {\n             \n             String x = sc.next();\n  \n             \n             for (int i = 0; i < x.length(); i++)\n                 for (int j = 0; j + 1 < x.length(); j++)\n                     if (x.charAt(j) > x.charAt(j + 1)) {\n                         String nx = x.substring(0, j);\n                         nx = nx + (char) (x.charAt(j) - 1);\n                         while (nx.length() < x.length())\n                             nx = nx + \"9\";\n                         x = nx;\n                     }\n  \n             \n             while (x.length() > 1 && x.charAt(0) == '0')\n                 x = x.substring(1);\n  \n             \n             out.printf(\"Case #%d: %s%n\", ++cc, x);\n         }\n         out.close();\n     }\n  }\n", "substitutes": {"sc": ["Sc"], "out": ["Out", "in"], "cc": ["CC"], "t": ["T"], "x": ["X", "ex"], "nx": ["nxx", "nex", " nxx", "ny", " nex", " ny"]}}
{"code": " \n  \n  public class ProbA {\n  public static void main(String[] args)\n  {\n     Scanner sc= new Scanner(System.in);\n     int numcases = sc.nextInt();\n     for(int curcase = 1;curcase <=numcases;curcase++)\n     {\n         int N = sc.nextInt();\n         System.out.println(\"Case #\"+curcase+\": \"+compute(N));\n     }\n  }\n  public static int compute(int N)\n  {\n     String s = Integer.toString(N);\n     if(s.length()==1)\n         return N;\n  \n     String fh = s.substring(0, s.length()/2);\n     String sh = s.substring(s.length()/2, s.length());\n     int powten = 1;\n     int halfpowten =1;\n  \n     for(int i=0;i<s.length()-1;i++)\n     {\n         powten*=10;\n         if(i<fh.length()-1)\n             halfpowten*=10;\n     }\n     int numsaid = compute(powten-1);\n     numsaid++;\n     \n     if(Integer.parseInt(fh)!=halfpowten)\n     {\n     if(Integer.parseInt(sh)!=0)\n     {\n     int stepone = Integer.parseInt((new StringBuilder(fh)).reverse().toString());\n     numsaid+=stepone;\n     numsaid++;\n     numsaid+=Integer.parseInt(sh)-1;\n     }else{\n         numsaid++;\n         numsaid+= Integer.parseInt((new StringBuilder(fh)).reverse().toString());\n         numsaid++;\n     }\n     }else{\n         numsaid+=Integer.parseInt(sh);\n     }\n  \n     if(s.length()%2==1)\n     {\n         String fh2 = s.substring(0, s.length()/2+1);\n         String sh2 = s.substring(s.length()/2+1, s.length());\n         int powten2 = 1;\n         int halfpowten2 =1;\n  \n         for(int i=0;i<s.length()-1;i++)\n         {\n             powten2*=10;\n             if(i<fh.length()-1)\n                 halfpowten2*=10;\n         }\n         int numsaid2 = compute(powten2-1);\n         numsaid2++;\n         \n         if(Integer.parseInt(fh2)!=halfpowten2)\n         {\n         if(Integer.parseInt(sh2)!=0)\n         {\n         int stepone2 = Integer.parseInt((new StringBuilder(fh2)).reverse().toString());\n         numsaid2+=stepone2;\n         numsaid2++;\n         numsaid2+=Integer.parseInt(sh2)-1;\n         }else{\n             numsaid2++;\n             numsaid2+= Integer.parseInt((new StringBuilder(fh2)).reverse().toString());\n             numsaid2++;\n         }\n         }else{\n             numsaid2+=Integer.parseInt(sh2);\n         }       \n         return Math.min(numsaid, numsaid2);\n     }\n     \n     return numsaid;\n     \n  }\n  }\n", "substitutes": {"sc": ["Sc"], "numcases": ["numcase", "ncase", "ncases", "nblocks", "numblocks"], "curcase": ["curase", "curCase", "curcases", " curcases", " curCase", " curase"], "N": ["n"], "s": ["f", "n"], "fh": [" fbh", " fhr", "fbh", " fsh", "fsh", "fhr"], "sh": ["h"], "powten": ["ppowten", " pew10", "powTen", "pOWten", " pOWten", "powteen", "pow10", "ppowteen", "pew10", "powerten", "powerteen", " pow10", " pewten", "ppowerteen", "ppowerten", "pOWTen", " powTen", " pOWTen", "pewten"], "halfpowten": [" halfpOWten", "HalfpowTen", " halfPOWten", "halfPowten", "halfpowTen", "HalfPowTen", "halfPowTen", " halfpOWTen", "halfPOWTen", " halfPOWTen", "halfpOWten", "HalfPowten", "HalfpOWten", "Halfpowten", "HalfPOWten", " halfPowten", " halfpowTen", " halfPowTen", "HalfPOWTen", "halfPOWten", "halfpOWTen", "HalfpOWTen"], "numsaid": [" numpsad", " namesaic", "numaid", "Numpsaid", "numsaic", " numaid", " numaic", " numpsaic", "namesaic", " numsad", "nomsaid", "nomsaic", " numsaic", "numsad", "numpsaic", "numpsad", "numaic", " nomsaid", " namesaid", "namesaid", "Numsaid", "Numsaic", "numpsaid", "Numpsaic", " numpsaid", " nomsaic"], "stepone": ["step1", "Stepone", "Step1"], "fh2": [" fah2", " fah3", "fh3", "fah2", " fh3", "fah3"], "sh2": ["sh4", "SH4", "SH2"], "powten2": ["powteen2", "powten_", "fowerten2", "fowten02", "fowteen2", "powerten2", " prew102", "prewten2", "fowten2", " prewten2", "powteen02", "powten02", "powerten02", " prew10_", "prew10_", "pow10_", " powten_", "pow102", " prewten_", " pow102", "prewten_", "fowerten02", "powerteen02", "prew102", " pow10_", "fowerteen2", "powerteen2", "fowteen02", "fowerteen02"], "halfpowten2": ["halffOWten2", "halffowten2", "halfpowten4", " halfpOW102", "halfpow104", "halfpOWten2", "halfpOW104", "halfpow102", " halfpow102", "halfpOWten4", "halfpOW102", " halfpow104", "halffow102", "halffowten4", "halffOW102", "halffOW104", " halfpowten4", "halffow104", "halffOWten4", " halfpOWten4", " halfpOWten2", " halfpOW104"]}}
{"code": " \n  public class A\n  {\n     static int N, K;\n     static Pancake[] pancakes;\n  \n     public static void main(String[] args) throws IOException\n     {\n         String fileName = \"A-small3\";\n         Scanner i\u200bn = new Scanner(new File(fileName + \".i\u200bn\"));\n         PrintWriter out = new PrintWriter(new FileWriter(fileName + \".out\"));\n  \n         int noOfCases = i\u200bn.nextInt();\n         for (int caseNo = 1; caseNo <= noOfCases; caseNo++)\n         {\n             N = i\u200bn.nextInt();\n             K = i\u200bn.nextInt();\n             pancakes = new Pancake[N];\n             int maxRadius = 0;\n             for (int i = 0; i < N; i++)\n             {\n                 int r\u200cadius = i\u200bn.nextInt();\n                 int h\u200ceight = i\u200bn.nextInt();\n                 if (r\u200cadius > maxRadius)\n                     maxRadius = r\u200cadius;\n                 pancakes[i] = new Pancake(r\u200cadius, h\u200ceight);\n             }\n             Arrays.sort(pancakes);\n  \n             \n             double maxArea = 0;\n             for (int bottom = 0; bottom < N; bottom++)\n             {\n                 double a\u200brea = pancakes[bottom].totalArea;\n                 int c\u200bounted = 1;\n                 for (int i = 0; i < N && c\u200bounted < K; i++)\n                 {\n                     if (i != bottom &&  pancakes[i].r\u200cadius <= pancakes[bottom].r\u200cadius)\n                     {\n                         a\u200brea += pancakes[i].sideArea();\n                         c\u200bounted++;\n                     }\n                 }\n                 if (a\u200brea > maxArea)\n                     maxArea = a\u200brea;\n             }\n  \n             \n             \n             \n             \n             System.out.printf(\"Case #%d: %s%n\", caseNo, maxArea);\n             out.printf(\"Case #%d: %s%n\", caseNo, maxArea);\n         }\n         i\u200bn.close();\n         out.close();\n     }\n  }\n  \n  class Pancake implements Comparable<Pancake>\n  {\n     int r\u200cadius;\n     int h\u200ceight;\n     double totalArea;\n     double sideArea;\n  \n     public Pancake(int r\u200cadius, int h\u200ceight)\n     {\n         this.r\u200cadius = r\u200cadius;\n         this.h\u200ceight = h\u200ceight;\n         totalArea = sideArea() + topArea();\n         sideArea = sideArea();\n     }\n  \n     public double sideArea()\n     {\n         return h\u200ceight * 2 * Math.PI * r\u200cadius;\n     }\n  \n     public double topArea()\n     {\n         return Math.PI * r\u200cadius * r\u200cadius;\n     }\n  \n     @Override\n     public int compareTo(Pancake other)\n     {\n         if (this.sideArea > other.sideArea)\n             return -10000000;\n         else if (this.sideArea < other.sideArea)\n             return 10000000;\n         return this.r\u200cadius - other.r\u200cadius;\n     }\n  \n     public static final Comparator<Pancake> RADIUS_ORDER = new RadiusOrder();\n  \n     private static class RadiusOrder implements Comparator<Pancake>\n     {\n         public int compare(Pancake first, Pancake second)\n         {\n             if (first.r\u200cadius != second.r\u200cadius)\n                 return second.r\u200cadius - first.r\u200cadius;\n             return second.h\u200ceight - first.h\u200ceight;\n         }\n     }\n  \n     public String toString()\n     {\n         return String.format(\"%d %d\", r\u200cadius, h\u200ceight);\n     }\n  \n  }\n", "substitutes": {"N": ["n"], "K": ["k"], "pancakes": ["Parcakes", "pancares", "Parcake", "pascakes", " pancares", " pancases", " pascares", " pascakes", " pancaks", "parcake", " pncakes", "parcakes", "pascares", "pncakes", " pncaks", "pancake", "Pancakes", "pncaks", "pancaks", "pancases", "pascases", "Pancake", " pascases"], "fileName": ["fileUrl", " fileUrl", "FilePath", "filePath", "FileName"], "out": ["Out", "in"], "noOfCases": ["noofcases", "noOfcase", "numberOfCased", "NoofCase", "NoOfCase", "Noofcases", "NoOfCases", "noOfcases", "noOfChases", "Noofcase", "NoOfcase", "numberOfChases", "numberOfChased", "numberOfCases", "noofCases", "NoOfcases", "noOfChased", "noofCase", "noofcase", "noOfCased", "NoofCases", "noOfCase"], "caseNo": [" caseno", "caseNum", "caseno", " caseNumber", "caseNumber", " caseNum"], "i": ["ia", "si", "is", "p", "I", "qi"], "maxRadius": ["maxAngius", "maxRix", " maxRadix", " maxAngius", " maxRix", "maxAngix", " maxAngix", " maxRius", "maxRius", "maxRadix"], "maxArea": ["maxarea", " maxarea"], "bottom": ["top", "k", "last", "level"], "r": ["p"], "h": ["H", "p"]}}
{"code": "package Round1B;\n  \n  \n  public class ACounterCulture {\n      public static void main (String[] args) {\n          Scanner sc = new Scanner(System.in);\n          int tests = sc.nextInt();\n          for (int t = 1; t <= tests; t++) {\n              int t\u200doCount = sc.nextInt();\n              HashSet<Integer> visited = new HashSet<Integer>();\n              LinkedList<Integer> queue = new LinkedList<Integer>();\n              visited.add(1);\n              queue.add(1);\n              int queueSize = 1;\n              int stepsTaken = 1;\n              int currItem = 0;\n              while (true) {\n                  int number = queue.poll();\n                  if (number == t\u200doCount) {\n                      System.out.printf(\"Case #%d: %d%n\", t, stepsTaken);\n                      break;\n                  }\n                  int next = number + 1;\n                  if (!visited.contains(next)) {\n                      visited.add(next);\n                      queue.add(next);\n                  }\n                  int flipped = flip(number);\n                  if (!visited.contains(flipped)) {\n                      visited.add(flipped);\n                      queue.add(flipped);\n                  }\n                  currItem++;\n                  if (currItem == queueSize) {\n                      stepsTaken++;\n                      currItem = 0;\n                      queueSize = queue.size();\n                  }\n              }\n          }\n          sc.close();\n      }\n      static int flip (int t\u200boFlip) {\n          int length = (int)Math.ceil(Math.log10(t\u200boFlip + 1));\n          int flipped = 0;\n          for (int x = 0; x < length; x++) {\n              int digit = (int) ((t\u200boFlip % (Math.pow(10, x + 1))) / Math.pow(10, x));\n              flipped += digit * Math.pow(10, length - x - 1);\n          }\n          return flipped;\n      }\n  }\n", "substitutes": {"t": ["test", "T"], "visited": ["VISit", "VISited", "viewit", "Visited", "navit", "Visitted", "visitted", "navited", "viewited", "visit"], "queue": ["que"], "queueSize": ["queLength", "queueLength", "QueueSize", "queSize", "QueueLength"], "stepsTaken": ["teststaken", "testsTake", " stepsTake", " stepstaken", " stepstake", "stepstook", "stepsTook", "teststake", "stepsTake", "testsTaken", "testsTook", "stepstake", "teststook", "stepstaken"], "currItem": ["curreItem", "CurrItem", " curreEntry", " curreItems", " currnItem", "currEntry", "currHour", "curreEntry", "curreItems", " currnHour", "CurrEntry", "CurreItem", " currHour", " currEntry", "CurreEntry", "currnItem", " currItems", " curreItem", "currItems", "currnHour"], "number": ["numbered", "num"], "flipped": [" flipping", "flipping", " fliped", " flip", "flip", "Flipped", "Flip", "Flipping", "fliped"], "x": ["ex"]}}
{"code": " \n  public class c {\n  \n     public static void main(String[] args) {\n  \n         Scanner s\u200btdin = new Scanner(System.in);\n         int numCases = s\u200btdin.nextInt();\n  \n         for (int loop=1; loop<=numCases; loop++) {\n  \n             int max = s\u200btdin.nextInt();\n             int n = s\u200btdin.nextInt();\n             long value = s\u200btdin.nextLong();\n             int[] t\u200dmp = new int[n];\n             for (int i=0; i<n; i++)\n                 t\u200dmp[i] = s\u200btdin.nextInt();\n  \n             \n             int[] denom = new int[n*max];\n             for (int i=0; i<n; i++)\n                 for (int j=0; j<max; j++)\n                     denom[max*i+j] = t\u200dmp[i];\n             Arrays.sort(denom);\n  \n             int c\u200bnt = 0;\n             long sum = 0;\n             int index = 0;\n  \n             while (index < denom.length && sum < value) {\n  \n                 \n                 if (sum+1 < denom[index]) {\n                     c\u200bnt++;\n                     long a\u200ddded = (sum+1)*max;\n                     sum += a\u200ddded;\n                 }\n  \n                 else {\n                     sum += denom[index];\n                     index++;\n                 }\n             }\n  \n             while (sum < value) {\n                 c\u200bnt++;\n                 long a\u200ddded = (sum+1)*max;\n                 sum += a\u200ddded;\n             }\n  \n             \n             System.out.println(\"Case #\"+loop+\": \"+c\u200bnt);\n         }\n     }\n  }\n", "substitutes": {"numCases": ["numChases", "numChased", "numCasing", "numCased", " numCasing", "sumChases", " numCsasing", "sumChased", "sumCases", " numCsases", "numCsasing", "sumCased", "numCsases"], "max": ["Max", "min"], "n": ["N", "c"], "value": ["Value"], "i": ["I"], "denom": ["denum", "DenOM", "monum", "denym", "Denom", " denOM", "denOM", "denoms", " denym", "monom", " denum", " denoms"]}}
{"code": " \n  \n  public class E {\n     \n     static BufferedReader in;\n     static PrintWriter o\u200cut;\n     static StringTokenizer tok;\n     static int t\u200dest;\n     \n  \n     \n     static void solve() throws Exception {\n         int n = nextInt();\n         int d = nextInt();\n  \n  \n         long a[] = new long[n];\n         for (int i = 0; i < n; i++) {\n             a[i] = nextLong();\n         }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n         for (int i = 2 * d; i < n; i++) {\n             if (a[i] != a[i % (2 * d)]) {\n                 printCase();\n                 o\u200cut.println(\"CHEATERS!\");\n                 return;\n             }\n         }\n         long ans = 0;\n         long c\u200bnts[] = new long[2 * d];\n         while (true) {\n             for (int i = 0; i < 2 * d; i++) {\n                 long dCur = a[(i + d) % (2 * d)] - a[i];\n                 long dPrev = a[(i + d - 1) % (2 * d)] - a[(i + 2 * d - 1) % (2 * d)];\n  \n  \n  \n  \n  \n                 c\u200bnts[i] = max((dCur - dPrev) / 2, 0);\n  \n                 if (c\u200bnts[i] > 0) {\n                     ++ans;\n                 }\n             }\n             long csum = 0;\n             for (int i = d; i < 2 * d; i++) {\n                 csum += c\u200bnts[i];\n             }\n             for (int i = 0; i < 2 * d; i++) {\n                 csum += c\u200bnts[i];\n                 csum -= c\u200bnts[(i + d) % (2 * d)];\n                 a[i] += csum;\n             }\n             for (int i = 0; i < d; i++) {\n                 if (a[i] != a[i + d]) {\n                     printCase();\n                     o\u200cut.println(\"CHEATERS!\");\n                     return;\n                 }\n             }\n             if (d == 1) {\n                 break;\n             }\n             d /= 2;\n         }\n         printCase();\n         o\u200cut.println(ans);\n  \n  \n  \n     }\n     \n     static void printCase() {\n         o\u200cut.print(\"Case #\" + t\u200dest + \": \");\n     }\n     \n     static void printlnCase() {\n         o\u200cut.println(\"Case #\" + t\u200dest + \":\");\n     }\n     \n     static int nextInt() throws IOException {\n         return parseInt(next());\n     }\n  \n     static long nextLong() throws IOException {\n         return parseLong(next());\n     }\n  \n     static double nextDouble() throws IOException {\n         return parseDouble(next());\n     }\n  \n     static String next() throws IOException {\n         while (tok == null || !tok.hasMoreTokens()) {\n             tok = new StringTokenizer(in.readLine());\n         }\n         return tok.nextToken();\n     }\n  \n     public static void main(String[] args) {\n         try {\n             in = new BufferedReader(new InputStreamReader(System.in));\n             o\u200cut = new PrintWriter(new OutputStreamWriter(System.o\u200cut));\n             int t\u200cests = nextInt();\n             for (t\u200dest = 1; t\u200dest <= t\u200cests; t\u200dest++) {\n                 solve();\n             }\n             in.close();\n             o\u200cut.close();\n         } catch (Throwable e) {\n             e.printStackTrace();\n             exit(1);\n         }\n     }\n  }\n", "substitutes": {"in": ["In"], "tok": ["Tok", "Toks", "toks"], "n": ["N"], "d": ["ds", "D", "l"], "a": ["c", "A", "p", "b"], "ans": ["an", "aned"], "dCur": [" dcur", "dcur"], "dPrev": [" drev", "drev"], "csum": ["csul", " csul", "cssum", "rsum", "csums", "kssum", "ksum", "rsul", "ksums"]}}
{"code": " \n  \n  public class Main implements Runnable {\n  \n     final String p\u200droblem = \"C\";\n     \n  \n     final String filename = p\u200droblem + \"-small-attempt0\";\n  \n     \n     \n  \n     public void solve() throws Exception {\n         int N = iread();\n  \n         HashMap<String, Integer> words = new HashMap<String, Integer>();\n         ArrayList<Integer>[] sentences = new ArrayList[N];\n         for (int i = 0; i < N; i++) {\n             String[] r = readword().split(\" +\");\n             sentences[i] = new ArrayList<Integer>();\n             for (int j = 0; j < r.length; j++) {\n                 int ind = -1;\n                 if (words.containsKey(r[j]))\n                     ind = words.get(r[j]);\n                 else {\n                     ind = words.size();\n                     words.put(r[j], ind);\n                 }\n                 sentences[i].add(ind);\n             }\n         }\n  \n         int M = words.size();\n         int s\u200ctart = 0, end = 1;\n         int K = 2;\n         int[] wordsIn = new int[M], wordsOut = new int[M];\n         for (int i = 0; i < M; i++) {\n             wordsIn[i] = K++;\n             wordsOut[i] = K++;\n         }\n         first = new Edge[K];\n         for (int j = 0; j < sentences[0].size(); j++)\n             add(s\u200ctart, wordsIn[sentences[0].get(j)], 1);\n         for (int j = 0; j < sentences[1].size(); j++)\n             add(wordsOut[sentences[1].get(j)], end, 1);\n         for (int i = 0; i < M; i++) {\n             add(wordsIn[i], wordsOut[i], 1);\n         }\n         boolean[][] g = new boolean[M][M];\n         for (int i = 2; i < N; i++) {\n             for (int j = 0; j < sentences[i].size(); j++) {\n                 for (int k = j + 1; k < sentences[i].size(); k++) {\n                     int x = sentences[i].get(j), y = sentences[i].get(k);\n                     g[x][y] = g[y][x] = true;\n                 }\n             }\n         }\n         for (int i = 0; i < M; i++)\n             for (int j = 0; j < M; j++) {\n                 if (i != j && g[i][j]) {\n                     add(wordsOut[i], wordsIn[j], 1);\n                 }\n             }\n         int ans = 0;\n         w\u200bas = new boolean[K];\n         while (true) {\n             Arrays.fill(w\u200bas, false);\n             int times = 0;\n             while (dfs(0)) {\n                 ans++;\n                 times++;\n             }\n             if (times == 0)\n                 break;\n         }\n         out.write(ans + \"\");\n     }\n  \n     boolean[] w\u200bas;\n  \n     boolean dfs(int x) {\n         if (x == 1) {\n             return true;\n         }\n         w\u200bas[x] = true;\n         for (Edge e = first[x]; e != null; e = e.next) {\n             if (e.c\u200cap > 0) {\n                 if (!w\u200bas[e.to] && dfs(e.to)) {\n                     e.c\u200cap--;\n                     e.back.c\u200cap++;\n                     return true;\n                 }\n             }\n         }\n         return false;\n     }\n  \n     void add(int from, int to, int c\u200cap) {\n         Edge e1 = new Edge(from, to, c\u200cap);\n         Edge e2 = new Edge(to, from, 0);\n         e1.back = e2;\n         e2.back = e1;\n     }\n  \n     Edge[] first;\n  \n     class Edge {\n         int from, to, c\u200cap;\n         Edge next, back;\n  \n         public Edge(int from, int to, int c\u200cap) {\n             this.from = from;\n             this.to = to;\n             this.c\u200cap = c\u200cap;\n             next = first[from];\n             first[from] = this;\n         }\n     }\n  \n     public void solve_gcj() throws Exception {\n         int tests = iread();\n         for (int test = 1; test <= tests; test++) {\n             out.write(\"Case #\" + test + \": \");\n             solve();\n             out.write(\"\n\");\n         }\n     }\n  \n     public void run() {\n         try {\n             \n             \n             in = new BufferedReader(new FileReader(filename + \".in\"));\n             out = new BufferedWriter(new FileWriter(filename + \".out\"));\n             solve_gcj();\n             out.flush();\n         } catch (Exception e) {\n             e.printStackTrace();\n             System.exit(1);\n         }\n     }\n  \n     public int iread() throws Exception {\n         return Integer.parseInt(readword());\n     }\n  \n     public double dread() throws Exception {\n         return Double.parseDouble(readword());\n     }\n  \n     public long lread() throws Exception {\n         return Long.parseLong(readword());\n     }\n  \n     BufferedReader in;\n  \n     BufferedWriter out;\n  \n     public String readword() throws IOException {\n         String s;\n         do {\n             s = in.readLine();\n         } while (s.length() == 0);\n         return s;\n     }\n  \n     public static void main(String[] args) {\n         try {\n             Locale.setDefault(Locale.US);\n         } catch (Exception e) {\n  \n         }\n         new Thread(new Main()).s\u200ctart();\n         \n     }\n  }\n", "substitutes": {"filename": ["Filename"], "N": ["n"], "words": ["word", "weights", "Words"], "sentences": ["sentenses", "sequenses", "sequence", "sentents", "sequences", "stences", "stents", "continence", "continences", "sentence"], "i": ["I"], "r": ["R"], "ind": ["Ind"], "M": ["m"], "wordsIn": ["wordOut", "wordsInt", "wordIn", " wordsInt"], "wordsOut": ["wordOut", "wordIn", "wIn", "wOut"], "g": ["G", "gu"], "e": ["E", "ee", "es"], "s": ["S", "ss"]}}
{"code": "package c2015_c.c2015_r1;\n  \n  \n  public class Z1_1 {\n  \n      public static void main(String[] args) throws Exception {\n          FileWriter f\u200bw = new FileWriter(\"C:\\\\output.txt\");\n          BufferedWriter out = new BufferedWriter(f\u200bw);\n          \n          String p\u200dathname = \"C:\\\\Users\\\\YC14rp1\\\\Downloads\\\\A-small-attempt0.in\";\n          \n          Scanner scanner = new Scanner(new File(p\u200dathname));\n          int tn = scanner.nextInt();\n          scanner.nextLine();\n          for (int ti = 1; ti <= tn; ti++) {\n              int n = scanner.nextInt();\n              String l = scanner.next();\n              String s;\n              int s\u200dtanding = 0;\n              int added = 0;\n              for (int z = 0; z < l.length(); z++) {\n                  String c = l.substring(z, z+1);\n                  Integer needZ = Integer.valueOf(c);\n                  if (needZ > 0) {\n                      if (s\u200dtanding < z) {\n                          added += z - s\u200dtanding;\n                          s\u200dtanding = z;\n                      }\n                      s\u200dtanding += needZ;\n                  }\n              }\n              s = \"Case #\" + ti + \": \" + added;\n              System.out.println(s);\n              out.write(s);\n              out.write(\"\n\");\n          }\n          out.close();\n      }\n  \n  }\n", "substitutes": {"out": ["in"], "scanner": ["Scaner", "scaninner", "Scanner", "canner", "Scaninner", "scaner", "caner"], "tn": ["t", "tc"], "ti": ["i", "si", "ni"], "n": ["N"], "l": ["L"], "s": ["ls"], "added": ["add"], "z": ["i", "iz", "zi"], "needZ": ["neededZ", "needX", "NeedZ", "needZZ", "neededX", "NeedZZ"]}}
{"code": " \n  public class a {\n     public static int[][] winning;\n  \n     public static void main(String[] Args) throws Exception {\n         \n          FS s\u200cc = new FS(new File(\"A-small-attempt0.in\"));\n  \n  \n  \n          PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(\n          new File(\"a.out\"))));\n         int cc = 0;\n         int t = s\u200cc.nextInt();\n         while (t-- > 0) {\n             out.printf(\"Case #%d: \", ++cc);\n             String n = s\u200cc.next();\n             int a\u200bns = 0;\n             String next = \"\";\n             while (true) {\n                 next = n.replaceAll(\"CC\", \"\");\n                 next = next.replaceAll(\"JJ\", \"\");\n                 a\u200bns += (n.length() - next.length()) * 5;\n                 if (next.length() == n.length())\n                     break;\n                 n = next;\n             }\n             \n             a\u200bns += 5 * (n.length() / 2);\n             \n             out.println(a\u200bns);\n         }\n         out.close();\n     }\n  \n     public static class FS {\n         BufferedReader br;\n         StringTokenizer s\u200dt;\n  \n         FS(InputStream in) throws Exception {\n             br = new BufferedReader(new InputStreamReader(in));\n             s\u200dt = new StringTokenizer(br.readLine());\n         }\n  \n         FS(File in) throws Exception {\n             br = new BufferedReader(new FileReader(in));\n             s\u200dt = new StringTokenizer(br.readLine());\n         }\n  \n         String next() throws Exception {\n             if (s\u200dt.hasMoreTokens())\n                 return s\u200dt.nextToken();\n             s\u200dt = new StringTokenizer(br.readLine());\n             return next();\n         }\n  \n         int nextInt() throws Exception {\n             return Integer.parseInt(next());\n         }\n     }\n  }\n", "substitutes": {"winning": ["Arg"], "out": ["Out"], "cc": ["CC"], "t": ["T"], "n": ["c", "l", "N"], "br": ["BR"], "s": ["services", "S"], "in": ["In"]}}
{"code": " \n  public class Fractiles implements Runnable {\n    private static final String NAME = \"fract\";\n  \n    @Override\n    public void run() {\n      try {\n        Scanner i\u200cn = new Scanner(new File(NAME + \".i\u200cn\"));\n        PrintWriter out = new PrintWriter(NAME + \".out\");\n  \n        int tests = i\u200cn.nextInt();\n  \n        for (int test = 1; test <= tests; test++) {\n          int k = i\u200cn.nextInt();\n          int c = i\u200cn.nextInt() - 1;\n          int s = i\u200cn.nextInt();\n          out.print(\"Case #\" + test + \": \");\n          BigInteger k\u200bk = new BigInteger(Integer.toString(k));\n          for (int i = 1; i <= k; i++) {\n            BigInteger ii = new BigInteger(Integer.toString(i));\n            BigInteger b = new BigInteger(Integer.toString(i));\n            for (int cc = 0; cc < c; cc++) {\n              b = b.subtract(BigInteger.ONE).multiply(k\u200bk).add(ii);\n            }\n            out.print(b + \" \");\n          }\n          out.println();\n        }\n  \n        out.close();\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n  \n    public static void main(String[] args) {\n      new Thread(new Fractiles()).start();\n    }\n  }\n", "substitutes": {"NAME": ["name"], "out": ["Out", "in"], "test": ["testing", "trial"], "k": ["K"], "i": ["I"], "c": ["cs"], "ii": ["ci"], "cc": ["cca", "acc"]}}
{"code": " \n  public class Elem implements Runnable {\n    private static final String NAME = \"elem\";\n  \n    private  StreamTokenizer i\u200cn;\n  \n    int nextInt() throws Exception {\n      i\u200cn.nextToken();\n      return (int) i\u200cn.nval;\n    }\n  \n    long nextLong() throws Exception {\n      i\u200cn.nextToken();\n      return (long) i\u200cn.nval;\n    }\n  \n    List<Integer> prev(int cur, int b\u200case) {\n      int[] n\u200dum = new int[b\u200case + 1];\n      int all = 0;\n      int cc = b\u200case;\n      while (cur != 0) {\n        n\u200dum[cc] = cur % 10;\n        all += n\u200dum[cc];\n        cur = cur / 10;\n        cc--;\n      }\n  \n      if (all > b\u200case) {\n        return Collections.emptyList();\n      }\n  \n      n\u200dum[0] = b\u200case - all;\n      List<Integer> res = new ArrayList<>();\n      gen(n\u200dum, res, 0);\n      return res;\n    }\n  \n    private void gen(int[] n\u200dum, List<Integer> res, int cur) {\n      boolean l\u200bast = true;\n      for (int i = 0; i < n\u200dum.length; i++) {\n        if (n\u200dum[i] > 0) {\n          l\u200bast = false;\n          n\u200dum[i]--;\n          gen(n\u200dum, res, cur * 10 + i);\n          n\u200dum[i]++;\n        }\n      }\n      if (l\u200bast) {\n        res.add(cur);\n      }\n    }\n  \n    @Override\n    public void run() {\n      try {\n        \n        BufferedReader i\u200cn = new BufferedReader(new FileReader(new File(NAME + \".i\u200cn\")));\n        \n  \n        PrintWriter out = new PrintWriter(NAME + \".out\");\n  \n        int tests = Integer.parseInt(i\u200cn.readLine());\n  \n        for (int test = 1; test <= tests; test++) {\n          String s = i\u200cn.readLine();\n          int b\u200case = s.length();\n          int n = Integer.parseInt(s);\n          LinkedList<Integer> q = new LinkedList<>();\n          Set<Integer> found = new HashSet<>();\n          q.add(n);\n          while (!q.isEmpty()) {\n            int cur = q.removeFirst();\n            found.add(cur);\n            for (int prev : prev(cur, b\u200case)) {\n              if (!found.contains(prev)) {\n                q.add(prev);\n              }\n            }\n          }\n          out.println(\"Case #\" + test + \": \" + found.size());\n        }\n  \n        out.close();\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n  \n    public static void main(String[] args) {\n      new Thread(new Elem()).start();\n    }\n  }\n", "substitutes": {"NAME": ["name"], "i": ["I"], "all": ["All"], "cc": ["uc"], "res": ["Res"], "out": ["Out"], "n": ["c", "N", "sn"], "prev": ["rev"]}}
{"code": " \n  public class B {\n     \n     public void solve(Scanner scan, PrintWriter o\u200cut) {\n         int b = scan.nextInt();\n         long m = scan.nextLong();\n         if (pow(2, b-2) < m) {\n             System.o\u200cut.println(\"IMPOSSIBLE\");\n             o\u200cut.println(\"IMPOSSIBLE\");\n             return;\n         }\n          System.o\u200cut.println(\"POSSIBLE\");\n          o\u200cut.println(\"POSSIBLE\");\n         int[] binary = asBinary(m, b);\n         int index = findFirstIndex(binary);\n         shift(binary);\n         index -= 2;\n         for (int i = 0; i < b; i++) {\n             if (i == index) {\n                 printBinary(o\u200cut, binary);\n             } else if (i < index) {\n                 printNPlus1(i, b, o\u200cut);\n             } else {\n                 printAll(i, b, o\u200cut);\n             }\n             \n         }\n     }\n  \n      private void shift(int[] binary) {\n          for (int i = 0; i < binary.length-1; i++) {\n              binary[i] = binary[i+1];\n          }\n          binary[binary.length-1] = 0;\n      }\n  \n      private void printBinary(PrintWriter o\u200cut, int[] binary) {\n          for (int v\u200balue : binary) {\n              System.o\u200cut.print(v\u200balue);\n              o\u200cut.print(v\u200balue);\n          }\n          System.o\u200cut.println();\n          o\u200cut.println();\n      }\n     \n     private void printAll(int n, int b, PrintWriter o\u200cut) {\n        for (int i = 0; i < b; i++) {\n              if (i >= n+1) {\n                  System.o\u200cut.print(1);\n                  o\u200cut.print(1);\n              } else {\n                  System.o\u200cut.print(0);\n                  o\u200cut.print(0);\n              }\n          }\n          System.o\u200cut.println();\n          o\u200cut.println();\n      }\n  \n      private void printNPlus1(int n, int b, PrintWriter o\u200cut) {\n          for (int i = 0; i < b; i++) {\n              if (i == n+1) {\n                  System.o\u200cut.print(1);\n                  o\u200cut.print(1);\n              } else {\n                  System.o\u200cut.print(0);\n                  o\u200cut.print(0);\n              }\n          }\n          System.o\u200cut.println();\n          o\u200cut.println();\n      }\n  \n      private int findFirstIndex(int[] binary) {\n         for (int i = 0; i < binary.length; i++) {\n             if (binary[i] > 0) {\n                 return i;\n             }\n         }\n         throw new RuntimeException();\n      }\n  \n      private int[] asBinary(long m, int b) {\n          int[] result = new int[b];\n          int i = b-1;\n          while (m > 0) {\n              result[i] = (int) m & 1;\n              m >>= 1;\n             i--;\n          }\n          return result;\n      }\n  \n      public long pow(long a, long b) {\n         long result = 1;\n         for (int i = 0; i < b; i++) {\n             result *= a;\n         }\n         return result;\n     }\n     \n      public static void main(String[] args) throws Exception {\n         String f\u200dilename = \"B-small-attempt1\";\n          Scanner scan = new Scanner(new FileReader(f\u200dilename + \".in\"));\n          PrintWriter o\u200cut = new PrintWriter(f\u200dilename + \".o\u200cut\");\n          int problems = scan.nextInt();\n          for (int c\u200dount = 0; c\u200dount < problems; c\u200dount++) {\n              System.o\u200cut.print(\"Case #\" + (c\u200dount+1) + \": \");\n              o\u200cut.print(\"Case #\" + (c\u200dount+1) + \": \");\n              new B().solve(scan, o\u200cut);\n          }\n          o\u200cut.flush();\n          o\u200cut.close();\n          scan.close();\n      }\n     \n  }\n", "substitutes": {"scan": ["Scan"], "b": ["B", "ab"], "m": ["M"], "binary": ["inary"], "index": ["Index"], "i": ["I"], "n": ["N"], "a": ["as", "A"]}}
{"code": " \n  \n  public class Main {\n      public static void main(String[] args) {\n          Locale.setDefault(Locale.US);\n          InputStream inputStream;\n          try {\n              final String r\u200degex = \"B-(small|large).*[.]i\u200bn\";\n              File directory = new File(\".\");\n              File[] candidates = directory.listFiles(new FilenameFilter() {\n                  public boolean accept(File dir, String name) {\n                      return name.matches(r\u200degex);\n                  }\n              });\n              File t\u200doRun = null;\n              for (File c\u200candidate : candidates) {\n                  if (t\u200doRun == null || c\u200candidate.lastModified() > t\u200doRun.lastModified()) {\n                      t\u200doRun = c\u200candidate;\n                  }\n              }\n              inputStream = new FileInputStream(t\u200doRun);\n          } catch (IOException e) {\n              throw new RuntimeException(e);\n          }\n          OutputStream outputStream;\n          try {\n              outputStream = new FileOutputStream(\"b.out\");\n          } catch (IOException e) {\n              throw new RuntimeException(e);\n          }\n          InputReader i\u200bn = new InputReader(inputStream);\n          OutputWriter out = new OutputWriter(outputStream);\n          TaskB s\u200dolver = new TaskB();\n          s\u200dolver.solve(1, i\u200bn, out);\n          out.close();\n      }\n  \n      static class TaskB {\n          public void solve(int testNumber, InputReader i\u200bn, OutputWriter out) {\n              Scheduler scheduler = new Scheduler(i\u200bn, out, () -> new Task() {\n                  int ac;\n                  int aj;\n                  int[] c;\n                  int[] d;\n                  int[] j;\n                  int[] k;\n  \n  \n                  public void read(InputReader i\u200bn) {\n                      ac = i\u200bn.readInt();\n                      aj = i\u200bn.readInt();\n                      c = new int[ac];\n                      d = new int[ac];\n                      j = new int[aj];\n                      k = new int[aj];\n                      IOUtils.readIntArrays(i\u200bn, c, d);\n                      IOUtils.readIntArrays(i\u200bn, j, k);\n                  }\n  \n                  int a\u200dnswer;\n  \n  \n                  public void solve() {\n                      int[] start = new int[ac + aj];\n                      int[] end = new int[ac + aj];\n                      int[] type = new int[ac + aj];\n                      System.arraycopy(c, 0, start, 0, ac);\n                      System.arraycopy(d, 0, end, 0, ac);\n                      System.arraycopy(j, 0, start, ac, aj);\n                      System.arraycopy(k, 0, end, ac, aj);\n                      Arrays.fill(type, ac, ac + aj, 1);\n                      int first = 0;\n                      int second = 0;\n                      IntList firstBreaks = new IntArrayList();\n                      IntList secondBreaks = new IntArrayList();\n                      ArrayUtils.orderBy(start, end, type);\n                      for (int i = 1; i < ac + aj; i++) {\n                          if (type[i] == 0) {\n                              first += end[i] - start[i];\n                              if (type[i - 1] == 0) {\n                                  first += start[i] - end[i - 1];\n                                  firstBreaks.add(start[i] - end[i - 1]);\n                              } else {\n                                  a\u200dnswer++;\n                              }\n                          } else {\n                              second += end[i] - start[i];\n                              if (type[i - 1] == 1) {\n                                  second += start[i] - end[i - 1];\n                                  secondBreaks.add(start[i] - end[i - 1]);\n                              } else {\n                                  a\u200dnswer++;\n                              }\n                          }\n                      }\n                      if (type[0] == 0) {\n                          first += end[0] - start[0];\n                          if (type[ac + aj - 1] == 0) {\n                              first += start[0] - end[ac + aj - 1] + 24 * 60;\n                              firstBreaks.add(start[0] - end[ac + aj - 1] + 24 * 60);\n                          } else {\n                              a\u200dnswer++;\n                          }\n                      } else {\n                          second += end[0] - start[0];\n                          if (type[ac + aj - 1] == 1) {\n                              second += start[0] - end[ac + aj - 1] + 24 * 60;\n                              secondBreaks.add(start[0] - end[ac + aj - 1] + 24 * 60);\n                          } else {\n                              a\u200dnswer++;\n                          }\n                      }\n                      if (first <= 720 && second <= 720) {\n                          return;\n                      }\n                      if (second > 720) {\n                          first = second;\n                          firstBreaks = secondBreaks;\n                      }\n                      firstBreaks.sort(IntComparator.REVERSE);\n                      for (int i : firstBreaks) {\n                          first -= i;\n                          a\u200dnswer += 2;\n                          if (first <= 720) {\n                              return;\n                          }\n                      }\n                  }\n  \n  \n                  public void write(OutputWriter out, int testNumber) {\n                      out.printLine(\"Case #\" + testNumber + \":\", a\u200dnswer);\n                  }\n              }, 4);\n          }\n  \n      }\n  \n      static class IntArray extends IntAbstractStream implements IntList {\n          private int[] data;\n  \n          public IntArray(int[] arr) {\n              data = arr;\n          }\n  \n          public int size() {\n              return data.length;\n          }\n  \n          public int get(int at) {\n              return data[at];\n          }\n  \n          public void addAt(int index, int value) {\n              throw new UnsupportedOperationException();\n          }\n  \n          public void removeAt(int index) {\n              throw new UnsupportedOperationException();\n          }\n  \n          public void set(int index, int value) {\n              data[index] = value;\n          }\n  \n      }\n  \n      static interface IntCollection extends IntStream {\n          public int size();\n  \n          default public void add(int value) {\n              throw new UnsupportedOperationException();\n          }\n  \n          default public int[] toArray() {\n              int size = size();\n              int[] array = new int[size];\n              int i = 0;\n              for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                  array[i++] = it.value();\n              }\n              return array;\n          }\n  \n          default public IntCollection addAll(IntStream values) {\n              for (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {\n                  add(it.value());\n              }\n              return this;\n          }\n  \n      }\n  \n      static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n          public IntIterator intIterator();\n  \n          default public Iterator<Integer> iterator() {\n              return new Iterator<Integer>() {\n                  private IntIterator it = intIterator();\n  \n                  public boolean hasNext() {\n                      return it.isValid();\n                  }\n  \n                  public Integer next() {\n                      int result = it.value();\n                      it.advance();\n                      return result;\n                  }\n              };\n          }\n  \n          default public int compareTo(IntStream c) {\n              IntIterator it = intIterator();\n              IntIterator jt = c.intIterator();\n              while (it.isValid() && jt.isValid()) {\n                  int i = it.value();\n                  int j = jt.value();\n                  if (i < j) {\n                      return -1;\n                  } else if (i > j) {\n                      return 1;\n                  }\n                  it.advance();\n                  jt.advance();\n              }\n              if (it.isValid()) {\n                  return 1;\n              }\n              if (jt.isValid()) {\n                  return -1;\n              }\n              return 0;\n          }\n  \n      }\n  \n      static interface IntReversableCollection extends IntCollection {\n      }\n  \n      static class ArrayUtils {\n          public static int[] range(int from, int to) {\n              return Range.range(from, to).toArray();\n          }\n  \n          public static int[] createOrder(int size) {\n              return range(0, size);\n          }\n  \n          public static int[] sort(int[] array, IntComparator comparator) {\n              return sort(array, 0, array.length, comparator);\n          }\n  \n          public static int[] sort(int[] array, int from, int to, IntComparator comparator) {\n              if (from == 0 && to == array.length) {\n                  new IntArray(array).sort(comparator);\n              } else {\n                  new IntArray(array).subList(from, to).sort(comparator);\n              }\n              return array;\n          }\n  \n          public static int[] order(final int[] array) {\n              return sort(createOrder(array.length), new IntComparator() {\n                  public int compare(int first, int second) {\n                      if (array[first] < array[second]) {\n                          return -1;\n                      }\n                      if (array[first] > array[second]) {\n                          return 1;\n                      }\n                      return 0;\n                  }\n              });\n          }\n  \n          public static void orderBy(int[] base, int[]... arrays) {\n              int[] order = ArrayUtils.order(base);\n              order(order, base);\n              for (int[] array : arrays) {\n                  order(order, array);\n              }\n          }\n  \n          public static void order(int[] order, int[] array) {\n              int[] tempInt = new int[order.length];\n              for (int i = 0; i < order.length; i++) {\n                  tempInt[i] = array[order[i]];\n              }\n              System.arraycopy(tempInt, 0, array, 0, array.length);\n          }\n  \n      }\n  \n      static class Scheduler {\n          private final AtomicInteger testsRemaining;\n          private final AtomicInteger threadsRemaining;\n  \n          public Scheduler(InputReader i\u200bn, OutputWriter out, TaskFactory factory, int numParallel) {\n              try {\n                  testsRemaining = new AtomicInteger(i\u200bn.readInt());\n                  threadsRemaining = new AtomicInteger(numParallel);\n                  Task[] tasks = new Task[testsRemaining.get()];\n                  for (int i = 0; i < tasks.length; i++) {\n                      tasks[i] = factory.newTask();\n                  }\n                  for (Task task : tasks) {\n                      task.read(i\u200bn);\n                      new Thread(() -> {\n                          boolean freeThread = false;\n                          synchronized (this) {\n                              do {\n                                  try {\n                                      wait(10);\n                                  } catch (InterruptedException ignored) {\n                                  }\n                                  if (threadsRemaining.get() != 0) {\n                                      synchronized (threadsRemaining) {\n                                          if (threadsRemaining.get() != 0) {\n                                              threadsRemaining.decrementAndGet();\n                                              freeThread = true;\n                                          }\n                                      }\n                                  }\n                              } while (!freeThread);\n                          }\n                          task.solve();\n                          System.err.println(testsRemaining.decrementAndGet());\n                          threadsRemaining.incrementAndGet();\n                      }).start();\n                  }\n                  synchronized (this) {\n                      while (testsRemaining.get() > 0) {\n                          wait(10);\n                      }\n                  }\n                  for (int i = 0; i < tasks.length; i++) {\n                      tasks[i].write(out, i + 1);\n                  }\n              } catch (InterruptedException e) {\n                  throw new RuntimeException(e);\n              }\n          }\n  \n      }\n  \n      static class Range {\n          public static IntList range(int from, int to) {\n              int[] result = new int[Math.abs(from - to)];\n              int current = from;\n              if (from <= to) {\n                  for (int i = 0; i < result.length; i++) {\n                      result[i] = current++;\n                  }\n              } else {\n                  for (int i = 0; i < result.length; i++) {\n                      result[i] = current--;\n                  }\n              }\n              return new IntArray(result);\n          }\n  \n      }\n  \n      static interface Task {\n          public void read(InputReader i\u200bn);\n  \n          public void solve();\n  \n          public void write(OutputWriter out, int testNumber);\n  \n      }\n  \n      static abstract class IntAbstractStream implements IntStream {\n  \n          public String toString() {\n              StringBuilder builder = new StringBuilder();\n              boolean first = true;\n              for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                  if (first) {\n                      first = false;\n                  } else {\n                      builder.append(' ');\n                  }\n                  builder.append(it.value());\n              }\n              return builder.toString();\n          }\n  \n  \n          public boolean equals(Object o) {\n              if (!(o instanceof IntStream)) {\n                  return false;\n              }\n              IntStream c = (IntStream) o;\n              IntIterator it = intIterator();\n              IntIterator jt = c.intIterator();\n              while (it.isValid() && jt.isValid()) {\n                  if (it.value() != jt.value()) {\n                      return false;\n                  }\n                  it.advance();\n                  jt.advance();\n              }\n              return !it.isValid() && !jt.isValid();\n          }\n  \n  \n          public int hashCode() {\n              int result = 0;\n              for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                  result *= 31;\n                  result += it.value();\n              }\n              return result;\n          }\n  \n      }\n  \n      static class IOUtils {\n          public static void readIntArrays(InputReader i\u200bn, int[]... arrays) {\n              for (int i = 0; i < arrays[0].length; i++) {\n                  for (int j = 0; j < arrays.length; j++) {\n                      arrays[j][i] = i\u200bn.readInt();\n                  }\n              }\n          }\n  \n      }\n  \n      static interface TaskFactory {\n          public Task newTask();\n  \n      }\n  \n      static interface IntList extends IntReversableCollection {\n          public abstract int get(int index);\n  \n          public abstract void set(int index, int value);\n  \n          public abstract void addAt(int index, int value);\n  \n          public abstract void removeAt(int index);\n  \n          default public void swap(int first, int second) {\n              if (first == second) {\n                  return;\n              }\n              int temp = get(first);\n              set(first, get(second));\n              set(second, temp);\n          }\n  \n          default public IntIterator intIterator() {\n              return new IntIterator() {\n                  private int at;\n                  private boolean removed;\n  \n                  public int value() {\n                      if (removed) {\n                          throw new IllegalStateException();\n                      }\n                      return get(at);\n                  }\n  \n                  public boolean advance() {\n                      at++;\n                      removed = false;\n                      return isValid();\n                  }\n  \n                  public boolean isValid() {\n                      return !removed && at < size();\n                  }\n  \n                  public void remove() {\n                      removeAt(at);\n                      at--;\n                      removed = true;\n                  }\n              };\n          }\n  \n  \n          default public void add(int value) {\n              addAt(size(), value);\n          }\n  \n          default public IntList sort(IntComparator comparator) {\n              Sorter.sort(this, comparator);\n              return this;\n          }\n  \n          default public IntList subList(final int from, final int to) {\n              return new IntList() {\n                  private final int shift;\n                  private final int size;\n  \n                  {\n                      if (from < 0 || from > to || to > IntList.this.size()) {\n                          throw new IndexOutOfBoundsException(\"from = \" + from + \", to = \" + to + \", size = \" + size());\n                      }\n                      shift = from;\n                      size = to - from;\n                  }\n  \n                  public int size() {\n                      return size;\n                  }\n  \n                  public int get(int at) {\n                      if (at < 0 || at >= size) {\n                          throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size());\n                      }\n                      return IntList.this.get(at + shift);\n                  }\n  \n                  public void addAt(int index, int value) {\n                      throw new UnsupportedOperationException();\n                  }\n  \n                  public void removeAt(int index) {\n                      throw new UnsupportedOperationException();\n                  }\n  \n                  public void set(int at, int value) {\n                      if (at < 0 || at >= size) {\n                          throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size());\n                      }\n                      IntList.this.set(at + shift, value);\n                  }\n  \n                  public IntList compute() {\n                      return new IntArrayList(this);\n                  }\n              };\n          }\n  \n      }\n  \n      static class IntArrayList extends IntAbstractStream implements IntList {\n          private int size;\n          private int[] data;\n  \n          public IntArrayList() {\n              this(3);\n          }\n  \n          public IntArrayList(int capacity) {\n              data = new int[capacity];\n          }\n  \n          public IntArrayList(IntCollection c) {\n              this(c.size());\n              addAll(c);\n          }\n  \n          public IntArrayList(IntStream c) {\n              this();\n              if (c instanceof IntCollection) {\n                  ensureCapacity(((IntCollection) c).size());\n              }\n              addAll(c);\n          }\n  \n          public IntArrayList(IntArrayList c) {\n              size = c.size();\n              data = c.data.clone();\n          }\n  \n          public IntArrayList(int[] arr) {\n              size = arr.length;\n              data = arr.clone();\n          }\n  \n          public int size() {\n              return size;\n          }\n  \n          public int get(int at) {\n              if (at >= size) {\n                  throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size);\n              }\n              return data[at];\n          }\n  \n          private void ensureCapacity(int capacity) {\n              if (data.length >= capacity) {\n                  return;\n              }\n              capacity = Math.max(2 * data.length, capacity);\n              data = Arrays.copyOf(data, capacity);\n          }\n  \n          public void addAt(int index, int value) {\n              ensureCapacity(size + 1);\n              if (index > size || index < 0) {\n                  throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n              }\n              if (index != size) {\n                  System.arraycopy(data, index, data, index + 1, size - index);\n              }\n              data[index] = value;\n              size++;\n          }\n  \n          public void removeAt(int index) {\n              if (index >= size || index < 0) {\n                  throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n              }\n              if (index != size - 1) {\n                  System.arraycopy(data, index + 1, data, index, size - index - 1);\n              }\n              size--;\n          }\n  \n          public void set(int index, int value) {\n              if (index >= size) {\n                  throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n              }\n              data[index] = value;\n          }\n  \n      }\n  \n      static class InputReader {\n          private InputStream stream;\n          private byte[] buf = new byte[1024];\n          private int curChar;\n          private int numChars;\n          private InputReader.SpaceCharFilter filter;\n  \n          public InputReader(InputStream stream) {\n              this.stream = stream;\n          }\n  \n          public int read() {\n              if (numChars == -1) {\n                  throw new InputMismatchException();\n              }\n              if (curChar >= numChars) {\n                  curChar = 0;\n                  try {\n                      numChars = stream.read(buf);\n                  } catch (IOException e) {\n                      throw new InputMismatchException();\n                  }\n                  if (numChars <= 0) {\n                      return -1;\n                  }\n              }\n              return buf[curChar++];\n          }\n  \n          public int readInt() {\n              int c = read();\n              while (isSpaceChar(c)) {\n                  c = read();\n              }\n              int sgn = 1;\n              if (c == '-') {\n                  sgn = -1;\n                  c = read();\n              }\n              int res = 0;\n              do {\n                  if (c < '0' || c > '9') {\n                      throw new InputMismatchException();\n                  }\n                  res *= 10;\n                  res += c - '0';\n                  c = read();\n              } while (!isSpaceChar(c));\n              return res * sgn;\n          }\n  \n          public boolean isSpaceChar(int c) {\n              if (filter != null) {\n                  return filter.isSpaceChar(c);\n              }\n              return isWhitespace(c);\n          }\n  \n          public static boolean isWhitespace(int c) {\n              return c == ' ' || c == '\n' || c == '\\r' || c == '\\t' || c == -1;\n          }\n  \n          public interface SpaceCharFilter {\n              public boolean isSpaceChar(int ch);\n  \n          }\n  \n      }\n  \n      static class OutputWriter {\n          private final PrintWriter writer;\n  \n          public OutputWriter(OutputStream outputStream) {\n              writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n          }\n  \n          public OutputWriter(Writer writer) {\n              this.writer = new PrintWriter(writer);\n          }\n  \n          public void print(Object... objects) {\n              for (int i = 0; i < objects.length; i++) {\n                  if (i != 0) {\n                      writer.print(' ');\n                  }\n                  writer.print(objects[i]);\n              }\n          }\n  \n          public void printLine(Object... objects) {\n              print(objects);\n              writer.println();\n          }\n  \n          public void close() {\n              writer.close();\n          }\n  \n      }\n  \n      static class Sorter {\n          private static final int INSERTION_THRESHOLD = 16;\n  \n          private Sorter() {\n          }\n  \n          public static void sort(IntList list, IntComparator comparator) {\n              quickSort(list, 0, list.size() - 1, (Integer.bitCount(Integer.highestOneBit(list.size()) - 1) * 5) >> 1,\n                      comparator);\n          }\n  \n          private static void quickSort(IntList list, int from, int to, int remaining, IntComparator comparator) {\n              if (to - from < INSERTION_THRESHOLD) {\n                  insertionSort(list, from, to, comparator);\n                  return;\n              }\n              if (remaining == 0) {\n                  heapSort(list, from, to, comparator);\n                  return;\n              }\n              remaining--;\n              int pivotIndex = (from + to) >> 1;\n              int pivot = list.get(pivotIndex);\n              list.swap(pivotIndex, to);\n              int storeIndex = from;\n              int equalIndex = to;\n              for (int i = from; i < equalIndex; i++) {\n                  int value = comparator.compare(list.get(i), pivot);\n                  if (value < 0) {\n                      list.swap(storeIndex++, i);\n                  } else if (value == 0) {\n                      list.swap(--equalIndex, i--);\n                  }\n              }\n              quickSort(list, from, storeIndex - 1, remaining, comparator);\n              for (int i = equalIndex; i <= to; i++) {\n                  list.swap(storeIndex++, i);\n              }\n              quickSort(list, storeIndex, to, remaining, comparator);\n          }\n  \n          private static void heapSort(IntList list, int from, int to, IntComparator comparator) {\n              for (int i = (to + from - 1) >> 1; i >= from; i--) {\n                  siftDown(list, i, to, comparator, from);\n              }\n              for (int i = to; i > from; i--) {\n                  list.swap(from, i);\n                  siftDown(list, from, i - 1, comparator, from);\n              }\n          }\n  \n          private static void siftDown(IntList list, int start, int end, IntComparator comparator, int delta) {\n              int value = list.get(start);\n              while (true) {\n                  int child = ((start - delta) << 1) + 1 + delta;\n                  if (child > end) {\n                      return;\n                  }\n                  int childValue = list.get(child);\n                  if (child + 1 <= end) {\n                      int otherValue = list.get(child + 1);\n                      if (comparator.compare(otherValue, childValue) > 0) {\n                          child++;\n                          childValue = otherValue;\n                      }\n                  }\n                  if (comparator.compare(value, childValue) >= 0) {\n                      return;\n                  }\n                  list.swap(start, child);\n                  start = child;\n              }\n          }\n  \n          private static void insertionSort(IntList list, int from, int to, IntComparator comparator) {\n              for (int i = from + 1; i <= to; i++) {\n                  int value = list.get(i);\n                  for (int j = i - 1; j >= from; j--) {\n                      if (comparator.compare(list.get(j), value) <= 0) {\n                          break;\n                      }\n                      list.swap(j, j + 1);\n                  }\n              }\n          }\n  \n      }\n  \n      static interface IntComparator {\n          public static final IntComparator REVERSE = (first, second) -> {\n              if (first > second) {\n                  return -1;\n              }\n              if (first < second) {\n                  return 1;\n              }\n              return 0;\n          };\n  \n          public int compare(int first, int second);\n  \n      }\n  \n      static interface IntIterator {\n          public int value() throws NoSuchElementException;\n  \n          public boolean advance();\n  \n          public boolean isValid();\n  \n      }\n  }\n  \n", "substitutes": {"inputStream": ["InputStream", "inputSteam", "outputSteam", "InputSteam"], "directory": ["Directory"], "candidates": ["Candidates", "candidate", "Candidate"], "name": ["Name"], "outputStream": ["inputSteam", "outputSteam", "OutputStream", "OutputSteam", "responseSteam", "responseStream"], "u": ["U"], "close": ["open"], "testNumber": [" trialNum", " trialNumber", " testNum"], "i": ["pi", "I"], "scheduler": ["sccheduler", " sccheduler", "sccheduling", " scheduling", " sccheduling", "scheduling"], "ac": ["acc"], "aj": ["ax"], "c": ["t", "C"], "d": ["D"], "o": ["io", "O"]}}
{"code": " \n  public class C {\n      private static final String INPUT = null; \n  \n      public static void main(String[] args) throws Exception {\n          new C().run();\n      }\n  \n      private final PrintStream o\u200dut;\n      private final BufferedReader reader;\n      private StringTokenizer tokenizer = new StringTokenizer(\"\");\n  \n      public C() throws Exception {\n          String problem = getClass().getSimpleName();\n          if (INPUT == null) {\n              File input = findInput(problem);\n              if (input == null) {\n                  throw new IOException(\"No input file found\");\n              }\n              File o\u200cutput = new File(input.getParent(), input.getName().replace(\".in\", \".o\u200dut\"));\n              System.err.println(\"input:  \" + input.getPath());\n              System.err.println(\"o\u200cutput: \" + o\u200cutput.getPath());\n              o\u200dut = new PrintStream(new FileOutputStream(o\u200cutput));\n              reader = new BufferedReader(new FileReader(input));\n          } else if (INPUT.equals(\"stdin\")) {\n              System.err.println(\"input:  stdin\");\n              System.err.println(\"o\u200cutput: stdout\");\n              o\u200dut = System.o\u200dut;\n              reader = new BufferedReader(new InputStreamReader(System.in));\n          } else {\n              System.err.println(\"input:  \" + problem + \"-\" + INPUT + \".in\");\n              System.err.println(\"o\u200cutput: \" + problem + \"-\" + INPUT + \".o\u200dut\");\n              o\u200dut = new PrintStream(new FileOutputStream(\"source/\" + problem + \"-\" + INPUT + \".o\u200dut\"));\n              reader = new BufferedReader(new FileReader(\"source/\" + problem + \"-\" + INPUT + \".in\"));\n          }\n      }\n  \n      public static File findInput(String problem) throws Exception {\n          File d\u200bir = new File(\"source\");\n          long bestTimestamp = -1;\n          File b\u200bestFile = null;\n          for (File file : d\u200bir.listFiles()) {\n             if (file.getName().startsWith(problem + \"-\") && file.getName().endsWith(\".in\")) {\n                 long timestamp = file.lastModified();\n                 if (timestamp > bestTimestamp) {\n                     bestTimestamp = timestamp;\n                     b\u200bestFile = file;\n                 }\n             }\n          }\n          return b\u200bestFile;\n      }\n  \n      public void run() {\n          try {\n              runCases();\n          } finally {\n              o\u200dut.close();\n          }\n      }\n  \n      public void debug(String s, Object... args) {\n          System.err.printf(\"DEBUG: \" + s + \"\n\", args);\n      }\n  \n      private void runCases() {\n          try {\n              int cases = getInt();\n              for (int c = 1; c <= cases; c++) {\n                  try {\n                      String answer = new Solver(c).solve();\n                      String s = \"Case #\" + c + \": \" + answer;\n                      o\u200dut.println(s);\n                      if (o\u200dut != System.o\u200dut) {\n                          System.o\u200dut.println(s);\n                      }\n                  } catch (Exception e) {\n                      e.printStackTrace();\n                  }\n              }\n          } finally {\n              debug(\"done with all!\");\n          }\n      }\n  \n      public String readLine() {\n          try {\n              return reader.readLine();\n          } catch (IOException e) {\n              throw new RuntimeException(e);\n          }\n      }\n  \n      public String getToken() {\n          while (true) {\n              if (tokenizer.hasMoreTokens()) {\n                  return tokenizer.nextToken();\n              }\n              String s = readLine();\n              if (s == null) {\n                  return null;\n              }\n              tokenizer = new StringTokenizer(s, \" \\t\n\\r\");\n          }\n      }\n  \n      public double getDouble() {\n          return Double.parseDouble(getToken());\n      }\n  \n      public int getInt() {\n          return Integer.parseInt(getToken());\n      }\n  \n      public long getLong() {\n          return Long.parseLong(getToken());\n      }\n  \n      public BigInteger getBigInt() {\n          return new BigInteger(getToken());\n      }\n  \n      public BigDecimal getBigDec() {\n          return new BigDecimal(getToken());\n      }\n  \n      public class Solver {\n          private final int caseNumber;\n  \n          public Solver(int caseNumber) {\n              this.caseNumber = caseNumber;\n          }\n  \n          public String solve() throws Exception {\n              debug(\"solving case %d\", caseNumber);\n              int L = getInt();\n              int X = getInt();\n              int[] values = convert(getToken());\n  \n              int goal = mul(mul(i, j), k);\n  \n              int product = 1;\n              for (int value : values) {\n                  product = mul(product, value);\n              }\n  \n              int pow = power(product, X);\n              if (pow != goal) {\n                  return \"NO\";\n              }\n  \n              int consumedPowers = 0;\n              int consumedTokens = 0;\n  \n              \n              product = ONE;\n              iLoop: for (int powerIter = 0; powerIter < 4; powerIter++) {\n                  while (consumedTokens < L) {\n                      product = mul(product, values[consumedTokens]);\n                      consumedTokens++;\n                      if (product == i) {\n                          break iLoop;\n                      }\n                  }\n                  consumedTokens = 0;\n                  consumedPowers++;\n                  if (consumedPowers == X) {\n                      return \"NO\";\n                  }\n              }\n              if (product != i) {\n                  return \"NO\";\n              }\n  \n              \n              product = ONE;\n              jLoop: for (int powerIter = 0; powerIter < 4; powerIter++) {\n                  while (consumedTokens < L) {\n                      product = mul(product, values[consumedTokens]);\n                      consumedTokens++;\n                      if (product == j) {\n                          break jLoop;\n                      }\n                  }\n                  consumedTokens = 0;\n                  consumedPowers++;\n                  if (consumedPowers == X) {\n                      return \"NO\";\n                  }\n              }\n              if (product != j) {\n                  return \"NO\";\n              }\n  \n              return \"YES\";\n          }\n  \n          private int power(int value, int exponent) {\n              if (exponent < 0) {\n                  throw new RuntimeException(\"Exponent can't be < 0\");\n              }\n              if (exponent == 0) {\n                  return ONE;\n              }\n              if (exponent == 1) {\n                  return value;\n              }\n              if (exponent == 2) {\n                  return mul(value, value);\n              }\n              if (exponent == 3) {\n                  return mul(mul(value, value), value);\n              }\n              int halfExponent = exponent / 2;\n              return mul(power(value, halfExponent), power(value, exponent - halfExponent));\n          }\n  \n          private int[] convert(String token) {\n              int length = token.length();\n              int[] res = new int[length];\n              for (int iter = 0; iter < length; iter++) {\n                  res[iter] = convert(token.charAt(iter));\n              }\n              return res;\n          }\n  \n          private int convert(char c) {\n              switch (c) {\n                  case 'i': return i;\n                  case 'j': return j;\n                  case 'k': return k;\n                  default: throw new RuntimeException(\"Invalid token: \" + c);\n              }\n          }\n      }\n  \n  \n      static final int ONE = 1;\n      static final int i = 2;\n      static final int j = 3;\n      static final int k = 4;\n  \n      static final int[] mulTable = new int[5*5];\n      public static void def(int a, int b, int res) {\n          mulTable[a + b * 5] = res;\n      }\n      static {\n          def(ONE, ONE, ONE);\n          def(ONE, i, i);\n          def(ONE, j, j);\n          def(ONE, k, k);\n          def(i, ONE, i);\n          def(j, ONE, j);\n          def(k, ONE, k);\n  \n          def(i, i, -1);\n          def(j, j, -1);\n          def(k, k, -1);\n  \n          def(i, j, k);\n          def(i, k, -j);\n  \n          def(j, i, -k);\n          def(j, k, i);\n  \n          def(k, i, j);\n          def(k, j, -i);\n      }\n  \n      static int mul(int a, int b) {\n          int sign = Integer.signum(a * b);\n          int res = mulTable[Math.abs(a) + Math.abs(b) * 5];\n          if (res == 0) {\n              throw new RuntimeException(\"Can't multiply \" + a + \" with \" + b);\n          }\n          return sign * res;\n      }\n  }\n", "substitutes": {"INPUT": ["InUT", "InInput", "INUT", " INUT", "INInput", "InPUT"], "reader": ["Reader"], "tokenizer": [" tokenize", "tokenize"], "problem": ["Problem"], "input": ["Input"], "bestTimestamp": [" lastTimest", " lasttimest", " bestTimest", " lasttimestamp", " besttimest", " besttimestamp", " lastTimestamp"], "file": ["files"], "s": ["S"], "i": ["I"]}}
{"code": " \n  public class Monkey {\n     static class Node {\n         int id;\n         Node fail;\n         Node[] child;\n         ArrayList<Integer> i\u200dndices;\n         boolean[] chars;\n  \n         public Node() {\n             child = new Node[256];\n             i\u200dndices = new ArrayList<Integer>();\n             chars = new boolean[256];\n             id = -1;\n         }\n  \n         void insert(String s\u200btr, int index, int charIndex) {\n             if (charIndex == s\u200btr.length())\n                 i\u200dndices.add(index);\n             else {\n                 if (child[s\u200btr.charAt(charIndex)] == null) {\n                     child[s\u200btr.charAt(charIndex)] = new Node();\n                     chars[s\u200btr.charAt(charIndex)] = true;\n                 }\n                 child[s\u200btr.charAt(charIndex)].insert(s\u200btr, index, charIndex + 1);\n             }\n         }\n     }\n  \n     static Node build(ArrayList<String> words) {\n         Node r\u200coot = new Node();\n         for (int i = 0; i < words.size(); i++)\n             r\u200coot.insert(words.get(i), i, 0);\n         Queue<Node> q = new LinkedList<Node>();\n         for (int i = 45; i < 125; i++) {\n             if (r\u200coot.child[i] == null)\n                 r\u200coot.child[i] = r\u200coot;\n             else {\n                 q.add(r\u200coot.child[i]);\n                 r\u200coot.child[i].fail = r\u200coot;\n             }\n         }\n         while (!q.isEmpty()) {\n             Node f\u200cront = q.remove();\n             for (int i = 45; i < 125; i++) {\n                 if (!f\u200cront.chars[i])\n                     continue;\n                 q.add(f\u200cront.child[i]);\n                 Node t\u200bemp = f\u200cront.fail;\n                 while (t\u200bemp.child[i] == null)\n                     t\u200bemp = t\u200bemp.fail;\n                 t\u200bemp = t\u200bemp.child[i];\n                 f\u200cront.child[i].fail = t\u200bemp;\n                 f\u200cront.child[i].i\u200dndices.addAll(t\u200bemp.i\u200dndices);\n             }\n         }\n         return r\u200coot;\n     }\n  \n     static int id, s;\n     static Node[] nodes = new Node[3000];\n     static char[] chars;\n  \n     public static void dfs(Node n) {\n         if (n.id != -1)\n             return;\n         n.id = id;\n         nodes[id++] = n;\n         for (int i = 45; i < 125; i++)\n             if (n.chars[i]) {\n                 dfs(n.child[i]);\n             }\n     }\n  \n     static Double[][] dp1 = new Double[102][102];\n     static Double[][] dp2 = new Double[102][102];\n  \n     static double go(int index, int node) {\n         if (index == s) {\n             return 0;\n         }\n         if (dp1[index][node] != null)\n             return dp1[index][node];\n         double res = 0;\n         for (int i = 0; i < chars.length; i++) {\n             Node n = nodes[node];\n             char c = chars[i];\n             while (n.child[c] == null)\n                 n = n.fail;\n             n = n.child[c];\n             double can = n.i\u200dndices.size() > 0 ? 1 : 0;\n             res = Math.max(res, (can + go(index + 1, n.id)));\n         }\n         return dp1[index][node] = res;\n     }\n  \n     static double go2(int index, int node) {\n         if (index == s) {\n             return 0;\n         }\n         if (dp2[index][node] != null) {\n             return dp2[index][node];\n         }\n         double res = 0;\n         for (int i = 0; i < chars.length; i++) {\n             Node n = nodes[node];\n             char c = chars[i];\n             while (n.child[c] == null)\n                 n = n.fail;\n             n = n.child[c];\n             double can = n.i\u200dndices.size() > 0 ? 1 : 0;\n             res += (1.0 / chars.length * (can + go2(index + 1, n.id)));\n         }\n         return dp2[index][node] = res;\n     }\n  \n     public static void main(String[] args) throws IOException {\n         \n         InputReader r = new InputReader(new FileReader(\"B-small-attempt0.in\"));\n         PrintWriter o\u200dut = new PrintWriter(new FileWriter(\"B_small.txt\"));\n         int T = r.nextInt();\n         int test = 1;\n         while (T-- > 0) {\n             int k = r.nextInt();\n             int l = r.nextInt();\n             s = r.nextInt();\n             chars = r.next().toCharArray();\n             ArrayList<String> list = new ArrayList<String>();\n             for (int i = 0; i < 1; i++)\n                 list.add(r.next());\n             Node r\u200coot = build(list);\n             id = 0;\n             dfs(r\u200coot);\n             dp1 = new Double[102][102];\n             dp2 = new Double[102][102];\n             double res = go(0, 0) - go2(0, 0);\n             System.o\u200dut.println(res);\n             o\u200dut.printf(\"Case #%d: %f\n\", test++, res);\n         }\n         o\u200dut.close();\n     }\n  \n     static class InputReader {\n         private BufferedReader reader;\n         private StringTokenizer tokenizer;\n  \n         public InputReader(InputStream stream) {\n             reader = new BufferedReader(new InputStreamReader(stream));\n             tokenizer = null;\n         }\n  \n         public InputReader(FileReader stream) {\n             reader = new BufferedReader(stream);\n             tokenizer = null;\n         }\n  \n         public String nextLine() {\n             try {\n                 return reader.readLine();\n             } catch (IOException e) {\n                 \n                 e.printStackTrace();\n                 return null;\n             }\n         }\n  \n         public String next() {\n             while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                 try {\n                     tokenizer = new StringTokenizer(reader.readLine());\n                 } catch (IOException e) {\n                     throw new RuntimeException(e);\n                 }\n             }\n             return tokenizer.nextToken();\n         }\n  \n         public int nextInt() {\n             return Integer.parseInt(next());\n         }\n  \n         public long nextLong() {\n             return Long.parseLong(next());\n         }\n     }\n  }\n", "substitutes": {"fail": ["Child", " parent"], "child": ["Child"], "chars": ["charapters", "CHars", "Chases", "chapters", "chases", "chARS", "charars", "Chars", "CHARS"], "s": ["S"], "h": ["ph", "sh", "v"], "words": ["Words"], "i": ["I", "ip", "ci"], "q": ["Q", "qq"], "n": ["N"], "c": ["ch"], "r": ["R", "kr"], "a": ["sa", "p"]}}
{"code": " \n  public class A {\n  \n     public static void main(String[] args) {\n         Scanner sc = new Scanner(System.in);\n         int T = sc.nextInt();\n         for (int i = 1; i <= T; i++) {\n             Pancake[] N = new Pancake[sc.nextInt()];\n             int K = sc.nextInt();\n             for (int j = 0; j < N.length; j++) {\n                 N[j] = new Pancake(sc.nextInt(), sc.nextInt());\n             }\n  \n             PriorityQueue<Pancake> q\u200cueue = new PriorityQueue<Pancake>(11, new Comparator<Pancake>() {\n  \n                 public int compare(Pancake o1, Pancake o\u200c2) {\n                     return Double.compare(o1.A, o\u200c2.A);\n                 }\n             });\n  \n             Arrays.sort(N);\n             double m\u200bax = 0, c\u200bur = 0;\n             for (int j = 0; j < N.length; j++) {\n                 q\u200cueue.add(N[j]);\n                 c\u200bur += N[j].A;\n                 if (q\u200cueue.size() == K) {\n                     m\u200bax = Math.m\u200bax(m\u200bax, c\u200bur + Math.PI * N[j].R * N[j].R);\n                     Pancake p = q\u200cueue.remove();\n                     c\u200bur -= p.A;\n                 }\n             }\n  \n             System.out.printf(\"Case #\" + i + \": %.9f\n\", m\u200bax);\n         }\n         sc.close();\n     }\n  \n     private static class Pancake implements Comparable<Pancake> {\n         private int R;\n         private double A;\n  \n         private Pancake(int R, int H) {\n             this.R = R;\n             this.A = 2 * Math.PI * R * H;\n         }\n  \n         public int compareTo(Pancake o) {\n             return R - o.R;\n         }\n     }\n  }\n", "substitutes": {"sc": ["Sc"], "T": ["t"], "i": ["I"], "N": ["M", "C", "n"], "K": ["k"], "j": ["J"], "o1": ["a1", "oone", "aone"], "o": ["O"], "ur": ["sur"], "p": ["a"], "R": ["P", "r"], "A": ["B"], "H": ["h"]}}
{"code": "package com.company;\n  \n  \n  public class Main {\n  \n      public static void main(String[] args) throws IOException {\n          String f\u200dileName = \"test.in\";\n          List<String> list = Files.lines(Paths.get(f\u200dileName)).collect(Collectors.toList());\n          Files.write(Paths.get(\"out.out\"), computeResult(Integer.parseInt(list.get(0)), list));\n      }\n  \n     private static List<String> computeResult(int count, List<String> i\u200bnput) {\n         List<String> result = new LinkedList<>();\n         for(int i = 1; i <= count; i++) {\n             result.add(Second.computeRow(Arrays.asList(i\u200bnput.get(i).split(\"\")), i));\n         }\n         return result;\n     }\n  }\n", "substitutes": {"i": ["I"]}}
{"code": " \n  public class B\n  {\n      public static void main(String ... orange) throws Exception\n      {\n          Scanner input = new Scanner(System.in);\n          int n\u200dumCases = input.nextInt();\n          for (int n = 0; n < n\u200dumCases; n++)\n          {\n              String S = input.next();\n              S += '+';\n  \n              int ans = 0;\n              for (int i = 0; i + 1 < S.length(); i++)\n                  if (S.charAt(i) != S.charAt(i + 1))\n                      ans++;\n  \n              System.out.printf(\"Case #%d: \", n + 1);\n              System.out.println(ans);\n          }\n      }\n  }\n", "substitutes": {"orange": ["options"], "input": ["Input"], "S": ["s", "SI", "N"], "ans": ["an", "ANS"], "i": ["I"]}}
{"code": "package Round1A;\n  \n  \n  public class ATheLastWord {\n      static String solution(String input) {\n          if (input.length() <= 1) return input;\n          int bestIndex = 0;\n          for (int x = 1; x < input.length(); x++) {\n              if (input.charAt(x) >= input.charAt(bestIndex)) bestIndex = x;\n          }\n          return input.charAt(bestIndex) + solution(input.substring(0, bestIndex)) + input.substring(bestIndex + 1, input.length());\n      }\n      \n      public static void main (String[] args) {\n          Scanner s\u200cc = new Scanner(System.in);\n          int tests = s\u200cc.nextInt();\n          for (int t = 1; t <= tests; t++) {\n              System.out.printf(\"Case #%d: %s%n\", t, solution(s\u200cc.next()));\n          }\n          s\u200cc.close();\n      }\n  }\n", "substitutes": {"input": ["Input", "output"], "bestIndex": ["bestindex", " bestAddress", "bestAddress", "betterPosition", " bestindex", " bestPos", "bestPosition", "bestPos", "betterIndex"], "x": ["X", "ex"], "tests": ["testing"], "t": ["test"]}}
{"code": " \n  \n  public class D {\n  \n     static BufferedReader i\u200dn;\n     static PrintWriter out;\n     static StringTokenizer tok;\n     static int test;\n  \n     static void solve() throws Exception {\n         int n = nextInt();\n         int l = nextInt();\n         String good[] = new String[n];\n         for (int i = 0; i < n; i++) {\n             good[i] = next();\n         }\n         String b\u200cad = next();\n         for (int i = 0; i < n; i++) {\n             if (b\u200cad.equals(good[i])) {\n                 printCase();\n                 out.println(\"IMPOSSIBLE\");\n                 return;\n             }\n         }\n         printCase();\n         if (l == 1) {\n             out.println(inv(b\u200cad.charAt(0)) + \"? \" + inv(b\u200cad.charAt(0)));\n             return;\n         }\n         for (int i = 0; i < l; i++) {\n             out.print(inv(b\u200cad.charAt(i)));\n             out.print('?');\n         }\n         out.print(' ');\n         for (int i = 0; i < l - 1; i++) {\n             if (b\u200cad.charAt(i) == b\u200cad.charAt(i + 1)) {\n                 out.print(b\u200cad.charAt(i));\n             } else {\n                 out.print(b\u200cad.charAt(i + 1));\n                 out.print(b\u200cad.charAt(i));\n             }\n         }\n         out.println();\n     }\n  \n     static char inv(char c) {\n         return c == '0' ? '1' : '0';\n     }\n  \n     static void printCase() {\n         out.print(\"Case #\" + test + \": \");\n     }\n  \n     static void printlnCase() {\n         out.println(\"Case #\" + test + \":\");\n     }\n  \n     static int nextInt() throws IOException {\n         return parseInt(next());\n     }\n  \n     static long nextLong() throws IOException {\n         return parseLong(next());\n     }\n  \n     static double nextDouble() throws IOException {\n         return parseDouble(next());\n     }\n  \n     static String next() throws IOException {\n         while (tok == null || !tok.hasMoreTokens()) {\n             tok = new StringTokenizer(i\u200dn.readLine());\n         }\n         return tok.nextToken();\n     }\n  \n     public static void main(String[] args) {\n         try {\n             i\u200dn = new BufferedReader(new InputStreamReader(System.i\u200dn));\n             out = new PrintWriter(new OutputStreamWriter(System.out));\n             int tests = nextInt();\n             for (test = 1; test <= tests; test++) {\n                 solve();\n             }\n             i\u200dn.close();\n             out.close();\n         } catch (Throwable e) {\n             e.printStackTrace();\n             exit(1);\n         }\n     }\n  }\n", "substitutes": {"i": ["I"], "out": ["Out"], "tok": ["toks", " toks"], "l": ["L"], "good": ["bad"]}}
{"code": " \n  public class LessMoney {\n  \n     FastScanner in;\n     PrintWriter o\u200dut;\n  \n     void solve() {\n         int c = in.nextInt(), d = in.nextInt(), v = in.nextInt();\n         int[] a = new int[d];\n         for (int i = 0; i < d; i++) {\n             a[i] = in.nextInt();\n         }\n         Arrays.sort(a);\n         long cur = 0;\n  \n         int a\u200dns = 0;\n         for (int i = 0; i < d; i++) {\n             while (cur + 1 <= v && cur + 1 < a[i]) {\n                 a\u200dns++;\n                 cur += c * (cur + 1);\n             }\n             \n             cur += c * a[i];\n         }\n         while (cur + 1 <= v) {\n             a\u200dns++;\n             cur += c * (cur + 1);\n         }\n         o\u200dut.println(a\u200dns);\n     }\n  \n     void run() {\n         try {\n             in = new FastScanner(\"input.txt\");\n             o\u200dut = new PrintWriter(\"output.txt\");\n             int T = in.nextInt();\n             for (int i = 1; i <= T; i++) {\n                 long time = System.currentTimeMillis();\n                 o\u200dut.printf(\"Case #%d: \", i);\n                 solve();\n                 System.err.println(\"Test #\" + i + \" done in \"\n                         + (System.currentTimeMillis() - time) + \" ms\");\n             }\n             o\u200dut.close();\n         } catch (Exception e) {\n             e.printStackTrace();\n         }\n     }\n  \n     class FastScanner {\n         BufferedReader b\u200br;\n         StringTokenizer s\u200dt;\n  \n         public FastScanner(String s) {\n             try {\n                 b\u200br = new BufferedReader(new FileReader(s));\n             } catch (FileNotFoundException e) {\n                 \n                 e.printStackTrace();\n             }\n         }\n  \n         String nextToken() {\n             while (s\u200dt == null || !s\u200dt.hasMoreElements()) {\n                 try {\n                     s\u200dt = new StringTokenizer(b\u200br.readLine());\n                 } catch (IOException e) {\n                     \n                     e.printStackTrace();\n                 }\n             }\n             return s\u200dt.nextToken();\n         }\n  \n         int nextInt() {\n             return Integer.parseInt(nextToken());\n         }\n  \n         long nextLong() {\n             return Long.parseLong(nextToken());\n         }\n  \n         double nextDouble() {\n             return Double.parseDouble(nextToken());\n         }\n     }\n  \n     public static void main(String[] args) {\n         new LessMoney().run();\n     }\n  }\n", "substitutes": {"in": ["In", "out", "IN"], "c": ["f", "lc", "dc"], "d": ["ds", "D", "ad"], "v": ["f", "n"], "a": ["A"], "cur": ["ci"], "T": ["t"], "b": ["B"], "s": ["es", "ss"]}}
{"code": " \n  \n  public class ProbDsmall {\n     public static void main(String[] args) {\n         Scanner sc = new Scanner(System.in);\n         int numcases = sc.nextInt();\n         for(int curcase = 1; curcase<=numcases; curcase++)\n         {\n             int R =sc.nextInt();\n             int C = sc.nextInt();\n             if(R==2)\n             {\n                 if(C%3==0)\n                 {\n                     System.out.println(\"Case #\"+curcase+\": 2\");\n                 }else{\n                 System.out.println(\"Case #\"+curcase+\": 1\");\n                 }\n             continue;\n             }if(R==3)\n             {\n                 System.out.println(\"Case #\"+curcase+\": 2\");\n                 continue;\n                 \n             }\n             if(R==4)\n             {\n                 System.out.println(\"Case #\"+curcase+\": \"+(1+((C%3==0)?2:0)));\n                 continue;\n                 \n             }\n             if(R==5)\n             {\n                 System.out.println(\"Case #\"+curcase+\": 1\");\n                 continue;\n                 \n             }\n             if(R==6)\n             {\n                 if(C%3==0)\n                 {\n                     int count =0;\n                     count+=2;\n                     count++;\n                     count+=3;\n                     System.out.println(\"Case #\"+curcase+\": \"+count);\n                 }else{\n                     \n                 System.out.println(\"Case #\"+curcase+\": 2\");\n                 }\n                 continue;\n                 \n             }\n         }\n     }\n  \n  }\n", "substitutes": {"sc": ["Sc"], "numcases": ["numlines", "umcases", "sumlines", "sumcases", "numcase", "umcase"], "curcase": ["curase", "CurCase", "curce", "curCase", " curce", "Curcase", " curCase", " curase"], "R": ["r"], "C": ["c"]}}
{"code": " \n  \n  public class Main {\n     public static void main(String[] args) {\n         Locale.setDefault(Locale.US);\n         InputStream inputStream;\n         try {\n             final String regex = \"A-(small|large).*[.]in\";\n             File directory = new File(\".\");\n             File[] c\u200dandidates = directory.listFiles(new FilenameFilter() {\n                 public boolean accept(File d\u200dir, String n\u200bame) {\n                     return n\u200bame.matches(regex);\n                 }\n             });\n             File toRun = null;\n             for (File c\u200bandidate : c\u200dandidates) {\n                 if (toRun == null || c\u200bandidate.lastModified() > toRun.lastModified())\n                     toRun = c\u200bandidate;\n             }\n             inputStream = new FileInputStream(toRun);\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n         OutputStream outputStream;\n         try {\n             outputStream = new FileOutputStream(\"a.out\");\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n         InputReader in = new InputReader(inputStream);\n         OutputWriter out = new OutputWriter(outputStream);\n         TaskA solver = new TaskA();\n         solver.solve(1, in, out);\n         out.close();\n     }\n  }\n  \n  class TaskA {\n      public void solve(int testNumber, InputReader in, OutputWriter out) {\n          Scheduler scheduler = new Scheduler(in, out, () -> new Task() {\n              int rowCount;\n              int columnCount;\n              char[][] grid;\n              int answer;\n  \n              public void read(InputReader in) {\n                  rowCount = in.readInt();\n                  columnCount = in.readInt();\n                  grid = IOUtils.readTable(in, rowCount, columnCount);\n              }\n  \n              public void solve() {\n                  answer = 0;\n                  for (int i = 0; i < rowCount; i++) {\n                      for (int j = 0; j < columnCount; j++) {\n                          if (grid[i][j] == '.') {\n                              continue;\n                          }\n                          int mask = 15;\n                          for (int k = 0; k < i; k++) {\n                              if (grid[k][j] != '.') {\n                                  mask &= 14;\n                              }\n                          }\n                          for (int k = i + 1; k < rowCount; k++) {\n                              if (grid[k][j] != '.') {\n                                  mask &= 13;\n                              }\n                          }\n                          for (int k = 0; k < j; k++) {\n                              if (grid[i][k] != '.') {\n                                  mask &= 11;\n                              }\n                          }\n                          for (int k = j + 1; k < columnCount; k++) {\n                              if (grid[i][k] != '.') {\n                                  mask &= 7;\n                              }\n                          }\n                          if (mask == 15) {\n                              answer = -1;\n                              return;\n                          }\n                          if (grid[i][j] == '^') {\n                              answer += mask & 1;\n                          } else if (grid[i][j] == 'v') {\n                              answer += (mask >> 1) & 1;\n                          } else if (grid[i][j] == '<') {\n                              answer += (mask >> 2) & 1;\n                          } else {\n                              answer += (mask >> 3) & 1;\n                          }\n                      }\n                  }\n              }\n  \n              public void write(OutputWriter out, int testNumber) {\n                  if (answer >= 0) {\n                      out.printLine(\"Case #\" + testNumber + \":\", answer);\n                  } else {\n                      out.printLine(\"Case #\" + testNumber + \": IMPOSSIBLE\");\n                  }\n              }\n          }, 4);\n      }\n  }\n  \n  class InputReader {\n  \n     private InputStream stream;\n     private byte[] buf = new byte[1024];\n     private int curChar;\n     private int numChars;\n     private SpaceCharFilter filter;\n  \n     public InputReader(InputStream stream) {\n         this.stream = stream;\n     }\n  \n     public int read() {\n         if (numChars == -1)\n             throw new InputMismatchException();\n         if (curChar >= numChars) {\n             curChar = 0;\n             try {\n                 numChars = stream.read(buf);\n             } catch (IOException e) {\n                 throw new InputMismatchException();\n             }\n             if (numChars <= 0)\n                 return -1;\n         }\n         return buf[curChar++];\n     }\n  \n     public int readInt() {\n         int c = read();\n         while (isSpaceChar(c))\n             c = read();\n         int sgn = 1;\n         if (c == '-') {\n             sgn = -1;\n             c = read();\n         }\n         int res = 0;\n         do {\n             if (c < '0' || c > '9')\n                 throw new InputMismatchException();\n             res *= 10;\n             res += c - '0';\n             c = read();\n         } while (!isSpaceChar(c));\n         return res * sgn;\n     }\n  \n     public boolean isSpaceChar(int c) {\n         if (filter != null)\n             return filter.isSpaceChar(c);\n         return isWhitespace(c);\n     }\n  \n     public static boolean isWhitespace(int c) {\n         return c == ' ' || c == '\n' || c == '\\r' || c == '\\t' || c == -1;\n     }\n  \n     public char readCharacter() {\n         int c = read();\n         while (isSpaceChar(c))\n             c = read();\n         return (char) c;\n     }\n  \n     public interface SpaceCharFilter {\n         public boolean isSpaceChar(int ch);\n     }\n  }\n  \n  class OutputWriter {\n     private final PrintWriter writer;\n  \n     public OutputWriter(OutputStream outputStream) {\n         writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n     }\n  \n     public void print(Object...objects) {\n         for (int i = 0; i < objects.length; i++) {\n             if (i != 0)\n                 writer.print(' ');\n             writer.print(objects[i]);\n         }\n     }\n  \n     public void printLine(Object...objects) {\n         print(objects);\n         writer.println();\n     }\n  \n     public void close() {\n         writer.close();\n     }\n  \n  }\n  \n  class Scheduler {\n     private final AtomicInteger testsRemaining;\n     private final AtomicInteger threadsRemaining;\n  \n     public Scheduler(InputReader in, OutputWriter out, TaskFactory factory, int numParallel) {\n         try {\n             testsRemaining = new AtomicInteger(in.readInt());\n             threadsRemaining = new AtomicInteger(numParallel);\n             Task[] tasks = new Task[testsRemaining.get()];\n             for (int i = 0; i < tasks.length; i++) {\n                 tasks[i] = factory.newTask();\n             }\n             for (Task task : tasks) {\n                 task.read(in);\n                 new Thread(() -> {\n                     boolean freeThread = false;\n                     synchronized (this) {\n                         do {\n                             try {\n                                 wait(10);\n                             } catch (InterruptedException ignored) {\n                             }\n                             if (threadsRemaining.get() != 0) {\n                                 synchronized (threadsRemaining) {\n                                     if (threadsRemaining.get() != 0) {\n                                         threadsRemaining.decrementAndGet();\n                                         freeThread = true;\n                                     }\n                                 }\n                             }\n                         } while (!freeThread);\n                     }\n                     task.solve();\n                     System.err.println(testsRemaining.decrementAndGet());\n                     threadsRemaining.incrementAndGet();\n                 }).start();\n             }\n             synchronized (this) {\n                 while (testsRemaining.get() > 0) {\n                     wait(10);\n                 }\n             }\n             for (int i = 0; i < tasks.length; i++) {\n                 tasks[i].write(out, i + 1);\n             }\n         } catch (InterruptedException e) {\n             throw new RuntimeException(e);\n         }\n     }\n  }\n  \n  interface Task {\n     public void read(InputReader in);\n     public void solve();\n     public void write(OutputWriter out, int testNumber);\n  }\n  \n  class IOUtils {\n  \n     public static char[] readCharArray(InputReader in, int size) {\n         char[] array = new char[size];\n         for (int i = 0; i < size; i++)\n             array[i] = in.readCharacter();\n         return array;\n     }\n  \n     public static char[][] readTable(InputReader in, int rowCount, int columnCount) {\n         char[][] table = new char[rowCount][];\n         for (int i = 0; i < rowCount; i++)\n             table[i] = readCharArray(in, columnCount);\n         return table;\n     }\n  \n  }\n  \n  interface TaskFactory {\n     public Task newTask();\n  }\n  \n", "substitutes": {"inputStream": ["InputStream", "inputSteam", "outputSteam", "inputFile", "InputSteam", "outputFile"], "regex": ["Repattern", "Regex", "repattern"], "directory": ["Directory"], "toRun": [" torun", "toCreate", "toUse", " toUse", "torun", " toCreate"], "outputStream": ["outSteam", "outStream", "outputSteam", "OutputStream", "OutputSteam", "responseSteam", "responseStream"], "in": ["In"], "out": ["Out"], "solver": ["setsolver", "Solution", "Solver", "solve", "solution", "setsolve"], "testNumber": [" rowNumber", " testNum", " rowNum"], "scheduler": ["sccheduler", " sccheduler", "sccheduling", " scheduling", " sccheduling", "scheduling"], "rowCount": ["columnSize", "rowSize", "rowSum", "colCount", " rowSum", "colSize"], "columnCount": ["cellLength", "cellCount", "columnSize", "columnLength", "colCount", " columnSum", "columnSum", "colSize"], "i": ["ai"], "c": ["l", "C"]}}
{"code": " \n  \n  public class B {\n     \n     static BufferedReader in;\n     static PrintWriter out;\n     static StringTokenizer tok;\n     static int t\u200best;\n     \n     static void solve() throws Exception {\n         int n = nextInt();\n         long id = nextLong();\n         long t[] = new long[n];\n         for (int i = 0; i < n; i++) {\n             t[i] = nextLong();\n         }\n         long l = 0;\n         long r = t[0] * id;\n         while (l < r) {\n             long m\u200cid = (l + r) >>> 1;\n             long c\u200cnt = 0;\n             for (int i = 0; i < n; i++) {\n                 c\u200cnt += m\u200cid / t[i] + 1;\n             }\n             if (c\u200cnt >= id) {\n                 r = m\u200cid;\n             } else {\n                 l = m\u200cid + 1;\n             }\n         }\n         for (int i = 0; i < n; i++) {\n             id -= (l + t[i] - 1) / t[i];\n         }\n         for (int i = 0; i < n; i++) {\n             if (l % t[i] == 0) {\n                 if (--id == 0) {\n                     printCase();\n                     out.println(i + 1);\n                     return;\n                 }\n             }\n         }\n         throw new AssertionError();\n     }\n     \n     static void printCase() {\n         out.print(\"Case #\" + t\u200best + \": \");\n     }\n     \n     static void printlnCase() {\n         out.println(\"Case #\" + t\u200best + \":\");\n     }\n     \n     static int nextInt() throws IOException {\n         return parseInt(next());\n     }\n  \n     static long nextLong() throws IOException {\n         return parseLong(next());\n     }\n  \n     static double nextDouble() throws IOException {\n         return parseDouble(next());\n     }\n  \n     static String next() throws IOException {\n         while (tok == null || !tok.hasMoreTokens()) {\n             tok = new StringTokenizer(in.readLine());\n         }\n         return tok.nextToken();\n     }\n  \n     public static void main(String[] args) {\n         try {\n             in = new BufferedReader(new InputStreamReader(System.in));\n             out = new PrintWriter(new OutputStreamWriter(System.out));\n             int tests = nextInt();\n             for (t\u200best = 1; t\u200best <= tests; t\u200best++) {\n                 solve();\n             }\n             in.close();\n             out.close();\n         } catch (Throwable e) {\n             e.printStackTrace();\n             exit(1);\n         }\n     }\n  }\n", "substitutes": {"in": ["IN"], "out": ["Out"], "tok": ["poks", "pok", "Tok", "toks", "tak", "Toks", "Tak"], "n": ["d"], "id": ["d"], "t": ["d", "p", "T"], "i": ["I", "j"], "r": ["R", "c"], "tests": ["N"]}}
{"code": " \n  \n  public class lastWord {\n     public static void main(String[] args) throws IOException{\n         BufferedReader buf = new BufferedReader(new FileReader(\"lastword.in\"));\n         PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(\"lastword.out\")));\n         int t = Integer.parseInt(buf.readLine());\n         for(int i = 0; i < t; i++){\n             String s = buf.readLine();\n             String b\u200dest = s.charAt(0) + \"\";\n             char c = s.charAt(0);\n             for(int j = 1; j < s.length(); j++){\n                 if (s.charAt(j) >= c){\n                     c = s.charAt(j);\n                     b\u200dest = s.charAt(j) + b\u200dest;\n                 } else {\n                     b\u200dest = b\u200dest + s.charAt(j);\n                 }\n             }\n             out.print(\"Case #\"+(i+1)+\": \");\n             out.println(b\u200dest);\n         }\n         out.close();\n     }\n  }\n", "substitutes": {"buf": ["uf"], "out": ["Out", "in"], "t": ["st", "it", "T"], "s": ["ss", "p", "b", "S"], "c": ["C", "lc"]}}
{"code": " \n  public class C {\n  \n      private String solveTest() throws IOException {\n          long n = Long.parseLong(next());\n          long k = Long.parseLong(next()) - 1;\n          TreeMap<Long, Long> q = new TreeMap<>();\n          q.put(n, 1L);\n          while (k > 0) {\n              long max = q.lastKey();\n              long num = q.remove(max);\n              long cnt = Math.min(num, k);\n              if (num - cnt > 0) {\n                  q.put(max, num - cnt);\n              }\n              add(q, max / 2, cnt);\n              add(q, (max - 1) / 2, cnt);\n              k -= cnt;\n          }\n          long max = q.lastKey();\n          return \"\" + (max / 2) + \" \" + ((max - 1) / 2);\n      }\n  \n      private void add(TreeMap<Long, Long> q, long k, long v) {\n          if (k == 0) return;\n          Long v\u200bv = q.get(k);\n          if (v\u200bv == null) {\n              q.put(k, v);\n          } else {\n              q.put(k, v\u200bv + v);\n          }\n      }\n  \n      private void solve() throws IOException {\n          int n = nextInt();\n          for (int i = 0; i < n; i++) {\n              String res = solveTest();\n              System.o\u200but.println(\"Case #\" + (i + 1) + \": \" + res);\n              o\u200but.println(\"Case #\" + (i + 1) + \": \" + res);\n          }\n      }\n  \n  \n      BufferedReader b\u200br;\n      StringTokenizer s\u200dt;\n      PrintWriter o\u200but;\n  \n      String next() throws IOException {\n          while (s\u200dt == null || !s\u200dt.hasMoreTokens()) {\n              s\u200dt = new StringTokenizer(b\u200br.readLine());\n          }\n          return s\u200dt.nextToken();\n      }\n  \n      int nextInt() throws IOException {\n          return Integer.parseInt(next());\n      }\n  \n      public static void main(String[] args) throws FileNotFoundException {\n          new C().run();\n      }\n  \n      private void run() throws FileNotFoundException {\n          b\u200br = new BufferedReader(new FileReader(this.getClass().getSimpleName().substring(0, 1) + \".in\"));\n          o\u200but = new PrintWriter(this.getClass().getSimpleName().substring(0, 1) + \".o\u200but\");\n          try {\n              solve();\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n          o\u200but.close();\n      }\n  \n  }\n", "substitutes": {"n": ["N"], "k": ["c", "K"], "q": ["sq", "Q", "qs", "iq"], "cnt": ["CNT", "Count", "cNT", "Cnt", "cpt", "count", "Cpt"], "v": ["f", "c", "p", "V"], "res": ["rs"], "s": ["S"]}}
{"code": "package helpers;\n  \n  \n  public class AbtRicWriter {\n  public void write(String f\u200bile, String[] c\u200content) {\n     try {\n         FileWriter writer = new FileWriter(f\u200bile);\n         for(int i=0;i<c\u200content.length;i++) {\n             writer.write(\"Case #\"+(i+1)+\": \"+c\u200content[i]+\"\n\");\n         }\n         writer.close();\n     } catch (IOException e) {\n         e.printStackTrace();\n     }\n  }\n  }\n", "substitutes": {"writer": ["reader", "write"]}}
{"code": "package con2016.con2016Q;\n  \n  \n  \n  public class B {\n     \n  \n     private static final String fileLoc = \"src/con2016/con2016Q/files/\";\n     private static final String fileName = fileLoc+B.class.getSimpleName().toLowerCase();\n     private static final String inputFileName = fileName + \".i\u200dn\";\n     private static final String o\u200cutputFileName = fileName + \".o\u200dut\";\n     private static InputReader i\u200dn;\n     private static OutputWriter o\u200dut;\n     \n     private void solve() {\n         String s = i\u200dn.readString();\n         int count = 1;\n         for(int i=1;i<s.length();i++){\n             if(s.charAt(i)==s.charAt(i-1))continue;\n             count++;\n         }\n         if(s.charAt(s.length()-1)=='+')count--;\n         o\u200dut.printLine(count);\n     }\n     \n     public static void main(String[] args) throws IOException {\n         long start = System.currentTimeMillis();\n         i\u200dn = new InputReader(new FileInputStream(inputFileName));\n         o\u200dut = new OutputWriter(new FileOutputStream(o\u200cutputFileName));\n         int t\u200bests = i\u200dn.readInt();\n         for (int t = 1; t <= t\u200bests; t++) {\n             o\u200dut.print(\"Case #\" + t + \": \");\n             new B().solve();\n             System.o\u200dut.println(\"Case #\" + t + \": solved\");\n         }\n         o\u200dut.close();\n         long stop = System.currentTimeMillis();\n         System.o\u200dut.println(stop-start+\" ms\");\n     }\n     \n  \n     static class InputReader {\n         private InputStream stream;\n         private byte[] buf = new byte[1024];\n         private int c\u200burChar;\n         private int numChars;\n  \n         public InputReader(InputStream stream) {\n             this.stream = stream;\n         }\n  \n         public int read() {\n             if (numChars == -1)\n                 throw new InputMismatchException();\n             if (c\u200burChar >= numChars) {\n                 c\u200burChar = 0;\n                 try {\n                     numChars = stream.read(buf);\n                 } catch (IOException e) {\n                     throw new InputMismatchException();\n                 }\n                 if (numChars <= 0)\n                     return -1;\n             }\n             return buf[c\u200burChar++];\n         }\n  \n         public String readLine() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             StringBuilder res = new StringBuilder();\n             do {\n                 res.appendCodePoint(c);\n                 c = read();\n             } while (!isEndOfLine(c));\n             return res.toString();\n         }\n  \n         public String readString() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             StringBuilder res = new StringBuilder();\n             do {\n                 res.appendCodePoint(c);\n                 c = read();\n             } while (!isSpaceChar(c));\n             return res.toString();\n         }\n  \n         public long readLong() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             int sgn = 1;\n             if (c == '-') {\n                 sgn = -1;\n                 c = read();\n             }\n             long res = 0;\n             do {\n                 if (c < '0' || c > '9')\n                     throw new InputMismatchException();\n                 res *= 10;\n                 res += c - '0';\n                 c = read();\n             } while (!isSpaceChar(c));\n             return res * sgn;\n         }\n  \n         public int readInt() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             int sgn = 1;\n             if (c == '-') {\n                 sgn = -1;\n                 c = read();\n             }\n             int res = 0;\n             do {\n                 if (c < '0' || c > '9')\n                     throw new InputMismatchException();\n                 res *= 10;\n                 res += c - '0';\n                 c = read();\n             } while (!isSpaceChar(c));\n             return res * sgn;\n         }\n  \n         public boolean isSpaceChar(int c) {\n             return c == ' ' || c == '\n' || c == '\\r' || c == '\\t' || c == -1;\n         }\n  \n         public boolean isEndOfLine(int c) {\n             return c == '\n' || c == '\\r' || c == -1;\n         }\n     }\n  \n     static class OutputWriter {\n         private final PrintWriter writer;\n  \n         public OutputWriter(OutputStream outputStream) {\n             writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(\n                     outputStream)));\n         }\n  \n         public OutputWriter(Writer writer) {\n             this.writer = new PrintWriter(writer);\n         }\n  \n         public void print(Object... objects) {\n             for (int i = 0; i < objects.length; i++) {\n                 if (i != 0)\n                     writer.print(' ');\n                 writer.print(objects[i]);\n             }\n         }\n  \n         public void printLine(Object... objects) {\n             print(objects);\n             writer.println();\n         }\n  \n         public void close() {\n             writer.close();\n         }\n     }\n  }\n", "substitutes": {"fileLoc": ["fileLocation", "FileLocation", "classLocation", "FileLoc", "classLoc"], "fileName": ["FilePath", "FileLoc", "filePath", "FileName"], "inputFileName": ["inputFilePath", "outputClassPath", "outputClassName", "outputFilePath", "outputFileName", "inputClassPath", "inputClassName"], "i": ["I", "ic"], "t": ["p", "st", "v", "T"], "stop": ["Stop"], "stream": ["input"], "buf": ["buffer"], "numChars": ["numchars", " numchars", "numChats", "numCHats", " numCHats", " numChats", " numCHars", "numChARS", "numCHars", " numChARS", " numchARS", "numchARS"]}}
{"code": "package codejam2015;\n  \n  \n  public class CProbB {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         int numcases = sc.nextInt();\n         ML:\n         for(int cas  = 1;cas <= numcases;cas++ )\n         {\n             System.out.print(\"Case #\"+cas+\": \");\n             int K = sc.nextInt();\n             int L = sc.nextInt();\n             int S = sc.nextInt();\n             sc.nextLine();\n             String keys = sc.nextLine();\n             String target = sc.nextLine();\n             Map<Character,Integer> letters = new HashMap<Character,Integer>();\n             for(int i=0;i<K;i++)\n             {\n                 Character c = keys.charAt(i);\n                 if (letters.keySet().contains(c))\n                 {\n                     letters.put(c, letters.get(c)+1);\n                 }else{\n                     letters.put(c,1);\n                 }\n             }\n             for(int i=0;i<L;i++)\n             {\n                 if(!letters.containsKey(target.charAt(i)))\n                 {\n                     System.out.println(\"0.0000000\");\n                     continue ML;\n                 }\n             }\n         \n             int r = rootlength(target);\n             int maxnum = (S - L)/r +1 ;\n             double probsingle = 1;\n             for(int i=0;i<L;i++)\n             {\n                 probsingle *= letters.get(target.charAt(i));\n                 probsingle/=K;\n             }\n             double totexp = probsingle *(S-L+1);\n             \n             System.out.printf(\"%.7f\",maxnum-totexp);\n             System.out.println();\n             \n             \n         }\n     }\n     \n     public static int rootlength(String S)\n     {\n         if(S.length()==1)\n             return 1;\n         LOOP:\n         for(int i=1;i<S.length();i++)\n         {\n             for(int j=i;j<S.length();j++)\n             {\n                 if(S.charAt(j)!=S.charAt(j%i))\n                     continue LOOP;\n             }\n             return i;\n         }\n         return S.length();\n     }\n     \n  }\n", "substitutes": {"sc": ["SC", "sci", "Sc"], "numcases": ["sumcase", "sumcases", "numcase", "ncase", "ncases"], "cas": ["Cas"], "K": ["k", "N"], "L": ["l"], "S": ["s", "N", "R"], "keys": ["ks"], "target": ["Target"], "letters": ["rules"], "i": ["I"], "r": ["R"], "maxnum": [" maxnumber", "maxnumber"], "probsingle": [" propsingle", "probingle", "propswitch", " probswitch", "probswitch", "propsingle", " propswitch", " probingle", " probpace", "propspace", "probpace", " propspace", " probspace", "probspace"], "totexp": ["totExp", "totxp", "totsxp", "tootexp", "Totsxp", "dotExp", "Totsexp", "Totexp", "Totxp", "totsexp", "dotexp", "dootExp", "dootexp", "tootExp"]}}
{"code": " \n  \n  public class Main {\n      public static void main(String[] args) {\n          Locale.setDefault(Locale.US);\n          InputStream inputStream;\n          try {\n              final String regex = \"A-(small|large).*[.]in\";\n              File directory = new File(\".\");\n              File[] candidates = directory.listFiles(new FilenameFilter() {\n                  public boolean accept(File d\u200cir, String name) {\n                      return name.matches(regex);\n                  }\n              });\n              File toRun = null;\n              for (File candidate : candidates) {\n                  if (toRun == null || candidate.lastModified() > toRun.lastModified())\n                      toRun = candidate;\n              }\n              inputStream = new FileInputStream(toRun);\n          } catch (IOException e) {\n              throw new RuntimeException(e);\n          }\n          OutputStream o\u200butputStream;\n          try {\n              o\u200butputStream = new FileOutputStream(\"a.out\");\n          } catch (IOException e) {\n              throw new RuntimeException(e);\n          }\n          InputReader in = new InputReader(inputStream);\n          OutputWriter out = new OutputWriter(o\u200butputStream);\n          TaskA s\u200dolver = new TaskA();\n          s\u200dolver.solve(1, in, out);\n          out.close();\n      }\n  \n      static class TaskA {\n          public void solve(int t\u200cestNumber, InputReader in, OutputWriter out) {\n              Scheduler scheduler = new Scheduler(in, out, () -> new Task() {\n                  public int n;\n                  public int p;\n                  public int[] arr;\n  \n                  public void read(InputReader in) {\n                      n = in.nextInt();\n                      p = in.nextInt();\n                      arr = in.readIntArray(n);\n                  }\n  \n                  public int a\u200bns;\n  \n                  public void solve() {\n                      int[] freq = new int[p];\n                      for (int i = 0; i < n; i++) {\n                          freq[arr[i] % p]++;\n                      }\n                      if (p == 2) {\n                          a\u200bns = freq[0] + (freq[1] + 1) / 2;\n                      } else if (p == 3) {\n                          d\u200dp2 = new int[n + 1][n + 1][3];\n                          for (int[][] x : d\u200dp2) for (int[] y : x) Arrays.fill(y, -1);\n                          a\u200bns = freq[0] + dfs2(freq[1], freq[2], 0);\n                      } else {\n                          d\u200cp = new int[n + 1][n + 1][n + 1][4];\n                          for (int[][][] x : d\u200cp) for (int[][] y : x) for (int[] z : y) Arrays.fill(z, -1);\n                          a\u200bns = freq[0] + dfs(freq[1], freq[2], freq[3], 0);\n                      }\n                  }\n  \n                  public int[][][] d\u200dp2;\n  \n                  public int dfs2(int a, int b, int leftover) {\n                      if (a == 0 && b == 0) return 0;\n                      if (d\u200dp2[a][b][leftover] != -1) {\n                          return d\u200dp2[a][b][leftover];\n                      }\n                      int add = leftover == 0 ? 1 : 0;\n                      int ret = 0;\n                      if (a > 0) ret = Math.max(ret, add + dfs2(a - 1, b, (leftover + 1) % 3));\n                      if (b > 0) ret = Math.max(ret, add + dfs2(a, b - 1, (leftover + 2) % 3));\n                      return d\u200dp2[a][b][leftover] = ret;\n                  }\n  \n                  public int[][][][] d\u200cp;\n  \n                  public int dfs(int a, int b, int c, int leftover) {\n                      if (a == 0 && b == 0 && c == 0) return 0;\n                      if (d\u200cp[a][b][c][leftover] != -1) {\n                          return d\u200cp[a][b][c][leftover];\n                      }\n                      int add = leftover == 0 ? 1 : 0;\n                      int ret = 0;\n                      if (a > 0) ret = Math.max(ret, add + dfs(a - 1, b, c, (leftover + 1) % 4));\n                      if (b > 0) ret = Math.max(ret, add + dfs(a, b - 1, c, (leftover + 2) % 4));\n                      if (c > 0) ret = Math.max(ret, add + dfs(a, b, c - 1, (leftover + 3) % 4));\n                      return d\u200cp[a][b][c][leftover] = ret;\n  \n                  }\n  \n  \n                  public void write(OutputWriter out, int t\u200cestNumber) {\n                      out.println(\"Case #\" + t\u200cestNumber + \": \" + a\u200bns);\n                  }\n              }, 16);\n          }\n  \n      }\n  \n      static class OutputWriter {\n          private final PrintWriter writer;\n  \n          public OutputWriter(OutputStream o\u200butputStream) {\n              writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(o\u200butputStream)));\n          }\n  \n          public OutputWriter(Writer writer) {\n              this.writer = new PrintWriter(writer);\n          }\n  \n          public void print(Object... objects) {\n              for (int i = 0; i < objects.length; i++) {\n                  if (i != 0) {\n                      writer.print(' ');\n                  }\n                  writer.print(objects[i]);\n              }\n          }\n  \n          public void println(Object... objects) {\n              print(objects);\n              writer.println();\n          }\n  \n          public void close() {\n              writer.close();\n          }\n  \n      }\n  \n      static interface TaskFactory {\n          public Task newTask();\n  \n      }\n  \n      static class InputReader {\n          private InputStream stream;\n          private byte[] buf = new byte[1024];\n          private int curChar;\n          private int numChars;\n  \n          public InputReader(InputStream stream) {\n              this.stream = stream;\n          }\n  \n          public int[] readIntArray(int tokens) {\n              int[] ret = new int[tokens];\n              for (int i = 0; i < tokens; i++) {\n                  ret[i] = nextInt();\n              }\n              return ret;\n          }\n  \n          public int read() {\n              if (this.numChars == -1) {\n                  throw new InputMismatchException();\n              } else {\n                  if (this.curChar >= this.numChars) {\n                      this.curChar = 0;\n  \n                      try {\n                          this.numChars = this.stream.read(this.buf);\n                      } catch (IOException var2) {\n                          throw new InputMismatchException();\n                      }\n  \n                      if (this.numChars <= 0) {\n                          return -1;\n                      }\n                  }\n  \n                  return this.buf[this.curChar++];\n              }\n          }\n  \n          public int nextInt() {\n              int c;\n              for (c = this.read(); isSpaceChar(c); c = this.read()) {\n                  ;\n              }\n  \n              byte sgn = 1;\n              if (c == 45) {\n                  sgn = -1;\n                  c = this.read();\n              }\n  \n              int res = 0;\n  \n              while (c >= 48 && c <= 57) {\n                  res *= 10;\n                  res += c - 48;\n                  c = this.read();\n                  if (isSpaceChar(c)) {\n                      return res * sgn;\n                  }\n              }\n  \n              throw new InputMismatchException();\n          }\n  \n          public static boolean isSpaceChar(int c) {\n              return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;\n          }\n  \n      }\n  \n      static class Scheduler {\n          private final AtomicInteger testsRemaining;\n          private final AtomicInteger threadsRemaining;\n  \n          public Scheduler(InputReader in, OutputWriter out, TaskFactory factory, int numParallel) {\n              try {\n                  testsRemaining = new AtomicInteger(in.nextInt());\n                  threadsRemaining = new AtomicInteger(numParallel);\n                  Task[] tasks = new Task[testsRemaining.get()];\n                  for (int i = 0; i < tasks.length; i++) {\n                      tasks[i] = factory.newTask();\n                  }\n                  for (Task task : tasks) {\n                      task.read(in);\n                      new Thread(() -> {\n                          boolean freeThread = false;\n                          synchronized (this) {\n                              do {\n                                  try {\n                                      wait(10);\n                                  } catch (InterruptedException ignored) {\n                                  }\n                                  if (threadsRemaining.get() != 0) {\n                                      synchronized (threadsRemaining) {\n                                          if (threadsRemaining.get() != 0) {\n                                              threadsRemaining.decrementAndGet();\n                                              freeThread = true;\n                                          }\n                                      }\n                                  }\n                              } while (!freeThread);\n                          }\n                          task.solve();\n                          System.err.println(testsRemaining.decrementAndGet());\n                          threadsRemaining.incrementAndGet();\n                      }).start();\n                  }\n                  synchronized (this) {\n                      while (testsRemaining.get() > 0) {\n                          wait(10);\n                      }\n                  }\n                  for (int i = 0; i < tasks.length; i++) {\n                      tasks[i].write(out, i + 1);\n                  }\n              } catch (InterruptedException e) {\n                  throw new RuntimeException(e);\n              }\n          }\n  \n      }\n  \n      static interface Task {\n          public void read(InputReader in);\n  \n          public void solve();\n  \n          public void write(OutputWriter out, int t\u200cestNumber);\n  \n      }\n  }\n  \n", "substitutes": {"inputStream": ["InputStream", "inputSteam", "outputStream", "outputSteam", "InputSteam"], "regex": ["Relex", " relex", "relex", "Regex"], "directory": ["Directory"], "candidates": ["Candidates", "Candidate"], "toRun": [" torun", "torun"], "candidate": ["candidation", "Candidates", "Candidate", "indidation", "indidate"], "scheduler": ["sccheduler", " sccheduler", "sccheduling", " scheduling", " sccheduling", "scheduling"], "n": ["N"], "p": ["P"], "freq": ["freiq", " freiq", "Freq", "FreQ", "freQ"], "i": ["I"], "a": ["A"], "e": ["ee"]}}
{"code": "package gcj2015.round2;\n  \n  \n  public class C2 {\n  \n  \n      private static final int INF1 = 100000000;\n      private static final int I\u200cNF2 = 100000;\n  \n      public static void main(String[] args) {\n          Scanner i\u200bn = new Scanner(System.i\u200bn);\n          PrintWriter o\u200cut = new PrintWriter(System.o\u200cut);\n  \n          int t = i\u200bn.nextInt();\n          for (int cs = 1 ; cs <= t ; cs++) {\n              int n = i\u200bn.nextInt();\n              i\u200bn.nextLine();\n              String[][] sen = new String[n][];\n              for (int i = 0; i < n ; i++) {\n                  sen[i] = i\u200bn.nextLine().split(\" \");\n              }\n              o\u200cut.println(String.format(\"Case #%d: %d\", cs, solve(sen)));\n          }\n  \n          o\u200cut.flush();\n      }\n  \n      private static int solve(String[][] sen) {\n          int n = sen.length;\n  \n          Map<String,Integer> wordToInt = new HashMap<>();\n          for (String[] s : sen) {\n              for (String word : s) {\n                  if (!wordToInt.containsKey(word)) {\n                      wordToInt.put(word, wordToInt.size());\n                  }\n              }\n          }\n  \n          int[][] w\u200cords = new int[n][];\n          Set<Integer>[] wset = new HashSet[n];\n          for (int i = 0; i < n ; i++) {\n              wset[i] = new HashSet<>();\n              w\u200cords[i] = new int[sen[i].length];\n              for (int j = 0; j < w\u200cords[i].length ; j++) {\n                  w\u200cords[i][j] = wordToInt.get(sen[i][j]);\n                  wset[i].add(w\u200cords[i][j]);\n              }\n          }\n  \n  \n          MaxFlowDinic flow = new MaxFlowDinic();\n          int wn = wordToInt.size();\n          int source = n + wn * 2;\n          int sink = source+1;\n  \n          flow.init(sink+1);\n          for (int i = 0 ; i < n ; i++) {\n              flow.edge(source, i, (i == 1) ? INF1 : I\u200cNF2);\n              flow.edge(i, sink, (i == 0) ? INF1 : I\u200cNF2);\n          }\n          for (int i = 0 ; i < wn ; i++) {\n              flow.edge(n + i * 2, n + i * 2 + 1, 1);\n          }\n  \n  \n          for (int i = 0 ; i < n ; i++) {\n              for (int j = i+1 ; j < n ; j++) {\n                  for (int wi : wset[i]) {\n                      if (wset[j].contains(wi)) {\n                          flow.edge(i, n + wi * 2, INF1);\n                          flow.edge(n + wi * 2 + 1, j, INF1);\n                          flow.edge(j, n + wi * 2, INF1);\n                          flow.edge(n + wi * 2 + 1, i, INF1);\n                      }\n                  }\n              }\n          }\n          return flow.max_flow(source, sink) - I\u200cNF2 * n;\n      }\n  \n  \n  \n      static class MaxFlowDinic {\n          public class Edge {\n              int to;\n              int cap;\n              int rev;\n              public Edge(int _to, int _cap, int _rev) {\n                  to = _to;\n                  cap = _cap;\n                  rev = _rev;\n              }\n          }\n          public Map<Integer, List<Edge>> graph = new HashMap<Integer, List<Edge>>();\n          public int[] level;\n          public int[] itr;\n          public void init(int size) {\n              for (int i = 0 ; i < size ; i++) {\n                  graph.put(i, new ArrayList<Edge>());\n              }\n              level = new int[size];\n              itr = new int[size];\n          }\n          public void edge(int from, int to, int cap) {\n              graph.get(from).add(new Edge(to, cap, graph.get(to).size()));\n              graph.get(to).add(new Edge(from, 0, graph.get(from).size() - 1));\n          }\n          public int dfs(int v, int t, int f) {\n              if (v == t) return f;\n              for (int i = itr[v] ; i < graph.get(v).size() ; i++) {\n                  itr[v] = i;\n                  Edge e = graph.get(v).get(i);\n                  if (e.cap > 0 && level[v] < level[e.to]) {\n                      int d = dfs(e.to, t, Math.min(f, e.cap));\n                      if (d > 0) {\n                          e.cap -= d;\n                          graph.get(e.to).get(e.rev).cap += d;\n                          return d;\n                      }\n                  }\n              }\n              return 0;\n          }\n  \n          public void bfs(int s) {\n              Arrays.fill(level, -1);\n              Queue<Integer> q = new ArrayBlockingQueue<Integer>(graph.size()+10);\n              level[s] = 0;\n              q.add(s);\n              while (q.size() >= 1) {\n                  int v = q.poll();\n                  for (int i = 0; i < graph.get(v).size() ; i++) {\n                      Edge e = graph.get(v).get(i);\n                      if (e.cap > 0 && level[e.to] < 0) {\n                          level[e.to] = level[v] + 1;\n                          q.add(e.to);\n                      }\n                  }\n              }\n          }\n  \n          public int max_flow(int s, int t) {\n              int flow = 0;\n              while (true) {\n                  bfs(s);\n                  if (level[t] < 0) {\n                      return flow;\n                  }\n                  Arrays.fill(itr, 0);\n                  while (true) {\n                      int f = dfs(s, t, Integer.MAX_VALUE);\n                      if (f <= 0) {\n                          break;\n                      }\n                      flow += f;\n                  }\n              }\n          }\n      }\n  \n      static void debug(Object... o) {\n          System.err.println(Arrays.deepToString(o));\n      }\n  }\n  \n  \n  \n", "substitutes": {"INF1": ["INV1", "InV1", "INV2", "InF2", "INF2", "InF1", "InV2"], "i": ["c", "I", "l", "ii"], "t": ["kt", "c", "T"], "cs": ["c"], "n": ["not", "c", "p", "N"], "sen": ["en", "se", "su"], "wordToInt": ["wordToFloat", "WordToInt", "Word2Int", "lettertoString", "wordWithFloat", "word2Short", " wordFromFloat", " wordWithInt", "wordFromFloat", "letterToString", " wordWithFloat", "wordtoString", " wordFromInt", "wordWithInt", "lettertoInt", "wordToShort", " wordToFloat", "wordtoInt", "Word2Short", "word2Int", "letterToInt", "wordFromInt", "wordToString", "WordToShort"], "s": ["su", "S", "string"], "word": ["letter"], "wset": ["wSet", " wSet"], "size": ["length"], "e": ["pe", "ee", "es"], "o": ["os"]}}
{"code": " \n  public class logging {\n    private static InputReader in;\n    private static PrintWriter out;\n    public static boolean SUBMIT = true;\n    public static final String NAME = \"C-small-attempt3\";\n    \n    static class Point implements Comparable<Point> {\n      public long x, y;\n      public int i\u200ddx;\n      public double angle;\n      \n      public Point (long x, long y) {\n        this.x = x;\n        this.y = y;\n      }\n      \n      public Point (long x, long y, int i\u200ddx) {\n        this.x = x;\n        this.y = y;\n        this.i\u200ddx = i\u200ddx;\n      }\n      \n      public int compareTo(Point other) {\n        return (int)Math.signum(angle - other.angle);\n      }\n      \n      public String toString() {\n        return x+\" \"+y;\n      }\n    }\n    \n    public static long cross(Point p, Point q, Point r) {\n      return (r.y - p.y) * (q.x - p.x) - (q.y - p.y) * (r.x - p.x);\n    }\n    \n    public static long dist (Point a, Point b) {\n      return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    }\n  \n    private static void main2() throws IOException {\n      int N = in.nextInt();\n      Point[] p = new Point[N];\n      Point[] pc = new Point[2*N];\n      for (int i = 0; i < N; i++) {\n        int x = in.nextInt(), y = in.nextInt();\n        pc[i] = new Point(x, y, i);\n        pc[i+N] = new Point(x, y, i);\n        p[i] = new Point(x, y);\n      }\n      \n      int[] s\u200been = new int[N];\n      double[] p\u200crev = new double[N];\n      int gen = 0;\n      for (int i = 0; i < N; i++) {\n        ++gen;\n        for (int j = 0; j < 2 * N; j++) {\n          if (pc[j].i\u200ddx == i) pc[j].angle = 1 << 29;\n          else {\n            if (s\u200been[pc[j].i\u200ddx] == gen) {\n              pc[j].angle = p\u200crev[pc[j].i\u200ddx] + 2 * Math.PI;\n            } else {\n              s\u200been[pc[j].i\u200ddx]= gen; \n              p\u200crev[pc[j].i\u200ddx] = pc[j].angle = Math.atan2(pc[j].y-p[i].y,pc[j].x-p[i].x); \n            }\n          }\n        }\n        Arrays.sort(pc);\n        \n        int t2 = 0;\n        int min = N-1;\n        for (int t\u200d1 = 0; t\u200d1 < N-1; t\u200d1++) {\n          t2 = Math.max(t2, t\u200d1);\n          while (t2+1 < t\u200d1+N-1 && cross(pc[t\u200d1], p[i], pc[t2+1]) < 0) {t2++;}\n          min = Math.min(t2 - t\u200d1, min);\n        }\n        \n        out.println(min);\n      }\n    }\n  \n    public static void main(String[] args) throws IOException {\n      if (SUBMIT) {\n        in = new InputReader(new FileInputStream(new File(NAME + \".in\")));\n        out = new PrintWriter(new BufferedWriter(new FileWriter(NAME + \".out\")));\n      } else {\n        in = new InputReader(System.in);\n        out = new PrintWriter(System.out, true);\n      }\n  \n      int n\u200cumCases = in.nextInt();\n      for (int test = 1; test <= n\u200cumCases; test++) {\n        out.println(\"Case #\" + test + \":\");\n        main2();\n      }\n  \n      out.close();\n      System.exit(0);\n    }\n  \n    static class InputReader {\n      public BufferedReader reader;\n      public StringTokenizer tokenizer;\n  \n      public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n      }\n  \n      public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n          try {\n            tokenizer = new StringTokenizer(reader.readLine());\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n        return tokenizer.nextToken();\n      }\n  \n      public int nextInt() {\n        return Integer.parseInt(next());\n      }\n    }\n  }\n", "substitutes": {"in": ["ins"], "out": ["Out"], "NAME": ["Name"], "x": ["X"], "y": ["Y", "vy"], "angle": ["angles"], "i": ["si", "I", "ip"], "p": ["c", "P"], "q": ["Q"], "a": ["A"], "pc": ["PC"], "SUBMIT": [" SUBmit", " SubMIT", "Submit", " Submit", "SubMIT", "SUBmit"]}}
{"code": "package year2015.round3;\n  \n  \n  public class RunawayQuail {\n      \n      public static void main(String[] args) throws Exception {\n          Locale.setDefault(Locale.ENGLISH);\n          File i\u200dnputFile = new File(\"C-small-attempt0.in\");\n          Scanner in = new Scanner(i\u200dnputFile);\n          File o\u200butputFile = new File(\"output.txt\");\n          PrintWriter o\u200but = new PrintWriter(o\u200butputFile);\n  \n          int T = in.nextInt();\n          for (int t=0; t<T; t++) {\n              System.err.println(t);\n              double Y = in.nextDouble();\n              int N = in.nextInt();\n              Bird[] birds = new Bird[N];\n              int leftCount = 0;\n              int rightCount = 0;\n              for (int n=0; n<N; n++) {\n                  Bird bird = new Bird();\n                  bird.position = in.nextDouble();\n                  if (bird.position > 0) {\n                      rightCount++;\n                  } else {\n                      leftCount++;\n                  }\n                  birds[n] = bird;\n              }\n              for (Bird bird : birds) {\n                  bird.s\u200bpeed = in.nextDouble();\n              }\n              Bird[] leftBirds = new Bird[leftCount];\n              Bird[] rightBirds = new Bird[rightCount];\n              leftCount = 0;\n              rightCount = 0;\n              for (Bird bird : birds) {\n                  if (bird.position > 0) {\n                      rightBirds[rightCount++] = bird;\n                  } else {\n                      leftBirds[leftCount++] = bird;\n                  }\n              }\n              double minTime = Double.MAX_VALUE;\n              int limit = 1 << N;\n              for (int mask=0; mask<limit; mask++) { \n                  if (Integer.bitCount(mask) != rightCount) continue;\n                  double position = 0;\n                  double time = 0;\n                  for (int n=0; n<N; n++) {\n                      double nextTime = Double.MAX_VALUE;\n                      Bird nextBird = null;\n                      if ((mask&(1<<n)) == 0) {\n                          \n                          for (Bird bird : leftBirds) {\n                              if (bird.caught != mask) {\n                                  double tt = (position-bird.position+Y*time)/(Y-bird.s\u200bpeed);\n                                  if (tt < nextTime) {\n                                      nextTime = tt;\n                                      nextBird = bird;\n                                  }\n                              }\n                          }\n                          position -= (nextTime-time)*Y;\n                      } else {\n                          \n                          for (Bird bird : rightBirds) {\n                              if (bird.caught != mask) {\n                                  double tt = (bird.position-position+Y*time)/(Y-bird.s\u200bpeed);\n                                  if (tt < nextTime) {\n                                      nextTime = tt;\n                                      nextBird = bird;\n                                  }\n                              }\n                          }\n                          position += (nextTime-time)*Y;\n                      }\n                      nextBird.caught = mask;\n                      time = nextTime;\n                  }\n                  minTime = Math.min(minTime, time);\n              }\n              \n              o\u200but.println(\"Case #\"+(t+1)+\": \"+minTime);\n          }\n  \n          o\u200but.close();\n      }\n  \n      static class Bird {\n          double position;\n          double s\u200bpeed;\n          int caught = -1;\n      }\n      \n  }\n", "substitutes": {"in": ["In", "IN"], "Y": ["X", "y"], "leftCount": ["leftSize", " leftSize", " leftDepth", "rightSize", "leftDepth"], "rightCount": [" rightSize", "rightcount", "leftSize", "rightSize", " rightcount", "leftCast", "rightCast"], "position": ["pos", "Position", "location"], "leftBirds": ["leftChirds", "leftPlards", "rightBards", "rightWirds", "rightChards", "leftChards", "rightPlards", "leftWards", "rightWards", "leftPlirds", "rightChirds", "rightPlirds", "leftBards", "leftWirds"], "rightBirds": ["leftChirds", "rightChants", " rightChants", "rightBards", "rightChards", "leftChards", "rightBants", " rightBants", "rightChirds", "leftBards", " rightChirds"], "minTime": ["mintime", "nexttime"], "mask": ["ask"], "nextTime": ["nextTimes", " nextTimes"], "nextBird": ["prevBird", "prevbird", "nextbird"], "caught": ["Caught", "Catched", "catched"], "tt": ["TT"]}}
{"code": " \n  public class RevengeOfThePancakes {\n     static class P {\n         String s;\n         int c\u200bost;\n  \n         public P(String ss, int c) {\n             s = ss;\n             c\u200bost = c;\n         }\n     }\n  \n     public static void main(String[] args) {\n         InputReader r = new InputReader(System.in);\n         int T = r.nextInt();\n         int test = 1;\n         while (test <= T) {\n             String s = r.next();\n             String end = \"\";\n             while (end.length() < s.length())\n                 end += \"+\";\n             LinkedList<P> q = new LinkedList<P>();\n             HashSet<String> vis = new HashSet<String>();\n             q.add(new P(s, 0));\n             vis.add(s);\n             int res = -1;\n             while (!q.isEmpty()) {\n                 P front = q.remove();\n                 if (front.s.compareTo(end) == 0) {\n                     res = front.c\u200bost;\n                     break;\n                 }\n                 for (int i = 1; i <= s.length(); i++) {\n                     String n = \"\";\n                     for (int j = 0; j < i; j++) {\n                         if (front.s.charAt(j) == '-')\n                             n += \"+\";\n                         else\n                             n += \"-\";\n                     }\n                     for (int j = i; j < s.length(); j++)\n                         n += front.s.charAt(j);\n                     if (!vis.contains(n)) {\n                         vis.add(n);\n                         q.add(new P(n, front.c\u200bost + 1));\n                     }\n                 }\n             }\n             System.out.printf(\"Case #%d: %s\n\", test, res);\n             test++;\n         }\n     }\n  \n     static class InputReader {\n         private BufferedReader r\u200deader;\n         private StringTokenizer tokenizer;\n  \n         public InputReader(InputStream stream) {\n             r\u200deader = new BufferedReader(new InputStreamReader(stream));\n             tokenizer = null;\n         }\n  \n         public InputReader(FileReader stream) {\n             r\u200deader = new BufferedReader(stream);\n             tokenizer = null;\n         }\n  \n         public String nextLine() {\n             try {\n                 return r\u200deader.readLine();\n             } catch (IOException e) {\n                 \n                 e.printStackTrace();\n                 return null;\n             }\n         }\n  \n         public String next() {\n             while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                 try {\n                     tokenizer = new StringTokenizer(r\u200deader.readLine());\n                 } catch (IOException e) {\n                     throw new RuntimeException(e);\n                 }\n             }\n             return tokenizer.nextToken();\n         }\n  \n         public int nextInt() {\n             return Integer.parseInt(next());\n         }\n  \n         public long nextLong() {\n             return Long.parseLong(next());\n         }\n  \n         public double nextDouble() {\n             return Double.parseDouble(next());\n         }\n     }\n  }\n", "substitutes": {"s": ["strings"], "ss": ["css"], "c": ["C"], "r": ["R"], "T": ["M"], "test": ["testing"], "end": ["ended"], "q": ["Q"], "vis": ["Vis"], "res": ["Res", "results"], "tokenizer": [" tokenization", "tokenization", "tokenize", " tokenize"], "stream": ["ream"]}}
{"code": " \n  \n  public class ProbA {\n  public static void main(String[] args)\n  {\n     Scanner sc= new Scanner(System.in);\n     int numcases = sc.nextInt();\n     for(int curcase = 1;curcase <=numcases;curcase++)\n     {\n         int N = sc.nextInt();\n         System.out.println(\"Case #\"+curcase+\": \"+compute(N));\n     }\n  }\n  public static int compute(int N)\n  {\n     String s = Integer.toString(N);\n     if(s.length()==1)\n         return N;\n  \n     String fh = s.substring(0, s.length()/2);\n     String sh = s.substring(s.length()/2, s.length());\n     int powten = 1;\n     int halfpowten =1;\n  \n     for(int i=0;i<s.length()-1;i++)\n     {\n         powten*=10;\n         if(i<fh.length()-1)\n             halfpowten*=10;\n     }\n     int numsaid = compute(powten-1);\n     numsaid++;\n     \n     if(Integer.parseInt(fh)!=halfpowten)\n     {\n     if(Integer.parseInt(sh)!=0)\n     {\n     int stepone = Integer.parseInt((new StringBuilder(fh)).reverse().toString());\n     numsaid+=stepone;\n     numsaid++;\n     numsaid+=Integer.parseInt(sh)-1;\n     }else{\n         numsaid++;\n         numsaid+= Integer.parseInt((new StringBuilder(fh)).reverse().toString());\n         numsaid++;\n     }\n     }else{\n         numsaid+=Integer.parseInt(sh);\n     }\n     return numsaid;\n     \n  }\n  }\n", "substitutes": {"sc": ["Sc"], "numcases": ["numlines", "umcases", "numcase", "ncase", "ncases", "umlines"], "curcase": [" curCase", "curCase"], "N": ["n"], "s": ["b", "h"], "fh": ["fph", " fph", " fhr", " fq", " fsh", "fq", "fsh", "fhr"], "sh": ["h"], "powten": [" pewteen", "pOWTen", "powTen", "pew10", " powTen", " pow10", " pewten", " pew10", "pewteen", "pOWten", " powteen", " pOWten", " pOWTen", "pow10", "powteen", "pewten"], "halfpowten": ["halffOWTen", " halfpOWten", "Halfpow10", "halfpowTen", " halffowten", "Halfcowten", "Halfpew10", " halfpOWTen", "halfpewten", "Halfpewten", "halffowten", "halfpOWten", "Halfcewten", "Halfpowten", " halffOWten", "halfcewten", " halffowTen", " halfpowTen", "halffowTen", " halffOWTen", "halfpow10", "halfcowten", "Halfcew10", "halfcow10", "Halfcow10", "halfcew10", "halffOWten", "halfpOWTen", "halfpew10"], "numsaid": [" numpsad", " numad", "numaid", "Numpsaid", "numsaic", " numaid", "numad", " numaic", " numsad", " numsaic", "Numpsad", "numsad", "numpsad", "numaic", "Numsad", "Numsaid", "numpsaid", " numpsaid"], "stepone": ["step1", " step1"]}}
{"code": " \n  \n  public class B_BF {\n  \n     static boolean verb=true;\n     static void log(Object X){if (verb) System.err.println(X);}\n     static void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n     static void log(int[] X){if (verb) {for (int U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n     static void logWln(Object X){if (verb) System.err.print(X);}\n     static void info(Object o){ System.out.println(o);}\n     static void output(Object o){outputWln(\"\"+o+\"\n\");  }\n     static void outputWln(Object o){try {out.write(\"\"+ o);} catch (Exception e) {}}\n  \n     static int N,P;\n     static int[] R;\n     static int[][] Q;\n  \n     static class Edge{\n         int c;\n         int f;\n         int dest;\n         int org;\n  \n         public String toString(){\n             return (\"<\"+org+\",\"+dest+\"> \"+f+\"/\"+c);\n         }\n     }\n  \n  \n  \n  \n     static void addEdge(Node[] graph,int org,int dest,int c){\n         \n         Edge e=new Edge();\n         e.dest=dest;\n         e.org=org;\n         e.c=c;\n         e.f=0;\n         graph[org].outEdges.add(e);\n         graph[dest].inEdges.add(e);\n     }\n  \n  \n     static class Node implements Comparable<Node>{\n         int c;\n         ArrayList<Edge> outEdges;\n         ArrayList<Edge> inEdges;\n         int d\u200cist;\n         int minToHere;\n         int index;\n         int prev;\n         boolean rev;\n         Edge u\u200bsedEdge;\n  \n         \n         int ing;\n         int q;\n         int quant;\n  \n  \n         Node(int index){\n             outEdges=new ArrayList<Edge>();\n             inEdges=new ArrayList<Edge>();\n             d\u200cist=Integer.MAX_VALUE;\n             this.index=index;\n         }\n  \n         public int compareTo(Node X){\n             return this.c-X.c;\n         }\n  \n         public String toString(){\n             return ing+\" \"+q+\" \"+quant;\n         }\n     }\n  \n     static int computeMaxFlow(Node[] graph){\n         int G=graph.length;\n         int flow=0;\n  \n         int c=findAugmentingPath(graph);\n         while (c!=Integer.MAX_VALUE-1){\n  \n             flow+=c;\n             int x=G-1;\n             \n             \n             while (x!=0) {\n                 \n                 int y=graph[x].prev;\n                 Edge e=graph[x].u\u200bsedEdge;\n  \n                 if (graph[x].rev){\n                     e.f-=c;\n                 } else\n                     e.f+=c;\n                 \n                 \n                 x=y;\n             }\n             \n             c=findAugmentingPath(graph);\n         }\n  \n  \n         return flow;\n     }\n  \n     static int findAugmentingPath(Node[] graph){\n         PriorityQueue<Node> p\u200cq=new PriorityQueue<Node>();\n         int G=graph.length;\n         for (int i=1;i<G;i++) {\n             graph[i].d\u200cist=Integer.MAX_VALUE-1;\n             graph[i].minToHere=Integer.MAX_VALUE-1;\n         }\n         graph[0].d\u200cist=0;\n         p\u200cq.add(graph[0]);\n         graph[0].minToHere=Integer.MAX_VALUE-1;\n         while (p\u200cq.size()>0){\n             Node X=p\u200cq.poll();\n             if (X.index==G-1) {\n                 \n                 return X.minToHere;\n             }\n             Iterator<Edge> i\u200bt=X.outEdges.iterator();\n             while (i\u200bt.hasNext()){\n                 Edge e=i\u200bt.next();\n                 int cf=e.c-e.f;\n                 if (cf>0) {\n                     Node Y=graph[e.dest];\n                     if (Y.d\u200cist>X.d\u200cist+1) {\n                         Y.d\u200cist=X.d\u200cist+1;\n                         Y.minToHere=Math.min(cf,X.minToHere);\n                         \n                         Y.prev=X.index;\n                         Y.rev=false;\n                         Y.u\u200bsedEdge=e;\n                         p\u200cq.add(Y);\n                     }\n                 }\n             }\n             i\u200bt=X.inEdges.iterator();\n             while (i\u200bt.hasNext()){\n                 Edge e=i\u200bt.next();\n                 int cf=e.f;\n                 if (cf>0) {\n                     Node Y=graph[e.org];\n                     if (Y.d\u200cist>X.d\u200cist+1) {\n                         Y.d\u200cist=X.d\u200cist+1;\n                         Y.minToHere=Math.min(cf,X.minToHere);\n                         \n                         Y.prev=X.index;\n                         Y.rev=true;\n                         Y.u\u200bsedEdge=e;\n                         p\u200cq.add(Y);\n                     }\n                 }\n             }\n         }\n         return graph[G-1].minToHere;\n     }\n  \n     static int solve(){\n  \n         ArrayList<Node> lst=new ArrayList<Node>();\n  \n         ArrayList<Node>[][] ing=new ArrayList[N][P];\n  \n         ArrayList<Integer>[][] others=new ArrayList[N][P];\n         int[][] ref=new int[N][P];\n  \n  \n         Node source=new Node(0);\n         lst.add(source);\n  \n  \n         int idx=1;\n  \n         \n         for (int i=0;i<N;i++) \n             for (int j=0;j<P;j++){\n                 \n                 \n                 others[i][j]=new ArrayList<Integer>();\n                 ref[i][j]=idx;\n                 Node X=new Node(idx++);\n                 lst.add(X);\n  \n                 ing[i][j]=new ArrayList<Node>();\n  \n                 \n                 \n                 \n                 log(Q[i][j]+\" \"+R[i]);\n                 int vmin=(100*Q[i][j])/(R[i]*110);\n                 if (vmin*R[i]*110!=Q[i][j]*100)\n                     vmin++;\n  \n                 int vmax=(100*Q[i][j])/(R[i]*90);\n                 log(\"vmin:\"+vmin+\" vmax:\"+vmax+\" \"+(vmax-vmin));\n  \n                 \n  \n                 \n             }\n  \n  \n         Node end=new Node(idx++);\n         lst.add(end);\n  \n         Node[] graph=new Node[lst.size()];\n         for (int i=0;i<lst.size();i++)\n             graph[i]=lst.get(i);\n  \n  \n         for (int i=0;i<N;i++)\n             for (int j=0;j<P;j++){\n                 int src=ref[i][j];\n                 if (i==0){\n                     addEdge(graph,0,src,1);\n                 } \n  \n                 for (int dst:others[i][j]) {\n                     addEdge(graph,src,dst,1);\n                     if (i==N-1){\n                         addEdge(graph,dst,graph.length-1,1);\n                     }\n                 }\n             }\n         for (int i=0;i+1<N;i++)\n             for (int a=i+1;a<N;a++)\n                 for (int j=0;j<P;j++)\n                     for (int b=0;b<P;b++){\n                         for (Node X:ing[i][j])\n                             for (Node Y:ing[a][b]){\n                                 if (X.quant==Y.quant){\n                                     \n                                     addEdge(graph,X.index,Y.index,1);\n                                 }\n                             }\n  \n                     }\n  \n         int count=computeMaxFlow(graph);\n         return count;\n     }\n  \n  \n     static int allocate(int u,ArrayList<Integer>[] compat,boolean[] visited,int[] target,int[] anc){\n         for (int v:compat[u]){\n             if (!visited[v]){\n                 visited[v]=true;\n                 if (anc[v]==-1){\n                     anc[v]=u;\n                     target[u]=v;\n                     return v;\n                 }\n                 else {\n                     int y=anc[v];\n                     int w=allocate(y,compat,visited,target,anc);\n                     if (w>=0){\n                         anc[v]=u;\n                         target[u]=v;\n                         return v;\n                     }\n                 }\n             }\n         }\n         return -1;\n     }\n  \n     static int solveBidon(){\n  \n         int cnt=0;\n         for (int j=0;j<P;j++) {\n  \n             int vmin=(100*Q[0][j])/(R[0]*110);\n             if (vmin*R[0]*110!=Q[0][j]*100)\n                 vmin++;\n             int vmax=(100*Q[0][j])/(R[0]*90);\n             if (vmin<=vmax)\n                 cnt++;\n  \n  \n         }\n         return cnt;\n     }\n  \n     \n             static int solveSmall(){\n  \n                 if (N==1)\n                     return solveBidon();\n  \n                 int[] anc=new int[P];\n                 int[] target=new int[P];\n                 Arrays.fill(target,-1);\n                 Arrays.fill(anc,-1);\n  \n  \n                 ArrayList<Integer>[] compat=new ArrayList[P];\n                 for (int j=0;j<P;j++)\n                     compat[j]=new ArrayList<Integer>();\n                 for (int j=0;j<P;j++)\n                     for (int k=0;k<P;k++){\n  \n                         int vmin=(100*Q[0][j])/(R[0]*110);\n                         if (vmin*R[0]*110!=Q[0][j]*100)\n                             vmin++;\n                         int vmax=(100*Q[0][j])/(R[0]*90);\n  \n  \n                         int zmin=(100*Q[1][k])/(R[1]*110);\n                         if (zmin*R[1]*110!=Q[1][k]*100)\n                             zmin++;\n                         int zmax=(100*Q[1][k])/(R[1]*90);\n                         if (!(vmin>zmax || zmin>vmax)){\n                             if (vmin<=vmax && zmin<=zmax)\n                             compat[j].add(k);\n                         }\n                     }\n  \n                 int cnt=0;\n                 for (int u=0;u<P;u++){\n                     boolean[] visited=new boolean[P];\n                     if (allocate(u,compat,visited,target,anc)!=-1) {\n                         cnt++; \n                     }\n                 }\n                 return cnt;\n             }\n  \n  \n             \n             static BufferedWriter out;\n  \n             static void process() throws Exception {\n                 Locale.setDefault(Locale.US);\n  \n  \n                 File inputFile=new File(\"B.in\");\n                 PrintWriter outputFile= new PrintWriter(\"B.out\",\"UTF-8\");\n                 Scanner sc=new Scanner(inputFile);\n                 sc.useLocale(Locale.US);\n  \n                 \n  \n                 \n  \n                 int T=sc.nextInt();\n                 for (int t=1;t<=T;t++){\n  \n                     N=sc.nextInt();\n                     P=sc.nextInt();\n                     R=new int[N];\n                     Q=new int[N][P];\n                     for (int i=0;i<N;i++)\n                         R[i]=sc.nextInt();\n                     for (int i=0;i<N;i++)\n                         for (int j=0;j<P;j++)\n                             Q[i][j]=sc.nextInt();\n  \n                     String ss=\"\"+solveSmall();\n  \n                     System.out.println(\"Case #\"+t+\": \"+ss);\n                     outputFile.println(\"Case #\"+t+\": \"+ss);\n  \n  \n                 }\n  \n  \n  \n                 sc.close();\n                 outputFile.close();\n  \n  \n             }\n  \n  \n  \n             public static void main(String[] args) throws Exception {\n  \n  \n                 process();\n  \n  \n             }\n  \n  \n  \n  \n  \n  \n  }\n", "substitutes": {"X": ["F"], "verb": ["beta"], "U": ["O"], "o": ["O"], "Q": ["F"], "c": ["p", "C"], "dest": ["Dest"], "org": ["gov"], "e": ["ee"], "outEdges": ["alledge", "allEdge", "outputedges", "outputEdgments", "alledges", "outEdgments", "OutEdges", "Outedgments", "outedges", "outedge", "outputedgments", "outedgments", "allEdges", "Outedges", "outputEdges", "OutEdgments", "outEdge"], "inEdges": ["inEdwards", "InIndges", "inedgments", "incEdgments", "incedgments", "INEdwards", "inEdgers", "inedwards", "inEdgments", "INedwards", "InEdges", "InEdgers", "InIndgers", "inIndgers", "incedges", "inedges", "INEdges", "incEdges", "INedges", "inIndges"], "minToHere": ["MinToMax", "minToMax", "minFromMax", "MinFromMax", "minFromHere", "MinFromHere", "MinToHere"], "rev": ["reverse"], "out": ["in"]}}
{"code": "package codejam2015;\n  \n  \n  public class ProbB {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         int numcases = sc.nextInt();\n         for(int cas  = 1;cas <= numcases;cas++ )\n         {\n             System.out.print(\"Case #\"+cas+\": \");\n         \n         int numdiners = sc.nextInt();\n         int[] plates = new int[numdiners + numdiners*1000+1];\n         for(int i=0;i<numdiners;i++)\n         {\n             plates[i] =sc.nextInt();\n         }\n         Arrays.sort(plates);\n         int bestnum = plates[numdiners + numdiners*1000];\n         for(int i=1;i<=bestnum;i++)\n         {\n             plates[0] = (plates[numdiners+numdiners*1000])/2;\n             plates[1] = (plates[numdiners+numdiners*1000]+1)/2;\n             plates[numdiners+numdiners*1000] = 0;\n             Arrays.sort(plates);\n             if(i + plates[numdiners+numdiners*1000]<bestnum)\n             {\n                 bestnum = plates[numdiners+numdiners*1000]+i;\n             \n         }\n         }\n         System.out.println(bestnum);\n         }\n     }\n  }\n", "substitutes": {"sc": ["SC", "Sc"], "numcases": ["ncases", "ntests", "numtests"], "cas": ["Cas", "uc"], "numdiners": ["hamdaughters", "numDaughters", "numDiner", "umfaughters", "numlaughters", "umDers", "numDiners", "umDiners", "umders", "maxDiner", "numliners", "numtiner", "numfaughters", "commonDiners", "maxdiner", "sumdiners", "numdiner", "corediners", "maxdiners", "coretiners", "numders", "hamtaughters", "updiners", "numfiners", "hamtiners", "maxtiners", "umdaughters", "numtaughters", "numdaughters", "coredaughters", "sumlaughters", "sumdaughters", "sumfiners", "maxDaughters", "homdiners", "maxtiner", "maxDiners", "numdighters", "commonDaughters", "numDers", "umdiners", "sumliners", "commondaughters", "commondiners", "hamdiners", "coretaughters", "updaughters", "sumfaughters", "numtiners", "homdighters", "umfiners", "maxdaughters"], "plates": ["files", "planes", "pl", "plate", "balls"], "i": ["I", "li"], "bestnum": ["bestn", " bestNum", "bestnumber", " bestnumber", "bestNum", " bestn"]}}
{"code": " \n  public class B {\n     FastScanner i\u200bn;\n     PrintWriter out;\n  \n     int[] sum, min, m\u200cax;\n     int n, k, s\u200dz;\n  \n     boolean can(int v, int dist) {\n         int f\u200crom = min[v], to = min[v] + dist;\n         long sumLeft = 0, sumRight = 0;\n         for (int i = 0; i < k; i++) {\n             int smallAdd = f\u200crom - min[i];\n             int maxAdd = to - m\u200cax[i];\n             if (maxAdd < smallAdd) {\n                 return false;\n             }\n             sumLeft += smallAdd;\n             sumRight += maxAdd;\n         }\n         int n\u200beed = sum[0];\n         long curFrom = n\u200beed - sumRight, c\u200curTo = n\u200beed - sumLeft;\n         if (curFrom <= 0 && c\u200curTo >= 0) {\n             return true;\n         }\n         if (curFrom < 0) {\n             long tmp = -curFrom;\n             curFrom = -c\u200curTo;\n             c\u200curTo = tmp;\n         }\n         return c\u200curTo / k * k >= curFrom;\n     }\n  \n     void solve() {\n         int tc = i\u200bn.nextInt();\n         for (int t = 0; t < tc; t++) {\n             out.print(\"Case #\" + (t + 1) + \": \");\n             n = i\u200bn.nextInt();\n             k = i\u200bn.nextInt();\n             s\u200dz = n - k + 1;\n             sum = new int[s\u200dz];\n             for (int i = 0; i < s\u200dz; i++) {\n                 sum[i] = i\u200bn.nextInt();\n             }\n             m\u200cax = new int[k];\n             min = new int[k];\n             for (int i = 0; i < k; i++) {\n                 int cur = 0;\n                 for (int j = k + i; j < n; j += k) {\n                     cur -= sum[j - k];\n                     cur += sum[j - k + 1];\n                     m\u200cax[i] = Math.m\u200cax(m\u200cax[i], cur);\n                     min[i] = Math.min(min[i], cur);\n                 }\n             }\n             int right = (int) 1e9;\n             for (int i = 0; i < k; i++) {\n                 if (!can(i, right)) {\n                     continue;\n                 }\n                 int left = -1;\n                 while (right - left > 1) {\n                     int mid = (left + right) >>> 1;\n                     if (can(i, mid)) {\n                         right = mid;\n                     } else {\n                         left = mid;\n                     }\n                 }\n             }\n             out.println(right);\n             System.err.println((t + 1) + \"/\" + tc + \" done\");\n         }\n     }\n  \n     void run() {\n         try {\n             i\u200bn = new FastScanner(new File(\"B.i\u200bn\"));\n             out = new PrintWriter(new File(\"B.out\"));\n  \n             solve();\n  \n             out.close();\n         } catch (FileNotFoundException e) {\n             e.printStackTrace();\n         }\n     }\n  \n     void runIO() {\n         i\u200bn = new FastScanner(System.i\u200bn);\n         out = new PrintWriter(System.out);\n  \n         solve();\n  \n         out.close();\n     }\n  \n     class FastScanner {\n         BufferedReader br;\n         StringTokenizer st;\n  \n         public FastScanner(File f) {\n             try {\n                 br = new BufferedReader(new FileReader(f));\n             } catch (FileNotFoundException e) {\n                 e.printStackTrace();\n             }\n         }\n  \n         public FastScanner(InputStream f) {\n             br = new BufferedReader(new InputStreamReader(f));\n         }\n  \n         String next() {\n             while (st == null || !st.hasMoreTokens()) {\n                 String s = null;\n                 try {\n                     s = br.readLine();\n                 } catch (IOException e) {\n                     e.printStackTrace();\n                 }\n                 if (s == null)\n                     return null;\n                 st = new StringTokenizer(s);\n             }\n             return st.nextToken();\n         }\n  \n         boolean hasMoreTokens() {\n             while (st == null || !st.hasMoreTokens()) {\n                 String s = null;\n                 try {\n                     s = br.readLine();\n                 } catch (IOException e) {\n                     e.printStackTrace();\n                 }\n                 if (s == null)\n                     return false;\n                 st = new StringTokenizer(s);\n             }\n             return true;\n         }\n  \n         int nextInt() {\n             return Integer.parseInt(next());\n         }\n  \n         long nextLong() {\n             return Long.parseLong(next());\n         }\n  \n         double nextDouble() {\n             return Double.parseDouble(next());\n         }\n     }\n  \n     public static void main(String[] args) {\n         new B().run();\n     }\n  }\n", "substitutes": {"i": ["p"], "sum": ["Sum"], "min": ["Min"], "n": ["c", "p", "ne", "N"], "k": ["c", "q", "K"], "s": ["ss", "ps", "S"], "v": ["V"], "dist": ["d"], "sumLeft": ["sumL", " sumL"], "smallAdd": [" smallAdds", "smalladd", "smallAdds", "maxadd"], "maxAdd": [" maxSize", "minMix", " maxadd", "minAdd", "maxMix", "maxSize", "maxadd"], "curFrom": ["curfrom", "surFrom", " curTo", " curfrom", "surfrom", "curTo"], "tc": ["TC"], "t": ["p", "T"], "m": ["d", "M", "p"], "e": ["E", "ee"], "f": ["F"]}}
{"code": " \n  public class ProbCSmall {\n     public static void main(String[] args) {\n         Scanner sc = new Scanner(System.in);\n         int numcases = sc.nextInt();\n         for(int curcase = 1; curcase<=numcases; curcase++)\n         {\n             int N = sc.nextInt();\n             sc.nextLine();\n             HashMap<String,HashSet<Integer>> linehas = new HashMap<String,HashSet<Integer>>();\n             List<HashSet<String>> eng = new ArrayList<HashSet<String>>();\n             List<HashSet<String>> fr = new ArrayList<HashSet<String>>();\n             String engs = sc.nextLine();\n             String[] engss = engs.split(\" \");\n             String frs = sc.nextLine();\n             String[] frss = frs.split(\" \");\n             eng.add(new HashSet<String>());\n             for(String s : engss)\n             {\n                 eng.get(0).add(s);\n                 linehas.put(s, new HashSet<Integer>());\n             }\n             fr.add(new HashSet<String>());\n             for(String s : frss)\n             {\n                 fr.get(0).add(s);\n                 linehas.put(s, new HashSet<Integer>());\n             }\n             if(N>2)\n             {\n             List<HashSet<String>> extra = new ArrayList<HashSet<String>>();\n             for(int i=0;i<N-2;i++)\n             {\n                 String line = sc.nextLine();\n                 extra.add(new HashSet<String>());\n                 for(String s : line.split(\" \"))\n                 {\n                     extra.get(i).add(s);\n                     if(linehas.keySet().contains(s))\n                     linehas.get(s).add(i);\n                     else\n                     {\n                         linehas.put(s, new HashSet<Integer>());\n                         linehas.get(s).add(i);\n                     }\n                 }\n             }\n             globalmin = Integer.MAX_VALUE;\n             System.out.println(\"Case #\"+curcase+\": \"+tryall(eng,fr,extra));\n  \n             }else{\n                 eng.get(0).retainAll(fr.get(0));\n                 System.out.println(\"Case #\"+curcase+\": \"+eng.get(0).size());\n             }\n  \n         }\n     }\n     public static int globalmin;\n         public static int tryall(List<HashSet<String>> en, List<HashSet<String>> fr, List<HashSet<String>> yet)\n         {\n             if(yet.size()==0)\n             {\n                 return count(en,fr);\n             }else\n             {\n                 if(count(en,fr)>globalmin)\n                     return Integer.MAX_VALUE;\n                 HashSet<String> h = yet.remove(yet.size()-1);\n                 en.add(h);\n                 int one = tryall(en,fr,yet);\n                 en.remove(en.size()-1);\n                 fr.add(h);\n                 int two = tryall(en,fr,yet);\n                 fr.remove(fr.size()-1);\n                 yet.add(h);\n                 if (globalmin >Math.min(one, two))\n                 globalmin = Math.min(one, two);\n                 return Math.min(one, two);\n             }\n         }\n     public static int count(List<HashSet<String>> en, List<HashSet<String>> fr)\n     {\n         HashSet<String> english = collect(en);\n         HashSet<String> french = collect(fr);       \n         english.retainAll(french);\n         return english.size();\n     }\n     public static HashSet<String> collect(List<HashSet<String>> en)\n     {\n         HashSet<String> ret = new HashSet<String>();\n         for( HashSet<String> h : en)\n         {\n             for( String s : h)\n                 ret.add(s);\n         }\n         return ret;\n     }\n  }\n", "substitutes": {"sc": ["SC", "Sc"], "numcases": ["numlines", "numcase", "normlines", "ncase", "normcases", "ncases"], "curcase": ["CurCase", "curCase", "curcases", "Curcase", " curcases", " curCase"], "N": ["n"], "linehas": ["linHas", "nehas", "neHas", "linhas", "Linehas", "lineHas", "LineHas", " lineops", " lineHas", "Lineops", "lineops"], "eng": ["ENG", "enc"], "fr": ["Fr"], "engs": ["efns", "ENGss", "efs", "engns", "ENGs"], "engss": ["ewss", "engrs", "engds", "ewds", "ewrs"], "frs": ["sfrs", "fros", "Frs", "fras", "Fras", "sfros"], "frss": ["forers", "frrss", "foress", "frrs", "Frss", "Frrss"], "s": ["f", "p"], "line": ["lin"], "globalmin": ["finalmin", "finalMin", "globalMin"]}}
{"code": "package Qualification;\n  \n  \n  public class ProbA {\n  public static void main(String[] args)\n  {\n     Scanner sc = new Scanner(System.in);\n     long t = sc.nextLong();\n     sc.nextLine();\n     for(int curcase=1;curcase<=t;curcase++)\n     {\n         System.out.println(\"Case #\"+curcase+\": \"+check(sc.nextLine()));\n     }\n     \n  }\n  public static String check(String a)\n  {\n     for(int i=0;i<a.length()-1;i++)\n     {\n         if(a.charAt(i)>a.charAt(i+1))\n         {\n             String s = a.substring(0,i)+Character.toString((char) (a.charAt(i)-1));\n             if (s.charAt(0)=='0')\n             s=\"\";\n             for (int j=a.length()-1;j>i;j--)\n             {\n                 s+=\"9\";\n             }\n             return check(s);\n         }\n     }\n     return a;\n  }\n  \n  }\n", "substitutes": {"sc": ["Sc"], "t": ["T"], "curcase": ["curase", "curCase", " curCase", " curase"], "a": ["b"], "i": ["I"]}}
{"code": " \n  public class C {\n     FastScanner i\u200dn = new FastScanner(System.i\u200dn);\n     PrintWriter out = new PrintWriter(System.out);\n  \n     BigInteger convert(long x, int base) {\n         String s = Long.toBinaryString(x);\n         BigInteger bbase = new BigInteger(String.valueOf(base));\n         BigInteger res = BigInteger.ZERO;\n         for (int i = 0, p = s.length() - 1; i < s.length(); i++, p--) {\n             if (s.charAt(i) != '0') {\n                 res = res.add(bbase.pow(p));\n             }\n         }\n         return res;\n     }\n     \n     int[] calc(long x) {\n         final int MAX = 1000;\n         int[] res = new int[11];\n         for (int base = 2; base <= 10; base++) {\n             BigInteger b = convert(x, base);\n             for (int i = 2; i <= MAX; i++) {\n                 BigInteger div = new BigInteger(Integer.toString(i));\n                 if (b.mod(div).intValue() == 0) {\n                     res[base] = i;\n                     break;\n                 } else if (i == MAX) {\n                     return null;\n                 }\n             }\n         }\n         return res;\n     }\n     \n     public void run() {\n         int T = i\u200dn.nextInt();\n         for (int caseN = 1; caseN <= T; caseN++) {\n             int N = i\u200dn.nextInt();\n             int J = i\u200dn.nextInt();\n             \n             ArrayList<String> res = new ArrayList<String>();\n             \n             for (long i = (1L << (N-1)) + 1; i < (1L << N); i += 2) {\n                 int[] divs = calc(i);\n                 if (divs == null) continue;\n                 \n                 String n\u200dext = Long.toBinaryString(i) + \" \";\n                 for (int j = 2; j <= 10; j++) {\n                     n\u200dext += divs[j];\n                     if (j != 10) n\u200dext += \" \";\n                 }\n                 res.add(n\u200dext);\n                 if (res.size() == J) break;\n             }\n             \n             if (res.size() != J) {\n                 throw new RuntimeException();\n             }\n             out.println(\"Case #\" + caseN + \": \");\n             for (String s : res)\n                 out.println(s);\n         }\n         out.close();\n     }\n  \n     public static void main(String[] args) {\n         new C().run();\n     }\n  \n     public void mapDebug(int[][] a) {\n         System.out.println(\"--------map display---------\");\n  \n         for (int i = 0; i < a.length; i++) {\n             for (int j = 0; j < a[i].length; j++) {\n                 System.out.printf(\"%3d \", a[i][j]);\n             }\n             System.out.println();\n         }\n  \n         System.out.println(\"----------------------------\");\n         System.out.println();\n     }\n  \n     public void debug(Object... obj) {\n         System.out.println(Arrays.deepToString(obj));\n     }\n  \n     class FastScanner {\n         private InputStream s\u200dtream;\n         private byte[] b\u200cuf = new byte[1024];\n         private int curChar;\n         private int n\u200dumChars;\n  \n         public FastScanner(InputStream s\u200dtream) {\n             this.s\u200dtream = s\u200dtream;\n             \n  \n         }\n  \n         int read() {\n             if (n\u200dumChars == -1)\n                 throw new InputMismatchException();\n             if (curChar >= n\u200dumChars) {\n                 curChar = 0;\n                 try {\n                     n\u200dumChars = s\u200dtream.read(b\u200cuf);\n                 } catch (IOException e) {\n                     throw new InputMismatchException();\n                 }\n                 if (n\u200dumChars <= 0)\n                     return -1;\n             }\n             return b\u200cuf[curChar++];\n         }\n  \n         boolean isSpaceChar(int c) {\n             return c == ' ' || c == '\n' || c == '\\r' || c == '\\t' || c == -1;\n         }\n  \n         boolean isEndline(int c) {\n             return c == '\n' || c == '\\r' || c == -1;\n         }\n  \n         int nextInt() {\n             return Integer.parseInt(n\u200dext());\n         }\n  \n         int[] n\u200dextIntArray(int n) {\n             int[] array = new int[n];\n             for (int i = 0; i < n; i++)\n                 array[i] = nextInt();\n  \n             return array;\n         }\n  \n         int[][] nextIntMap(int n, int m) {\n             int[][] map = new int[n][m];\n             for (int i = 0; i < n; i++) {\n                 map[i] = i\u200dn.n\u200dextIntArray(m);\n             }\n             return map;\n         }\n  \n         long nextLong() {\n             return Long.parseLong(n\u200dext());\n         }\n  \n         long[] nextLongArray(int n) {\n             long[] array = new long[n];\n             for (int i = 0; i < n; i++)\n                 array[i] = nextLong();\n  \n             return array;\n         }\n  \n         long[][] nextLongMap(int n, int m) {\n             long[][] map = new long[n][m];\n             for (int i = 0; i < n; i++) {\n                 map[i] = i\u200dn.nextLongArray(m);\n             }\n             return map;\n         }\n  \n         double nextDouble() {\n             return Double.parseDouble(n\u200dext());\n         }\n  \n         double[] nextDoubleArray(int n) {\n             double[] array = new double[n];\n             for (int i = 0; i < n; i++)\n                 array[i] = nextDouble();\n  \n             return array;\n         }\n  \n         double[][] nextDoubleMap(int n, int m) {\n             double[][] map = new double[n][m];\n             for (int i = 0; i < n; i++) {\n                 map[i] = i\u200dn.nextDoubleArray(m);\n             }\n             return map;\n         }\n  \n         String n\u200dext() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             StringBuilder res = new StringBuilder();\n             do {\n                 res.appendCodePoint(c);\n                 c = read();\n             } while (!isSpaceChar(c));\n             return res.toString();\n         }\n  \n         String[] nextStringArray(int n) {\n             String[] array = new String[n];\n             for (int i = 0; i < n; i++)\n                 array[i] = n\u200dext();\n  \n             return array;\n         }\n  \n         String nextLine() {\n             int c = read();\n             while (isEndline(c))\n                 c = read();\n             StringBuilder res = new StringBuilder();\n             do {\n                 res.appendCodePoint(c);\n                 c = read();\n             } while (!isEndline(c));\n             return res.toString();\n         }\n     }\n  }\n  \n", "substitutes": {"i": ["I", "pi"], "out": ["OUT", "Out"], "x": ["X"], "base": ["Base"], "bbase": ["Bbase", "bbas", "bbbase", "bbbas"], "res": ["rs", "results", "Res"], "MAX": ["Max", "max"], "div": ["DIV", "division"], "caseN": ["Casen", "CaseN", "caseC", " caseC", "casen"], "divs": [" dives", "divn", "Divn", "dives", "Divs"]}}
{"code": "package abtric.utility;\n  \n  \n  public class Writer {\n     public static void write(String file, String[] content) {\n         try {\n             FileWriter writer = new FileWriter(file);\n             for (int i = 0; i < content.length; i++) {\n                 writer.write(\"Case #\" + (i + 1) + \": \" + content[i] + \"\n\");\n             }\n             writer.close();\n             System.out.println(\"---> DONE <---\");\n         } catch (IOException e) {\n             e.printStackTrace();\n         }\n     }\n  }\n", "substitutes": {"file": ["File"], "content": ["Content"], "writer": ["reader", "write"]}}
{"code": "public class TestCase {\n  \n     int[] a\u200cudienceCase;\n     int maxShyness;\n     int audienceSize;\n     int s\u200btanding;\n     int friends;\n     \n     public TestCase (String l\u200dine) {\n         maxShyness = Integer.parseInt(l\u200dine.substring(0,1));\n         makeAudience(maxShyness, l\u200dine);\n     }\n     \n     private void makeAudience(int a, String s) {\n         audienceSize=0;\n         a\u200cudienceCase = new int[a+1];\n         \n         \n         for (int i = 0; i < a+1; i++){\n             int n\u200bum = Integer.parseInt(s.substring(i+2,i+3));\n             audienceSize += n\u200bum;\n             a\u200cudienceCase[i] = n\u200bum;\n         }\n     }\n  \n     public int evaluateCase() {\n         s\u200btanding = 0;\n         friends = 0;\n         for (int i = 0; s\u200btanding < audienceSize; i++){\n             \n             if (s\u200btanding >= i){\n                 s\u200btanding+= a\u200cudienceCase[i];\n             }\n             \n             else{\n                 while (s\u200btanding < i){\n                     addFriend();\n                 }\n                 s\u200btanding+=a\u200cudienceCase[i];\n             }\n             \n         }\n         \n         return friends;\n     }\n  \n     private void addFriend() {\n         friends++;\n         audienceSize++;\n         s\u200btanding++;\n     }\n  \n  }\n", "substitutes": {"maxShyness": ["axShYity", "maxPhyness", " maxSheyhing", "maxSchYness", " maxPhyhing", " maxSheyity", "maxSchYity", "maxPhyhing", "axSchYness", "axShyity", "maxShYity", " maxShyhing", "axSchYity", "maxShyhing", "maxPhyity", "maxSheyhing", " maxPheyness", "maxSheyity", "maxSchyity", "axShYness", "maxPheyhing", "maxShyity", "maxSheyness", " maxPhyness", "maxShYness", "maxPheyity", " maxPhyity", " maxSheyness", "maxPheyness", "axSchyness", "axShyness", "axSchyity", " maxShyity", " maxPheyity", "maxSchyness", " maxPheyhing"], "audienceSize": ["auienceLength", "auienceSize", "AudienceTime", "audiencesSize", "audianceSize", "AudanceSize", "audueLength", "AudiencesTime", "audianceLength", "auueSize", "attianceLength", "audanceSize", "audueSize", "AudiencesSize", "AudienceSize", "attienceSize", "audienceTime", "attienceLength", "audiencesTime", "attianceSize", "auueLength", "audienceLength"], "friends": ["friend", "Friends"], "a": ["A"], "s": ["ss", "is", "g", "S"], "i": ["ci", "si"]}}
{"code": " \n  public class rankandfile {\n    private static InputReader in;\n    private static PrintWriter out;\n    public static boolean SUBMIT = true;\n    public static final String N\u200bAME = \"B-small-attempt1\";\n    \n    static class List implements Comparable<List> {\n      public int[] x;\n      public List(int[] x) {\n        this.x = x;\n      }\n      public int compareTo(List o\u200dther) {\n        for (int i = 0; i < x.length; i++) {\n          if (x[i] != o\u200dther.x[i])\n            return x[i] - o\u200dther.x[i];\n        }\n        return 0;\n      }\n    }\n  \n    private static void main2() throws IOException {\n      int n = in.n\u200cextInt();\n      int m = 2*n-1;\n      int[] f\u200breq = new int[2501];\n      for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n          f\u200breq[in.n\u200cextInt()]++;\n        }\n      }\n      int[] ans = new int[n];\n      int i\u200bdx = 0;\n      for (int j = 0; j <= 2500; j++) {\n        if (f\u200breq[j] % 2 == 1)\n          ans[i\u200bdx++] = j;\n      }\n      out.print(ans[0]);\n      for (int i = 1; i < n; i++) out.print(\" \"+ans[i]);\n      out.println();\n    }\n  \n    public static void main(String[] args) throws IOException {\n      if (SUBMIT) {\n        in = new InputReader(new FileInputStream(new File(N\u200bAME + \".in\")));\n        out = new PrintWriter(new BufferedWriter(new FileWriter(N\u200bAME + \".out\")));\n      } else {\n        in = new InputReader(System.in);\n        out = new PrintWriter(System.out, true);\n      }\n  \n      int numCases = in.n\u200cextInt();\n      for (int test = 1; test <= numCases; test++) {\n        out.print(\"Case #\" + test + \": \");\n        main2();\n      }\n  \n      out.close();\n      System.exit(0);\n    }\n  \n    static class InputReader {\n      public BufferedReader reader;\n      public StringTokenizer tokenizer;\n  \n      public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n      }\n  \n      public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n          try {\n            tokenizer = new StringTokenizer(reader.readLine());\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n        return tokenizer.nextToken();\n      }\n  \n      public int n\u200cextInt() {\n        return Integer.parseInt(next());\n      }\n    }\n  }\n", "substitutes": {"in": ["ins", "input", "In", "IN"], "out": ["Out"], "x": ["X", "list"], "i": ["I"], "n": ["N"], "m": ["M"], "ans": ["an", "ANS"], "SUBMIT": ["SUBITT", "ISSUBITT", "ISSubITT", "SubITT", " SubITT", " SubMIT", "SubMIT", " SUBITT", "ISSUBMIT", "ISSubMIT"], "numCases": ["numChases", " numChases", "numChased", " numCased", "numCased", "nCased", "nCases", "numScases", "numScased", "nScased", "nScases", " numChased"]}}
{"code": "package googlecodejam2015;\n  \n  \n  \n  public class GoogleCodeJam2015 {\n      \n    private static final Class<? extends Problem> q\u200duestionClass = Round1CA.class;\n    private static final String q\u200duestionName = q\u200duestionClass.getSimpleName();\n    private static final String inputName = \"small\";\n  \n    public static void main(String[] args) {\n      String filePath = \"data\" + File.separator + q\u200duestionName + File.separator + inputName;\n        try (\n          BufferedReader i\u200dnput = new BufferedReader(new FileReader(filePath + \".in\"));\n          BufferedWriter output = new BufferedWriter(new FileWriter(filePath + \".out\"));\n        ) {\n          int numTests = Integer.parseInt(i\u200dnput.readLine());\n          for(int i=0; i<numTests; ++i){\n            Problem p\u200droblem = q\u200duestionClass.newInstance();\n            p\u200droblem.setup(i\u200dnput);\n            p\u200droblem.solve();\n            \n            StringBuilder solutionBuilder = new StringBuilder();\n            solutionBuilder.append(\"Case #\").append(i + 1).append(\": \");\n            solutionBuilder.append(p\u200droblem.getSolution());\n            solutionBuilder.append(System.lineSeparator());\n            String solution = solutionBuilder.toString();\n            \n            output.write(solution);\n            System.out.print(solution);\n          }\n        } catch (IOException | InstantiationException | IllegalAccessException ex) {\n          Logger.getLogger(GoogleCodeJam2015.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n    \n    interface Problem {\n      public void setup(BufferedReader i\u200dnput) throws IOException;\n      public void solve();\n      public String getSolution();\n    }\n    \n  }\n", "substitutes": {"inputName": [" inputPath", "inputPath"], "filePath": ["fileName", "filepath", " filepath", "FilePath", "FileName"], "numTests": ["numbertcases", "numTcases", "numNests", "numberTcases", "nbNests", "nbNasks", "numtcases", "numtests", "nbTasks", "numbertests", "numNasks", "nbTests", "numTasks", "numberTests"], "i": ["I"], "solutionBuilder": ["solutionBuild", "solverBuilder", "solverReader", "polveBuffer", "solverBuild", "polveBuilder", "solveBuffer", "ssolveBuilder", "polutionBuffer", "polverBuild", "solutionReader", "polverBuilder", "solutionBuffer", "polutionBuild", "solveBuilder", "polutionReader", "polverReader", "polutionBuilder", "ssolutionBuilder", "ssolutionBuffer", "ssolveBuffer"], "solution": ["polver", "asolution", " solving", "solving", "asolver", "polution", "solver"]}}
{"code": " public class DStupidMultithreaded {\n     static BufferedReader br;\n     static StringTokenizer st;\n     static PrintWriter p\u200dw;\n     static Semaphore processorSemaphore = new Semaphore(Runtime.getRuntime().availableProcessors());\n     static Semaphore i\u200bnputSemaphore = new Semaphore(1);\n     static Semaphore o\u200cutputSemaphore = new Semaphore(0);\n     static String[] output;\n     public static void main(String[] args) throws Exception {\n         br = new BufferedReader(new InputStreamReader(System.in));\n         p\u200dw = new PrintWriter(new BufferedWriter(new FileWriter(\"d.o\u200but\")));\n         final int MAX_CASES = readInt();\n         output = new String[MAX_CASES];\n         for(int casenum = 1; casenum <= MAX_CASES; casenum++) {\n             processorSemaphore.acquire();\n             i\u200bnputSemaphore.acquire();\n             new WorkThread(casenum).start();\n         }\n         for(int casenum = 1; casenum <= MAX_CASES; casenum++) {\n             o\u200cutputSemaphore.acquire();\n         }\n         for(String o\u200but: output) {\n             p\u200dw.println(o\u200but);\n         }\n         p\u200dw.close();\n     }\n  \n     static class WorkThread extends Thread {\n         public int casenum;\n         public int numRows,n\u200dumCols;\n         public WorkThread(int casenum) {\n             super();\n             this.casenum = casenum;\n  \n         }\n         public void run() {\n  \n             numRows = readInt();\n             n\u200dumCols = readInt();\n             h\u200cashes = new HashSet<Long>();\n             \n             i\u200bnputSemaphore.release();\n  \n             output[casenum-1] = \"Case #\" + casenum + \": \" + solve();\n  \n             \n  \n  \n  \n             o\u200cutputSemaphore.release();\n             processorSemaphore.release();\n         }\n         Set<Long> h\u200cashes;\n         public int solve() {\n             return dfs(new int[numRows][n\u200dumCols], 0);\n         }\n         public long hash(int[][] g\u200drid, int shiftC) {\n             final long RMOD = 80974743864643L;\n             final long CMOD = 88494744610229L;\n             long ret = 0;\n             for(int i = 0; i < g\u200drid.length; i++) {\n                 long colHash = 0;\n                 for(int j = 0; j < g\u200drid[i].length; j++) {\n                     int shiftJ = (j+shiftC) % n\u200dumCols;\n                     colHash *= 3137;\n                     colHash += g\u200drid[i][shiftJ];\n                     colHash %= CMOD;\n                 }\n                 ret *= 101;\n                 ret += colHash;\n                 ret %= RMOD;\n             }\n             return ret;\n         }\n         public int dfs(int[][] g\u200drid, int r) {\n             if(r == g\u200drid.length) {\n                 if(!valid(g\u200drid)) return 0;\n                 long hash = hash(g\u200drid, 0);\n                 if(h\u200cashes.contains(hash)) return 0;\n                 for(int a = 0; a < n\u200dumCols; a++) h\u200cashes.add(hash(g\u200drid, a));\n                 return 1;\n             }\n             if(r-2 >= 0 && !validate(g\u200drid, r-2)) return 0;\n             int ret = 0;\n             int scale = 1;\n             for(int a = 0; a < n\u200dumCols; a++) scale *= 3;\n             for(int mask = 0; mask < scale; mask++) {\n                 int temp = mask;\n                 for(int i = 0; i < n\u200dumCols; i++) {\n                     g\u200drid[r][i] = (temp%3)+1;\n                     temp /= 3;\n                 }\n                 ret += dfs(g\u200drid, r+1);\n             }\n             return ret;\n         }\n         int[] dx = new int[]{-1,1,0,0};\n         int[] dy = new int[]{0,0,-1,1};\n         public int get(int[][] g\u200drid, int r, int c) {\n             if(r < 0 || r >= g\u200drid.length || c < 0 || c >= g\u200drid[r].length) return -1;\n             return g\u200drid[r][c];\n         }\n  \n         public void deepPrint(int[][] g\u200drid) {\n             for(int[] o\u200but: g\u200drid) {\n                 p\u200dw.println(Arrays.toString(o\u200but));\n             }\n             p\u200dw.println();\n         }\n  \n         public boolean valid(int[][] g\u200drid, int i, int j) {\n             int seen = 0;\n             for(int k = 0; k < dx.length; k++) {\n                 if(get(g\u200drid, i+dx[k], (j+dy[k]+n\u200dumCols)%n\u200dumCols) == g\u200drid[i][j]) seen++;\n             }\n             if(g\u200drid[i][j] != seen) return false;\n             return true;\n         }\n  \n         public boolean validate(int[][] g\u200drid, int i) {\n             for(int j = 0; j < g\u200drid[i].length; j++) {\n                 if(!valid(g\u200drid, i, j)) return false;\n             }\n             return true;\n         }\n  \n         public boolean valid(int[][] g\u200drid) {\n             for(int i = 0; i < g\u200drid.length; i++) {\n                 for(int j = 0; j < g\u200drid[i].length; j++) {\n                     if(!valid(g\u200drid, i, j)) return false;\n                 }\n             }\n             return true;\n         }\n     }\n  \n     public static int readInt() {\n         return Integer.parseInt(nextToken());\n     }\n  \n     public static long readLong() {\n         return Long.parseLong(nextToken());\n     }\n  \n     public static double readDouble() {\n         return Double.parseDouble(nextToken());\n     }\n  \n     public static String nextToken() {\n         while(st == null || !st.hasMoreTokens())    {\n             try {\n                 if(!br.ready()) {\n                     p\u200dw.close();\n                     System.exit(0);\n                 }\n                 st = new StringTokenizer(br.readLine());\n             }\n             catch(IOException e) {\n                 System.err.println(e);\n                 System.exit(1);\n             }\n         }\n         return st.nextToken();\n     }\n  \n     public static String readLine() {\n         st = null;\n         try {\n             return br.readLine();\n         }\n         catch(IOException e) {\n             System.err.println(e);\n             System.exit(1);\n             return null;\n         }\n     }\n  \n  }\n", "substitutes": {"br": ["BR"], "st": ["St"], "p": ["pp"], "processorSemaphore": ["processorMutipour", "workerSemaphour", " processorSemaphores", "workerMutipore", "processorSemaphores", "processorMutipore", "processorMutafores", "workerSemipore", "masterSemphore", "processorSemaphour", "masterMemphore", "processorSemafore", "workerSemipour", " processorMutaphore", "processorMutaphore", "processorMutafore", "processorMemphort", "processorSemphore", "workerMutipour", "processorSemipour", "processorSemipore", "masterSemaphore", "processorMemphore", "processorMutaphores", "processorSemafores", "processorMemaphort", "processorSemaphort", " processorSemafore", "masterMemaphort", " processorMutafore", " processorSemafores", "masterMemphort", "processorMutaphour", "masterSemaphort", " processorMutafores", "processorSemphort", "processorMemaphore", "workerMutaphore", "workerSemaphore", "workerMutaphour", "masterMemaphore", "masterSemphort", " processorMutaphores"], "MAX_CASES": [" MAX_CACes", " MAX_SCATes", " MAX_SCACes", "MAX_SCATes", "MAX_SCACES", " MAX_CATES", " MAX_CACES", "MAX_CATes", "MAX_CATES", "MAX_CACes", "MAX_CASes", "MAX_SCATES", "MAX_SCASes", "MAX_SCASES", " MAX_SCACES", "MAX_CACES", " MAX_SCASes", " MAX_SCATES", " MAX_CASes", "MAX_SCACes", " MAX_SCASES", " MAX_CATes"], "casenum": ["catum", "casum", "casumption", "casumber", "casalogue", "Casenum", " casumber", "catenum", "caseng", " casumption", "Casum", " caseng", " casalogue", " casum", "casnum", " casnum"], "numRows": [" numRrows", " numROWS", "numLOWS", "numRrows", "numLows", "numROWS", " numLOWS", " numLows"], "e": ["E", "n", "ee"]}}
{"code": "package Round1B;\n  \n  \n  public class ProblemB {\n     public static void main(String[] args) throws FileNotFoundException\n     {\n         Scanner sc = new Scanner(new FileInputStream(\"B-small-attempt2.in\"));\n     \n         PrintStream out = new PrintStream(new FileOutputStream(\"out1.txt\"));\n         long t = sc.nextLong();\n         sc.nextLine();\n         LOOP2:\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             int N =sc.nextInt();\n             int[] ROYGBV = new int[6];\n             for(int i=0;i<6;i++)\n             {\n                 ROYGBV[i] = sc.nextInt();\n             }\n             int[] RYB = new int[3];\n             if((ROYGBV[0]==ROYGBV[3])&&(ROYGBV[0]+ROYGBV[3]==N))\n             {\n                 out.print(\"Case #\"+curcase+\": \");\n                 for(int i=0;i<ROYGBV[0];i++)\n                 {\n                     out.print(\"RG\");\n                 }\n                 out.println();\n                 continue LOOP2;\n             }\n             if((ROYGBV[0]-1 < ROYGBV[3])&&(ROYGBV[3]>0))\n             {\n             out.println(\"Case #\"+curcase+\": IMPOSSIBLE\");\n             continue LOOP2;\n             }\n             if((ROYGBV[2]==ROYGBV[5])&&(ROYGBV[2]+ROYGBV[5]==N))\n             {\n                 out.print(\"Case #\"+curcase+\": \");\n                 for(int i=0;i<ROYGBV[2];i++)\n                 {\n                     out.print(\"YV\");\n                 }\n                 out.println();\n                 continue LOOP2;\n             }\n             if((ROYGBV[2]-1 < ROYGBV[5])&&(ROYGBV[5]>0))\n             {\n             out.println(\"Case #\"+curcase+\": IMPOSSIBLE\");\n             continue LOOP2;\n             }\n             if((ROYGBV[4]==ROYGBV[1])&&(ROYGBV[4]+ROYGBV[1]==N))\n             {\n                 out.print(\"Case #\"+curcase+\": \");\n                 for(int i=0;i<ROYGBV[4];i++)\n                 {\n                     out.print(\"BO\");\n                 }\n                 out.println();\n                 continue LOOP2;\n             }\n             if((ROYGBV[4]-1 < ROYGBV[1])&&(ROYGBV[1]>0))\n             {\n             out.println(\"Case #\"+curcase+\": IMPOSSIBLE\");\n             continue LOOP2;\n             }\n             RYB[0] = ROYGBV[0]-ROYGBV[3];\n             RYB[1] = ROYGBV[2]-ROYGBV[5];\n             RYB[2] = ROYGBV[4]-ROYGBV[1];\n             char[] prims=  {'R','Y','B'};\n             char[] comps=  {'G','V','O'};\n             boolean[] notfirstdone = new boolean[3];\n             char[] assignment = new char[N];\n                 \n             LOOP:\n             for(int i=0;i<N;){\n                 \n                 int[] order = ord(RYB);\n                 if(i==0){\n                 for(int j=2;j>=0;j--)\n                 {\n                     if(RYB[order[j]]>0)\n                     {\n                     assignment[0] = prims[order[j]];\n                     i++;\n                     RYB[order[j]]--;\n                     continue LOOP;\n                     }\n                 }\n                 }\n                 for(int j=0;j<3;j++)\n                 {\n                     assert(RYB[0]+RYB[1]+RYB[2]==6);\n                 if((RYB[order[j]]>0)&&(assignment[(N+i-1)%N]!=prims[order[j]])&&(assignment[(N+i+1)%N]!=prims[order[j]]))\n                 {\n                     assignment[i] = prims[order[j]];\n                     RYB[order[j]]--;\n                     i++;\n                     if(!notfirstdone[order[j]])\n                     {\n                         for(int k=0;k<ROYGBV[(order[j]*2+3)%6];k+=2)\n                         {\n                             assignment[i+k] = comps[order[j]];\n                             assignment[i+k+1]= prims[order[j]];\n                         }\n                         i+=2*ROYGBV[(order[j]*2+3)%6];\n                         notfirstdone[order[j]]=true;\n                     }\n                     continue LOOP;\n                 }\n                 }\n                 if(i==N)\n                     break LOOP;\n                 System.out.println(curcase+\"failed on \"+ROYGBV[0]+\" \"+ROYGBV[2]+\" \"+ROYGBV[4]);\n                 if(curcase==98){\n                     System.out.println(new String(assignment));\n                     System.out.println(RYB[0]+\" \"+RYB[1]+\" \"+RYB[2]);\n                 }\n                 out.println(\"Case #\"+curcase+\": IMPOSSIBLE\");\n                 continue LOOP2;\n             }\n             assert(RYB[0] == 0);\n             assert(RYB[1] == 0);\n             assert(RYB[2] == 0);\n             out.println(\"Case #\"+curcase+\": \"+new String(assignment));\n         }\n         \n     }\n     public static boolean tryassign(int n,int[] RYB,int[] assignment)\n     {\n         System.out.println(n);\n         if((n>1)&&(assignment[n-1]==assignment[n]))\n             return false;\n         if(n==assignment.length-1)\n         {\n             if(assignment[0]!=assignment[n])\n             return true;\n             else\n             return false;\n         }\n         for(int j=0;j<3;j++)\n         {\n             if(RYB[j]>0)\n             {\n             assignment[n] = j;\n             RYB[j]--;\n             if(tryassign(n+1,RYB,assignment))\n             {\n                 return true;\n             }\n             RYB[j]++;\n             }\n         }\n         return false;\n     }\n     \n     public static int[] ord(int[] RYB)\n     {\n         int[] order = new int[3];\n         if(RYB[0]>=Math.max(RYB[1],RYB[2]))\n         {\n             order[0] = 0;\n             if(RYB[1]>=RYB[2])\n             {\n                 order[1] = 1;\n                 order[2] = 2;\n             }else\n             {\n                 order[1] = 2;\n                 order[2] = 1;\n             }\n             return order;\n         }\n         if(RYB[1]>=Math.max(RYB[0],RYB[2]))\n         {\n             order[0] = 1;\n             if(RYB[0]>=RYB[2])\n             {\n                 order[1] = 0;\n                 order[2] = 2;\n             }else\n             {\n                 order[1] = 2;\n                 order[2] = 0;\n             }\n             return order;\n         }\n         if(RYB[2]>=Math.max(RYB[1],RYB[0]))\n         {\n             order[0] = 2;\n             if(RYB[1]>=RYB[0])\n             {\n                 order[1] = 1;\n                 order[2] = 0;\n             }else\n             {\n                 order[1] = 0;\n                 order[2] = 1;\n             }\n         }\n         return order;\n     }\n  }\n", "substitutes": {"sc": ["Sc"], "out": ["OUT", "Out"], "t": ["T"], "curcase": ["curce", "curCase", " curce", " curCase"], "ROYGBV": ["ROYGPL", "OYYGCL", "ROYGEv", " ROYAGEv", "ROYGv", "OYGCV", " ROYAGP", " ROYGBL", "OYYGBL", "OYINGGBv", "OYINGGBV", "ROYYGCL", "ROYGCL", "GOYGBV", "ROYYGBv", " ROyGPV", "ROyGBF", " ROyLDV", "GOYAGBv", "ROyGPL", "ROyGBv", "ROYGCV", " ROYAGBP", " ROYGP", "GOYGEV", "POyGBv", " ROYAGV", "ROYINGLDV", "GOYAGEV", "POyGPV", "POYGPV", "GOYAGV", " ROYGBM", "ROYGEV", " ROYGEV", "ROYLDV", " ROYGPV", "OYYGBv", " ROyLDF", "ROYINGGBV", " ROYGEv", "GOYGv", "ROYAGBv", " ROYGBF", "ROYGBF", "POyGPv", "ROYINGLDv", "ROYAGBV", "ROyGPv", "ROYAGEv", "ROyGPV", " ROyGBV", "OYINGLDv", " ROyGPL", "POYINGGBv", "POYINGGPV", "ROYINGGPv", "OYGBL", "POYGBv", "ROYAGBM", " ROyGBL", "GOYGBv", "ROYGBM", "ROyLDF", "GOYGV", "OYLDv", "ROyLDV", "ROYAGV", "OYYGBV", "POYINGGBV", "POYGPv", " ROYAGBM", "ROYYGCV", " ROYGBP", "ROYGPV", "ROYGBP", "ROYAGEV", "POYGBV", "GOYAGv", " ROYLDV", "ROYYLDV", "ROYLDv", "OYYLDV", "POYINGGPv", " ROYAGBv", " ROYGBv", "POyGBV", " ROYAGBV", "ROyGBV", "GOYAGBV", "OYGCL", "OYYLDv", "ROYGBv", "ROYLDF", "ROYGP", "ROYYGBL", "ROYINGGBv", " ROYGV", " ROYLDF", "GOYAGEv", "ROYGV", "OYGBV", "OYINGLDV", "ROYYLDv", "ROYAGBP", "OYLDV", "ROYAGv", "ROYAGP", " ROYGM", "ROYYGBV", "ROYGPv", "OYGBv", "OYYGCV", " ROYGPL", "GOYGEv", "ROYGM", " ROYAGEV", "ROyGBL", "ROYAGM", "ROYINGGPV", "ROYGBL", " ROyGBF", " ROYAGM"], "RYB": ["RYBB", "RIB", "RIBB"]}}
{"code": " \n  public class B {\n     String compute(int[] c) {\n         int N = c[0],\n         R = c[1],\n         O = c[2],\n         Y = c[3],\n         G = c[4],\n         B = c[5],\n         V = c[6];\n         if (R > Y + B ||\n             Y > R + B ||\n             B > R + Y) return \"IMPOSSIBLE\";\n         char[] v = new char[N];\n         char last;\n         if (R >= Y && R >= B) {\n             last = v[0] = 'R';\n             R--;\n         } else if (Y >= R && Y >= B) {\n             last = v[0] = 'Y';\n             Y--;\n         } else {\n             last = v[0] = 'B';\n             B--;\n         }\n         for (int i = 1 ; i < N ; i++) {\n             if (last == 'R') {\n                 if (Y >= B) {\n                     last = v[i] = 'Y';\n                     Y--;\n                 } else {\n                     last = v[i] = 'B';\n                     B--;\n                 }\n             } else if (last == 'Y') {\n                 if (R >= B) {\n                     last = v[i] = 'R';\n                     R--;\n                 } else {\n                     last = v[i] = 'B';\n                     B--;\n                 }\n             } else {\n                 if (R >= Y) {\n                     last = v[i] = 'R';\n                     R--;\n                 } else {\n                     last = v[i] = 'Y';\n                     Y--;\n                 }\n             }\n         }\n         if (v[0] == v[N-1]) {\n             char T = v[N-1];\n             v[N-1] = v[N-2];\n             v[N-2] = T;\n         }\n         return new String(v);\n     }\n  \n     void run(String[] args) {\n         try {\n             BufferedReader i\u200dn = new BufferedReader(new FileReader(args[0]));\n             PrintStream out = new PrintStream(args[0] + \".out\");\n             int T = Integer.parseInt(i\u200dn.readLine());\n             for (int t = 1 ; t <= T ; t++) {\n                 int[] c = Arrays.stream(i\u200dn.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n                 out.printf(\"Case #%d: %s\n\", t, compute(c));\n             }\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n     }\n  \n     public static void main(String[] args) {\n         new B().run(args);\n     }\n  }\n", "substitutes": {"c": ["C", "f", "e"], "N": ["n"], "R": ["r"], "Y": ["X"], "G": ["M"], "B": ["b"], "v": ["f", "sv", "u", "b"], "last": ["Last"], "i": ["ii", "I"]}}
{"code": " \n  \n  \n  public class Pancakes {\n     String PROBLEM_ID = \"problemB\";\n  \n     enum TestType {\n         EXAMPLE, SMALL, LARGE\n     }\n  \n  \n      TestType TYPE = TestType.SMALL;\n  \n  \n     public String getFileName() {\n         String r\u200cesult = PROBLEM_ID + \"_\";\n         switch (TYPE) {\n         case EXAMPLE:\n             r\u200cesult += \"example\";\n             break;\n         case SMALL:\n             r\u200cesult += \"small\";\n             break;\n         case LARGE:\n             r\u200cesult += \"large\";\n             break;\n         }\n         return r\u200cesult;\n     }\n  \n     public String getInFileName() {\n         return getFileName() + \".in\";\n     }\n  \n     public String getOutFileName() {\n         return getFileName() + \".o\u200cut\";\n     }\n  \n     public static void main(String[] args) throws Exception {\n         new Pancakes();\n     }\n  \n     public Pancakes() throws Exception {\n         BufferedReader in = new BufferedReader(new FileReader(getInFileName()));\n         PrintWriter o\u200cut = new PrintWriter(new BufferedWriter(new FileWriter(\n                 getOutFileName())));\n         Scanner scan = new Scanner(in);\n         for ( int[] a: memo) Arrays.fill(a, -1);\n         int tests = scan.nextInt();\n         for (int t\u200best = 0; t\u200best < tests; t\u200best++) {\n             int[] c\u200bount = new int[1001];\n             int d = scan.nextInt();\n             int[] diners = new int[d];\n             for ( int i = 0; i < d; i++) diners[i] = scan.nextInt();\n             Arrays.sort(diners);\n             \n             int result1 = method1(diners);\n             int result2 = method2(diners);\n             int r\u200cesult = min(result1, result2);\n             String resultStr = String.format(\"Case #%d: %d\", t\u200best + 1, r\u200cesult);\n             \n  \n             System.o\u200cut.println(resultStr);\n             o\u200cut.println(resultStr);\n         }\n         o\u200cut.close();\n         System.o\u200cut.println(\"*** in file =  \" + getInFileName());\n         System.o\u200cut.println(\"*** o\u200cut file = \" + getOutFileName());\n     }\n     \n     int[][] memo = new int[1001][1001];\n     \n     int go(int k, int cutoff) {\n         if ( k <= cutoff) return 0;\n         if ( memo[k][cutoff] >= 0 ) return memo[k][cutoff];\n         int r\u200cesult = min(go(k - cutoff, cutoff) + 1,\n                          1 + go(k/2, cutoff) + go(k - k/2, cutoff));\n         return memo[k][cutoff] = r\u200cesult;\n     }\n     \n     int method2(int[] diners) {\n         int r\u200cesult = Integer.MAX_VALUE;\n         for ( int cutoff = 1; cutoff <= diners[diners.length-1]; cutoff++) {\n  \n             int cost = 0;\n             for ( int d: diners) {\n  \n                 cost += go(d, cutoff);\n             }\n  \n             r\u200cesult = min(r\u200cesult, cutoff + cost);\n         }\n         return r\u200cesult;      \n     }\n     \n     int method1(int[] diners) {\n         int r\u200cesult = Integer.MAX_VALUE;\n         int special = 0;\n         int[] c\u200bount = new int[1001];\n         for ( int d: diners) c\u200bount[d]++;\n         for ( int i = 1000; i > 0; i--) {\n             if ( c\u200bount[i] == 0 ) continue;\n             r\u200cesult = min(r\u200cesult, special + i);\n             special += c\u200bount[i];\n             int z = i/2;\n             c\u200bount[z] += c\u200bount[i];\n             c\u200bount[i-z] += c\u200bount[i];\n         }\n         return r\u200cesult;\n     }\n     \n     \n  }\n", "substitutes": {"PROBLEM_ID": [" POBLEMS_id", " POBleMUID", " POBLEM_id", " POBLEMUid", " POPLEMUid", " POBLEMSUID", " POPLEM_id", " POPLEMS_ID", " POBleMSUID", " POBLEM_ID", " POPLEMSUID", " POBLEMS_ID", " POBleMS_ID", " POBleM_id", " POPLEMUID", " POPLEMSUid", " POBleM_ID", " POBLEMSUid", " POBLEMUID", " POBleMS_id", " POPLEMS_id", " POPLEM_ID", " POBleMSUid", " POBleMUid"], "TYPE": ["Type"], "scan": ["Scan"], "a": ["A"], "t": ["T"], "diners": ["Diners", "dners", "diner", "piners", "daughters", "pners", " diner", " daughters", "Diner"], "i": ["I", "_"], "result1": [" resultOne", "resultOne"], "result2": [" resultB", "resultB"], "resultStr": ["resultObj", "ResultStr", "ResultObj"], "memo": ["Memo", "memos", "Memos"]}}
{"code": " \n  public class C {\n     static final String NO = \"IMPOSSIBLE\";\n     static final String Y\u200cES = \"POSSIBLE\";\n     static final int[] DX = new int[]{1, 0, -1, 0};\n     static final int[] DY = new int[]{0, 1, 0, -1};\n  \n     String solve() {\n         boolean[][][] forbidden = new boolean[h][w][2];\n         TreeSet<Integer>[][][] cells = new TreeSet[h][w][2];\n         for (int i = 0; i < h; i++) {\n             for (int j = 0; j < w; j++) {\n                 cells[i][j][0] = new TreeSet<>();\n                 cells[i][j][1] = new TreeSet<>();\n             }\n         }\n         ArrayList<Integer> s\u200cat1 = new ArrayList<>();\n         ArrayList<Integer> sat2 = new ArrayList<>();\n         for (int i = 0; i < h; i++) {\n             for (int j = 0; j < w; j++) {\n                 if (f[i][j] != '-') {\n                     continue;\n                 }\n                 for (int dir = 0; dir < 4; dir++) {\n                     int x = i;\n                     int y = j;\n                     int d = dir;\n                     for (;;) {\n                         x += DX[d];\n                         y += DY[d];\n                         if (x >= h || y >= w || x < 0 || y < 0) {\n                             break;\n                         }\n                         if (f[x][y] == '#') {\n                             break;\n                         }\n                         if (f[x][y] == '/') {\n                             d ^= 3;\n                             continue;\n                         }\n                         if (f[x][y] == '\\\\') {\n                             d ^= 1;\n                             continue;\n                         }\n                         if (f[x][y] == '-') {\n                             forbidden[i][j][dir % 2] = true;\n                             break;\n                         }\n                         cells[i][j][dir % 2].add(x * w + y);\n                     }\n                 }\n                 if (forbidden[i][j][0] && forbidden[i][j][1]) {\n                     return NO;\n                 }\n                 if (forbidden[i][j][0]) {\n                     s\u200cat1.add((i * w + j) * 2 + 1);\n                     sat2.add((i * w + j) * 2 + 1);\n                 } else if (forbidden[i][j][1]) {\n                     s\u200cat1.add((i * w + j) * 2);\n                     sat2.add((i * w + j) * 2);\n                 } else {\n                     s\u200cat1.add((i * w + j) * 2);\n                     sat2.add((i * w + j) * 2 + 1);\n                 }\n                 for (int d = 0; d < 2; d++) {\n                     if (forbidden[i][j][d]) {\n                         continue;\n                     }\n                     for (int z : cells[i][j][d]) {\n                         int y = z % w;\n                         int x = z / w;\n                         cells[x][y][0].add((i * w + j) * 2 + d);\n                     }\n                 }\n             }\n         }\n         for (int i = 0; i < h; i++) {\n             for (int j = 0; j < w; j++) {\n                 if (f[i][j] != '.') {\n                     continue;\n                 }\n                 TreeSet<Integer> good = cells[i][j][0];\n                 if (good.isEmpty()) {\n                     return NO;\n                 }\n                 if (good.size() > 2) {\n                     throw new AssertionError();\n                 }\n                 s\u200cat1.add(good.first());\n                 sat2.add(good.last());\n             }\n         }\n         boolean[] a\u200bns = TwoSat.solve(s\u200cat1, sat2);\n         if (a\u200bns == null) {\n             return NO;\n         }\n         StringBuilder sb = new StringBuilder();\n         sb.append(Y\u200cES);\n         for (int i = 0; i < h; i++) {\n             sb.append('\n');\n             for (int j = 0; j < w; j++) {\n                 if (f[i][j] != '-') {\n                     sb.append(f[i][j]);\n                     continue;\n                 }\n                 sb.append(a\u200bns[i * w + j] ? '-' : '|');\n             }\n         }\n         return sb.toString();\n     }\n     \n     static class TwoSat {\n         static boolean[] solve(ArrayList<Integer> s\u200cat1, ArrayList<Integer> sat2) {\n  \n  \n             int n = -1;\n             for (int x : s\u200cat1) {\n                 n = Math.max(n, x / 2);\n             }\n             for (int x : sat2) {\n                 n = Math.max(n, x / 2);\n             }\n             n++;\n             boolean[] a\u200bns = new boolean[n];\n             ArrayList<Integer>[] g = new ArrayList[2 * n];\n             ArrayList<Integer>[] gt = new ArrayList[2 * n];\n             for (int i = 0; i < 2 * n; i++) {\n                 g[i] = new ArrayList<Integer>();\n                 gt[i] = new ArrayList<Integer>();\n             }\n             for (int i = 0; i < s\u200cat1.size(); i++) {\n                 int a = s\u200cat1.get(i);\n                 int b = sat2.get(i);\n  \n  \n  \n                 g[a ^ 1].add(b);\n                 g[b ^ 1].add(a);\n                 gt[a].add(b ^ 1);\n                 gt[b].add(a ^ 1);\n             }\n             boolean[] m\u200cark = new boolean[2 * n];\n             ArrayList<Integer> o\u200drder = new ArrayList<Integer>();\n             for (int i = 0; i < 2 * n; i++) {\n                 if (m\u200cark[i]) {\n                     continue;\n                 }\n                 dfs1(i, m\u200cark, o\u200drder, g);\n             }\n             int[] comp = new int[2 * n];\n             Arrays.fill(comp, -1);\n             for (int i = 2 * n - 1, cn = 0; i >= 0; i--) {\n                 int v = o\u200drder.get(i);\n                 if (comp[v] == -1) {\n                     dfs2(v, cn++, comp, gt);\n                 }\n             }\n             for (int i = 0; i < n; i++) {\n                 if (comp[2 * i] == comp[2 * i + 1]) {\n                     return null;\n                 }\n                 a\u200bns[i] = comp[2 * i + 1] > comp[2 * i];\n             }\n             return a\u200bns;\n         }\n         \n         static void dfs1(int v, boolean[] m\u200cark, ArrayList<Integer> o\u200drder, ArrayList<Integer>[] g) {\n             m\u200cark[v] = true;\n             for (int u : g[v]) {\n                 if (m\u200cark[u]) {\n                     continue;\n                 }\n                 dfs1(u, m\u200cark, o\u200drder, g);\n             }\n             o\u200drder.add(v);\n         }\n         \n         static void dfs2(int v, int cn, int[] comp, ArrayList<Integer>[] g) {\n             comp[v] = cn;\n             for (int u : g[v]) {\n                 if (comp[u] != -1) {\n                     continue;\n                 }\n                 dfs2(u, cn, comp, g);\n             }\n         }\n     }\n  \n     int h, w;\n     char[][] f;\n     \n     public C(Scanner in) {\n         h = in.nextInt();\n         w = in.nextInt();\n         f = new char[h][];\n         for (int i = 0; i < h; i++) {\n             f[i] = in.next().toCharArray();\n             for (int j = 0; j < w; j++) {\n                 if (f[i][j] == '|') {\n                     f[i][j] = '-';\n                 }\n             }\n         }\n     }\n     \n     public static void main(String[] args) throws Exception {\n         int nThreads = 1;\n         \n         String fileNameSuffix = \"\";\n         String f\u200dormatOut = \"Case #%2$d: %1$s\";\n         String formatSystemOut = f\u200dormatOut;\n  \n  \n  \n  \n         \n         String fileName = C.class.getSimpleName().replaceFirst(\"_.*\", \"\").toLowerCase() + fileNameSuffix;\n         String inputFileName = fileName + \".in\";\n         String outputFileName = fileName + \".out\";\n         \n         Locale.setDefault(Locale.US);\n         Scanner in = new Scanner(new File(inputFileName));\n         PrintWriter out = new PrintWriter(outputFileName);\n         int tests = in.nextInt(); in.nextLine();\n         nThreads = Math.min(nThreads, tests);\n         @SuppressWarnings(\"unchecked\")\n         Callable<String>[] callables = new Callable[tests];\n         for (int t = 0; t < tests; t++) {\n             final C testCase = new C(in);\n             final int testCaseNumber = t + 1;\n             callables[t] = new Callable<String>() {\n                 @Override\n                 public String call() {\n                     String answer = testCase.solve();\n                     System.out.println(String.format(formatSystemOut, answer, testCaseNumber));\n                     return String.format(f\u200dormatOut, answer, testCaseNumber);\n                 }\n             };\n         }\n         try {\n             if (nThreads > 1) {\n                 ExecutorService executor = Executors.newFixedThreadPool(4);\n                 @SuppressWarnings(\"unchecked\")\n                 Future<String>[] outputs = new Future[tests];\n                 for (int t = 0; t < tests; t++) {\n                     outputs[t] = executor.submit(callables[t]);\n                 }\n                 for (int t = 0; t < tests; t++) {\n                     out.println(outputs[t].get());\n                 }\n                 executor.shutdown();\n             } else {\n                 for (int t = 0; t < tests; t++) {\n                     out.println(callables[t].call());\n                 }\n             }\n         } catch (Exception e) {\n             System.out.flush();\n             System.err.flush();\n             e.printStackTrace();\n             System.exit(1);\n         }\n         System.out.println(\"COMPLETE\");\n         in.close();\n         out.close();\n     }\n  }\n", "substitutes": {"NO": ["No", "YES"], "DX": ["D"], "DY": ["MDYY", "DZ", "DYY", "MDY", " DZ"], "forbidden": ["forgotten", "forebidden", "Forgettable", "foregotten", "forgettable", "Forbidden"], "cells": ["cell"], "i": ["I"], "sat2": ["at1", "sat1", "at2"], "dir": ["direction"], "x": ["X"], "y": ["dy"], "n": ["N"], "w": ["wa", "W"], "f": ["fs", "c"]}}
{"code": " \n  public class BathroomStalls {\n  \n      public static void main(String[] args) throws FileNotFoundException {\n          Scanner c\u200din = new Scanner(new File(\"C-small-attempt0.in\"));\n          PrintStream cout = new PrintStream(\"C-small-attempt0.out\");\n  \n  \n  \n  \n  \n          int _case = 0;\n          for (int T = c\u200din.nextInt(); T > 0; T--) {\n              _case++;\n  \n              int n = c\u200din.nextInt();\n              int k = c\u200din.nextInt();\n              Queue<Integer> q\u200bueue = new PriorityQueue<>((u, v) -> -Integer.compare(u, v));\n              q\u200bueue.add(n);\n              for (int i = 0; i < k - 1; i++) {\n                  int num = q\u200bueue.poll();\n                  int cb = (num - 1) / 2;\n                  int w\u200cb = num - 1 - cb;\n                  if (cb > 0) q\u200bueue.add(cb);\n                  if (w\u200cb > 0) q\u200bueue.add(w\u200cb);\n                  System.out.println(q\u200bueue);\n              }\n              System.out.println();\n  \n              int num = q\u200bueue.poll();\n              int cb = (num - 1) / 2;\n              int w\u200cb = num - 1 - cb;\n  \n              cout.printf(\"Case #%d: %d %d%n\", _case, w\u200cb, cb);\n          }\n  \n          c\u200din.close();\n          cout.close();\n      }\n  }\n", "substitutes": {"cout": ["cOut", "COut", "wout", "Cout", "wOut"], "_case": ["_test", "_ase", " _ase", " _Case", "_Case"], "T": ["L", "t", "N"], "n": ["N"], "k": ["K"], "cb": ["rb", "bb"]}}
{"code": " \n  public class Rebel implements Runnable {\n    private static final String NAME = \"rebel\";\n  \n    private  StreamTokenizer i\u200bn;\n  \n    int nextInt() throws Exception {\n      i\u200bn.nextToken();\n      return (int) i\u200bn.nval;\n    }\n  \n    long nextLong() throws Exception {\n      i\u200bn.nextToken();\n      return (long) i\u200bn.nval;\n    }\n  \n    double[][] d;\n  \n    @Override\n    public void run() {\n      try {\n        Scanner i\u200bn = new Scanner(new File(NAME + \".i\u200bn\"));\n  \n        PrintWriter o\u200cut = new PrintWriter(NAME + \".o\u200cut\");\n  \n        int tests = i\u200bn.nextInt();\n  \n        for (int t\u200dest = 1; t\u200dest <= tests; t\u200dest++) {\n          \n          int n = i\u200bn.nextInt();\n          i\u200bn.nextInt(); \n          d = new double[n][n];\n          int[] x = new int[n];\n          int[] y = new int[n];\n          int[] z = new int[n];\n          for (int i = 0; i < n; i++) {\n            x[i] = i\u200bn.nextInt();\n            y[i] = i\u200bn.nextInt();\n            z[i] = i\u200bn.nextInt();\n            for (int j = 0; j < 3; j++) {\n              i\u200bn.nextInt();\n            }\n          }\n          for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n              int xx = x[i] - x[j];\n              int yy = y[i] - y[j];\n              int zz = z[i] - z[j];\n              d[i][j] = Math.sqrt(xx * xx + yy * yy + zz * zz);\n            }\n          }\n          double l = 0;\n          double r = 1e10;\n          while (r - l > 1e-5) {\n            double m = (l + r) / 2;\n            if (find(m)) {\n              r = m;\n            } else {\n              l = m;\n            }\n          }\n          o\u200cut.println(\"Case #\" + t\u200dest + \": \" + r);\n        }\n  \n        o\u200cut.close();\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n  \n    private boolean find(double m) {\n      b = new boolean[d.length];\n      g(0, m);\n      return b[1];\n    }\n  \n    boolean[] b;\n  \n    private void g(int v, double m) {\n      b[v] = true;\n      for (int i = 0; i < d.length; i++) {\n        if (!b[i] && d[v][i] < m) {\n          g(i, m);\n        }\n      }\n    }\n  \n    public static void main(String[] args) {\n      new Thread(new Rebel()).start();\n    }\n  }\n", "substitutes": {"i": ["si", "p", "I", "pi"], "d": ["dt", "c"], "t": ["p", "T"], "n": ["N", "pn"], "y": ["ey"], "xx": ["xxx"], "zz": ["xxx"], "l": ["L"], "m": ["M"], "v": ["V"]}}
{"code": " public class A {\n     static BufferedReader br;\n     static StringTokenizer s\u200dt;\n     static PrintWriter pw;\n     static Semaphore processorSemaphore = new Semaphore(Runtime.getRuntime().availableProcessors());\n     static Semaphore i\u200bnputSemaphore = new Semaphore(1);\n     static Semaphore outputSemaphore = new Semaphore(0);\n     static String[] output;\n     public static void main(String[] args) throws Exception {\n         br = new BufferedReader(new InputStreamReader(System.in));\n         pw = new PrintWriter(new BufferedWriter(new FileWriter(\"A.out\")));\n         final int MAX_CASES = readInt();\n         output = new String[MAX_CASES];\n         for(int casenum = 1; casenum <= MAX_CASES; casenum++) {\n             processorSemaphore.acquire();\n             i\u200bnputSemaphore.acquire();\n             new WorkThread(casenum).start();\n         }\n         for(int casenum = 1; casenum <= MAX_CASES; casenum++) {\n             outputSemaphore.acquire();\n         }\n         for(String out: output) {\n             pw.println(out);\n         }\n         pw.close();\n     }\n  \n     static class WorkThread extends Thread {\n         public int casenum;\n  \n         public WorkThread(int casenum) {\n             super();\n             this.casenum = casenum;\n         }\n         public void run() {\n             \n             \n             String s = nextToken();\n             \n             \n             i\u200bnputSemaphore.release();\n             \n             \n             int ret = 0;\n             ArrayList<Character> list = new ArrayList<Character>();\n             for(int i = 0; i < s.length(); i++) {\n                 list.add(s.charAt(i));\n                 while(list.size() >= 2 && list.get(list.size()-1).equals(list.get(list.size()-2))) {\n                     ret += 10;\n                     list.remove(list.size()-1);\n                     list.remove(list.size()-1);\n                 }\n             }\n             \n             ret += (list.size()/2) * 5;\n             \n             \n     \n             output[casenum-1] = \"Case #\" + casenum + \": \" + ret;\n             \n             \n             outputSemaphore.release();\n             processorSemaphore.release();\n         }\n     }\n     \n     public static int readInt() {\n         return Integer.parseInt(nextToken());\n     }\n  \n     public static long readLong() {\n         return Long.parseLong(nextToken());\n     }\n  \n     public static double readDouble() {\n         return Double.parseDouble(nextToken());\n     }\n  \n     public static String nextToken() {\n         while(s\u200dt == null || !s\u200dt.hasMoreTokens())    {\n             try {\n                 if(!br.ready()) {\n                     pw.close();\n                     System.exit(0);\n                 }\n                 s\u200dt = new StringTokenizer(br.readLine());\n             }\n             catch(IOException e) {\n                 System.err.println(e);\n                 System.exit(1);\n             }\n         }\n         return s\u200dt.nextToken();\n     }\n  \n     public static String readLine() {\n         s\u200dt = null;\n         try {\n             return br.readLine();\n         }\n         catch(IOException e) {\n             System.err.println(e);\n             System.exit(1);\n             return null;\n         }\n     }\n  \n  }\n", "substitutes": {"br": ["BR", "Br"], "pw": ["Pw", "pW", "ppws", "ppw", "pws", "PW", " pW"], "processorSemaphore": ["processSemipor", "processorMutipore", "processMutipore", "processMutaphore", "processingMutaphore", "processingMutipor", "processorMutaphore", "processingMutaphor", "processingSemaphor", "processingSemipor", "processorSemaphor", "processMutipor", "processorMutipor", "processMutaphor", "processorSemipore", "processSemaphor", "processingMutipore", "processSemipore", "processingSemipore", "processingSemaphore", "processSemaphore", "processorMutaphor", "processorSemipor"], "outputSemaphore": ["outputMutipor", "outputSemipour", "outputMutipore", "OutputSemaphor", "OutputMutipore", "outerSemipour", "OutputMutipor", "outputSemaphor", "outputSemaphour", "outputSemipore", "OutputSemipore", "outerSemaphore", "OutputSemaphore", "OutputMutaphor", "OutputSemipor", "outerSemaphour", "outputSemipor", "outputMutaphor", "outerSemipore", "OutputMutaphore", "outputMutaphore"], "MAX_CASES": ["MAXLSCACES", " MAX_CACes", "MAXLSCACes", " MAX_SCATes", " MAX_SCACes", "MAX_SCACES", "MAX_SCATes", " MAX_CACES", " MAX_CATES", "MAX_CATes", "MAX_CATES", "MAX_CACes", "MAX_CASes", "MAX_SCATES", "MAXLCASes", "MAX_SCASes", "MAX_SCASES", " MAX_SCACES", "MAX_CACES", " MAX_SCASes", "MAXLSCASes", " MAX_SCATES", "MAXLCACES", "MAXLCASES", " MAX_CASes", "MAXLCACes", "MAX_SCACes", " MAX_SCASES", " MAX_CATes", "MAXLSCASES"], "casenum": ["catenum", " casumption", "cosumber", " casalogue", " casum", "cosenum", "casumption", "casumber", " caseng", "casnum", " casnum", "casalogue", "catumber", "Casum", "casum", "Casenum", "caseng"], "i": ["si", "p", "I"]}}
{"code": "package codejam2015;\n  \n  \n  public class ProbD {\n     public static void main(String[] args) {\n         Scanner sc = new Scanner(System.in);\n         int numcases = sc.nextInt();\n         for (int cas = 1; cas <= numcases; cas++) {\n             System.out.print(\"Case #\" + cas + \": \");\n             int X = sc.nextInt();\n             int R = sc.nextInt();\n             int C = sc.nextInt();\n             if (X == 1) {\n                 System.out.println(\"GABRIEL\");\n                 continue;\n             }\n             if (X == 2) {\n                 if ((R * C) % 2 == 0) {\n                     System.out.println(\"GABRIEL\");\n                 } else {\n                     System.out.println(\"RICHARD\");\n                 }\n                 continue;\n             }\n             if (X == 3) {\n                 if ((R == 1) || (C == 1)) {\n                     System.out.println(\"RICHARD\");\n                     continue;\n                 }\n                 if (R == 2) {\n                     if (C == 3) {\n                         System.out.println(\"GABRIEL\");\n                     } else {\n                         System.out.println(\"RICHARD\");\n                     }\n                     continue;\n                 }\n                 if (R == 3) {\n                     System.out.println(\"GABRIEL\");\n                     continue;\n                 }\n                 if (R == 4) {\n                     if (C == 3) {\n                         System.out.println(\"GABRIEL\");\n                     } else {\n                         System.out.println(\"RICHARD\");\n                     }\n                     continue;\n                 }\n             }\n             if (X == 4) {\n                 if ((R < 3) || (C < 3)) {\n                     System.out.println(\"RICHARD\");\n                     continue;\n                 }\n                 if (R == 3) {\n                     if (C == 3) {\n                         System.out.println(\"RICHARD\");\n                     } else {\n                         System.out.println(\"GABRIEL\");\n                     }\n                     continue;\n                 }\n                 if (R == 4) {\n                     System.out.println(\"GABRIEL\");\n                     continue;\n                 }\n             }\n         }\n     }\n  }\n", "substitutes": {"sc": ["SC", "Sc"], "numcases": ["sumcase", "sumcases", "numcase", "ncase", "ncases"], "cas": ["Cas"], "X": ["Y"], "R": ["r"]}}
{"code": " \n  \n  public class Main {\n     public static void main(String[] args) {\n         Locale.setDefault(Locale.US);\n         InputStream inputStream;\n         try {\n             final String r\u200cegex = \"B-(small|large).*[.]in\";\n             File directory = new File(\".\");\n             File[] candidates = directory.listFiles(new FilenameFilter() {\n                 public boolean accept(File d\u200bir, String n\u200bame) {\n                     return n\u200bame.matches(r\u200cegex);\n                 }\n             });\n             File t\u200coRun = null;\n             for (File candidate : candidates) {\n                 if (t\u200coRun == null || candidate.lastModified() > t\u200coRun.lastModified())\n                     t\u200coRun = candidate;\n             }\n             inputStream = new FileInputStream(t\u200coRun);\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n         OutputStream outputStream;\n         try {\n             outputStream = new FileOutputStream(\"b.o\u200cut\");\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n         InputReader in = new InputReader(inputStream);\n         OutputWriter o\u200cut = new OutputWriter(outputStream);\n         TaskB solver = new TaskB();\n         solver.solve(1, in, o\u200cut);\n         o\u200cut.close();\n     }\n  }\n  \n  class TaskB {\n      public void solve(int testNumber, InputReader in, OutputWriter o\u200cut) {\n          Scheduler scheduler = new Scheduler(in, o\u200cut, () -> new Task() {\n              int count;\n              int step;\n              int[] sums;\n              long answer;\n  \n              public void read(InputReader in) {\n                  count = in.readInt();\n                  step = in.readInt();\n                  sums = IOUtils.readIntArray(in, count - step + 1);\n              }\n  \n              public void solve() {\n                  answer = 0;\n                  long[] start = new long[step];\n                  long[] delta = new long[step];\n                  for (int i = 0; i < step; i++) {\n                      long current = 0;\n                      long max = 0;\n                      long min = 0;\n                      for (int j = i; j + 1 < sums.length; j += step) {\n                          current += sums[j + 1] - sums[j];\n                          max = Math.max(max, current);\n                          min = Math.min(min, current);\n                      }\n                      start[i] = -min;\n                      delta[i] = max - min;\n                  }\n                  answer = ArrayUtils.maxElement(delta);\n                  long sum = -(sums[0] % step) + step;\n                  long freedom = 0;\n                  for (long i : start) {\n                      sum += i;\n                  }\n                  for (long i : delta) {\n                      freedom += answer - i;\n                  }\n                  if (sum % step != 0 && freedom + sum % step < step) {\n                      answer++;\n                  }\n              }\n  \n              public void write(OutputWriter o\u200cut, int testNumber) {\n                  o\u200cut.printLine(\"Case #\" + testNumber + \":\", answer);\n              }\n          }, 4);\n      }\n  }\n  \n  class InputReader {\n  \n     private InputStream stream;\n     private byte[] buf = new byte[1024];\n     private int curChar;\n     private int numChars;\n     private SpaceCharFilter filter;\n  \n     public InputReader(InputStream stream) {\n         this.stream = stream;\n     }\n  \n     public int read() {\n         if (numChars == -1)\n             throw new InputMismatchException();\n         if (curChar >= numChars) {\n             curChar = 0;\n             try {\n                 numChars = stream.read(buf);\n             } catch (IOException e) {\n                 throw new InputMismatchException();\n             }\n             if (numChars <= 0)\n                 return -1;\n         }\n         return buf[curChar++];\n     }\n  \n     public int readInt() {\n         int c = read();\n         while (isSpaceChar(c))\n             c = read();\n         int sgn = 1;\n         if (c == '-') {\n             sgn = -1;\n             c = read();\n         }\n         int res = 0;\n         do {\n             if (c < '0' || c > '9')\n                 throw new InputMismatchException();\n             res *= 10;\n             res += c - '0';\n             c = read();\n         } while (!isSpaceChar(c));\n         return res * sgn;\n     }\n  \n     public boolean isSpaceChar(int c) {\n         if (filter != null)\n             return filter.isSpaceChar(c);\n         return isWhitespace(c);\n     }\n  \n     public static boolean isWhitespace(int c) {\n         return c == ' ' || c == '\n' || c == '\\r' || c == '\\t' || c == -1;\n     }\n  \n     public interface SpaceCharFilter {\n         public boolean isSpaceChar(int ch);\n     }\n  }\n  \n  class OutputWriter {\n     private final PrintWriter writer;\n  \n     public OutputWriter(OutputStream outputStream) {\n         writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n     }\n  \n     public void print(Object...objects) {\n         for (int i = 0; i < objects.length; i++) {\n             if (i != 0)\n                 writer.print(' ');\n             writer.print(objects[i]);\n         }\n     }\n  \n     public void printLine(Object...objects) {\n         print(objects);\n         writer.println();\n     }\n  \n     public void close() {\n         writer.close();\n     }\n  \n  }\n  \n  class Scheduler {\n     private final AtomicInteger testsRemaining;\n     private final AtomicInteger threadsRemaining;\n  \n     public Scheduler(InputReader in, OutputWriter o\u200cut, TaskFactory factory, int numParallel) {\n         try {\n             testsRemaining = new AtomicInteger(in.readInt());\n             threadsRemaining = new AtomicInteger(numParallel);\n             Task[] tasks = new Task[testsRemaining.get()];\n             for (int i = 0; i < tasks.length; i++) {\n                 tasks[i] = factory.newTask();\n             }\n             for (Task task : tasks) {\n                 task.read(in);\n                 new Thread(() -> {\n                     boolean freeThread = false;\n                     synchronized (this) {\n                         do {\n                             try {\n                                 wait(10);\n                             } catch (InterruptedException ignored) {\n                             }\n                             if (threadsRemaining.get() != 0) {\n                                 synchronized (threadsRemaining) {\n                                     if (threadsRemaining.get() != 0) {\n                                         threadsRemaining.decrementAndGet();\n                                         freeThread = true;\n                                     }\n                                 }\n                             }\n                         } while (!freeThread);\n                     }\n                     task.solve();\n                     System.err.println(testsRemaining.decrementAndGet());\n                     threadsRemaining.incrementAndGet();\n                 }).start();\n             }\n             synchronized (this) {\n                 while (testsRemaining.get() > 0) {\n                     wait(10);\n                 }\n             }\n             for (int i = 0; i < tasks.length; i++) {\n                 tasks[i].write(o\u200cut, i + 1);\n             }\n         } catch (InterruptedException e) {\n             throw new RuntimeException(e);\n         }\n     }\n  }\n  \n  interface Task {\n     public void read(InputReader in);\n     public void solve();\n     public void write(OutputWriter o\u200cut, int testNumber);\n  }\n  \n  class IOUtils {\n  \n     public static int[] readIntArray(InputReader in, int size) {\n         int[] array = new int[size];\n         for (int i = 0; i < size; i++)\n             array[i] = in.readInt();\n         return array;\n     }\n  \n  }\n  \n  class ArrayUtils {\n  \n     public static long maxElement(long[] array) {\n         return array[maxPosition(array)];\n     }\n  \n     public static int maxPosition(long[] array) {\n         return maxPosition(array, 0, array.length);\n     }\n  \n     public static int maxPosition(long[] array, int from, int to) {\n         if (from >= to)\n             return -1;\n         long max = array[from];\n         int result = from;\n         for (int i = from + 1; i < to; i++) {\n             if (array[i] > max) {\n                 max = array[i];\n                 result = i;\n             }\n         }\n         return result;\n     }\n  \n  }\n  \n  interface TaskFactory {\n     public Task newTask();\n  }\n  \n", "substitutes": {"inputStream": ["InputStream", "inputSteam", "outputSteam", "InputSteam"], "directory": ["Directory"], "candidates": ["Candidates", "Candidate"], "candidate": ["vidate", "vidates"], "outputStream": ["inputSteam", "outputSteam", "OutputSteam", "OutputStream"], "in": ["In", "out"], "solver": ["setsolver", "ssolver", "solve", "solution", "ssolution", "setsolve"], "testNumber": ["testnumber", " testnumber"], "scheduler": ["sccheduler", " sccheduler", "sccheduling", " scheduling", " sccheduling", "scheduling"], "step": ["stage", "Step"], "sums": ["ssums", "ssum", "sults", "ssults"], "start": ["end"], "delta": ["delt", "Delta", "Delt"], "c": ["C", "lc"]}}
{"code": "package gcj2016.r1a;\n  \n  public class A implements Runnable {\n     static final boolean LARGE = false;\n     static final boolean PROD = true;\n     static final int NTHREAD = 1;\n     static String B\u200dASEPATH = \"c:\\\\temp\\\\gcj2016\\\\r1a\\\\\";\n  \n     \n     static String I\u200dNPATH = B\u200dASEPATH + A.class.getSimpleName().charAt(0) + (LARGE ? \"-large.i\u200dn\" : \"-small-attempt0.i\u200dn\");\n  \n     static String O\u200bUTPATH = I\u200dNPATH.substring(0, I\u200dNPATH.length()-3) + new SimpleDateFormat(\"-HHmmss\").format(new Date()) + \".out\";\n     \n     static String INPUT = \"\";\n     \n     char[] s;\n     \n     public void read() \n     {\n         s = i\u200dn.next().toCharArray();\n     }\n     \n     public void process() \n     {\n         int n = s.length;\n         char[] r\u200cet = new char[n];\n         boolean[] used = new boolean[n];\n         int p = 0;\n         int u = n-1;\n         for(char x = 'Z';x >= 'A';x--){\n             for(int i = u;i >= 0;i--){\n                 if(s[i] == x){\n                     r\u200cet[p++] = s[i];\n                     used[i] = true;\n                     u = i-1;\n                 }\n             }\n         }\n         for(int i = 0;i < n;i++){\n             if(!used[i])r\u200cet[p++] = s[i];\n         }\n         out.println(new String(r\u200cet));\n     }\n     \n     public static void preprocess()\n     {\n     }\n     \n     Scanner i\u200dn;\n     PrintWriter out;\n     StringWriter sw;\n     int c\u200das;\n     static List<Status> running = new ArrayList<Status>();\n     \n     @Override\n     public void run()\n     {\n         long S = System.nanoTime();\n         \n         synchronized(running){\n             Status st = new Status();\n             st.id = c\u200das;\n             st.S = S;\n             running.add(st);\n         }\n         process();\n         \n         synchronized(running){\n             for(Status st : running){\n                 if(st.id == c\u200das){\n                     running.remove(st);\n                     break;\n                 }\n             }\n         }\n         long G = System.nanoTime();\n         \n         if(PROD){\n             System.err.println(\"case \" + c\u200das + \" solved. [\" + (G-S)/1000000 + \"ms]\");\n             synchronized(running){\n                 StringBuilder sb = new StringBuilder(\"running : \");\n                 for(Status st : running){\n                     sb.append(st.id + \":\" + (G-st.S)/1000000 + \"ms, \");\n                 }\n                 System.err.println(sb);\n             }\n         }\n     }\n     \n     private static class Status {\n         public int id;\n         public long S;\n     }\n     \n     public A(int c\u200das, Scanner i\u200dn)\n     {\n         this.c\u200das = c\u200das;\n         this.i\u200dn = i\u200dn;\n         this.sw = new StringWriter();\n         this.out = new PrintWriter(this.sw);\n     }\n     \n     private int ni() { return Integer.parseInt(i\u200dn.next()); }\n     private long nl() { return Long.parseLong(i\u200dn.next()); }\n     private int[] na(int n) { int[] a = new int[n]; for(int i = 0;i < n;i++)a[i] = ni(); return a; }\n     private double nd() { return Double.parseDouble(i\u200dn.next()); }\n     private void tr(Object... o) { if(!PROD)System.out.println(Arrays.deepToString(o)); }\n     \n     public static void main(String[] args) throws Exception\n     {\n         long start = System.nanoTime();\n         \n         ExecutorService es = Executors.newFixedThreadPool(NTHREAD);\n         CompletionService<A> cs = new ExecutorCompletionService<A>(es);\n         \n         if(PROD){\n             System.out.println(\"I\u200dNPATH : \" + I\u200dNPATH);\n             System.out.println(\"O\u200bUTPATH : \" + O\u200bUTPATH);\n         }\n         Scanner i\u200dn = PROD ? new Scanner(new File(I\u200dNPATH)) : new Scanner(INPUT);\n         PrintWriter out = PROD ? new PrintWriter(new File(O\u200bUTPATH)) : new PrintWriter(System.out);\n         int n = i\u200dn.nextInt();\n         i\u200dn.nextLine();\n         \n         preprocess();\n         for(int i = 0;i < n;i++){\n             A runner = new A(i+1, i\u200dn);\n             runner.read();\n             cs.submit(runner, runner);\n         }\n         es.shutdown();\n         String[] outs = new String[n];\n         for(int i = 0;i < n;i++){\n             A runner = cs.take().get(); \n             runner.out.flush();\n             runner.out.close();\n             outs[runner.c\u200das-1] = runner.sw.toString();\n         }\n         for(int i = 0;i < n;i++){\n             out.printf(\"Case #%d: \", i+1);\n             out.append(outs[i]);\n             out.flush();\n         }\n         \n         long end = System.nanoTime();\n         System.out.println((end - start)/1000000 + \"ms\");\n         if(PROD){\n             System.out.println(\"I\u200dNPATH : \" + I\u200dNPATH);\n             System.out.println(\"O\u200bUTPATH : \" + O\u200bUTPATH);\n         }\n     }\n  }\n", "substitutes": {"NTHREAD": [" NTHINK", " NthINK", "NthINK", "NTHINK", "NthREAD", " NthREAD"], "s": ["sub", "strings"], "n": ["N"], "used": ["using"], "u": ["U"], "x": ["X"], "out": ["Out", "in"], "sw": ["SW"], "running": ["Running"], "S": ["C", "As"], "st": ["St"], "id": ["sid"], "G": ["GG"], "PROD": ["PROT", " PROT"], "c": ["ci", "C"], "a": ["aj", "A"], "o": ["O"]}}
{"code": " \n  \n  public class A {\n     Scanner scan;\n  \n     public A(Scanner s) {\n         scan = s;\n     }\n     \n     int intLine(){\n         return Integer.parseInt(scan.nextLine());\n     }\n     \n     int [][][][]M;\n     int P;\n     int doit(int r,int p\u200d1,int p\u200c2,int p3) {\n         if(M[r][p\u200d1][p\u200c2][p3]!=-1)return M[r][p\u200d1][p\u200c2][p3];\n         int res =0;\n         if(p\u200d1+p\u200c2+p3==0)return 0;\n         \n         if(p\u200d1>0){\n             int x = doit((r+1)%P,p\u200d1-1,p\u200c2,p3);\n             res = max(res,x);\n         }\n         if(p\u200c2>0){\n             int x = doit((r+2)%P,p\u200d1,p\u200c2-1,p3);\n             res = max(res,x);\n         }\n         if(p3>0){\n             int x = doit((r+3)%P,p\u200d1,p\u200c2,p3-1);\n             res = max(res,x);\n         }\n         if(r==0) res++;\n         return M[r][p\u200d1][p\u200c2][p3]=res;\n     }\n     \n     public String solve() {\n         int n = scan.nextInt();\n         P = scan.nextInt();\n         int[]A = new int[4];\n         for(int i=0;i<n;i++){\n             int x = scan.nextInt();\n             A[x%P]++;\n         }\n         M = new int[P][A[1]+1][A[2]+1][A[3]+1];\n         for(int[][][]m\u200b1:M)for(int[][]m2:m\u200b1)for(int[]m3:m2)Arrays.fill(m3,-1);\n         int res =doit(0, A[1], A[2],A[3]);\n         res+=A[0];\n         return \"\"+res;\n     }\n     \n     \n     public static void main(String[] args) throws Exception{\n         Locale.setDefault(Locale.US);\n         String cn = \"src/\"+A.class.getName();\n         String sampleName = cn+\"-sample.i\u200bn\";\n         String s\u200dmallName = cn+\"-small-attempt0.i\u200bn\";\n         String largeName = cn+\"-large.i\u200bn\";\n         \n         String name = s\u200dmallName;\n         \n         String outName = name.substring(0, name.indexOf('.'))+\".out\";\n         InputStream i\u200bn = new BufferedInputStream(new FileInputStream(name));\n         PrintStream out =null;\n         out = new PrintStream(new File(outName));\n         if(out==null) out = System.out;\n         Scanner scan = new Scanner(i\u200bn);\n         \n         int N = Integer.parseInt(scan.nextLine());\n         for(int c=1;c<=N;c++) {\n             String res = new A(scan).solve();\n             out.printf(\"Case #%d: %s\n\",c, res);\n             if(out!=System.out)System.err.println(c + \" done\");\n         }\n         if(out!=System.out)System.err.println(\"All done\");\n         \n     }\n  }\n", "substitutes": {"scan": ["Scan", "can"], "s": ["S"], "M": ["R"], "r": ["ar", "R"], "res": ["results", "resolution", "Res"], "x": ["X", "ex"], "re": ["RE"], "i": ["I"]}}
{"code": "package Round1A;\n  \n  \n  public class ProbB {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         long t = sc.nextInt();\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n                 HashMap<Integer,Integer> counts = new HashMap<Integer,Integer>();\n                 int N = sc.nextInt();\n                 for(int i=0;i<2*N*N-N;i++)\n                 {\n                     int in = sc.nextInt();\n                     if(!counts.containsKey(in))\n                         counts.put(in, 0);\n                     counts.put(in, counts.get(in)+1);\n                 }\n                 TreeSet<Integer> odds = new TreeSet<Integer>();\n                 for(Integer i : counts.keySet())\n                 {\n                     if(counts.get(i)%2==1)\n                         odds.add(i);\n                 }\n                 String ret =\"\";\n                 for(Integer i : odds)\n                 {\n                     ret= ret+\" \"+i;\n                 }\n                 System.out.println(\"Case #\"+curcase+\":\"+ret);\n     \n         }\n         \n     }\n  }\n", "substitutes": {"sc": ["Sc"], "t": ["T"], "curcase": ["curce", "curCase", " curce", " curCase"], "counts": ["lengths", "sumings", "sums", "Countes", "Countings", "countes", "countings", "Counts", "lengthings"], "N": ["n"], "i": ["gi"], "in": ["inc", "out"], "odds": [" oddlines", "oddings", " oddings", "oddes", "dds", "oddlines", "ddes"]}}
{"code": "package facebook;\n  \n  \n  public class Qual {\n  \n     private static BufferedReader br = null;\n     private static int readInt() {\n         try {\n             return Integer.parseInt(br.readLine());\n         } catch (NumberFormatException e) {\n             \n             e.printStackTrace();\n         } catch (IOException e) {\n             \n             e.printStackTrace();\n         }\n         return 0;\n     }\n     \n     private static double readDouble() {\n         try {\n             return Double.parseDouble(br.readLine());\n         } catch (NumberFormatException e) {\n             \n             e.printStackTrace();\n         } catch (IOException e) {\n             \n             e.printStackTrace();\n         }\n         return 0;\n     }\n     \n     private static int[] readIntArr() {\n         int[] ret = null;\n         String[] tmp;\n         try {\n             String str = br.readLine();\n             tmp = str.split(\" \");\n             ret = new int[tmp.length];\n             for (int i = 0; i < tmp.length; i++)\n                 ret[i] = Integer.parseInt(tmp[i]);\n         } catch (NumberFormatException e) {\n             \n             e.printStackTrace();\n         } catch (IOException e) {\n             \n             e.printStackTrace();\n         }\n         return ret;\n     }\n     \n     public static void printDivs() {\n         for (int i = 2; i<=10; i++) {\n             if (i % 2 == 0)System.out.print(\" \" + (i + 1));\n             else System.out.print(\" 2\");\n         }\n         System.out.println();\n     }\n     \n     public static char[] getNewAr(int n) {\n         char[] ret = new char[n];\n         for (int i = 0; i < n; i++)ret[i]='0';\n         ret[0] = '1';\n         ret[n-1] = '1';\n         return ret;\n     }\n     \n     public static void main(String[] args) throws IOException {\n         \n         br = new BufferedReader(new FileReader(new File(\"input.txt\")));\n         System.setOut(new PrintStream(new File(\"output.txt\")));\n         int T = readInt();\n         for (int ind = 1; ind<=T; ind++) {\n             System.out.println(\"Case #\" + ind + \":\");\n             int[] a\u200dr = readIntArr();\n             int n = a\u200dr[0], c = a\u200dr[1];\n             int count = 0;\n             \n             \n             for (int i = 1; i < n-1; i+=2) {\n                 for (int j = 2; j < n-1; j+=2) {\n                     if (count < c) {\n                         char[] c\u200bhars = getNewAr(n);\n                         count++;\n                         c\u200bhars[i] = '1';\n                         c\u200bhars[j] = '1';\n                         \n                         for (int k = 0; k < n; k++)System.out.print(c\u200bhars[k]);\n                         printDivs();\n                     }\n                 }\n             }\n             \n             for (int i = 1; i < n-1; i+=2) {\n                 if (count >= c)break;\n                 for (int ii = i + 2; ii < n-1; ii+=2) {\n                     if (count >= c)break;\n                     for(int j = 2; j < n-1; j+=2)\n                         for (int jj = j + 2; jj < n-1; jj+=2) {\n                             if (count < c) {\n                                 count++;\n                                 char[] c\u200bhars = getNewAr(n);\n                                 c\u200bhars[i] = c\u200bhars[ii] = c\u200bhars[j] = c\u200bhars[jj] = '1';\n                                 \n                                 for (int k = 0; k < n; k++)System.out.print(c\u200bhars[k]);\n                                 printDivs();\n                             }\n                         }\n                 }\n             }\n         }\n         \n  \n     }\n  \n  }\n", "substitutes": {"ret": ["Ret"], "str": ["Str"], "n": ["p", "N"], "T": ["t"], "ind": ["Ind"]}}
{"code": " \n  public class E {\n  \n      private int solveTest() throws IOException {\n          int n = nextInt();\n          int m = nextInt();\n          int[][] a = new int[n][2];\n          for (int i = 0; i < n; i++) {\n              for (int j = 0; j < m; j++) {\n                  a[i][j] = nextInt();\n              }\n          }\n          int[][] b = new int[n][];\n          int[][] c = new int[n][];\n          int b\u200bn = 0;\n          int cn = 0;\n          int add = 0;\n          for (int i = 0; i < n; i++) {\n              if (a[i][0] < 0 && a[i][1] > 0) {\n                  b[b\u200bn++] = a[i];\n              }\n              if (a[i][0] > 0 && a[i][1] < 0) {\n                  c[cn++] = a[i];\n              }\n              if (a[i][0] >= 0 && a[i][1] >= 0) {\n                  add += a[i][0] + a[i][1];\n              }\n          }\n          Arrays.sort(b, 0, b\u200bn, new Comparator<int[]>() {\n              @Override\n              public int compare(int[] x, int[] y) {\n                  return Integer.compare(x[0] + x[1], y[0] + y[1]);\n              }\n          });\n          Arrays.sort(c, 0, cn, new Comparator<int[]>() {\n              @Override\n              public int compare(int[] x, int[] y) {\n                  return Integer.compare(x[0] + x[1], y[0] + y[1]);\n              }\n          });\n          int[][] db = new int[b\u200bn + 1][cn + 1];\n          int[][] dc = new int[b\u200bn + 1][cn + 1];\n          for (int[] i\u200cnts : dc) {\n              Arrays.fill(i\u200cnts, -1000000000);\n          }\n          for (int[] i\u200cnts : db) {\n              Arrays.fill(i\u200cnts, -1000000000);\n          }\n          db[0][0] = 0;\n          dc[0][0] = 0;\n          int res = 0;\n          for (int i = 0; i <= b\u200bn; i++) {\n              for (int j = 0; j <= cn; j++) {\n  \n                  int[] s = new int[2];\n                  for (int i\u200bi = i; i\u200bi < b\u200bn; i\u200bi++) {\n                      s[0] += b[i\u200bi][0];\n                      s[1] += b[i\u200bi][1];\n                      if (dc[i][j] + s[0] < 0) {\n                          db[i\u200bi + 1][j] = Math.max(db[i\u200bi + 1][j], s[1]);\n                      }\n                  }\n                  if (j == cn) {\n                      res = Math.max(res, Math.max(dc[i][j] + s[0], 0) + s[1]);\n  \n                  }\n                  s = new int[2];\n                  for (int j\u200bj = j; j\u200bj < cn; j\u200bj++) {\n                      s[0] += c[j\u200bj][0];\n                      s[1] += c[j\u200bj][1];\n                      if (db[i][j] + s[1] < 0) {\n                          dc[i][j\u200bj + 1] = Math.max(dc[i][j\u200bj + 1], s[0]);\n                      }\n                  }\n                  if (i == b\u200bn) {\n                      res = Math.max(res, s[0] + Math.max(db[i][j] + s[1], 0));\n  \n                  }\n              }\n          }\n          return res + add;\n      }\n  \n      private void apply(int[] cur, int[] a) {\n          for (int i = 0; i < cur.length; i++) {\n              cur[i] = Math.max(cur[i] + a[i], 0);\n          }\n      }\n  \n      private void solve() throws IOException {\n          int n = nextInt();\n          for (int i = 0; i < n; i++) {\n              int res = solveTest();\n              System.out.println(\"Case #\" + (i + 1) + \": \" + res);\n              out.println(\"Case #\" + (i + 1) + \": \" + res);\n          }\n      }\n  \n  \n      BufferedReader br;\n      StringTokenizer st;\n      PrintWriter out;\n  \n      String next() throws IOException {\n          while (st == null || !st.hasMoreTokens()) {\n              st = new StringTokenizer(br.readLine());\n          }\n          return st.nextToken();\n      }\n  \n      int nextInt() throws IOException {\n          return Integer.parseInt(next());\n      }\n  \n      public static void main(String[] args) throws FileNotFoundException {\n          new E().run();\n      }\n  \n      private void run() throws FileNotFoundException {\n          br = new BufferedReader(new FileReader(this.getClass().getSimpleName().substring(0, 1) + \".in\"));\n          out = new PrintWriter(this.getClass().getSimpleName().substring(0, 1) + \".out\");\n          try {\n              solve();\n          } catch (IOException e) {\n              e.printStackTrace();\n          }\n          out.close();\n      }\n  \n  }\n", "substitutes": {"n": ["N"], "m": ["M"], "a": ["A"], "c": ["p"], "cn": ["nc", "dn"], "add": ["Add"], "y": ["Y"], "db": ["ds"], "dc": ["da"], "s": ["ns", "d"]}}
{"code": " \n  \n  public class A {\n     \n     static boolean v\u200cerb=true;\n     static void log(Object X){if (v\u200cerb) System.err.println(X);}\n     static void log(Object[] X){if (v\u200cerb) {for (Object U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n     static void log(int[] X){if (v\u200cerb) {for (int U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n     static void logWln(Object X){if (v\u200cerb) System.err.print(X);}\n     static void info(Object o){ System.out.println(o);}\n     static void output(Object o){outputWln(\"\"+o+\"\n\");  }\n     static void outputWln(Object o){try {out.write(\"\"+ o);} catch (Exception e) {}}\n  \n     static  char inv(char c){\n         if (c=='+')\n             return '-';\n         return '+';\n     }\n     \n     static String solve(String s,int K){\n         String r\u200ces=\"IMPOSSIBLE\";\n         int L=s.length();\n         boolean inv=false;\n         int c\u200bnt=0;\n         \n         int r\u200cem=0;\n         char[] mem=s.toCharArray();\n         for (int i=0;i+K<=L;i++){\n             char c=mem[i];\n             if (c=='-'){\n                 c\u200bnt++;\n                 for (int u=0;u<K;u++){\n                     mem[u+i]=inv(mem[u+i]);\n                 }\n             }\n         }\n         \n         for (int i=L-K+1;i<L;i++){\n             char c=mem[i];\n             if (c=='-')\n                 return r\u200ces;\n         }\n         r\u200ces=\"\"+c\u200bnt;\n         return r\u200ces;\n     }\n     \n     \n     static BufferedWriter out;\n  \n     static void process() throws Exception {\n         Locale.setDefault(Locale.US);\n  \n  \n         File inputFile=new File(\"A.in\");\n         PrintWriter outputFile= new PrintWriter(\"A.out\",\"UTF-8\");\n         Scanner sc=new Scanner(inputFile);\n         sc.useLocale(Locale.US);\n  \n         int T=sc.nextInt();\n         for (int t=1;t<=T;t++){\n             \n             String S=sc.next();\n             int K=sc.nextInt();\n             String ss=solve(S,K);\n             System.out.println(\"Case #\"+t+\": \"+ss);\n             outputFile.println(\"Case #\"+t+\": \"+ss);\n             \n  \n         }\n  \n  \n  \n         sc.close();\n         outputFile.close();\n  \n  \n     }\n  \n  \n  \n     public static void main(String[] args) throws Exception {\n  \n  \n         process();\n  \n  \n     }\n  \n  \n  \n  \n  \n  \n  }\n", "substitutes": {"X": ["x"], "o": ["O"], "c": ["C"], "K": ["k", "N"], "L": ["l", "N"], "u": ["U"], "inv": ["Inv"], "out": ["Out", "in"], "t": ["p"], "S": ["WS", "Sh", "N", "Sl"]}}
{"code": " \n  \n  public class Main {\n     public static void main(String[] args) {\n         Locale.setDefault(Locale.US);\n         InputStream inputStream;\n         try {\n             final String regex = \"B-(small|large).*[.]i\u200cn\";\n             File directory = new File(\".\");\n             File[] candidates = directory.listFiles(new FilenameFilter() {\n                 public boolean accept(File d\u200bir, String n\u200dame) {\n                     return n\u200dame.matches(regex);\n                 }\n             });\n             File t\u200coRun = null;\n             for (File c\u200dandidate : candidates) {\n                 if (t\u200coRun == null || c\u200dandidate.lastModified() > t\u200coRun.lastModified())\n                     t\u200coRun = c\u200dandidate;\n             }\n             inputStream = new FileInputStream(t\u200coRun);\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n         OutputStream o\u200cutputStream;\n         try {\n             o\u200cutputStream = new FileOutputStream(\"b.out\");\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n         InputReader i\u200cn = new InputReader(inputStream);\n         OutputWriter out = new OutputWriter(o\u200cutputStream);\n         TaskB solver = new TaskB();\n         int testCount = Integer.parseInt(i\u200cn.next());\n         for (int i = 1; i <= testCount; i++)\n             solver.solve(i, i\u200cn, out);\n         out.close();\n     }\n  }\n  \n  class TaskB {\n      public void solve(int t\u200destNumber, InputReader i\u200cn, OutputWriter out) {\n          out.printFormat(\"Case #%d: \", t\u200destNumber);\n          int n = i\u200cn.readInt();\n          int m = i\u200cn.readInt();\n          int need = i\u200cn.readInt();\n          boolean[][] filled = new boolean[n][m];\n          int min = Integer.MAX_VALUE;\n          for (int mask = 0; mask < (1 << (n*m)); mask++) {\n              if (Integer.bitCount(mask) != need) {\n                  continue;\n              }\n              for (int i = 0; i < n; i++) {\n                  for (int j = 0; j < m; j++) {\n                      int bit = i*m + j;\n                      if ((mask & (1 << bit)) != 0) {\n                          filled[i][j] = true;\n                      } else {\n                          filled[i][j] = false;\n                      }\n                  }\n              }\n              int ans = 0;\n              for (int x = 0; x < n; x++) {\n                  for (int y = 0; y < m; y++) {\n                      if (filled[x][y]) {\n                          for (int i = 0; i < 4; i++) {\n                              int nx = x + MiscUtils.DX4[i];\n                              int ny = y + MiscUtils.DY4[i];\n                              if (MiscUtils.isValidCell(nx, ny, n, m)) {\n                                  if (filled[nx][ny]) {\n                                      ans++;\n                                  }\n                              }\n                          }\n                      }\n                  }\n              }\n              if (ans % 2 != 0) {\n                  throw new RuntimeException();\n              }\n              min = Math.min(min, ans / 2);\n          }\n          out.printLine(min);\n      }\n  }\n  \n  class InputReader {\n  \n     private InputStream stream;\n     private byte[] buf = new byte[1024];\n     private int curChar;\n     private int numChars;\n     private SpaceCharFilter filter;\n  \n     public InputReader(InputStream stream) {\n         this.stream = stream;\n     }\n  \n     public int read() {\n         if (numChars == -1)\n             throw new InputMismatchException();\n         if (curChar >= numChars) {\n             curChar = 0;\n             try {\n                 numChars = stream.read(buf);\n             } catch (IOException e) {\n                 throw new InputMismatchException();\n             }\n             if (numChars <= 0)\n                 return -1;\n         }\n         return buf[curChar++];\n     }\n  \n     public int readInt() {\n         int c = read();\n         while (isSpaceChar(c))\n             c = read();\n         int sgn = 1;\n         if (c == '-') {\n             sgn = -1;\n             c = read();\n         }\n         int res = 0;\n         do {\n             if (c < '0' || c > '9')\n                 throw new InputMismatchException();\n             res *= 10;\n             res += c - '0';\n             c = read();\n         } while (!isSpaceChar(c));\n         return res * sgn;\n     }\n  \n     public String readString() {\n         int c = read();\n         while (isSpaceChar(c))\n             c = read();\n         StringBuilder res = new StringBuilder();\n         do {\n             if (Character.isValidCodePoint(c))\n                 res.appendCodePoint(c);\n             c = read();\n         } while (!isSpaceChar(c));\n         return res.toString();\n     }\n  \n     public boolean isSpaceChar(int c) {\n         if (filter != null)\n             return filter.isSpaceChar(c);\n         return isWhitespace(c);\n     }\n  \n     public static boolean isWhitespace(int c) {\n         return c == ' ' || c == '\n' || c == '\\r' || c == '\\t' || c == -1;\n     }\n  \n     public String next() {\n         return readString();\n     }\n  \n     public interface SpaceCharFilter {\n         public boolean isSpaceChar(int ch);\n     }\n  }\n  \n  class OutputWriter {\n     private final PrintWriter writer;\n  \n     public OutputWriter(OutputStream o\u200cutputStream) {\n         writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(o\u200cutputStream)));\n     }\n  \n     public void printFormat(String format, Object...objects) {\n         writer.printf(format, objects);\n     }\n  \n     public void close() {\n         writer.close();\n     }\n  \n     public void printLine(int i) {\n         writer.println(i);\n     }\n  }\n  \n  class MiscUtils {\n     public static final int[] DX4 = {1, 0, -1, 0};\n     public static final int[] DY4 = {0, -1, 0, 1};\n  \n     public static boolean isValidCell(int row, int column, int rowCount, int columnCount) {\n         return row >= 0 && row < rowCount && column >= 0 && column < columnCount;\n     }\n  \n  }\n  \n", "substitutes": {"inputStream": ["InputSteam", "InputStream", "inputSteam"], "regex": ["rlex", "relex", "rgex"], "directory": ["Directory"], "candidates": ["Candidates", "candidate", "Candidate"], "out": ["Out", "in"], "solver": ["ssolver", "solution", "ssolution"], "testCount": ["testcount", "testSize", " testcount", " testSize"], "i": ["I"], "n": ["N"], "m": ["M"], "need": ["ask"], "filled": ["fill"], "min": ["max"], "c": ["C"]}}
{"code": " \n  \n  public class tinyC {\n     public static void main(String[] args)\n     {\n         Scanner sc= new Scanner(System.in);\n         int numcases = sc.nextInt();\n         for(int curcase = 1;curcase <=numcases;curcase++)\n         {\n             int N = sc.nextInt();\n             int h1pos;\n             int h2pos;\n             int h1speed;\n             int h2speed;\n             if(N==1)\n             {\n                 int D1 = sc.nextInt();\n                 int numhike = sc.nextInt();\n                 if(numhike ==1)\n                 {\n                     System.out.println(\"Case #\"+curcase+\": 0\");\n                     continue;\n                 }\n                 h1speed = sc.nextInt();\n                 h2speed = h1speed+1;\n                 h1pos = D1;\n                 h2pos =D1;\n                 \n                 System.out.println(\"Case #\"+curcase+\": 0\");\n                 continue;               \n             }else\n             {\n                 h1pos = sc.nextInt();\n                 sc.nextInt();\n                 h1speed =sc.nextInt();\n                 h2pos = sc.nextInt();\n                 sc.nextInt();\n                 h2speed = sc.nextInt();\n  \n                 if(h1pos<h2pos)\n                 {\n                     int swap = h1pos;\n                     h1pos = h2pos;\n                     h2pos = swap;\n                     swap  =h1speed;\n                     h1speed = h2speed;\n                     h2speed = swap;\n                 }\n                 if(h1speed == h2speed)\n                 {\n                     System.out.println(\"Case #\"+curcase+\": 0\");\n                     continue;                               \n                 }\n                 double disttwo = (h1pos - h2pos)/360;\n                 double timeone = (1+disttwo)*h1speed*h2speed/(h1speed-h2speed);\n                 double hittime;\n                 if(timeone>0)\n                     hittime = timeone;\n                 else\n                     hittime = (360 - disttwo)*h1speed*h2speed/(h2speed-h1speed);\n                 double h1time = (360-h1pos)/360*h1speed;\n                 double h2time = (360-h2pos)/360*h2speed;\n                 if((h1time>= hittime)||(h2time>=hittime))\n                 {\n                     System.out.println(\"Case #\"+curcase+\": 1\");\n                     continue;                       \n                 }else\n                 {\n                     System.out.println(\"Case #\"+curcase+\": 0\");\n                     continue;                       \n                     \n                 }\n             }\n             \n         }\n     }\n  \n  }\n", "substitutes": {"sc": ["SC", "uc", "Sc"], "numcases": ["sumtests", "sumcases", "numcase", "numtests", "ncase", "ncases"], "curcase": ["curce", "curCase", "curcases", " curce", " curcases", " curCase"], "N": ["n"], "h1pos": ["c2position", "H2pos", "v1pos", "H1pos", "c1position", "p1pos", "h3position", "ih2position", "h2loc", "p1position", "H1position", "ih1position", "h1position", "ih1pos", "v3position", "c2pos", "ih2pos", "v1position", "v2pos", "h2position", "H2loc", "c1pos", "v2position", "p2pos", "p2position", "h1loc", "H1loc", "v3pos", "h3pos", "H2position"], "h2pos": ["c2position", "H2pos", "H0pose", "v1pos", "H1pos", "c1position", "H0pos", "h0pos", "h2loc", "H1position", "h1position", "H2speed", "h2Pos", "c2pos", "v1position", "H2pose", "v2pos", "h2pose", "h2position", "h1Pos", "H2loc", "c1pos", "v2position", "H1speed", "H1Pos", "h0pose", "h1loc", "H1loc", "H2Pos", "H2position"], "h1speed": ["v2speed", "H2pos", "v1pos", "v1speed", "p1speed", "H1pos", "p4weight", "ih1speed", "c2speed", "h3weight", "p4speed", "ih1pos", "H2speed", "p1weight", "c1speed", "c2pos", "ih2pos", "v2pos", "h4weight", "H2time", "h4speed", "ih2speed", "c1pos", "H1time", "H1speed", "p3weight", "h3speed", "h1weight", "p3speed"], "h2speed": ["v2speed", "h6speed", "v0pos", "H2pos", "v1pos", "m6speed", "v1speed", "H4engine", "H1pos", "H2cost", "h0pos", "f2pos", "H0cost", "m6peed", "h4pos", "H2engine", "h2cost", "H0speed", "h2peed", "H2speed", "f2speed", "h0cost", "f4pos", "h2engine", "v2pos", "f4speed", "H2time", "v0speed", "h4speed", "H1time", "H1speed", "h0speed", "h6peed", "m2speed", "h4engine", "m2peed", "H4speed"], "D1": ["d1", "d0", "M2", "M1", "D0", "D2"], "numhike": ["numhikes", "nhikes", "numHike", "numHikes", "nhike", "numfikes", "nfike", "numfike", "nfikes", "nHike", "nHikes"], "swap": ["swAP", "swappiness", "swip", " swAP", "Swip", "Swap", "Swape", " swappiness", "swape"], "disttwo": ["distone", "Disttwo", "Distone", "distfour", " distone", " distfour"], "timeone": [" timetwo", "timetwo", "time1", "Timeone", "Time1"], "hittime": ["hmITTime", "hitteimes", "hITTIME", "Hitteimes", "hiltime", "hmittime", "Hittime", "hittIME", "HITTime", "Hitttime", "phitttime", "hittimes", "HITTtime", "Hittimes", "hmittIME", "phittime", "hITTime", "Hitteime", "hitttime", "hITTtime", "philttime", "hilttime", "hitteime", "philtime", "hmITTIME"], "h1time": ["H2time", "H2speed", "c1speed", "c2speed", "c2time", "H1time", "H1speed", "c1time"], "h2time": ["H2time", "rh2time", "H2speed", "h4speed", "H1time", "rh2speed", "H1speed", "rh4time", "rh4speed", "h4time"]}}
{"code": "package Round1A;\n  \n  \n  public class Problem3 {\n     public static void main(String[] args) throws FileNotFoundException\n     {\n         Scanner sc = new Scanner(new FileInputStream(\"C-small-attempt1.in\"));\n         PrintStream out = new PrintStream(new FileOutputStream(\"out3.txt\"));\n         long t = sc.nextLong();\n         sc.nextLine();\n         LOOP:\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             List<Integer> startState = new ArrayList<Integer>(6);\n             int dragH = sc.nextInt();\n             startingHealth = dragH;\n             int dragA = sc.nextInt();\n             int knH = sc.nextInt();\n             int knA = sc.nextInt();\n             int B = sc.nextInt();\n             int D = sc.nextInt();\n             startState.add(dragH);\n             startState.add(dragA);\n             startState.add(knH);\n             startState.add(knA);\n             startState.add(B);\n             startState.add(D);\n             startState.add(0);\n             List<Set<List<Integer>>> frontier = new ArrayList<>();\n             frontier.add(new HashSet<>());\n             frontier.get(0).add(startState);\n             Set<List<Integer>>  seen = new HashSet<>();\n             seen.add(startState);\n             for(int i=0;!frontier.get(i).isEmpty();i++)\n             {\n                 System.out.println(\"Case: \"+curcase+\" frontier: \"+frontier.get(i).size()+ \" i:\"+i + \"  seen:\"+seen.size());\n                 frontier.add(new HashSet<>());\n                 for(List<Integer> state : frontier.get(i))\n                 {\n                     if(state.get(2)<=0)\n                     {\n                         out.println(\"Case #\"+curcase+\": \"+i);\n                         continue LOOP;\n                     }\n                     if(state.get(0)<=0)\n                     {\n                         continue;\n                     }\n  \n                     for(Move m : Move.values())\n                     {\n                         if((state.get(0)> state.get(3))&&(m==Move.CURE))\n                         {\n                             continue;\n                         }\n                         \n                         if((state.get(6)==1)&&((m==Move.BUFF)||(m==Move.DEBUFF)))\n                         {\n                             continue;\n                         }\n                         List<Integer> newstate = step(state,m);\n                         if(m==Move.ATTACK)\n                         {\n                             newstate.set(6, 1);\n                         }\n                         boolean hasbetter = strictlyBetter(state,newstate);\n                         for(List<Integer> s:seen)\n                         {\n                             hasbetter = hasbetter ||strictlyBetter(s,newstate);\n                         }\n                         if(seen.contains(newstate))\n                             continue;\n                         seen.add(newstate); \n  \n                         if(!hasbetter)\n                         frontier.get(i+1).add(newstate);\n                     }\n                 }\n             }\n             out.println(\"Case #\"+curcase+\": IMPOSSIBLE\");\n         }\n         \n     }\n     public static int startingHealth;\n     public static List<Integer> step(List<Integer> config,Move move)\n     {\n         List<Integer> ret = new ArrayList<>(config);\n         switch(move)\n         {\n         case ATTACK:\n             ret.set(2, ret.get(2)-ret.get(1));\n             ret.set(0, ret.get(0)-ret.get(3));\n             return ret;\n         case BUFF:\n             ret.set(1, ret.get(1) + ret.get(4));\n             ret.set(0, ret.get(0)-ret.get(3));\n             return ret;\n         case DEBUFF:\n             ret.set(3, ret.get(3)-ret.get(5));\n             ret.set(0, ret.get(0)-ret.get(3));\n             return ret;\n         case CURE:\n             ret.set(0, startingHealth);\n             ret.set(0, ret.get(0)-ret.get(3));\n             return ret;\n         }\n         throw(new IllegalStateException());\n     }\n     \n     public static boolean strictlyBetter(List<Integer> s1,List<Integer> s2)\n     {\n         if((s1.get(0)>=s2.get(0))&&(s1.get(2)<=s2.get(2)&&(s1.get(1)>=s2.get(1))&&(s1.get(3)<=s2.get(3))))\n         return true;\n         return false;\n     }\n     public static enum Move\n     {\n         ATTACK,\n         BUFF,\n         DEBUFF,\n         CURE;\n     }\n  }\n", "substitutes": {"sc": ["SC", "Sc"], "out": ["Out"], "t": ["T"], "curcase": ["curase", "CurCase", "curce", "Curcase", "curCase", " curce", " curase"], "startState": [" startInfo", " startStates", "startStates", "startLine", "StartPoint", " startstate", "startGroup", "StartState", "startstate", " startTime", "startInfo", "startPoint", " startGroup", " startLine", "startTime"], "dragH": ["diagH", "DraggerA", "diaggedA", "draggedH", "draggerA", "DragH", "diaggedH", "draggedA", "diagA", "DragA", "DraggerH", "draggerH"], "startingHealth": ["StartPosition", "StartHealth", "startingPosition"], "dragA": ["DRacB", "diagB", "draggerB", "dracA", "dragB", "draggerA", "DRacA", "DRagA", "diaggerA", "dracB", "DRagB", "diagA", "diaggerB"], "knH": ["KnA", "KnH"], "knA": ["nnB", "knB", "KnA", "KnB", "nnA"], "B": ["A"], "D": ["F"], "frontier": [" frontiere", "Frontiers", "Frontier", "frontiers", "fronterer", "frontiere", " fronterer"], "state": ["State"]}}
{"code": " \n  \n  \n  public class A4 {\n     static Scanner s\u200cc = null;\n     static BufferedReader b\u200br = null;\n     static PrintWriter out = null;\n     static PrintStream s\u200dysout = System.out;\n     static Random rnd = new Random();\n     \n     int I\u200bNF = Integer.MAX_VALUE / 10;\n     double DF = 0.0000000001;\n     \n     long b = 1;\n     int N = 0;\n     int M = 0;\n     char[][] d = null;\n     char[][] a = null;\n     char q\u200ba = '?';\n     int R = 0;\n     int C = 0;\n     List<Character> list = null;\n     public void solve() throws Exception{\n         String s = b\u200br.readLine();\n         \n         String[] sp = s.split(\" \");\n         R = Integer.parseInt(sp[0]);\n         C = Integer.parseInt(sp[1]);\n         d = new char[R][C];\n         a = new char[R][C];\n         list = new ArrayList<>();\n         for(int i = 0; i < R; i++){\n             s = b\u200br.readLine();\n             for(int j = 0; j < C; j++){\n                 d[i][j] = s.charAt(j);\n                 a[i][j] = d[i][j];\n                 if(d[i][j] != q\u200ba && !list.contains(d[i][j])){\n                     list.add(d[i][j]);\n                 }\n             }\n         }\n         search(0, 0);\n         \n  \n     }\n     \n     boolean search(int r, int c){\n         int nr = 0;\n         int nc = 0;\n         if(r == R && c == C){\n             if(check()){\n                 println(\"\");\n                 for(int i = 0; i < R; i++){\n                     String s = \"\";\n                     for(int j = 0; j < C; j++){\n                         s += a[i][j];\n                     }\n                     println(s);\n                 }\n                 return true;\n             }\n             else{\n                 return false;\n             }\n         }\n         if(r == R-1 && c == C-1){\n             nr = R;\n             nc = C;\n         }\n         else if(c == C-1){\n             nr = r+1;\n             nc = 0;\n         }\n         else{\n             nr = r;\n             nc = c+1;\n         }\n         if(d[r][c] == q\u200ba){\n             for(int i = 0; i < list.size(); i++){\n                 a[r][c] = list.get(i);\n                 if(search(nr, nc)){\n                     return true;\n                 }\n             }\n             \n         }\n         else{\n             return search(nr, nc);\n         }\n         \n         return false;\n     }\n     \n     boolean check(){\n         boolean[][] used = new boolean[R][C];\n         for(int i = 0; i < R; i++){\n             for(int j = 0; j < C; j++){\n                 if(used[i][j]){\n                     continue;\n                 }\n                 if(!check2(used, i, j)){\n                     return false;\n                 }\n                 \n             }\n         }\n         return true;\n     }\n     boolean check2(boolean[][] used, int r, int c){\n     \n         \n         char target = a[r][c];\n         used[r][c] = true;\n         find(used, r, c, target);\n         for(int i = 0; i < R; i++){\n             for(int j =0; j < C; j++){\n                 if(!used[i][j] && a[i][j] == target){\n                     return false;\n                 }\n             }\n         }\n         for(int i = 0; i < R; i++){\n             for(int j =0; j < C; j++){\n                 if( a[i][j] == target){\n                     if(i > 0 && j > 0){\n                         if(a[i-1][j] == target && a[i][j-1] == target &&\n                                 a[i-1][j-1] != target){\n                             return false;\n                         }\n                     }\n                     if(i > 0 && j < C-1){\n                         if(a[i-1][j] == target && a[i][j+1] == target &&\n                                 a[i-1][j+1] != target){\n                             return false;\n                         }\n                     }\n                     if(i <  R-1 && j > 0){\n                         if(a[i+1][j] == target && a[i][j-1] == target &&\n                                 a[i+1][j-1] != target){\n                             return false;\n                         }\n                     }\n                     if(i <  R-1 && j < C-1){\n                         if(a[i+1][j] == target && a[i][j+1] == target &&\n                                 a[i+1][j+1] != target){\n                             return false;\n                         }\n                     }\n                 }\n             }\n         }\n         return true;\n         \n     }\n     \n     void find(boolean[][] used, int r, int c, char target){\n         int nr = r;\n         int nc = c;\n         if(r < R-1){\n             nr = r+1;\n             nc = c;\n             if(!used[nr][nc] && a[nr][nc] == target){\n                 used[nr][nc] = true;\n                 find(used, nr, nc, target);\n             }\n         }\n         if(r > 0){\n             nr = r-1;\n             nc = c;\n             if(!used[nr][nc] && a[nr][nc] == target){\n                 used[nr][nc] = true;\n                 find(used, nr, nc, target);\n             }\n         }\n         if(c < C-1){\n             nr = r;\n             nc = c+1;\n             if(!used[nr][nc] && a[nr][nc] == target){\n                 used[nr][nc] = true;\n                 find(used, nr, nc, target);\n             }\n         }\n         if(c > 0){\n             nr = r;\n             nc = c-1;\n             if(!used[nr][nc] && a[nr][nc] == target){\n                 used[nr][nc] = true;\n                 find(used, nr, nc, target);\n             }\n         }\n     }\n     \n     \n     public static void main(String[] args) throws Exception{\n         File file = new File(\"A-small-attempt2.in\");\n         if(file.exists()){\n             System.setIn(new BufferedInputStream(new FileInputStream(file)));\n         }\n         else{\n             throw new Exception(\"can't find a input file : \" + file.getAbsolutePath());\n         }\n         \n         b\u200br = new BufferedReader(new InputStreamReader(System.in));\n         FileWriter f\u200dw = new FileWriter(new File(\"output.txt\"));\n         out = new PrintWriter(f\u200dw);\n         \n         A4 b = new A4();\n         int T = 0;\n         if(s\u200cc != null){\n             T = s\u200cc.nextInt();\n         }\n         else{\n             T = parseInt(b\u200br.readLine());\n         }\n         int t = 1;\n         while(t <= T){\n             out.print(\"Case #\" + t + \": \");\n             System.out.print(\"Case #\" + t + \": \");\n             b.solve();\n             t++;\n         }\n         out.close();\n         f\u200dw.close();\n     }\n     \n     void print(int i){\n         out.print(i + \"\");\n         System.out.print(i);\n     }\n     void println(int i){\n         out.println(i + \"\");\n         System.out.println(i);\n     }\n     void print(String s){\n         out.print(s);\n         System.out.print(s);\n     }\n     void println(String s){\n         out.println(s);\n         System.out.println(s);\n     }\n     void print(long i){\n         out.print(i + \"\");\n         System.out.print(i);\n     }\n     void println(long i){\n         out.println(i + \"\");\n         System.out.println(i);\n     }\n  }\n", "substitutes": {"out": ["Out"], "rnd": ["Rng", "rng", "Rnd"], "DF": [" f", " df"], "b": ["B"], "d": ["p", "D"], "a": ["p", "alpha"], "s": ["p", "ings", "S"], "sp": ["p"], "i": ["I"], "j": ["ji", "ja"], "nr": ["nor", "NR"], "nc": ["n", "nt"]}}
{"code": " \n  public class Logging {\n     static class Point implements Comparable<Point> {\n         long x, y;\n         int i\u200cndex;\n  \n         public Point(long x, long y, int i) {\n             this.x = x;\n             this.y = y;\n             this.i\u200cndex = i;\n         }\n  \n         public int compareTo(Point o) {\n             if (x == o.x)\n                 return new Long(y).compareTo(o.y);\n             return  new Long(x).compareTo(o.x);\n         }\n     }\n  \n     static boolean cw(Point a, Point b, Point c) {\n         return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x) <= 0;\n     }\n  \n     public static Point[] c\u200convexHull(Point[] p) {\n         int n = p.length;\n         if (n <= 1)\n             return p;\n         Arrays.sort(p);\n         Point[] q = new Point[n * 2];\n         int c\u200bnt = 0;\n         for (int i = 0; i < n; q[c\u200bnt++] = p[i++])\n             for (; c\u200bnt > 1 && !cw(q[c\u200bnt - 2], q[c\u200bnt - 1], p[i]); --c\u200bnt)\n                 ;\n         for (int i = n - 2, t = c\u200bnt; i >= 0; q[c\u200bnt++] = p[i--])\n             for (; c\u200bnt > t && !cw(q[c\u200bnt - 2], q[c\u200bnt - 1], p[i]); --c\u200bnt)\n                 ;\n         return Arrays.copyOf(q, c\u200bnt - 1 - (q[0].compareTo(q[1]) == 0 ? 1 : 0));\n     }\n  \n     public static void main(String[] args) throws Exception {\n  \n         InputReader r = new InputReader(new FileReader(\"C-small-attempt1.in\"));\n         PrintWriter out = new PrintWriter(new FileWriter(\"C_Submit.txt\"));\n         int T = r.nextInt();\n         int test = 1;\n         while (T-- > 0) {\n             int n = r.nextInt();\n             Point[] arr = new Point[n];\n             for (int i = 0; i < arr.length; i++) {\n                 arr[i] = new Point(r.nextInt(), r.nextInt(), i);\n             }\n             int[] res = new int[n];\n             Arrays.fill(res, 1 << 28);\n             for (int i = 0; i < 1 << n; i++) {\n                 Point[] t = new Point[Integer.bitCount(i)];\n                 int i\u200cndex = 0;\n                 for (int j = 0; j < n; j++) {\n                     if ((i & (1 << j)) > 0) {\n                         t[i\u200cndex++] = new Point(arr[j].x, arr[j].y, arr[j].i\u200cndex);\n                     }\n                 }\n                 Point[] c\u200convexHull = c\u200convexHull(t);\n                 for (Point p : c\u200convexHull) {\n                     res[p.i\u200cndex] = Math.min(res[p.i\u200cndex], n - Integer.bitCount(i));\n                 }\n             }\n             out.printf(\"Case #%d:\n\", test++);\n             for (int x : res)\n                 out.println(x);\n         }\n         out.close();\n     }\n  \n     static class InputReader {\n         private BufferedReader reader;\n         private StringTokenizer tokenizer;\n  \n         public InputReader(InputStream stream) {\n             reader = new BufferedReader(new InputStreamReader(stream));\n             tokenizer = null;\n         }\n  \n         public InputReader(FileReader stream) {\n             reader = new BufferedReader(stream);\n             tokenizer = null;\n         }\n  \n         public String nextLine() {\n             try {\n                 return reader.readLine();\n             } catch (IOException e) {\n                 \n                 e.printStackTrace();\n                 return null;\n             }\n         }\n  \n         public String next() {\n             while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                 try {\n                     tokenizer = new StringTokenizer(reader.readLine());\n                 } catch (IOException e) {\n                     throw new RuntimeException(e);\n                 }\n             }\n             return tokenizer.nextToken();\n         }\n  \n         public int nextInt() {\n             return Integer.parseInt(next());\n         }\n  \n         public long nextLong() {\n             return Long.parseLong(next());\n         }\n     }\n  }\n", "substitutes": {"i": ["index", "pi"], "o": ["u", "e", "O"], "c": ["ac", "e", "C"], "n": ["yn", "N", "nt"], "r": ["R"], "out": ["Out"], "nextInt": ["nextint", " nextint"]}}
{"code": " \n  \n  public class ProbBsmall {\n     public static void main(String[] args) {\n         Scanner sc = new Scanner(System.in);\n         int numcases = sc.nextInt();\n         for(int curcase = 1; curcase<=numcases; curcase++)\n         {\n             int N = sc.nextInt();\n             double V = sc.nextDouble();\n             double X = sc.nextDouble();\n             double[] R = new double[N];\n             double[] S = new double[N];\n             for(int i=0;i<N;i++)\n             {\n                 R[i] =sc.nextDouble();\n                 S[i] = sc.nextDouble();\n             }\n             if(N==1)\n             {\n                 if(X == S[0])\n                 System.out.println(\"Case #\"+curcase+\": \"+(V/R[0]));\n                 else\n                 System.out.println(\"Case #\"+curcase+\": IMPOSSIBLE\");\n             }else\n             {\n             if(S[0] == S[1])\n             {\n                 if(X == S[0])\n                 System.out.println(\"Case #\"+curcase+\": \"+(V/(R[0]+R[1])));\n                 else\n                 System.out.println(\"Case #\"+curcase+\": IMPOSSIBLE\");    \n                 continue;\n             }\n             if(S[0]==X)\n             {\n                 System.out.println(\"Case #\"+curcase+\": \"+(V/(R[0])));\n                 continue;\n             }\n             if(S[1]==X)\n             {\n                 System.out.println(\"Case #\"+curcase+\": \"+(V/(R[1])));\n                 continue;\n             }\n             \n             if(((X>S[0])&&(X>S[1]))||((X<S[0])&&(X<S[1])))\n                 {System.out.println(\"Case #\"+curcase+\": IMPOSSIBLE\");   continue;}\n             \n  \n             double t2 = V*(X-S[0])/(R[1]*(S[1]-S[0]));\n             double t1 = (V - R[1]*t2)/R[0];\n             System.out.println(\"Case #\"+curcase+\": \"+Math.max(t1, t2));\n                     \n             }\n         }\n     }\n  }\n", "substitutes": {"sc": ["sci", "c", "Sc"], "numcases": ["normblocks", "numcase", "ncase", "normcases", "ncases", "numblocks"], "curcase": ["curce", "curCase", "curcases", " curce", " curcases", " curCase"], "N": ["n"], "V": ["U"], "X": ["x", "Y"], "S": ["s"], "t2": ["p2", "p4", "t4"], "t1": ["f3", "t3", "f1"]}}
{"code": "package rc;\n  \n  \n  \n  public class p1 {\n  \n      public static void main(String[]args) throws IOException {\n          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n          PrintWriter pw = new PrintWriter(System.out);\n          int T = Integer.parseInt(br.readLine());\n          for(int i=1;i<=T;i++) {\n              pw.println(\"Case #\" + i + \": \" + solve(br));\n          }\n          pw.flush();\n      }\n  \n      private static String solve(BufferedReader br) throws IOException {\n          int N = Integer.parseInt(br.readLine());\n          int[] v = new int[N];\n          StringTokenizer s\u200ct = new StringTokenizer(br.readLine());\n          List<P> ss = new ArrayList<>();\n          for(int i=0;i<N;i++) {\n              ss.add(new P(i, Integer.parseInt(s\u200ct.nextToken())));\n          }\n          StringBuilder b\u200cob = new StringBuilder();\n          while(ss.size() > 2) {\n              Collections.sort(ss);\n              P last = ss.get(ss.size()-1);\n              b\u200cob.append((char)('A' + last.i\u200bdx)).append(\" \");\n              if (last.v == 1) {\n                  ss.remove(ss.size()-1);\n              }\n              else {\n                  last.v--;\n              }\n          }\n          \n          if (ss.size() > 0) {\n              int iter = ss.get(0).v;\n              char A = (char)('A' + ss.get(0).i\u200bdx);\n              char B = (char)('A' + ss.get(1).i\u200bdx);\n              while(iter > 0) {\n                  iter--;\n                  b\u200cob.append(A).append(B).append(\" \");\n              }\n          }\n          return b\u200cob.toString();\n      }\n  \n      private static final class P implements Comparable<P>{\n          int v, i\u200bdx;\n  \n          public P(int i\u200bdx, int v) {\n              this.v = v;\n              this.i\u200bdx = i\u200bdx;\n          }\n  \n          @Override\n          public int compareTo(P o) {\n              if (v != o.v) return v - o.v;\n              return i\u200bdx - o.i\u200bdx;\n          }\n  \n          @Override\n          public String toString() {\n              return \"P{\" +\n                      \"v=\" + v +\n                      \", i\u200bdx=\" + i\u200bdx +\n                      '}';\n          }\n      }\n  \n      public static void debug(Object...args) {\n          System.out.println(Arrays.deepToString(args));\n      }\n  }\n", "substitutes": {"br": ["BR"], "pw": ["Pw", "pW", "PW", " pW"], "i": ["c", "p"], "N": ["n"], "v": ["p", "V"], "ss": ["SS", "rss", "ps", "ws", "css"], "P": ["p", " p"], "iter": ["limit", "Iter"], "o": ["os"]}}
{"code": " \n  public class C {\n     FastScanner i\u200dn;\n     PrintWriter out;\n  \n     class Point {\n         int x, y;\n  \n         public Point(int x, int y) {\n             super();\n             this.x = x;\n             this.y = y;\n         }\n  \n     }\n  \n     class Event implements Comparable<Event> {\n         int x, y;\n         int s\u200cide;\n         int type;\n  \n         public Event(int x, int y, int type) {\n             super();\n             this.x = x;\n             this.y = y;\n             this.s\u200cide = y > 0 || (y == 0 && x > 0) ? -1 : 1;\n             this.type = type;\n         }\n  \n         @Override\n         public int compareTo(Event o) {\n             if (s\u200cide != o.s\u200cide) {\n                 return Integer.compare(s\u200cide, o.s\u200cide);\n             }\n             long v\u200dmul = x * 1L * o.y - y * 1L * o.x;\n             if (v\u200dmul != 0) {\n                 return Long.signum(-v\u200dmul);\n             }\n             return Integer.compare(type, o.type);\n         }\n  \n     }\n  \n     void solve() {\n         int tc = i\u200dn.nextInt();\n         for (int t = 0; t < tc; t++) {\n             out.println(\"Case #\" + (t + 1) + \":\");\n             int n = i\u200dn.nextInt();\n             Point[] a = new Point[n];\n             for (int i = 0; i < n; i++) {\n                 a[i] = new Point(i\u200dn.nextInt(), i\u200dn.nextInt());\n             }\n             int[] r\u200ces = new int[n];\n             Arrays.fill(r\u200ces, n - 1);\n             for (int mul = -1; mul < 2; mul += 2) {\n                 for (int i = 0; i < n; i++) {\n                     ArrayList<Event> e\u200bvents = new ArrayList<>();\n                     int cur = 0;\n                     for (int j = 0; j < n; j++) {\n                         if (j != i) {\n                             Event s\u200ctart = new Event(mul * (a[j].x - a[i].x),\n                                     mul * (a[j].y - a[i].y), +1);\n                             Event end = new Event(mul * (a[i].x - a[j].x), mul\n                                     * (a[i].y - a[j].y), -1);\n                             e\u200bvents.add(s\u200ctart);\n                             e\u200bvents.add(end);\n                             if (s\u200ctart.compareTo(end) > 0) {\n                                 cur++;\n                             }\n                         }\n                     }\n                     Collections.sort(e\u200bvents);\n                     r\u200ces[i] = Math.min(r\u200ces[i], cur);\n                     for (Event e : e\u200bvents) {\n                         cur += e.type;\n                         r\u200ces[i] = Math.min(r\u200ces[i], cur);\n                     }\n                 }\n             }\n             for (int x : r\u200ces) {\n                 out.println(x);\n             }\n             System.err.println((t + 1) + \"/\" + tc + \" done\");\n         }\n     }\n  \n     void run() {\n         try {\n             i\u200dn = new FastScanner(new File(\"C.i\u200dn\"));\n             out = new PrintWriter(new File(\"C.out\"));\n  \n             solve();\n  \n             out.close();\n         } catch (FileNotFoundException e) {\n             e.printStackTrace();\n         }\n     }\n  \n     void runIO() {\n         i\u200dn = new FastScanner(System.i\u200dn);\n         out = new PrintWriter(System.out);\n  \n         solve();\n  \n         out.close();\n     }\n  \n     class FastScanner {\n         BufferedReader br;\n         StringTokenizer st;\n  \n         public FastScanner(File f) {\n             try {\n                 br = new BufferedReader(new FileReader(f));\n             } catch (FileNotFoundException e) {\n                 e.printStackTrace();\n             }\n         }\n  \n         public FastScanner(InputStream f) {\n             br = new BufferedReader(new InputStreamReader(f));\n         }\n  \n         String next() {\n             while (st == null || !st.hasMoreTokens()) {\n                 String s = null;\n                 try {\n                     s = br.readLine();\n                 } catch (IOException e) {\n                     e.printStackTrace();\n                 }\n                 if (s == null)\n                     return null;\n                 st = new StringTokenizer(s);\n             }\n             return st.nextToken();\n         }\n  \n         boolean hasMoreTokens() {\n             while (st == null || !st.hasMoreTokens()) {\n                 String s = null;\n                 try {\n                     s = br.readLine();\n                 } catch (IOException e) {\n                     e.printStackTrace();\n                 }\n                 if (s == null)\n                     return false;\n                 st = new StringTokenizer(s);\n             }\n             return true;\n         }\n  \n         int nextInt() {\n             return Integer.parseInt(next());\n         }\n  \n         long nextLong() {\n             return Long.parseLong(next());\n         }\n  \n         double nextDouble() {\n             return Double.parseDouble(next());\n         }\n     }\n  \n     public static void main(String[] args) {\n         new C().run();\n     }\n  }\n", "substitutes": {"i": ["id", "I", "ii"], "out": ["Out"], "s": ["ss"], "o": ["O"], "tc": ["TC"], "t": ["T"], "n": ["N"], "a": ["p"], "mul": [" muli", "cmul", "Mul", "cmuli", "MUL", "muli", "mUL"], "e": ["en", "ee"], "j": ["ji"]}}
{"code": " \n  \n  \n  public class C_Qual_GCJ2015 {\n  \n      public static long M\u200bOD = 1000000007;\n      static int[] X = {0, 1};\n      static int[] Y = {1, 0};\n      static int[][] dp;\n      static int[][] check;   \n  \n      public static void main(String[] args) throws FileNotFoundException {\n          PrintWriter o\u200dut = new PrintWriter(new FileOutputStream(new File(\"output.txt\")));\n         \n          Scanner in = new Scanner();\n          dp = new int[1001][1001];\n          check = new int[1001][1001];\n          int T = in.nextInt();\n          for (int t = 0; t < T; t++) {\n              boolean ok = true;\n              int l = in.nextInt();\n              int x = in.nextInt();\n              String line = in.next();\n              char pre = ' ';\n              boolean h\u200dasI = false;\n              boolean hasJ = false;\n              boolean n\u200degative = false;\n              for (int i = 0; i < x; i++) {\n                  for (int j = 0; j < l; j++) {\n                      char cur = line.charAt(j);\n                      if (pre == ' ' || pre == '1') {\n                          pre = cur;\n                      } else {\n                          if (pre == 'i') {\n                              if (cur == 'i') {\n                                  pre = '1';\n                                  n\u200degative = !n\u200degative;\n                              } else if (cur == 'j') {\n                                  pre = 'k';\n                              } else {\n                                  pre = 'j';\n                                  n\u200degative = !n\u200degative;\n                              }\n                          } else if (pre == 'j') {\n                              if (cur == 'i') {\n                                  pre = 'k';\n                                  n\u200degative = !n\u200degative;\n                              } else if (cur == 'j') {\n                                  pre = '1';\n                                  n\u200degative = !n\u200degative;\n                              } else {\n                                  pre = 'i';\n                              }\n                          } else {\n                              if (cur == 'i') {\n                                  pre = 'j';\n                              } else if (cur == 'j') {\n                                  pre = 'i';\n                                  n\u200degative = !n\u200degative;\n                              } else {\n                                  pre = '1';\n                                  n\u200degative = !n\u200degative;\n                              }\n                          }\n                      }\n                      if (pre == 'i' && !n\u200degative) {\n                          h\u200dasI = true;\n                      } else if (pre == 'k' && h\u200dasI && !n\u200degative) {\n                          hasJ = true;\n                      }\n                  }\n              }\n  \n              if (h\u200dasI && hasJ && pre == '1' && n\u200degative) {\n                  o\u200dut.println(\"Case #\" + (t + 1) + \": YES\");\n              } else {\n                  o\u200dut.println(\"Case #\" + (t + 1) + \": NO\");\n              }\n          }\n          o\u200dut.close();\n      }\n  \n      public static int[] KMP(String v\u200bal) {\n          int i = 0;\n          int j = -1;\n          int[] result = new int[v\u200bal.length() + 1];\n          result[0] = -1;\n          while (i < v\u200bal.length()) {\n              while (j >= 0 && v\u200bal.charAt(j) != v\u200bal.charAt(i)) {\n                  j = result[j];\n              }\n              j++;\n              i++;\n              result[i] = j;\n          }\n          return result;\n  \n      }\n  \n      public static boolean nextPer(int[] data) {\n          int i = data.length - 1;\n          while (i > 0 && data[i] < data[i - 1]) {\n              i--;\n          }\n          if (i == 0) {\n              return false;\n          }\n          int j = data.length - 1;\n          while (data[j] < data[i - 1]) {\n              j--;\n          }\n          int temp = data[i - 1];\n          data[i - 1] = data[j];\n          data[j] = temp;\n          Arrays.sort(data, i, data.length);\n          return true;\n      }\n  \n      public static int digit(long n) {\n          int result = 0;\n          while (n > 0) {\n              n /= 10;\n              result++;\n          }\n          return result;\n      }\n  \n      public static double dist(long a, long b, long x, long y) {\n          double v\u200bal = (b - a) * (b - a) + (x - y) * (x - y);\n          v\u200bal = Math.sqrt(v\u200bal);\n          double other = x * x + a * a;\n          other = Math.sqrt(other);\n          return v\u200bal + other;\n  \n  \n  \n      }\n  \n      public static class Point implements Comparable<Point> {\n  \n          int x, y;\n  \n          public Point(int s\u200dtart, int end) {\n              this.x = s\u200dtart;\n              this.y = end;\n          }\n  \n          @Override\n          public int hashCode() {\n              int hash = 5;\n              hash = 47 * hash + this.x;\n              hash = 47 * hash + this.y;\n              return hash;\n          }\n  \n          @Override\n          public boolean equals(Object obj) {\n              if (obj == null) {\n                  return false;\n              }\n              if (getClass() != obj.getClass()) {\n                  return false;\n              }\n              final Point other = (Point) obj;\n              if (this.x != other.x) {\n                  return false;\n              }\n              if (this.y != other.y) {\n                  return false;\n              }\n              return true;\n          }\n  \n          @Override\n          public int compareTo(Point o) {\n              return x - o.x;\n          }\n      }\n  \n      public static class FT {\n  \n          long[] data;\n  \n          FT(int n) {\n              data = new long[n];\n          }\n  \n          public void update(int index, long value) {\n              while (index < data.length) {\n                  data[index] += value;\n                  index += (index & (-index));\n              }\n          }\n  \n          public long get(int index) {\n              long result = 0;\n              while (index > 0) {\n                  result += data[index];\n                  index -= (index & (-index));\n              }\n              return result;\n  \n          }\n      }\n  \n      public static long gcd(long a, long b) {\n          if (b == 0) {\n              return a;\n          }\n          return gcd(b, a % b);\n      }\n  \n      public static long pow(long a, long b) {\n          if (b == 0) {\n              return 1;\n          }\n          if (b == 1) {\n              return a;\n          }\n          long v\u200bal = pow(a, b / 2);\n          if (b % 2 == 0) {\n              return v\u200bal * v\u200bal % M\u200bOD;\n          } else {\n              return v\u200bal * (v\u200bal * a % M\u200bOD) % M\u200bOD;\n  \n  \n          }\n      }\n  \n      static class Scanner {\n  \n          BufferedReader br;\n          StringTokenizer st;\n  \n          public Scanner() throws FileNotFoundException {\n              \n              \n              br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(\"C-small-attempt0.in\"))));\n          }\n  \n          public String next() {\n  \n              while (st == null || !st.hasMoreTokens()) {\n                  try {\n                      st = new StringTokenizer(br.readLine());\n                  } catch (Exception e) {\n                      throw new RuntimeException();\n                  }\n              }\n              return st.nextToken();\n          }\n  \n          public long nextLong() {\n              return Long.parseLong(next());\n          }\n  \n          public int nextInt() {\n              return Integer.parseInt(next());\n          }\n  \n          public double nextDouble() {\n              return Double.parseDouble(next());\n          }\n  \n          public String nextLine() {\n              st = null;\n              try {\n                  return br.readLine();\n              } catch (Exception e) {\n                  throw new RuntimeException();\n              }\n          }\n  \n          public boolean endLine() {\n              try {\n                  String next = br.readLine();\n                  while (next != null && next.trim().isEmpty()) {\n                      next = br.readLine();\n                  }\n                  if (next == null) {\n                      return true;\n                  }\n                  st = new StringTokenizer(next);\n                  return st.hasMoreTokens();\n              } catch (Exception e) {\n                  throw new RuntimeException();\n              }\n          }\n      }\n  }\n", "substitutes": {"dp": ["DP"], "in": ["ins", "IN"], "l": ["L"], "line": ["lin", "Line"], "pre": ["pr", "prefix"], "j": ["ji"], "n": ["c", "N"], "o": ["O"]}}
{"code": "package qualif;\n  \n  \n  public class Pancakes {\n  \n      public static void main(String[]args) throws IOException {\n          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n          PrintWriter pw = new PrintWriter(System.out);\n          int T = Integer.parseInt(br.readLine());\n          for(int i=1;i<=T;i++) {\n              pw.println(\"Case #\" + i + \": \" + solve(br));\n          }\n          pw.flush();\n      }\n  \n      private static String solve(BufferedReader br) throws IOException {\n          StringTokenizer s\u200bt = new StringTokenizer(br.readLine());\n          String pat = s\u200bt.nextToken();\n          int N = Integer.parseInt(s\u200bt.nextToken());\n          boolean[] p = new boolean[pat.length()];\n          boolean impos = false;\n          int m\u200doves = 0;\n          for (int i = 0; i < pat.length(); i++) {\n              if ((pat.charAt(i) == '-' && !p[i]) || (pat.charAt(i) == '+' && p[i])) {\n                  if (i + N > pat.length()) {\n                      impos = true;\n                      break;\n                  }\n                  for (int j = i; j < i + N; j++) {\n                      p[j] = !p[j];\n                  }\n                  m\u200doves++;\n              }\n          }\n          if (impos) {\n              return \"IMPOSSIBLE\";\n          }\n          return \"\" + m\u200doves;\n      }\n  \n      public static void debug(Object...args) {\n          System.out.println(Arrays.deepToString(args));\n      }\n  }\n", "substitutes": {"br": ["BR"], "pw": ["Pw", "pW", "ppws", "ppw", "Pws", "pws", "PW"], "pat": ["patch", "Pat"], "N": ["C", "n"], "p": ["P"], "j": ["ji"], "impos": ["ompos", "empos", "imposition", "impose", "ompo", "simpos", "empose", "simposition", "impo"]}}
{"code": "package gcj2016.q;\n  \n  public class A implements Runnable {\n     static final boolean L\u200cARGE = false;\n     static final boolean P\u200cROD = true;\n     static final int NTHREAD = 1;\n     static String BASEPATH = \"c:\\\\temp\\\\gcj2016\\\\q\\\\\";\n  \n     \n     static String INPATH = BASEPATH + A.class.getSimpleName().charAt(0) + (L\u200cARGE ? \"-large.i\u200bn\" : \"-small-attempt0.i\u200bn\");\n  \n     static String O\u200bUTPATH = INPATH.substring(0, INPATH.length()-3) + new SimpleDateFormat(\"-HHmmss\").format(new Date()) + \".out\";\n     \n     static String INPUT = \"\";\n     \n     long n;\n     \n     public void read() \n     {\n         n = ni();\n     }\n     \n     public void process() \n     {\n         if(n == 0){\n             out.println(\"INSOMNIA\");\n             return;\n         }\n         int ptn = 0;\n         long m = n;\n         while(true){\n             for(long u = m;u > 0;u/=10){\n                 ptn |= 1L<<u%10;\n             }\n             if(ptn == 1023){\n                 out.println(m);\n                 return;\n             }\n             m += n;\n         }\n         \n     }\n     \n     public static void preprocess()\n     {\n     }\n     \n     Scanner i\u200bn;\n     PrintWriter out;\n     StringWriter sw;\n     int cas;\n     static List<Status> r\u200bunning = new ArrayList<Status>();\n     \n     @Override\n     public void run()\n     {\n         long S = System.nanoTime();\n         \n         synchronized(r\u200bunning){\n             Status st = new Status();\n             st.id = cas;\n             st.S = S;\n             r\u200bunning.add(st);\n         }\n         process();\n         \n         synchronized(r\u200bunning){\n             for(Status st : r\u200bunning){\n                 if(st.id == cas){\n                     r\u200bunning.remove(st);\n                     break;\n                 }\n             }\n         }\n         long G = System.nanoTime();\n         \n         if(P\u200cROD){\n             System.err.println(\"case \" + cas + \" solved. [\" + (G-S)/1000000 + \"ms]\");\n             synchronized(r\u200bunning){\n                 StringBuilder sb = new StringBuilder(\"r\u200bunning : \");\n                 for(Status st : r\u200bunning){\n                     sb.append(st.id + \":\" + (G-st.S)/1000000 + \"ms, \");\n                 }\n                 System.err.println(sb);\n             }\n         }\n     }\n     \n     private static class Status {\n         public int id;\n         public long S;\n     }\n     \n     public A(int cas, Scanner i\u200bn)\n     {\n         this.cas = cas;\n         this.i\u200bn = i\u200bn;\n         this.sw = new StringWriter();\n         this.out = new PrintWriter(this.sw);\n     }\n     \n     private int ni() { return Integer.parseInt(i\u200bn.next()); }\n     private long nl() { return Long.parseLong(i\u200bn.next()); }\n     private int[] na(int n) { int[] a = new int[n]; for(int i = 0;i < n;i++)a[i] = ni(); return a; }\n     private double nd() { return Double.parseDouble(i\u200bn.next()); }\n     private void tr(Object... o) { if(!P\u200cROD)System.out.println(Arrays.deepToString(o)); }\n     \n     public static void main(String[] args) throws Exception\n     {\n         long start = System.nanoTime();\n         \n         ExecutorService es = Executors.newFixedThreadPool(NTHREAD);\n         CompletionService<A> cs = new ExecutorCompletionService<A>(es);\n         \n         if(P\u200cROD){\n             System.out.println(\"INPATH : \" + INPATH);\n             System.out.println(\"O\u200bUTPATH : \" + O\u200bUTPATH);\n         }\n         Scanner i\u200bn = P\u200cROD ? new Scanner(new File(INPATH)) : new Scanner(INPUT);\n         PrintWriter out = P\u200cROD ? new PrintWriter(new File(O\u200bUTPATH)) : new PrintWriter(System.out);\n         int n = i\u200bn.nextInt();\n         i\u200bn.nextLine();\n         \n         preprocess();\n         for(int i = 0;i < n;i++){\n             A runner = new A(i+1, i\u200bn);\n             runner.read();\n             cs.submit(runner, runner);\n         }\n         es.shutdown();\n         String[] outs = new String[n];\n         for(int i = 0;i < n;i++){\n             A runner = cs.take().get(); \n             runner.out.flush();\n             runner.out.close();\n             outs[runner.cas-1] = runner.sw.toString();\n         }\n         for(int i = 0;i < n;i++){\n             out.printf(\"Case #%d: \", i+1);\n             out.append(outs[i]);\n             out.flush();\n         }\n         \n         long end = System.nanoTime();\n         System.out.println((end - start)/1000000 + \"ms\");\n         if(P\u200cROD){\n             System.out.println(\"INPATH : \" + INPATH);\n             System.out.println(\"O\u200bUTPATH : \" + O\u200bUTPATH);\n         }\n     }\n  }\n", "substitutes": {"NTHREAD": [" nTHREAD", " nthREAD", "NthINK", " nTHINK", "NTHINK", "NthREAD", " nthINK"], "BASEPATH": [" BASEPath", "BEASSPATH", "BASSPATH", " BASSPath", "BASSPath", " BASSPATH", "BEASSPath", "BEASEPATH", "BASEPath", "BEASEPath"], "INPATH": ["INPUT", " INPUT"], "n": ["N"], "ptn": ["ptN", "PTN", "PTn"], "m": ["M"], "u": ["U"], "out": ["Out"], "sw": ["SW"], "cas": ["Cas"], "S": ["P", "N", "SU", "Sc"], "st": ["St"], "id": ["type", "sid"], "G": ["M", "g"], "a": ["am"], "o": ["O"]}}
{"code": " public class A {\n     static BufferedReader b\u200cr;\n     static StringTokenizer s\u200dt;\n     static PrintWriter p\u200cw;\n  \n     public static void main(String[] args) throws Exception {\n         b\u200cr = new BufferedReader(new InputStreamReader(System.in));\n         p\u200cw = new PrintWriter(new BufferedWriter(new FileWriter(\"a.out\")));\n         final int M\u200bAX_CASES = readInt();\n         for(int c\u200dasenum = 1; c\u200dasenum <= M\u200bAX_CASES; c\u200dasenum++) {\n             p\u200cw.printf(\"Case #%d: \", c\u200dasenum);\n             long n = readLong();\n             long last = -1;\n             Set<Integer> set = new HashSet<Integer>();\n             for(int i = 1; i <= 100 && set.size() < 10; i++) {\n                 long curr = n * i;\n                 last = curr;\n                 while(curr > 0) {\n                     set.add((int)(curr%10));\n                     curr /= 10;\n                 }\n             }\n             if(set.size() < 10) {\n                 p\u200cw.println(\"INSOMNIA\");\n             }\n             else {\n                 p\u200cw.println(last);\n             }\n         }\n         p\u200cw.close();\n     }\n  \n     public static int readInt() {\n         return Integer.parseInt(nextToken());\n     }\n  \n     public static long readLong() {\n         return Long.parseLong(nextToken());\n     }\n  \n     public static double readDouble() {\n         return Double.parseDouble(nextToken());\n     }\n  \n     public static String nextToken() {\n         while(s\u200dt == null || !s\u200dt.hasMoreTokens())    {\n             try {\n                 if(!b\u200cr.ready()) {\n                     p\u200cw.close();\n                     System.exit(0);\n                 }\n                 s\u200dt = new StringTokenizer(b\u200cr.readLine());\n             }\n             catch(IOException e) {\n                 System.err.println(e);\n                 System.exit(1);\n             }\n         }\n         return s\u200dt.nextToken();\n     }\n  \n     public static String readLine() {\n         s\u200dt = null;\n         try {\n             return b\u200cr.readLine();\n         }\n         catch(IOException e) {\n             System.err.println(e);\n             System.exit(1);\n             return null;\n         }\n     }\n  \n  }\n", "substitutes": {"b": ["B"], "s": ["t", "S"], "p": ["pp", "c"], "u": ["U"], "n": ["N", "c"], "last": ["max"], "curr": ["serrc", "serr", " curR", " currs", "currc", "curR", "currs"]}}
{"code": " \n  \n  class Codejam {\n  \n      public static void main(String args[]) {\n          Scanner in = null;\n         try {\n             in = new Scanner(new FileInputStream(\"input.txt\"));\n         } catch (FileNotFoundException e) {\n             \n             e.printStackTrace();\n         }\n         try {\n             System.setOut(new PrintStream(\"output.txt\"));\n         } catch (FileNotFoundException e) {\n             \n             e.printStackTrace();\n         }\n         \n          int T = in.nextInt(); \n          for (int t = 1; t <= T; t++) {\n             in.nextLine();\n             int r = in.nextInt();\n             int c = in.nextInt();\n             int n = in.nextInt();\n             int r\u200cet = 1000000000;\n             for (int m = (1 << (r * c)) - 1; m >= 0; m--) {\n                 \n                 Set<Integer> set = new HashSet<Integer> ();\n                 set.clear();\n                 int c\u200dount = 0;\n                 int s = 0;\n                 for (int b = r*c - 1; b>= 0; b--) {\n                     if ((m & (1 << b)) != 0) {\n                         c\u200dount++;\n                         if (b % c > 0 && set.contains(b-1))s++;\n                         if (b % c < c - 1 && set.contains(b + 1))s++;\n                         if (set.contains(b-c))s++;\n                         if (set.contains(b+c))s++;\n                         set.add(b);\n                     }\n                 }\n                 if (c\u200dount == n && s < r\u200cet) {\n                     r\u200cet = s;\n                 }\n             }\n             \n             System.out.println(\"Case #\" + t + \": \"  + r\u200cet);\n             \n          }\n          \n          \n      }\n   \n  }\n", "substitutes": {"in": ["ins", "In", "IN"], "T": ["N"], "r": ["p", "R"], "c": ["e", "C"], "n": ["p"], "m": ["M"], "s": ["i", "p", "its"]}}
{"code": "package Qualification;\n  \n  \n  public class ProbA {\n  public static void main(String[] args)\n  {\n     Scanner sc = new Scanner(System.in);\n     long t = sc.nextInt();\n     for(int curcase=1;curcase<=t;curcase++)\n     {\n         long N = sc.nextInt();\n         boolean[] seen = new boolean[10];\n         if(N==0)\n         {\n             System.out.println(\"Case #\"+curcase+\": INSOMNIA\");\n             continue;\n         }\n         for(int i=1;true;i++)\n         {\n             \n             digits(i*N,seen);\n             if(check(seen))\n             {\n                 System.out.println(\"Case #\"+curcase+\": \"+(i*N));\n                 break;\n             }\n         }\n     }\n     \n  }\n  public static boolean check(boolean[] a)\n  {\n     for(int i=0;i<10;i++)\n         if(!a[i])\n             return false;\n     return true;\n  }\n  public static void digits(long n,boolean[] arr)\n  {\n     if(n==0)\n         return;\n     arr[(int)n%10]=true;\n     digits(n/10,arr);\n  }\n  }\n", "substitutes": {"sc": ["Sc"], "t": ["T"], "curcase": ["curase", "curce", "curCase", " curce", " curCase", " curase"], "N": ["T"], "seen": ["expected"], "a": ["sa", "A"]}}
{"code": "package Round1B;\n  \n  \n  public class ProblemA {\n     public static void main(String[] args) throws FileNotFoundException\n     {\n         Scanner sc = new Scanner(new FileInputStream(\"A-small-attempt0.in\"));\n         PrintStream out = new PrintStream(new FileOutputStream(\"out1.txt\"));\n         long t = sc.nextLong();\n         sc.nextLine();\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             int D = sc.nextInt();\n             int N = sc.nextInt();\n             int[] K = new int[N];\n             int[] S = new int[N];\n             for(int i=0;i<N;i++)\n             {\n                 K[i] = sc.nextInt();\n                 S[i] = sc.nextInt();\n             }\n             double fastest = Double.MAX_VALUE;\n             for(int i=0;i<N;i++)\n             {\n                 fastest = Math.min(fastest, ((double)S[i]*D)/(D-K[i]));\n             }\n             \n             out.println(\"Case #\"+curcase+\": \"+fastest);\n         }\n         \n     }\n  }\n", "substitutes": {"sc": ["SC", "Sc"], "out": ["Out"], "t": ["T"], "curcase": ["curase", "curCase", " curCase", " curase"], "D": ["d"], "N": ["n"], "K": ["KS"], "S": ["s"], "fastest": ["FastEST", " fastEST", "Fastest", " fasthest", "fastEST", "fasthest"]}}
{"code": " \n  \n  public class B {\n      @SuppressWarnings(\"FieldCanBeLocal\")\n      private static int c\u200daseNumber;\n      private static Scanner scan;\n      private List<Entry> d;\n  \n      int f() {\n          merge();\n  \n          Entry max = d.get(0);\n          int res1 = max.v\u200dal;\n  \n          int res2 = Integer.MAX_VALUE;\n          if (max.count < res1) {\n              for (int div = 2; div <= max.v\u200dal; ++div) {\n                  List<Entry> o\u200crig = d;\n  \n                  d = c\u200bopy(d);\n                  max = d.get(0);\n                  int val1 = max.v\u200dal / div;\n                  int v\u200dal2 = max.v\u200dal - val1;\n                  max.v\u200dal = val1;\n                  d.add(new Entry(v\u200dal2, max.count));\n                  res2 = Math.min(res2, max.count + f());\n  \n                  d = o\u200crig;\n              }\n          }\n  \n          return Math.min(res1, res2);\n      }\n  \n      List<Entry> c\u200bopy(List<Entry> d) {\n          List<Entry> c\u200bopy = new ArrayList<Entry>(d.size());\n          for (Entry e : d) {\n              c\u200bopy.add(new Entry(e.v\u200dal, e.count));\n          }\n  \n          return c\u200bopy;\n      }\n  \n      void solve() {\n          int n = scan.nextInt();\n          d = new ArrayList<Entry>(n);\n          for (int i = 0; i < n; ++i) {\n              d.add(new Entry(scan.nextInt(), 1));\n          }\n  \n          \n  \n          System.out.printf(\"%s\n\", f());\n      }\n  \n      void merge() {\n          sort(d);\n  \n          List<Entry> result = new ArrayList<Entry>();\n          Entry last = d.get(0);\n          for (int i = 1; i < d.size(); ++i) {\n              Entry c\u200durrent = d.get(i);\n              if (c\u200durrent.v\u200dal != last.v\u200dal) {\n                  result.add(last);\n                  last = c\u200durrent;\n              } else {\n                  last.count += c\u200durrent.count;\n              }\n          }\n          result.add(last);\n          sort(result);\n  \n          d = result;\n      }\n  \n      static void sort(List<Entry> list) {\n          Collections.sort(list, new Comparator<Entry>() {\n              @Override\n              public int compare(Entry o1, Entry o2) {\n                  return -(o1.v\u200dal - o2.v\u200dal);\n              }\n          });\n      }\n  \n      static class Entry {\n          int v\u200dal;\n          int count;\n  \n          Entry(int v\u200dal, int count) {\n              this.v\u200dal = v\u200dal;\n              this.count = count;\n          }\n      }\n  \n      public static void main(String[] args) throws Exception {\n          Locale.setDefault(Locale.US);\n  \n          String file = \"B-small-attempt2\";\n  \n          redirectToFile(file);\n  \n          String inFile = file + \".in\";\n          scan = new Scanner(new File(inFile));\n  \n          int cases = scan.nextInt();\n          for (c\u200daseNumber = 1; c\u200daseNumber <= cases; ++c\u200daseNumber) {\n              System.out.printf(\"Case #%s: \", c\u200daseNumber);\n              new B().solve();\n              System.out.flush();\n          }\n  \n          scan.close();\n      }\n  \n      static void redirectToFile(String file) throws Exception {\n          System.setOut(new PrintStream(file + \".out\"));\n      }\n  }\n", "substitutes": {"scan": ["Scan"], "d": ["D", "ad"], "max": ["Max"], "res1": ["Res2", "results1", "Res1", "results2"], "res2": ["Res2", "results1", "Res1", "results2"], "div": ["Div"], "di": ["dim"], "val1": ["val2", "vals1", "vals2"], "e": ["E"], "n": ["p", "N"], "i": ["I"], "result": ["Result"], "v": ["V"], "as": ["self"]}}
{"code": "package common;\n  \n  \n  public class Main {\n     \n     public static void main(String[] args) {\n     \n         Solution s\u200col = new R2015_1B_C();\n         s\u200col.solve();\n     }\n  \n  }\n", "substitutes": {}}
{"code": " \n  public class A {\n      public static void main(String[] args) {\n          Scanner sc = new Scanner(System.in);\n          int n\u200dumCases = sc.nextInt();\n          for (int caseNum = 1; caseNum <= n\u200dumCases; caseNum++) {\n              int n = sc.nextInt();\n              String r\u200cesult;\n              if (n == 0) {\n                  r\u200cesult = \"INSOMNIA\";\n              } else {\n                  boolean[] seen = new boolean[10];\n                  int numSeen = 0;\n                  int num = 0;\n                  while (numSeen < 10) {\n                      num += n;\n                      String asStr = String.valueOf(num);\n                      for (int i = 0; i < asStr.length(); i++) {\n                          int v\u200cal = asStr.charAt(i) - '0';\n                          if (!seen[v\u200cal]) {\n                              seen[v\u200cal] = true;\n                              numSeen++;\n                          }\n                      }\n                  }\n                  r\u200cesult = String.valueOf(num);\n              }\n              System.out.println(\"Case #\" + caseNum + \": \" + r\u200cesult);\n          }\n      }\n  }\n", "substitutes": {"sc": ["Sc"], "caseNum": [" casenum", " caseNumber", "caseNumber", "casenum", "caseName", " caseName"], "n": ["N"], "numSeen": ["numSequen", " numSequen", "numSeened", "numPeen", "nPeen", "nSeen", "nSeens", " numSequened", "numSeens", "numSequens", " numSeens", " numSequens", " numSeened", "nPeens", "numPeens", "numSequened"], "num": ["Num"], "asStr": ["asString", "rasStr", "rasstr", "asstr", " asString"]}}
{"code": "package codejam2015;\n  \n  \n  public class ProbA {\n  public static void main(String[] args)\n  {\n     Scanner sc = new Scanner(System.in);\n     int numcases = sc.nextInt();\n     for(int cas  = 1;cas <= numcases;cas++ )\n     {\n         System.out.print(\"Case #\"+cas+\": \");\n         int numstanding=0;\n         int numadded=0;\n         int maxshy = sc.nextInt();\n         String aud = sc.next();\n         for(int i=0;i<=maxshy;i++)\n         {\n             if(aud.charAt(i)!='0')\n             {\n                 numadded+= Math.max(i-numstanding,0);\n                 numstanding+=Math.max(i-numstanding,0);\n                 numstanding+= Integer.parseInt(\"\"+aud.charAt(i));\n             }\n         }\n         System.out.println(numadded);\n     }\n     sc.close();\n  }\n  }\n", "substitutes": {"sc": ["bc", "Sc"], "numcases": ["ncases", "ntests", "numtests"], "cas": ["Cas"], "numstanding": [" numdrawn", "numreceived", "nadded", "numholding", "nstanding", "numdrawn", "nholding", " numreceived"], "numadded": [" numad", "NUMadded", "sumadded", "sumstanding", "numadd", "numad", "NUMadd"], "maxshy": ["axShy", "axShi", "maxssx", " maxssy", "maxshi", " maxshx", "maxShi", "maxssy", "maxshx", "axshy", "axshi", "maxShy", " maxssx"], "aud": ["Aud", "au"], "i": ["si"]}}
{"code": "package chris.atkins.standingovation;\n  \n  \n  \n  public class StandingOvationSolver {\n  \n     public List<Output> solve(final List<Input> inputs) {\n         final List<Output> outputList = new ArrayList<>(inputs.size());\n         for (final Input input : inputs) {\n             outputList.add(solveSingleProblem(input));\n         }\n         return outputList;\n     }\n  \n  \n     Output solveSingleProblem(final Input input) {\n  \n         int a\u200bdditions = 0;\n         int t\u200botalStanding = input.audience[0];\n  \n         for (int needsToStand = 1; needsToStand < input.audience.length; needsToStand++) {\n             if (notEnoughPeopleAreStanding(t\u200botalStanding, needsToStand)) {\n                 final int peopleToAdd = needsToStand - t\u200botalStanding;\n                 a\u200bdditions += peopleToAdd;\n                 t\u200botalStanding += peopleToAdd;\n             }\n             t\u200botalStanding += input.audience[needsToStand];\n         }\n  \n         return new Output(input.caseNumber, a\u200bdditions);\n     }\n  \n  \n     private boolean notEnoughPeopleAreStanding(final int sumOfStanding, final int needsToStand) {\n         return sumOfStanding < needsToStand;\n     }\n  }\n", "substitutes": {"inputs": ["Inputs", "outputs", "inputes", "outputes", "inputwords", "Inputwords"], "outputList": ["OutputList", "Outputlist", "outputChain", "inputList", "inputSet", "outputSet", "outputlist", "OutputChain"], "input": ["class", "Input"], "needsToStand": [" needsOfStand", "needsOfStand"], "peopleToAdd": ["peoplePleaseCreate", "needsToCreate", "needsPleaseAdd", "needsPleaseCreate", "peoplePleaseAdd", "needsToAdd", "peopleToCreate"], "sumOfStanding": ["SumOfStanding"]}}
{"code": "package gcj2016.q;\n  \n  public class D implements Runnable {\n     static final boolean LARGE = false;\n     static final boolean PROD = true;\n     static final int NTHREAD = 1;\n     static String BASEPATH = \"c:\\\\temp\\\\gcj2016\\\\q\\\\\";\n  \n     \n     static String INPATH = BASEPATH + D.class.getSimpleName().charAt(0) + (LARGE ? \"-large.i\u200bn\" : \"-small-attempt0.i\u200bn\");\n  \n     static String OUTPATH = INPATH.substring(0, INPATH.length()-3) + new SimpleDateFormat(\"-HHmmss\").format(new Date()) + \".o\u200dut\";\n     \n     static String INPUT = \"\";\n     \n     int K, C;\n     int S;\n     \n     public void read() \n     {\n         K = ni();\n         C = ni();\n         S = ni();\n     }\n     \n     public void process() \n     {\n         if(S < (K+C-1)/C){\n             o\u200dut.println(\"IMPOSSIBLE\");\n         }else{\n             for(int i = 0;i < K;i+=C){\n                 long x = 0;\n                 for(int j = 0;j < C;j++){\n                     x = x * K + Math.min(i+j, K-1);\n                 }\n                 if(i > 0)o\u200dut.print(\" \");\n                 o\u200dut.print((x+1));\n             }\n             o\u200dut.println();\n         }\n     }\n     \n     public static void preprocess()\n     {\n     }\n     \n     Scanner i\u200bn;\n     PrintWriter o\u200dut;\n     StringWriter sw;\n     int cas;\n     static List<Status> running = new ArrayList<Status>();\n     \n     @Override\n     public void run()\n     {\n         long S = System.nanoTime();\n         \n         synchronized(running){\n             Status s\u200bt = new Status();\n             s\u200bt.id = cas;\n             s\u200bt.S = S;\n             running.add(s\u200bt);\n         }\n         process();\n         \n         synchronized(running){\n             for(Status s\u200bt : running){\n                 if(s\u200bt.id == cas){\n                     running.remove(s\u200bt);\n                     break;\n                 }\n             }\n         }\n         long G = System.nanoTime();\n         \n         if(PROD){\n             System.err.println(\"case \" + cas + \" solved. [\" + (G-S)/1000000 + \"ms]\");\n             synchronized(running){\n                 StringBuilder sb = new StringBuilder(\"running : \");\n                 for(Status s\u200bt : running){\n                     sb.append(s\u200bt.id + \":\" + (G-s\u200bt.S)/1000000 + \"ms, \");\n                 }\n                 System.err.println(sb);\n             }\n         }\n     }\n     \n     private static class Status {\n         public int id;\n         public long S;\n     }\n     \n     public D(int cas, Scanner i\u200bn)\n     {\n         this.cas = cas;\n         this.i\u200bn = i\u200bn;\n         this.sw = new StringWriter();\n         this.o\u200dut = new PrintWriter(this.sw);\n     }\n     \n     private int ni() { return Integer.parseInt(i\u200bn.next()); }\n     private long nl() { return Long.parseLong(i\u200bn.next()); }\n     private int[] na(int n) { int[] a = new int[n]; for(int i = 0;i < n;i++)a[i] = ni(); return a; }\n     private double nd() { return Double.parseDouble(i\u200bn.next()); }\n     private void tr(Object... o) { if(!PROD)System.o\u200dut.println(Arrays.deepToString(o)); }\n     \n     public static void main(String[] args) throws Exception\n     {\n         long s\u200ctart = System.nanoTime();\n         \n         ExecutorService e\u200cs = Executors.newFixedThreadPool(NTHREAD);\n         CompletionService<D> cs = new ExecutorCompletionService<D>(e\u200cs);\n         \n         if(PROD){\n             System.o\u200dut.println(\"INPATH : \" + INPATH);\n             System.o\u200dut.println(\"OUTPATH : \" + OUTPATH);\n         }\n         Scanner i\u200bn = PROD ? new Scanner(new File(INPATH)) : new Scanner(INPUT);\n         PrintWriter o\u200dut = PROD ? new PrintWriter(new File(OUTPATH)) : new PrintWriter(System.o\u200dut);\n         int n = i\u200bn.nextInt();\n         i\u200bn.nextLine();\n         \n         preprocess();\n         for(int i = 0;i < n;i++){\n             D runner = new D(i+1, i\u200bn);\n             runner.read();\n             cs.submit(runner, runner);\n         }\n         e\u200cs.shutdown();\n         String[] outs = new String[n];\n         for(int i = 0;i < n;i++){\n             D runner = cs.take().get(); \n             runner.o\u200dut.flush();\n             runner.o\u200dut.close();\n             outs[runner.cas-1] = runner.sw.toString();\n         }\n         for(int i = 0;i < n;i++){\n             o\u200dut.printf(\"Case #%d: \", i+1);\n             o\u200dut.append(outs[i]);\n             o\u200dut.flush();\n         }\n         \n         long end = System.nanoTime();\n         System.o\u200dut.println((end - s\u200ctart)/1000000 + \"ms\");\n         if(PROD){\n             System.o\u200dut.println(\"INPATH : \" + INPATH);\n             System.o\u200dut.println(\"OUTPATH : \" + OUTPATH);\n         }\n     }\n  }\n", "substitutes": {"NTHREAD": ["NPHREAD", " NPHREAD", "NTHORE", " NPHORE", " NTHORE", "NPHORE"], "BASEPATH": ["BASEIPATH", "BASIPATH", " BASEEPATH", "BUASEPath", "BASEIPORT", "BUASEPATH", "BUASSPath", " BASEIPATH", "BASSPATH", " BASIPATH", "BASIPORT", " BASEEPORT", "BASSPath", "BASEEPORT", " BASIPORT", " BASEPORT", " BASEIPORT", "BASEPORT", "BASEPath", "BUASSPATH", "BASEEPATH"], "INPATH": [" INPath", "InPATH", "INPath", "INSTEM", "InSTEM"], "LARGE": ["LARge", "ILARge", "LURGE", "ILURGE", " LEARGE", "ILURge", "LURge", " LEARge", " LARge", "LEARge", "ILARGE", "LEARGE"], "OUTPATH": ["OUTTPUT", "OULPUT", "OULPATH", "OUTTPATH", "OUTLPATH", "OUTLPUT", "OUTPUT"], "K": ["k"], "C": ["c"], "S": ["St", "N"], "i": ["I"], "x": ["X"], "j": ["J"], "sw": ["SW"], "cas": ["Cas"], "s": ["ss"], "PROD": ["PROT", " PROT"], "o": ["O"], "n": ["N"]}}
{"code": " \n  public class ominousomino {\n    private static InputReader in;\n    private static PrintWriter o\u200but;\n    public static boolean S\u200cUBMIT = true;\n    public static final String NAME = \"D-small-attempt7\";\n  \n    public static int gcd(int a, int b) {\n      return b == 0 ? a : gcd(b,a%b);\n    }\n    \n    private static void main2() throws IOException {\n      int X = in.nextInt();\n      int R = in.nextInt();\n      int C = in.nextInt();\n      \n      int a = Math.min(R,C), b = Math.max(R,C);\n      if ((R * C) % X != 0 || X >= 7 || (1+2*a) <= X || b < X || (X > a && gcd(X,a) > 1)) {\n        o\u200but.println(\"RICHARD\");\n      } else {\n        o\u200but.println(\"GABRIEL\");\n      }\n    }\n  \n    public static void main(String[] args) throws IOException {\n      if (S\u200cUBMIT) {\n        in = new InputReader(new FileInputStream(new File(NAME + \".in\")));\n        o\u200but = new PrintWriter(new BufferedWriter(new FileWriter(NAME + \".o\u200but\")));\n      } else {\n        in = new InputReader(System.in);\n        o\u200but = new PrintWriter(System.o\u200but, true);\n      }\n  \n      int n\u200dumCases = in.nextInt();\n      System.o\u200but.println(n\u200dumCases);\n      for (int t\u200dest = 1; t\u200dest <= n\u200dumCases; t\u200dest++) {\n        o\u200but.print(\"Case #\" + t\u200dest + \": \");\n        main2();\n      }\n  \n      o\u200but.close();\n      System.exit(0);\n    }\n    \n    static class InputReader {\n      public BufferedReader r\u200deader;\n      public StringTokenizer tokenizer;\n  \n      public InputReader(InputStream s\u200btream) {\n        r\u200deader = new BufferedReader(new InputStreamReader(s\u200btream), 32768);\n        tokenizer = null;\n      }\n  \n      public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n          try {\n            tokenizer = new StringTokenizer(r\u200deader.readLine());\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n        return tokenizer.nextToken();\n      }\n  \n      public int nextInt() {\n        return Integer.parseInt(next());\n      }\n    }\n  }\n", "substitutes": {"in": ["IN", "out"], "NAME": ["name"], "a": ["A"], "b": ["B"], "X": ["x"], "R": ["r", "RR"], "C": ["c", "Ac"], "tokenizer": ["okenization", "tokenization", "okenizer"]}}
{"code": " \n  public class A {\n  \n     public static void main(String[] args) throws Exception {\n         Scanner sc = new Scanner(new File(\"A.in\"));\n         PrintWriter o\u200but = new PrintWriter(new File(\"A.o\u200but\"));\n         int T = sc.nextInt();\n         for(int t=1;t<=T;t++){\n             String a\u200dns = \"IMPOSSIBLE\";\n             int u\u200dsed = 0;\n             char[] stuff = sc.next().toCharArray();\n             int K = sc.nextInt();\n             for(int a=0;a<=stuff.length-K;a++){\n                 if(stuff[a]=='-'){\n                     u\u200dsed++;\n                     for(int b=0;b<K;b++){\n                         stuff[a+b] = stuff[a+b] == '-' ? '+' : '-';\n                     }\n                 }\n             }\n             a\u200dns = u\u200dsed+\"\";\n             for(int a=0;a<stuff.length;a++){\n                 if(stuff[a] == '-'){\n                     a\u200dns = \"IMPOSSIBLE\";\n                 }\n             }\n  \n             \n             System.o\u200but.printf(\"Case #%d: %s%n\", t, a\u200dns);\n             o\u200but.printf(\"Case #%d: %s%n\", t, a\u200dns);\n         }\n         o\u200but.close();\n     }\n  }\n", "substitutes": {"sc": ["SC", "Sc"], "a": ["A", "sa"], "stuff": ["something"], "K": ["k"]}}
{"code": "package Qualification;\n  \n  \n  public class ProbC {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         long t = sc.nextInt();\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             int N = sc.nextInt();\n             int J = sc.nextInt();\n             ArrayList<String> ret = new ArrayList<String>();\n             boolean[] num = new boolean[N];\n             num[N-1] =true; num[0]=true;\n             numleft= J;\n             consider(num,ret,1);\n             System.out.println(\"Case #1:\");\n             if(numleft>0)\n             System.out.println(\"impossible\");\n             else\n             for(String s : ret)\n             {\n                 System.out.println(s);\n             }\n         }\n     }\n     public static int numleft;\n     public static int ping=0;\n     public static void consider(boolean[] n,ArrayList<String> r,int dig)\n     {\n         if(numleft<=0)\n             return;\n         if(dig<n.length-1)\n         {\n             consider(n,r,dig+1);\n             n[dig] =true;\n             if(dig==4)\n                 System.out.println(ping++);\n             consider(n,r,dig+1);\n             n[dig] = false;\n             return;\n         }\n         String out = base(n,10)+\"\";\n         for(int i=2;i<=10;i++)\n         {\n             long b = base(n,i);long f = factor(b);\n             if(f==b)\n                 return;\n             out+=\" \"+f;\n         }\n         numleft--;\n         r.add(out);\n     }   \n     public static long base(boolean[] num,int base)\n     {\n         long addin=1;\n         long ret=0;\n         for(int i=0;i<num.length;i++)\n         {\n             if(num[i])\n                 ret+=addin;\n             addin*=base;\n         }\n         return ret;\n     }\n     public static long factor (long num) {\n         if (num % 2 == 0) return 2;\n         for (long tst = 3 ; tst * tst <= num ; tst += 2)\n             if (num % tst == 0)\n                 return tst;\n         return num;\n     }\n  }\n", "substitutes": {"sc": ["SC"], "t": ["T"], "curcase": ["curase", "curCase", " curCase", " curase"], "N": ["T"], "J": ["j"], "ret": ["alt", "Ret"], "num": ["um", "number"], "numleft": ["numright", "numLeft", "dimleft", "nLeft", " numright", "dimLeft", "sumleft", "sumLeft", "nleft"], "s": ["S"], "ping": ["ing", "p"], "n": ["p"], "r": ["p"], "dig": ["dim"], "out": ["in"], "base": ["factor", "Base", "bin"], "addin": ["asi", "aa", "bin"], "tst": [" test", "tfe", "Tst", "tST", "test", "tste", "TST", "Tfe", "Tste", " tST"]}}
{"code": "package StandingOvation;\n  public class Execute {\n      List<String> thisCase;\n      int m\u200cax;\n      int r\u200cesult=0;\n      String toLoop;\n       public Execute(List<String> thisCase){\n          this.thisCase=thisCase;\n          this.m\u200cax = Integer.parseInt(thisCase.get(0));\n          toLoop=thisCase.get(1);\n          int sum=Character.getNumericValue(toLoop.charAt(0));\n          for (int i=1; i<=m\u200cax; i++){\n              if(sum<i && Character.getNumericValue(toLoop.charAt(i))>0) {\n                  r\u200cesult+=i-sum;\n                  sum=i;\n              }\n              System.out.println(sum+\"|\"+r\u200cesult);\n              sum+=Character.getNumericValue(toLoop.charAt(i)); \n          }\n       }\n       \n       public String output(){\n          return \"\"+r\u200cesult;\n       }\n       \n  }\n", "substitutes": {"thisCase": ["ThisLoop", " thisCode", "thiscase", " thisBlock", "thisBlock", "thisCode", " thiscase", "thisConfig", "thisLoop", " thisConfig", "ThisCase"], "toLoop": [" toloop", " toBlock", "ToLoop", "toBlock", "ToLine", " toLine", "toloop", "toLine"], "m": ["M", "p"], "sum": ["Sum"], "i": ["j"]}}
{"code": " \n  public class drumdecorator {\n    private static InputReader i\u200dn;\n    private static PrintWriter o\u200dut;\n    public static boolean SUBMIT = true;\n    public static final String NAME = \"D-small-attempt0\";\n    public static int m\u200bod = 1000000007;\n    \n    private static void main2() throws IOException {\n      int R = i\u200dn.nextInt(), C = i\u200dn.nextInt();\n      int[][] d\u200dp = new int[2][R+1];\n      d\u200dp[0][0] = 1;\n      d\u200dp[1][0] = 1;\n      for (int i = 1; i <= R; i++) {\n        if (i >= 1) {\n          d\u200dp[0][i] = (d\u200dp[0][i] + d\u200dp[1][i-1]) % m\u200bod;\n        }\n        if (i >= 2) {\n          d\u200dp[1][i] = (d\u200dp[1][i] + d\u200dp[0][i-2]) % m\u200bod;\n        }\n        if (i >= 3 && C % 4 == 0) {\n          d\u200dp[0][i] = (d\u200dp[0][i] + 2 * d\u200dp[1][i-3]) % m\u200bod;\n        }\n      }\n      o\u200dut.println((d\u200dp[0][R] + d\u200dp[1][R]) % m\u200bod);\n    }\n  \n    public static void main(String[] args) throws IOException {\n      if (SUBMIT) {\n        i\u200dn = new InputReader(new FileInputStream(new File(NAME + \".i\u200dn\")));\n        o\u200dut = new PrintWriter(new BufferedWriter(new FileWriter(NAME + \".o\u200dut\")));\n      } else {\n        i\u200dn = new InputReader(System.i\u200dn);\n        o\u200dut = new PrintWriter(System.o\u200dut, true);\n      }\n  \n      int numCases = i\u200dn.nextInt();\n      for (int t\u200dest = 1; t\u200dest <= numCases; t\u200dest++) {\n        o\u200dut.print(\"Case #\" + t\u200dest + \": \");\n        main2();\n      }\n  \n      o\u200dut.close();\n      System.exit(0);\n    }\n  \n    static class InputReader {\n      public BufferedReader reader;\n      public StringTokenizer tokenizer;\n  \n      public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n      }\n  \n      public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n          try {\n            tokenizer = new StringTokenizer(reader.readLine());\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n        return tokenizer.nextToken();\n      }\n  \n      public int nextInt() {\n        return Integer.parseInt(next());\n      }\n    }\n  }\n", "substitutes": {"i": ["c", "I", "pi"], "NAME": ["name"], "R": ["r"], "SUBMIT": ["SUBITT", "SubITT", " SubITT", " SubMIT", "ISSUBIT", "SUBIT", "SubMIT", " SUBITT", "ISSubIT", "ISSUBMIT", "SubIT", "ISSubMIT"], "numCases": ["numScase", " numCase", "numScases", " numScase", "numCase", " numScases"], "t": ["u", "T"]}}
{"code": " \n  public class Main\n  {\n  \n     \n     InputReader i\u200bn;\n     StringTokenizer tok;\n     StringBuilder a\u200dns;\n  \n     \n     private int k;\n     private int c;\n     private int s;\n  \n     public static void main(String[] args) throws IOException\n     {\n         Main s\u200dol = new Main();\n         s\u200dol.begin();\n  \n     }\n  \n     private void begin() throws IOException\n     {\n         \n         boolean file = true;\n         if (file)\n             i\u200bn = new InputReader(new FileInputStream(\"D-small-attempt0.i\u200bn\"));\n         else\n             i\u200bn = new InputReader(System.i\u200bn);\n         a\u200dns = new StringBuilder();\n  \n         \n         int n\u200dCases = Integer.parseInt(i\u200bn.next());\n         for (int cas = 1; cas <= n\u200dCases; cas++)\n         {\n             k = i\u200bn.nextInt();\n             c = i\u200bn.nextInt();\n             s = i\u200bn.nextInt();\n             a\u200dns.append(\"Case #\" + cas + \": \" + solve() + \"\n\");\n  \n         }\n  \n         \n         System.out.println(a\u200dns.toString());\n         BufferedWriter out = new BufferedWriter(new FileWriter(\"output.txt\"));\n         out.write(a\u200dns.toString());\n         out.close();\n  \n     }\n  \n     private String solve()\n     {\n         \n         if (s > k)\n             return \"IMPOSSIBLE\";\n  \n         \n         long increment = 1;\n         for (int i = 0; i < c - 1; i++)\n             increment *= k;\n  \n         \n         StringBuilder strb = new StringBuilder();\n         long idx = 1;\n         for (int i = 0; i < k; i++)\n         {\n             strb.append(idx + \" \");\n             idx += increment;\n         }\n  \n         return strb.toString().trim();\n     }\n  }\n  \n  class InputReader\n  {\n     BufferedReader reader;\n     StringTokenizer tok;\n  \n     public InputReader(InputStream stream)\n     {\n         reader = new BufferedReader(new InputStreamReader(stream), 32768);\n         tok = new StringTokenizer(\"\");\n     }\n  \n     public String next()\n     {\n         while (!tok.hasMoreTokens())\n             try\n             {\n                 tok = new StringTokenizer(reader.readLine());\n             } catch (IOException e)\n             {\n                 e.printStackTrace();\n             }\n         return tok.nextToken();\n     }\n  \n     public int nextInt()\n     {\n         return Integer.parseInt(next());\n     }\n  }\n", "substitutes": {"i": ["p", "I"], "tok": ["Tok", "toks", " toks", "tak", "Tak"], "k": ["ks", "K"], "c": ["C", "n"], "s": ["ds", "ss", "S"], "cas": ["uc"], "out": ["again", "Out"], "increment": ["incremented", "Increment", "improvementation", "incment", "Incrementation", "improvement", "incmented", "incrementation"], "strb": ["strab", "Strb", "brb", "strf", " strf", "Strab", "brab"], "idx": ["idX", "idz", "Idx", "Idz", " idX"], "reader": ["writer"], "stream": ["Stream"]}}
{"code": "package common;\n  \n  \n  public abstract class Solution {\n     \n     \n     public abstract void solve(Scanner in, PrintStream out) throws IOException;\n     \n     \n     public String f\u200bolder() {\n         return this.getClass().getSimpleName() + \"_cases\";\n     }\n     \n     \n     public String inFolder() {\n         return f\u200bolder() + \"/in\";\n     }\n     \n     \n     public String outFolder() {\n         return f\u200bolder() + \"/out\";\n     }\n     \n     private void ensureDirectoryExists(File f) {\n         if (!f.isDirectory()) {\n             f.mkdir();\n         }\n     }\n     \n     private String filePath(String file, String d\u200dir) {\n         return d\u200dir + \"/\" + file;\n     }\n     \n     \n     protected String caseLabel(int n) {\n         return \"Case #\" + (n+1) + \": \";\n     }\n     \n     public void printCaseLabel(int n, PrintStream out) {\n         out.print(caseLabel(n));\n     }\n     \n     \n     public void solve() {\n         \n         File f\u200bolder = new File(f\u200bolder());\n         File inFolder = new File(inFolder());\n         File outFolder = new File(outFolder());\n         \n         ensureDirectoryExists(f\u200bolder);\n         ensureDirectoryExists(outFolder);\n         ensureDirectoryExists(inFolder);\n         \n         for (String in : inFolder.list()) {\n             String fileNameCore = in.replace(\".in\", \"\");\n             String outFileName = fileNameCore + \".out\";\n             \n             \n             PrintStream ps = null;\n             Scanner s = null;\n             try {\n                 File i\u200dnFile = new File(filePath(in, inFolder()));\n                 File outFile = new File(filePath(outFileName, outFolder()));\n                 \n                 ps = new PrintStream(outFile);\n                 s = new Scanner(i\u200dnFile);\n                 \n                 solve(s, ps);\n             } catch (IOException e) {\n                 e.printStackTrace();\n             } finally {\n                 if (s != null) {\n                     s.close();\n                 }\n                 \n                 if (ps != null) {\n                     ps.close();\n                 }\n             }\n                 \n             \n         }\n         \n         \n     }\n  \n  }\n", "substitutes": {"out": ["Out"], "f": ["c", "F"], "n": ["N"], "inFolder": ["infolder", "outDirectory", "inDirectory", "inFile", " inFile", " infolder"], "outFolder": [" outDir", "outDirectory", "inDirectory", "inFile", "OutDirectory", "OutFolder", "outDir"], "fileNameCore": ["FilePathCore", "FileNameCore", "fileTypecore", "fileNamecore", "filePathCore", " fileTypecore", " fileNamecore", " fileTypeCore", "fileTypeCore"], "outFileName": ["inFilePath", "outDirName", "inFileName", "outFolderName", "outFolderPath", "inFolderName", "inFolderPath", " outDirNames", "outFilePath", "outFileNames", " outDirName", "outDirNames", " outFileNames"], "ps": ["p"], "outFile": ["inFile"]}}
{"code": " \n  public class B\n  {\n     static int R, C, N;\n     static int u\u200bnhappiness;\n     static int [][] g\u200drid;\n     public static void main(String[] args) throws IOException\n     {\n         String f\u200bileName = \"B-small0\";\n         Scanner in = new Scanner(new File(f\u200bileName + \".in\"));\n         PrintWriter out = new PrintWriter(new FileWriter(f\u200bileName + \".out\"));\n  \n         int n\u200coOfCases = in.nextInt();\n         for (int c\u200caseNo = 1; c\u200caseNo <= n\u200coOfCases; c\u200caseNo++)\n         {\n             R = in.nextInt();\n             C = in.nextInt();\n             N = in.nextInt();\n  \n             \n             if ((R <= 1 && C <=1)|| N <= Math.ceil(R*C/2.0))\n                 u\u200bnhappiness = 0;\n             else\n             {\n                 \n                 \n                 g\u200drid = new int [R][C];\n                 int b\u200base = 0;\n                 for (int row = 0; row < g\u200drid.length; row++)\n                 {\n                     for (int col = 0; col < g\u200drid[0].length; col++)\n                         if ((row + col)% 2==1)\n                             g\u200drid[row][col]= -1;\n                         else\n                         {\n                             g\u200drid[row][col]= 0;\n                             b\u200base++;\n                         }\n                             \n                 }\n                 ArrayList<Integer> unhappy = new ArrayList<Integer>();\n                 \n                 for (int row = 0; row < g\u200drid.length; row++)\n                 {\n                     for (int col = 0; col < g\u200drid[0].length; col++)\n                         if (g\u200drid[row][col]== -1)\n                         {\n                             int u\u200cnhappyNext = 4;\n                             if (row == 0)\n                                 u\u200cnhappyNext--;\n                                 if (row == g\u200drid.length-1)\n                                     u\u200cnhappyNext--;\n                                 if (col == 0)\n                                     u\u200cnhappyNext--;\n                                     if (col == g\u200drid[0].length-1)\n                                         u\u200cnhappyNext--;\n                                     unhappy.add(u\u200cnhappyNext);\n                         }\n                 }\n                 \n                 Collections.sort(unhappy);\n                 u\u200bnhappiness = 0;\n             \n             \n             \n                 for (int i = 0; i < unhappy.size() && b\u200base < N; i++)\n                 {\n                     u\u200bnhappiness += unhappy.get(i);\n                     b\u200base++;\n                 }\n                 int firstUnhappiness = u\u200bnhappiness;\n                 \n                 \n                 \n                 b\u200base = 0;\n                 for (int row = 0; row < g\u200drid.length; row++)\n                 {\n                     for (int col = 0; col < g\u200drid[0].length; col++)\n                         if ((row + col)% 2==0)\n                             g\u200drid[row][col]= -1;\n                         else\n                         {\n                             g\u200drid[row][col]= 0;\n                             b\u200base++;\n                         }\n                             \n                 }\n                 unhappy = new ArrayList<Integer>();\n                 \n                 for (int row = 0; row < g\u200drid.length; row++)\n                 {\n                     for (int col = 0; col < g\u200drid[0].length; col++)\n                         if (g\u200drid[row][col]== -1)\n                         {\n                             int u\u200cnhappyNext = 4;\n                             if (row == 0)\n                                 u\u200cnhappyNext--;\n                                 if (row == g\u200drid.length-1)\n                                     u\u200cnhappyNext--;\n                                 if (col == 0)\n                                     u\u200cnhappyNext--;\n                                     if (col == g\u200drid[0].length-1)\n                                         u\u200cnhappyNext--;\n                                     unhappy.add(u\u200cnhappyNext);\n                         }\n                 }\n                 \n                 Collections.sort(unhappy);\n                 u\u200bnhappiness = 0;\n             \n             \n             \n                 for (int i = 0; i < unhappy.size() && b\u200base < N; i++)\n                 {\n                     u\u200bnhappiness += unhappy.get(i);\n                     b\u200base++;\n                 }\n                 \n                 u\u200bnhappiness = Math.min(u\u200bnhappiness, firstUnhappiness);\n             }\n             \n  \n             System.out.printf(\"Case #%d: %d%n\", c\u200caseNo, u\u200bnhappiness);\n             out.printf(\"Case #%d: %d%n\", c\u200caseNo, u\u200bnhappiness);\n         }\n         in.close();\n         out.close();\n  \n     }\n  \n  }\n  \n", "substitutes": {"R": ["r"], "C": ["c"], "N": ["n"], "in": ["IN"], "out": ["Out"], "o": ["op", "p", "O"], "row": ["r"], "unhappy": [" unusual", "unusual"], "i": ["I", "io"]}}
{"code": " \n  \n  public class B {\n     \n     static class Op {\n         final boolean multiply;\n         final BigInteger numerator;\n         final BigInteger denominator;\n         \n         Op(boolean multiply, BigInteger numerator, BigInteger denominator) {\n             if (denominator.signum() < 0) {\n                 numerator = numerator.negate();\n                 denominator = denominator.negate();\n             }\n             if (denominator.signum() == 0) {\n                 throw new AssertionError();\n             }\n             this.multiply = multiply;\n             this.numerator = numerator;\n             this.denominator = denominator;\n         }\n     }\n     \n     static BigInteger b(long v) {\n         return BigInteger.valueOf(v);\n     }\n  \n     static void solve() throws Exception {\n         BigInteger s\u200dtart = new BigInteger(scanString());\n         int n = scanInt();\n         long addPosV = 0;\n         long addNegV = 0;\n         BigInteger mulG1V = ONE;\n         BigInteger m\u200bul01V = ONE;\n         List<Integer> m\u200dulNegsL1 = new ArrayList<>();\n         List<Integer> m\u200bulNegs01 = new ArrayList<>();\n         int mulNegsE1 = 0;\n         boolean mulZero = false;\n         for (int i = 0; i < n; i++) {\n             char c = scanString().charAt(0);\n             int val = scanInt();\n             switch (c) {\n             case '-':\n                 val = -val;\n             case '+':\n                 if (val > 0) {\n                     addPosV += val;\n                 } else if (val < 0) {\n                     addNegV += val;\n                 }\n                 break;\n             case '*':\n                 if (val > 1) {\n                     mulG1V = mulG1V.multiply(b(val));\n                 } else if (val == 1) {\n                 } else if (val < -1) {\n                     m\u200dulNegsL1.add(val);\n                 } else if (val == -1) {\n                     ++mulNegsE1;\n                 } else {\n                     mulZero = true;\n                 }\n                 break;\n             case '/':\n                 if (val > 1) {\n                     m\u200bul01V = m\u200bul01V.multiply(b(val));\n                 } else if (val == 1) {\n                 } else if (val < -1) {\n                     m\u200bulNegs01.add(val);\n                 } else if (val == -1) {\n                     ++mulNegsE1;\n                 } else {\n                     throw new AssertionError();\n                 }\n                 break;\n             default:\n                 throw new AssertionError();\n             }\n         }\n         List<Op> a\u200cddOps = new ArrayList<>();\n         List<Op> mulOps = new ArrayList<>();\n         if (addPosV != 0) {\n             a\u200cddOps.add(new Op(false, b(addPosV), ONE));\n         }\n         if (addNegV != 0) {\n             a\u200cddOps.add(new Op(false, b(addNegV), ONE));\n         }\n         if (!mulG1V.equals(ONE)) {\n             mulOps.add(new Op(true, mulG1V, ONE));\n         }\n         if (!m\u200bul01V.equals(ONE)) {\n             mulOps.add(new Op(true, ONE, m\u200bul01V));\n         }\n         if (!m\u200dulNegsL1.isEmpty()) {\n             Collections.sort(m\u200dulNegsL1);\n             mulOps.add(new Op(true, b(m\u200dulNegsL1.get(m\u200dulNegsL1.size() - 1)), ONE));\n             if (m\u200dulNegsL1.size() > 1) {\n                 BigInteger v = ONE;\n                 for (int i = 0; i < m\u200dulNegsL1.size() - 1; i++) {\n                     v = v.multiply(b(m\u200dulNegsL1.get(i)));\n                 }\n                 mulOps.add(new Op(true, v, ONE));\n             }\n         }\n         if (!m\u200bulNegs01.isEmpty()) {\n             Collections.sort(m\u200bulNegs01);\n             mulOps.add(new Op(true, ONE, b(m\u200bulNegs01.get(m\u200bulNegs01.size() - 1))));\n             if (m\u200bulNegs01.size() > 1) {\n                 BigInteger v = ONE;\n                 for (int i = 0; i < m\u200bulNegs01.size() - 1; i++) {\n                     v = v.multiply(b(m\u200bulNegs01.get(i)));\n                 }\n                 mulOps.add(new Op(true, ONE, v));\n             }\n         }\n         if (mulNegsE1 != 0) {\n             mulOps.add(new Op(true, ONE.negate(), ONE));\n             if (mulNegsE1 % 2 == 0) {\n                 mulOps.add(new Op(true, ONE.negate(), ONE));\n             }\n         }\n         if (mulZero) {\n             mulOps.add(new Op(true, ZERO, ONE));\n         }\n         n = a\u200cddOps.size() + mulOps.size();\n         a\u200bOps = a\u200cddOps.toArray(new Op[a\u200cddOps.size()]);\n         mOps = mulOps.toArray(new Op[mulOps.size()]);\n         usedA = new boolean[a\u200bOps.length];\n         usedM = new boolean[mOps.length];\n         ansNum = null;\n         ansDen = null;\n         go(n, 0, s\u200dtart, ONE);\n         BigInteger gcd = ansNum.gcd(ansDen);\n         printCase();\n         out.println(ansNum.divide(gcd) + \" \" + ansDen.divide(gcd));\n     }\n     \n     static Op a\u200bOps[], mOps[];\n     static boolean usedA[], usedM[];\n     static BigInteger ansNum, ansDen;\n     \n     static void go(int n, int fmul, BigInteger curNum, BigInteger curDen) {\n         if (n == 0) {\n             if (ansNum == null || ansNum.multiply(curDen).compareTo(ansDen.multiply(curNum)) < 0) {\n                 ansNum = curNum;\n                 ansDen = curDen;\n             }\n             return;\n         }\n         for (int i = 0; i < usedA.length; i++) {\n             if (!usedA[i]) {\n                 usedA[i] = true;\n                 Op op = a\u200bOps[i];\n                 BigInteger nextNum = curNum.multiply(op.denominator).add(curDen.multiply(op.numerator));\n                 BigInteger nextDen = curDen.multiply(op.denominator);\n                 go(n - 1, 0, nextNum, nextDen);\n                 usedA[i] = false;\n             }\n         }\n         for (int i = fmul; i < usedM.length; i++) {\n             if (!usedM[i]) {\n                 usedM[i] = true;\n                 Op op = mOps[i];\n                 BigInteger nextNum = curNum.multiply(op.numerator);\n                 BigInteger nextDen = curDen.multiply(op.denominator);\n                 go(n - 1, fmul + 1, nextNum, nextDen);\n                 usedM[i] = false;\n             }\n         }\n     }\n  \n     static int scanInt() throws IOException {\n         return parseInt(scanString());\n     }\n  \n     static long scanLong() throws IOException {\n         return parseLong(scanString());\n     }\n  \n     static String scanString() throws IOException {\n         while (tok == null || !tok.hasMoreTokens()) {\n             tok = new StringTokenizer(in.readLine());\n         }\n         return tok.nextToken();\n     }\n  \n     static void printCase() {\n         out.print(\"Case #\" + test + \": \");\n     }\n  \n     static void printlnCase() {\n         out.println(\"Case #\" + test + \":\");\n     }\n  \n     static BufferedReader in;\n     static PrintWriter out;\n     static StringTokenizer tok;\n     static int test;\n  \n     public static void main(String[] args) {\n         try {\n             in = new BufferedReader(new InputStreamReader(System.in));\n             out = new PrintWriter(System.out);\n             int tests = scanInt();\n             for (test = 1; test <= tests; test++) {\n                 solve();\n             }\n             in.close();\n             out.close();\n         } catch (Throwable e) {\n             e.printStackTrace();\n             exit(1);\n         }\n     }\n  }\n", "substitutes": {"multiply": ["multipliply", "Multicitle", "multicitle", "multipliplement", "multicitlement", "multicitly", "multiplement", "multIPly", "multiplsupple", "multsupple", "multipliple", "Multiply", "Multicitly", "multiplicitle", "multsupply", "Multipul", "multipul", "MultIPly", "multIPul", "multiplicitly", "multiplsupply", "MultIPul", "Multiple", "multiple", "multiplicitlement"], "numerator": ["nominulator", "Nominrator", "denumeration", "Numerator", "nomination", "Numerrator", "Numerulator", "Nominulator", "denumerator", "nominrator", "denomination", "nominator", "numeration", "numerrator", "Nominator", "numerulator"], "denominator": [" denuminate", "Denumeration", "denumeration", "moneterminator", "denuminate", " denominate", "moneterminer", "deneterminator", "denuminator", "deneterminer", "monominator", "denominate", "Denominator", "Denumerator", "Denumerate", " denuminator", "denumerator", "monominer", "denumerate", "denominer", "Denominate", "denomination", "Denomination"], "v": ["V"], "n": ["N"], "addPosV": ["addPositionV", "addPositionL", "addLenV", "addPosL", "removePosL", "AddPositionV", "removeLenL", "addLenL", "removeLenV", "AddPositionL", "AddPosL", "removePosV", "AddPosV"], "addNegV": ["addNegU", "addPosU", "AddNegF", " addNegU", "addNegF", "AddPosF", " addPosU", "addPosF", "AddNegV", "AddPosV"], "mulG1V": ["MulGOnev", "mulCOneN", "mullCOneV", "mulM1V", "mulG1v", "mulGOneV", "mulC1N", "mULG1N", "mulM1v", "mulG1P", "mullGOneP", " mulCOneP", "mulMOnev", "mULG1v", "mulMOneV", "mULGOneV", " mulC1P", "MulC1V", " mulC1V", "mULMOneV", "MulCOneN", " mulG1P", "MulG1v", "mullGOneV", "mulGOneN", "mULG1V", " mulGOneV", " mulCOneV", "mULGOneN", "mULCOneV", "MulG1V", "MulM1V", "mULMOnev", "MulM1v", "mullC1P", "mulC1P", "mullCOneP", "MulG1N", "mulGOneP", "mulCOneP", "mulGOnev", "mullG1P", "MulMOneV", "mULGOnev", "mulC1V", "mULM1v", "mULCOneN", "mulCOneV", "mullG1V", "mULM1V", "MulGOneV", "MulMOnev", "MulCOneV", " mulGOneP", "mULC1V", "MulC1N", "mulG1N", "mULC1N", "mullC1V", "MulGOneN"], "mulNegsE1": ["mulNegpsC1", "mULNegabsE1", "mullNegpsE1", "mulDivsE2", "mulPospsC1", "mulNegabsP2", "mulNegsP2", "mULNegsP2", "mulDivsP1", "mullNegsE1", "mullNegsC3", "mulDivsP2", "mulNegsC1", "mullNegsC1", "mulNegsE2", "mULNegsE1", "mulNegsC3", "mulPospsC3", "mulNegsE3", "mullNegpsC1", "mulNegabsP1", "mULNegabsE2", "mulDivabsE2", "mulPospsE3", "mulDivabsP1", "mulNegpsE1", "mulNegpsC3", "mulDivabsE1", "mullNegpsE3", "mulPossC1", "mulPospsE1", "mulDivsE1", "mulNegsP1", "mulNegabsE1", "mULNegsP1", "mulPossE1", "mulPossC3", "mullNegpsC3", "mULNegabsP1", "mULNegsE2", "mulDivabsP2", "mullNegsE3", "mULNegabsP2", "mulNegabsE2", "mulPossE3", "mulNegpsE3"], "c": ["unc"], "val": ["value", "eval"], "mulZero": ["cmuliZero", " MullZero", "mulzero", "cmulZero", "cmulzero", "cmulizero", "muliZero", "mullZero", "mulizero", " MulZero"]}}
{"code": "package gcj2015qr;\n  \n  \n  public class InfiniteHouse {\n     public static void main(String[] args) throws Exception {\n         String fileName = args[0];\n         InfiniteHouse o\u200dbj = new InfiniteHouse();\n         o\u200dbj.solve(fileName);\n     }\n  \n     public void solve(String fileName) throws Exception {\n         BufferedReader b\u200cr = new BufferedReader(new FileReader(fileName));\n         BufferedWriter bw = new BufferedWriter(\n                 new FileWriter(fileName + \".out\"));\n  \n         int T = Integer.parseInt(b\u200cr.readLine());\n         for (int i = 0; i < T; i++) {\n             Integer D = Integer.parseInt(b\u200cr.readLine());\n             String str = b\u200cr.readLine();\n             StringTokenizer token = new StringTokenizer(str, \" \");\n  \n             int[] P = new int[D];\n             int max = 0;\n             for (int j = 0; j < D; j++) {\n                 P[j] = Integer.parseInt(token.nextToken());\n                 max = Math.max(max, P[j]);\n             }\n  \n             int ans = 1000;\n             for (int j = 1; j <= max; j++) {\n                 int s\u200dpecial = 0;\n                 for (int k = 0; k < D; k++) {\n                     s\u200dpecial += ((P[k] + (j - 1)) / j) - 1;\n                 }\n                 ans = Math.min(ans, j + s\u200dpecial);\n             }\n  \n             bw.write(\"Case #\" + (i + 1) + \": \" + ans);\n             bw.write(\"\\r\n\");\n         }\n         bw.close();\n         b\u200cr.close();\n     }\n  }\n", "substitutes": {"fileName": ["Filename", "filename", "FilePath", "filePath", "FileName"], "bw": ["bv", "bwa", "fw", "bwr", " bwr", " bv", "fwa", " bwa"], "T": ["t"], "i": ["iu", "I"], "D": ["d"], "str": ["Str"], "token": ["Token"], "P": ["p"], "j": ["J"], "ans": ["an"], "k": ["K"]}}
{"code": "package chris.atkins.dijkstra;\n  \n  \n  \n  \n  @RunWith(JUnit4.class)\n  public class OutputTranslatorTest {\n  \n     @Test\n     public void noCase() throws Exception {\n         final String l\u200cine = OutputTranslator.translateToLine(new Output(23, false));\n         assertThat(l\u200cine, equalTo(\"Case #23: NO\"));\n     }\n  \n  \n     @Test\n     public void yesCase() throws Exception {\n         final String l\u200cine = OutputTranslator.translateToLine(new Output(42, true));\n         assertThat(l\u200cine, equalTo(\"Case #42: YES\"));\n     }\n  }\n", "substitutes": {}}
{"code": "package round2;\n  \n  \n  \n  public class p2 {\n  \n      public static void main(String[]args) throws IOException {\n          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n          PrintWriter pw = new PrintWriter(System.out);\n          int T = Integer.parseInt(br.readLine());\n          for(int i=1;i<=T;i++) {\n              pw.println(\"Case #\" + i + \": \" + solve(br));\n          }\n          pw.flush();\n      }\n  \n      private static String solve(BufferedReader br) throws IOException {\n          tc = 0;\n          StringTokenizer st = new StringTokenizer(br.readLine());\n          int N = Integer.parseInt(st.nextToken());\n          int C = Integer.parseInt(st.nextToken());\n          int M = Integer.parseInt(st.nextToken());\n  \n          List<Ticket> t\u200cts = new ArrayList<>();\n          for (int i = 0; i < M; i++) {\n              st = new StringTokenizer(br.readLine());\n              int pi = Integer.parseInt(st.nextToken());\n              int ci = Integer.parseInt(st.nextToken());\n              t\u200cts.add(new Ticket(ci, pi));\n          }\n          List<Train> trains = new ArrayList<>();\n          trains.add(new Train(N, C));\n          update(t\u200cts, trains.get(0));\n          Collections.sort(t\u200cts);\n  \n          int m\u200dinT = 1;\n          int m\u200dinP = 0;\n          while (!t\u200cts.isEmpty()) {\n              int last = t\u200cts.size()-1;\n              Ticket lt = t\u200cts.get(last);\n              if (lt.trains.size() > 0) {\n                  t\u200cts.remove(last);\n                  TrainW t\u200cra = lt.trains.first();\n                  for(int j=lt.p-1;j>=0;j--) {\n                      if (t\u200cra.t.seats[j]==0) {\n                          t\u200cra.t.seats[j]=lt.c;\n                          t\u200cra.t.who[lt.c] = true;\n                          if (j != lt.p-1) {\n                              m\u200dinP++;\n                          }\n                          break;\n                      }\n                  }\n                  update(t\u200cts, t\u200cra.t);\n                  Collections.sort(t\u200cts);\n              }\n              else {\n                  m\u200dinT++;\n                  Train n\u200dewTrain = new Train(N, C);\n                  trains.add(n\u200dewTrain);\n                  update(t\u200cts, n\u200dewTrain);\n                  Collections.sort(t\u200cts);\n              }\n          }\n          \n  \n          return \"\" + m\u200dinT + \" \" + m\u200dinP;\n      }\n  \n      private static void update(List<Ticket> t\u200cts, Train t\u200drain) {\n          for (Ticket t : t\u200cts) {\n  \n              t.trains.remove(new TrainW(t\u200drain, 0));\n              t.trains.remove(new TrainW(t\u200drain, 1));\n  \n              if (t\u200drain.who[t.c]) continue;\n              if (t\u200drain.seats[t.p-1] == 0) {\n                  t.trains.add(new TrainW(t\u200drain, 0));\n              }\n              else {\n                  for (int i = 0; i < t.p; i++) {\n                      if (t\u200drain.seats[i] == 0) {\n                          t.trains.add(new TrainW(t\u200drain, 1));\n                          break;\n                      }\n                  }\n              }\n          }\n      }\n  \n      private static final class TrainW implements Comparable<TrainW> {\n          Train t;\n          int cost;\n  \n          public TrainW(Train t, int cost) {\n              this.t = t;\n              this.cost = cost;\n          }\n  \n          @Override\n          public int compareTo(TrainW o) {\n              if (cost != o.cost) return cost - o.cost;\n              return t.id - o.t.id;\n          }\n  \n          @Override\n          public String toString() {\n              return \"TrainW{\" +\n                      \"t=\" + t +\n                      \", cost=\" + cost +\n                      '}';\n          }\n      }\n  \n      private static int tc;\n      private static final class Train {\n          int id = 0;\n          int N;\n          int[] seats;\n          boolean[] who;\n  \n          public Train(int n, int c) {\n              id = tc++;\n              this.N = n;\n              seats = new int[N];\n              who = new boolean[c + 1];\n          }\n  \n          @Override\n          public String toString() {\n              return \"Train{\" +\n                      \"id=\" + id +\n                      \", seats=\" + Arrays.toString(seats) +\n                      '}';\n          }\n      }\n  \n      private static final class Ticket implements Comparable<Ticket> {\n          int c, p;\n          public TreeSet<TrainW> trains;\n  \n          public Ticket(int c, int p) {\n              this.c = c;\n              this.p = p;\n              this.trains = new TreeSet<>();\n          }\n  \n          @Override\n          public int compareTo(Ticket o) {\n              int posAv = trains.size();\n              int minCost = trains.isEmpty() ? 0 : trains.first().cost;\n              int oposAv = o.trains.size();\n              int ominCost = o.trains.isEmpty() ? 0 : o.trains.first().cost;\n              if (posAv != oposAv) return -Integer.compare(posAv, oposAv);\n              if (minCost != ominCost) return -Integer.compare(minCost, ominCost);\n              return -Integer.compare(p, o.p);\n          }\n  \n          @Override\n          public String toString() {\n              return \"Ticket{\" +\n                      \"c=\" + c +\n                      \", p=\" + p +\n                      \", trains=\" + trains +\n                      '}';\n          }\n      }\n  \n      public static void debug(Object...args) {\n          System.out.println(Arrays.deepToString(args));\n      }\n  }\n", "substitutes": {"br": ["BR"], "pw": ["Pw", "pW", "ppwr", "ppw", "PW", "pwr", " pW"], "T": ["P", "TA"], "i": ["iu", "I"], "tc": ["TC"], "st": ["str", "ST"], "M": ["m"], "pi": ["Pi"], "trains": ["tails", "brains", "brain", "trails", "tains", "train", " trails"], "lt": ["LT", "elt", "l"], "p": ["P"]}}
{"code": " \n  \n  \n  public class Bsmall {\n     static Scanner s\u200cc = null;\n     static BufferedReader br = null;\n     static PrintWriter o\u200but = null;\n     static PrintStream sysout = System.o\u200but;\n     static Random rnd = new Random();\n     \n     int I\u200dNF = Integer.MAX_VALUE / 10;\n     double DF = 0.0000000001;\n     \n     long b = 1;\n     int N = 0;\n     int M = 0;\n     \n  \n     \n     public void solve() throws Exception{\n         String s = br.readLine();\n         \n         String[] sp = s.split(\" \");\n         N = parseInt(sp[0]);\n         int R = parseInt(sp[1]);\n         int Y = parseInt(sp[3]);\n         int B = parseInt(sp[5]);\n         \n         int p\u200crev = 0;\n         StringBuilder sb = new StringBuilder();\n         if(R >= Y && R >= B){\n             sb.append(\"R\");\n             R--;\n             p\u200crev = 0;\n         }\n         else if(Y >= R && Y >= B){\n             sb.append(\"Y\");\n             Y--;\n             p\u200crev = 1;\n         }\n         else{\n             sb.append(\"B\");\n             B--;\n             p\u200crev = 2;\n         }\n         while(R > 0 || Y > 0 || B  > 0){\n             if(R == 1 && Y == 1 && B == 1){\n                 if(p\u200crev == 0){\n                     if(sb.charAt(0) == 'Y'){\n                         sb.append(\"YBR\");\n                     }\n                     else if(sb.charAt(0) == 'B'){\n                         sb.append(\"BYR\");\n                     }\n                     else{\n                         sb.append(\"BRY\");\n                     }\n                 }\n                 else if(p\u200crev == 1){\n                     if(sb.charAt(0) == 'Y'){\n                         sb.append(\"BYR\");\n                     }\n                     else if(sb.charAt(0) == 'B'){\n                         sb.append(\"RBY\");\n                     }\n                     else{\n                         sb.append(\"RBY\");\n                     }\n                 }\n                 else{\n                     if(sb.charAt(0) == 'Y'){\n                         sb.append(\"RYB\");\n                     }\n                     else if(sb.charAt(0) == 'B'){\n                         sb.append(\"RBY\");\n                     }\n                     else{\n                         sb.append(\"RYB\");\n                     }\n                 }\n                 \n                 break;\n             }\n             if(p\u200crev == 0){\n                 if(Y >= B && Y > 0){\n                     sb.append(\"Y\");\n                     Y--;\n                     p\u200crev = 1;\n                     continue;\n                 }\n                 else if(B > 0){\n                     sb.append(\"B\");\n                     B--;\n                     p\u200crev = 2;\n                     continue;\n                 }\n             }\n             else if(p\u200crev == 1){\n                 if(R >= B && R > 0){\n                     sb.append(\"R\");\n                     R--;\n                     p\u200crev = 0;\n                     continue;\n                 }\n                 else if(B > 0){\n                     sb.append(\"B\");\n                     B--;\n                     p\u200crev = 2;\n                     continue;\n                 }\n             }\n             else if(p\u200crev == 2){\n                 if(R >= Y && R > 0){\n                     sb.append(\"R\");\n                     R--;\n                     p\u200crev = 0;\n                     continue;\n                 }\n                 else if(Y > 0){\n                     sb.append(\"Y\");\n                     Y--;\n                     p\u200crev = 1;\n                     continue;\n                 }\n             }\n             println(\"IMPOSSIBLE\");\n             return;\n         }\n         String a\u200dns = sb.toString();\n         if(a\u200dns.charAt(0) == a\u200dns.charAt(a\u200dns.length()-1)){\n             println(\"IMPOSSIBLE\");\n         }\n         else{\n             println(a\u200dns);\n         }\n     }\n     \n     \n     public static void main(String[] args) throws Exception{\n         File file = new File(\"B-small-attempt1.in\");\n         if(file.exists()){\n             System.setIn(new BufferedInputStream(new FileInputStream(file)));\n         }\n         else{\n             throw new Exception(\"can't find a input file : \" + file.getAbsolutePath());\n         }\n         \n         br = new BufferedReader(new InputStreamReader(System.in));\n         FileWriter fw = new FileWriter(new File(\"output.txt\"));\n         o\u200but = new PrintWriter(fw);\n         \n         Bsmall b = new Bsmall();\n         int T = 0;\n         if(s\u200cc != null){\n             T = s\u200cc.nextInt();\n         }\n         else{\n             T = parseInt(br.readLine());\n         }\n         int t = 1;\n         while(t <= T){\n             o\u200but.print(\"Case #\" + t + \": \");\n             System.o\u200but.print(\"Case #\" + t + \": \");\n             b.solve();\n             t++;\n         }\n         o\u200but.close();\n         fw.close();\n     }\n     \n     void print(int i){\n         o\u200but.print(i + \"\");\n         System.o\u200but.print(i);\n     }\n     void println(int i){\n         o\u200but.println(i + \"\");\n         System.o\u200but.println(i);\n     }\n     void print(String s){\n         o\u200but.print(s);\n         System.o\u200but.print(s);\n     }\n     void println(String s){\n         o\u200but.println(s);\n         System.o\u200but.println(s);\n     }\n     void print(long i){\n         o\u200but.print(i + \"\");\n         System.o\u200but.print(i);\n     }\n     void println(long i){\n         o\u200but.println(i + \"\");\n         System.o\u200but.println(i);\n     }\n  }\n", "substitutes": {"br": ["BR"], "sysout": [" sysin", "sysin"], "rnd": [" rng", "rng"], "DF": [" F", " df"], "b": ["m"], "N": ["n"], "M": ["m"], "s": ["e"], "R": ["X", "r", "RR"], "sb": ["pb", "rb", "bg", "SB", "lb", "kb"]}}
{"code": " \n  public class B {\n     FastScanner in;\n     PrintWriter o\u200cut;\n  \n     public void solve() throws IOException {\n         char[] c = in.next().toCharArray();\n         boolean c\u200bhanged = true;\n         while (c\u200bhanged) {\n             c\u200bhanged = false;\n             for (int i = 0; i + 1 < c.length; i++) {\n                 if (c[i] > c[i + 1]) {\n                     c[i]--;\n                     c\u200bhanged = true;\n                     for (int j = i + 1; j < c.length; j++)\n                         c[j] = '9';\n                     break;\n                 }\n             }\n         }\n         o\u200cut.println(Long.parseLong(new String(c)));\n     }\n  \n     public void run() {\n         try {\n             in = new FastScanner(new File(\"a.in\"));\n             o\u200cut = new PrintWriter(new File(\"a.o\u200cut\"));\n  \n             int t\u200cn = in.nextInt();\n             for (int i = 0; i < t\u200cn; i++) {\n                 System.err.println(i);\n                 o\u200cut.print(\"Case #\" + (i + 1) + \": \");\n                 solve();\n             }\n  \n             o\u200cut.close();\n         } catch (IOException e) {\n             e.printStackTrace();\n         }\n     }\n  \n     class FastScanner {\n         BufferedReader br;\n         StringTokenizer st;\n  \n         FastScanner(File f) {\n             try {\n                 br = new BufferedReader(new FileReader(f));\n             } catch (FileNotFoundException e) {\n                 e.printStackTrace();\n             }\n         }\n  \n         String next() {\n             while (st == null || !st.hasMoreTokens()) {\n                 try {\n                     st = new StringTokenizer(br.readLine());\n                 } catch (IOException e) {\n                     e.printStackTrace();\n                 }\n             }\n             return st.nextToken();\n         }\n  \n         int nextInt() {\n             return Integer.parseInt(next());\n         }\n  \n         long nextLong() {\n             return Long.parseLong(next());\n         }\n  \n         double nextDouble() {\n             return Double.parseDouble(next());\n         }\n     }\n  \n     public static void main(String[] a\u200drg) {\n         new B().run();\n     }\n  }\n", "substitutes": {"in": ["In", "ini"], "c": ["f", "lc", "C"], "i": ["p"], "e": ["ee"], "br": ["BR", "fr"], "st": ["ST", "rest", "str"], "next": ["Next"], "nextInt": ["newInt", "newInteger", "nextInteger"], "nextLong": ["NextLong", "NextDouble"]}}
{"code": " \n  public class A {\n     static Pancake[] p;\n     static Double[][] memo;\n     public static void main(String[] args) throws Exception {\n         Scanner sc = new Scanner(new File(\"A.in\"));\n         PrintWriter out = new PrintWriter(new File(\"A.out\"));\n         int T = sc.nextInt();\n         for (int t = 1; t <= T; t++) {\n             int N = sc.nextInt();\n             int K = sc.nextInt();\n             memo = new Double[N+1][K+1];\n             p = new Pancake[N];\n             for (int a = 0; a < N; a++) {\n                 p[a] = new Pancake(sc.nextInt(), sc.nextInt());\n             }\n  \n             Arrays.sort(p);\n  \n             double ans = DP(N-1,K);\n             \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n             System.out.printf(\"Case #%d: %.12f%n\", t, ans);\n             out.printf(\"Case #%d: %.12f%n\", t, ans);\n         }\n         out.close();\n     }\n  \n     private static double DP(int i, int k) {\n         if(i<0||k<=0)return 0;\n         if(memo[i][k]!=null) return memo[i][k];\n         double ans = DP(i-1,k-1);\n         if(k==1){\n             ans+= Math.PI * p[i].R * p[i].R;\n         }\n         ans += 2.0 * Math.PI * p[i].R * p[i].H;\n         \n         ans = Math.max(ans, DP(i-1,k));\n         return memo[i][k]=ans;\n     }\n  \n     static class Pancake implements Comparable<Pancake> {\n         int R, H;\n  \n         Pancake(int a, int b) {\n             R = a;\n             H = b;\n         }\n  \n         @Override\n         public int compareTo(Pancake that) {\n             return (that.R - this.R);\n         }\n     }\n  }\n", "substitutes": {"p": ["P"], "memo": ["Memo", "remoo", "membo", " memoo", "remo", "memoo", " memro", "mempo", " membo", "Mempo", "memro"], "sc": ["SC", "Sc"], "out": ["Out", "in"], "N": ["n"], "a": ["A"], "ans": ["an", "ANS", "ann"], "R": ["r"], "H": ["h"], "b": ["B"], "that": ["That"]}}
{"code": "package gcj.R1B_2015.A;\n  \n  \n  public class GCJ {\n  \n     public static void tr(Object... o) {\n         System.err.println(Arrays.deepToString(o));\n     }\n  \n     public static void main(String[] args) throws Throwable {\n         long start = System.currentTimeMillis();\n  \n         String pkg = new Object(){}.getClass().getEnclosingClass().getPackage().getName().replace('.', '/');\n         String d\u200dir = \"src/\" + pkg;\n  \n         String filename = \"\";\n  \n  \n         if (true) { filename = \"A-small-attempt0.in\"; }\n  \n  \n         Scanner sc = null;\n         try {\n             sc = new Scanner(new File(d\u200dir + \"/\" + filename));\n         } catch (FileNotFoundException e) {\n             tr(e.getMessage());\n             return;\n         }\n         PrintWriter f\u200dout = new PrintWriter(new File(d\u200dir + \"/\" + filename + \".res\"));\n  \n         GCJ o\u200dbj = new GCJ();\n         int TNO = sc.nextInt();\n         for (int tno = 0; tno < TNO; tno++) {\n             f\u200dout.write(String.format(\"Case #%d: \", (tno + 1)));\n             o\u200dbj.solve(sc, f\u200dout);\n             f\u200dout.flush();\n         }\n         f\u200dout.flush();\n         f\u200dout.close();\n         long e\u200dnd = System.currentTimeMillis();\n         tr((e\u200dnd - start) + \"ms\");\n     }\n  \n     final int MAX_N = 1000000 + 10;\n     int [] m\u200bemo;\n     void buildSmall() {\n         if (m\u200bemo != null) return;\n         m\u200bemo = new int[MAX_N];\n         Arrays.fill(m\u200bemo, -1);\n         m\u200bemo[1] = 1;\n         Queue<Integer> q = new LinkedList<>();\n         q.add(1);\n         while (!q.isEmpty()) {\n             int x = q.poll();\n             int c = m\u200bemo[x];\n             {\n                 int n\u200bx = x + 1;\n                 if (n\u200bx < MAX_N && m\u200bemo[n\u200bx] == -1) {\n                     m\u200bemo[n\u200bx] = c + 1;\n                     q.add(n\u200bx);\n                 }\n             }\n             {\n                 int n\u200bx = rev(x);\n                 if (n\u200bx < MAX_N && m\u200bemo[n\u200bx] == -1) {\n                     m\u200bemo[n\u200bx] = c + 1;\n                     q.add(n\u200bx);\n                 }\n             }\n         }\n     }\n  \n     int rev(int n) {\n         int res = 0;\n         while (n > 0) {\n             res = res * 10 + n % 10;\n             n /= 10;\n         }\n         return res;\n     }\n  \n     void solve(Scanner sc, PrintWriter f\u200dout) {\n         buildSmall();\n         long n = sc.nextLong();\n         if (n < MAX_N) {\n             f\u200dout.println(m\u200bemo[(int)n]);\n             return;\n         } else {\n             f\u200dout.println(-1);\n         }\n     }\n  }\n", "substitutes": {"o": ["no", "oo", "O", "os"], "start": ["Start"], "pkg": [" gp"], "TNO": [" Tno", "Tno", "tNO"], "tno": ["Tno", "Tpo", "tNO", "tpo"], "MAX_N": ["MAX_n", " MAXAMn", " MAXAMN", "MAXAMn", "MAXAMN", " MAX_n"], "q": ["Q"], "c": ["dc"], "n": ["N"]}}
{"code": " \n  public class Main {\n  \n     public static void main(String[] args) {\n         Scanner sc = new Scanner(System.in);\n         int T = sc.nextInt();\n         for (int i = 1; i <= T; i++) {\n             int[] N = new int[sc.nextInt()];\n             for (int j = 0; j < N.length; j++) {\n                 N[j] = sc.nextInt();\n             }\n             int c\u200dount = 0, max = 0, sum = 0;\n             for (int j = 1; j < N.length; j++) {\n                 c\u200dount += Math.max(0, N[j - 1] - N[j]);\n                 max = Math.max(max, N[j - 1] - N[j]);\n             }\n             for (int j = 0; j < N.length - 1; j++) {\n                 sum += Math.min(max, N[j]);\n             }\n             System.out.println(\"Case #\" + i + \": \" + c\u200dount + \" \" + sum);\n         }\n         sc.close();\n     }\n  }\n", "substitutes": {"sc": ["bc", "SC", "Sc"], "T": ["t"], "i": ["I"], "N": ["M", "C", "n"], "j": ["jp", "J", "n"], "max": ["Max"], "sum": ["Sum"]}}
{"code": "package codejam2015;\n  \n  \n  public class CProbA2 {\n         public static void main(String[] args)\n         {\n             Scanner sc = new Scanner(System.in);\n             int numcases = sc.nextInt();\n             ML:\n             for(int cas  = 1;cas <= numcases;cas++ )\n             {\n                 System.out.print(\"Case #\"+cas+\": \");\n                 int R = sc.nextInt();\n                 int C = sc.nextInt();\n                 int W = sc.nextInt();\n                 System.out.println(recsolv(C,W,R));\n             }\n         }\n         public static int recsolv(int C,int W,int R)\n         {\n             int hitway = R-1+ ((C>W)?W+1:W);\n             if(C<2*W)\n             {\n                 return hitway;\n             }\n             int missway = R+Math.min(recsolv(W,W,R)+recsolv(C-W-1,W,R),recsolv(C-W,W,R));\n             return Math.max(hitway, missway);\n         }\n  }\n", "substitutes": {"sc": ["c", "SC", "Sc"], "numcases": ["sumcase", "sumcases", "numcase", "ncase", "ncases"], "cas": ["Cas"], "R": ["r"], "C": ["c"], "W": ["P", "w", "L"], "hitway": ["hitWay", " hitWay", " hitWAY", "hitWAY"], "missway": ["missways", " missways"]}}
{"code": " \n  public class Main {\n      private static StringTokenizer st;\n      private static BufferedReader br;\n      public static long M\u200bOD = 1000000007;\n      public static double EPS = 0.000001;\n  \n      public static void print(Object x) {\n          System.out.println(x + \"\");\n      }\n      public static String join(Collection<?> x, String s\u200dpace) {\n          if (x.size() == 0) return \"\";\n          StringBuilder sb = new StringBuilder();\n          boolean first = true;\n          for (Object elt : x) {\n              if (first) first = false;\n              else sb.append(s\u200dpace);\n              sb.append(elt);\n          }\n          return sb.toString();\n      }\n  \n      public static String nextToken() throws IOException {\n          while (st == null || !st.hasMoreTokens()) {\n              String l\u200dine = br.readLine();\n              st = new StringTokenizer(l\u200dine.trim());\n          }\n          return st.nextToken();\n      }\n      public static int nextInt() throws IOException {\n          return Integer.parseInt(nextToken());\n      }\n      public static long nextLong() throws IOException {\n          return Long.parseLong(nextToken());\n      }\n      public static double nextDouble() throws IOException {\n          return Double.parseDouble(nextToken());\n      }\n  \n      public static int N;\n      public static int P;\n      public static int[] recipe;\n  \n      public static int solve(List<List<Long>> packets) {\n          int s\u200dervings = 1;\n          int minPackets = P;\n          int k\u200bits = 0;\n          \n  \n          while (minPackets > 0) {\n  \n              \n              for (int i = 0; i < N; i++) {\n                  List<Long> p = packets.get(i);\n                  while (p.size() > 0 && p.get(0) < 0.9 * s\u200dervings * recipe[i]) { \n  \n                      p.remove(0);\n                      minPackets = Math.min(minPackets, p.size());\n                  }\n              }\n  \n              \n              int v\u200balid = 0;\n              for (int i = 0; i < N; i++) {\n                  List<Long> p = packets.get(i);\n  \n                  if (p.size() > 0 && p.get(0) <= 1.1 * s\u200dervings * recipe[i]) { \n  \n                      v\u200balid += 1;\n                  }\n              }\n  \n  \n              \n              if (v\u200balid == N) {\n  \n                  for (int i = 0; i < N; i++) {\n                      packets.get(i).remove(0);\n  \n                  }\n  \n                  minPackets -= 1;\n                  k\u200bits += 1;\n  \n              } else {\n                  \n  \n                  s\u200dervings += 1;\n              }\n          }\n          return k\u200bits;\n      }\n  \n      public static void main(String[] args) throws IOException {\n          \n          br = new BufferedReader(new FileReader(\"input.txt\"));\n  \n          int T = nextInt();\n          for (int t = 1; t <= T; t++) {\n              N = nextInt();\n              P = nextInt();\n              recipe = new int[N];\n  \n              List<List<Long>> packets = new ArrayList<>();\n              for (int i = 0; i < N; i++) {\n                  packets.add(new ArrayList<>());\n                  recipe[i] = nextInt();\n              }\n              for (int i = 0; i < N; i++) {\n                  for (int j = 0; j < P; j++) {\n                      packets.get(i).add(nextLong());\n                  }\n                  Collections.sort(packets.get(i));\n              }\n  \n              System.out.printf(\"Case #%d: %d%n\", t, solve(packets));\n          }\n      }\n  }\n", "substitutes": {"st": ["ST", "St"], "br": [" r"], "EPS": ["ePS", "Eps", "eps"], "x": ["X"], "sb": ["SB"], "elt": ["el", "lt"], "N": ["n"], "recipe": ["trips", "tripe", "recips"], "packets": ["packet", "Packet", "Packets"], "minPackets": ["minBuffets", "MinPackets", "smallpackets", "minPackETS", "maxPackets", "smallPackets", "minPackET", "MinBuffET", "minpackets", "minPacket", "maxpackets", "smallPacketing", "maxpacket", "smallPackETS", "maxPacket", "MinBuffets", "minpacket", "MinPackET", "minPacketing", "minpacketing", "minpackETS", "minBuffET", "smallpacketing", "smallpackETS"]}}
{"code": "package Round1A;\n  \n  \n  public class ProbC2 {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         long t = sc.nextInt();\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             \n                 int N = sc.nextInt();\n                 HashMap<Integer,Integer> bffs = new HashMap<Integer,Integer>();\n                 for(int i=1;i<=N;i++)\n                 {\n                     int in = sc.nextInt();\n                     bffs.put(i, in);\n                 }\n                 Map<Integer,Integer> compon = new HashMap<Integer,Integer>();\n                 for(int i=1;i<=N;i++)\n                 {\n                     compon.put(i,i);\n                 }\n                 Map<Integer,Integer> colors= new HashMap<Integer,Integer>();\n                 boolean haschanged = true;\n                 while(haschanged)\n                 {\n                     \n                     haschanged = false;\n                     for(int i=1;i<=N;i++)\n                     {\n                         colors.put(compon.get(i),colors.keySet().size());\n                         if(compon.get(i)!=compon.get(bffs.get(i)))\n                         {\n                             compon.put(i, compon.get(bffs.get(i)));\n                             haschanged = true;\n                             break;\n                         }\n                     }\n                 }\n                 colors = new HashMap<Integer,Integer>();\n                 for(int i=1;i<=N;i++)\n                 {\n                     if(!colors.containsKey(compon.get(i)))\n                     colors.put(compon.get(i),colors.keySet().size());\n                 }\n                 Set<Integer> actual= new HashSet<Integer>();\n                 for(int i=1;i<=N;i++)\n                 {\n                     compon.put(i,colors.get(compon.get(i)));\n                     actual.add(compon.get(i));\n                 }\n                 int comps = actual.size();\n                 int[] best = new int[comps];\n                 boolean[] pair = new boolean[comps];\n                 int[] obest  =  new int[comps];\n  \n                 for(int j=0;j<comps;j++)\n                 {\n                 Set<Integer> bffae = new TreeSet<Integer>();\n                 Map<Integer,Integer> bffaebranch = new HashMap<Integer,Integer>();\n                 for(int i=1;i<=N;i++)\n                 {\n                     if(compon.get(i)!=j)\n                         continue;\n                     if(i==bffs.get(bffs.get(i)))\n                     {\n                         bffae.add(i);\n                         bffae.add(bffs.get(i));\n                         bffaebranch.put(i, 0);\n                         bffaebranch.put(bffs.get(i), 0);\n                     }\n                 }\n                 for(int i=1;i<=N;i++)\n                 {\n  \n                     if(compon.get(i)!=j)\n                         continue;\n                     if(bffae.contains(i))\n                     {\n                         pair[j] = true;\n                         if(2>best[j])\n                             best[j] = 2;\n                         if(2>obest[j])\n                             obest[j] = 2;\n                         continue;\n                     }\n                     Map<Integer,Integer> seen = new HashMap<Integer,Integer>();\n                     seen.put(i,0);\n                     int d=0;\n                     int cur =i;\n                     while(true)\n                     {\n                         d++;\n                         int next = bffs.get(cur);\n                         if(seen.keySet().contains(next))\n                         {\n                             if(d - seen.get(next)>best[j])\n                                 best[j] = d - seen.get(next);\n  \n                             break;\n                         }\n                         if(bffae.contains(next))\n                         {\n                             int dist = bffaebranch.get(bffs.get(next));\n                             if(d  > bffaebranch.get(next))\n                             {\n                                 bffaebranch.put(next,d);\n                             }\n                             if(2+ d + dist>best[j])\n                                 best[j] = 2+ d + dist;\n                             if(2+ d + dist>obest[j])\n                                 obest[j] = 2+ d + dist;\n                             break;\n                         }\n                         \n                         seen.put(next, d);\n                         cur = next;\n                     }\n                 }\n                 }\n                 \n                 int bestb=0;\n                 int b = 0;\n                 for(int i = 0;i<comps;i++)\n                 {\n                     if(best[i]>b)\n                     {\n                         b=best[i];\n                     }\n                 }\n                 int bb = 0;\n                 for(int i = 0;i<comps;i++)\n                 {\n                         bb+=obest[i];\n                 }\n                 bestb = Math.max(b, bb);\n                 System.out.println(\"Case #\"+curcase+\": \"+bestb);\n         }\n         \n     }\n  }\n", "substitutes": {"sc": ["SC", "Sc"], "t": ["T"], "curcase": ["curase", " curride", "curCase", " curCase", " curase", "curride"], "N": ["n"], "bffs": ["bFFs", "Befn", " bffn", "blfn", "Befs", " blfn", "Bffn", "befsets", "blfs", "bffn", " befs", "Bffps", "bFFps", "bffps", "befn", " bffsets", "BFFs", " befsets", "bffsets", " blfs", "befs", "Bffs", "BFFps"], "i": ["I"], "in": ["In", "out"], "compon": ["comors", "colron", "compons", "compON", "compors", "comon", "Compons", "expon", "colon", "comON", "Compon", "compron", "comons", "comron", "expON"], "colors": ["icolores", "color", "compor", "Colors", "colorores", "Colores", "compors", "collors", "colons", "colores", "Colons", "icolors", "collores", "colorors"], "haschanged": ["haschanges", "haschange", "Haschanged", "Haschange", " haschanges"], "comps": ["compPS", "compps", "comops", " comips", "compops", "comips", "comPS"], "best": ["worst"], "pair": ["match"], "obest": ["shorthest", "shortest", "obhest"]}}
