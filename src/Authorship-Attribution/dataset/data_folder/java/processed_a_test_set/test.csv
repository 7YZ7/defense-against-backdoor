vincentbelrose	<>	0	<>	11254486_5686313294495744_vincentbelrose_gcj_technobabble.java	<>	\n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.File;\n import java.io.PrintWriter;\n import java.math.BigInteger;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.HashSet;\n import java.util.Locale;\n import java.util.Random;\n import java.util.Scanner;\n import java.util.StringTokenizer;\n \n public class GCJ_TechnoBabble {\n \n    void log(long[] X){\n        int L=X.length;\n        for (int i=0;i<L;i++){\n            logWln(X[i]+" ");\n        }\n        log("");\n    }\n \n    void log(double[] X){\n        int L=X.length;\n        for (int i=0;i<L;i++){\n            logWln(X[i]+" ");\n        }\n        log("");\n    }\n \n    void log(int[] X){\n        int L=X.length;\n        for (int i=0;i<L;i++){\n            logWln(X[i]+" ");\n        }\n        log("");\n    }\n    void log(Object[] X){\n        int L=X.length;\n        for (int i=0;i<L;i++){\n            logWln(X[i]+" ");\n        }\n        log("");\n    }\n \n \n    void log(Object o){\n        logWln(o+"\n");\n    }\n \n    void logWln(Object o){\n        System.out.print(o);\n        \n \n    }\n    void info(Object o){\n        System.out.println(o);\n        \n    }\n \n \n \n \n    String solveBourrin(String[] A,String[] B){\n        int min=Integer.MAX_VALUE;\n        int MX=1<<N;\n        for (int u=1;u<MX;u++){\n            HashSet<String> first=new HashSet<String>();\n            HashSet<String> second=new HashSet<String>();\n            \n            for (int i=0;i<N;i++){\n                if ((u & (1<<i))!=0){\n                    first.add(A[i]);\n                    second.add(B[i]);\n                    \n                }\n                \n            }\n            \n            boolean ok=true;\n            loop:for (int i=0;i<N;i++){\n                if (!(first.contains(A[i]) && second.contains(B[i]))){\n                    ok=false;\n                    break loop;\n                }\n            }\n            if (ok){\n                int cnt=Integer.bitCount(u);\n                if (cnt<min)\n                    min=cnt;\n            }\n        }\n        return ""+(N-min);\n    }\n \n \n \n    \n    StringTokenizer st;\n    BufferedReader in;\n    BufferedWriter out;\n int N;\n \n \n \n    void process() throws Exception {\n        Locale.setDefault(Locale.US);\n \n \n \n \n        \n        File inputFile=new File("C.in");\n \n \n \n        \n        PrintWriter outputFile= new PrintWriter("C.out","UTF-8");\n \n \n \n        Scanner sc=new Scanner(inputFile);\n        sc.useLocale(Locale.US);\n \n        int T=sc.nextInt();\n        for (int t=1;t<=T;t++){\n \n            N=sc.nextInt();\n            String[] A=new String[N];\n            String[] B=new String[N];\n            \n            for (int i=0;i<N;i++){\n                A[i]=sc.next();\n                B[i]=sc.next();\n                \n                \n            }\n            String ss=""+solveBourrin(A,B);\n            System.out.println("Case #"+t+": "+ss);\n            outputFile.println("Case #"+t+": "+ss);\n \n \n        }\n \n \n \n        sc.close();\n        outputFile.close();\n \n \n    }\n \n \n \n    public static void main(String[] args) throws Exception {\n        GCJ_TechnoBabble J=new GCJ_TechnoBabble();\n \n        J.process();\n \n \n    }\n \n \n \n \n \n \n }\n
vincentbelrose	<>	0	<>	11254486_5695413893988352_vincentbelrose_gcj_closematch.java	<>	\n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.File;\n import java.io.PrintWriter;\n import java.math.BigInteger;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.HashSet;\n import java.util.Locale;\n import java.util.Random;\n import java.util.Scanner;\n import java.util.StringTokenizer;\n \n public class GCJ_CloseMatch {\n \n    void log(long[] X){\n        int L=X.length;\n        for (int i=0;i<L;i++){\n            logWln(X[i]+" ");\n        }\n        log("");\n    }\n \n    void log(double[] X){\n        int L=X.length;\n        for (int i=0;i<L;i++){\n            logWln(X[i]+" ");\n        }\n        log("");\n    }\n \n    void log(int[] X){\n        int L=X.length;\n        for (int i=0;i<L;i++){\n            logWln(X[i]+" ");\n        }\n        log("");\n    }\n    void log(Object[] X){\n        int L=X.length;\n        for (int i=0;i<L;i++){\n            logWln(X[i]+" ");\n        }\n        log("");\n    }\n \n \n    void log(Object o){\n        logWln(o+"\n");\n    }\n \n    void logWln(Object o){\n        System.out.print(o);\n        \n \n    }\n    void info(Object o){\n        System.out.println(o);\n        \n    }\n \n \n \n    String solveKO2(String A,String B){\n \n        int L=A.length();\n        char[] a;\n        char[] b;\n        String ta,tb;\n        a=A.toCharArray();\n        b=B.toCharArray();\n        int sta=0,stb=0;\n        \n \n        boolean divergent=false;\n        int option=-1;\n        int divPoint=-1;\n        for (int u=0;u<L && !divergent;u++){\n            if (a[u]!='?' && b[u]!='?' && a[u]!=b[u]) {\n                divergent=true;\n                divPoint=u;\n            } if (!divergent && (a[u]=='?' || b[u]=='?')){\n                option=u;\n            }\n        }\n \n        String[] mina=new String[L];\n        String[] minb=new String[L];\n        String[] maxa=new String[L];\n        String[] maxb=new String[L];\n \n        for (int u=L-1;u>=0;u--){\n            if (u==L-1){\n                \n                if (a[u]=='?')\n                    mina[u]="0";\n                else\n                    mina[u]=""+a[u];\n                if (b[u]=='?')\n                    minb[u]="0";\n                else\n                    minb[u]=""+b[u];\n \n                if (a[u]=='?')\n                    maxa[u]="9";\n                else\n                    maxa[u]=""+a[u];\n                if (b[u]=='?')\n                    maxb[u]="9";\n                else\n                    maxb[u]=""+b[u];\n            } else {\n                \n                if (a[u]=='?'){\n                    mina[u]="0"+mina[u+1];\n                    maxa[u]="9"+maxa[u+1];\n                } else {\n                    mina[u]=a[u]+mina[u+1];\n                    maxa[u]=a[u]+maxa[u+1];\n                }\n \n                if (b[u]=='?'){\n                    minb[u]="0"+minb[u+1];\n                    maxb[u]="9"+maxb[u+1];\n                } else {\n                    minb[u]=b[u]+minb[u+1];\n                    maxb[u]=b[u]+maxb[u+1];\n                }\n            }\n        }\n \n        if (!divergent){\n            \n            for (int u=0;u<L;u++){\n                if (a[u]=='?' && b[u]=='?'){\n                    a[u]='0';\n                    b[u]='0';\n                } else {\n                    if (a[u]=='?')\n                        a[u]=b[u];\n                    if (b[u]=='?')\n                        b[u]=a[u];\n                }\n \n            }\n            return new String(a)+" "+new String(b);\n        }\n \n        log("Divergent");\n \n        \n        \n        if (option==-1){\n            \n            log("But no option");\n            sta=0;\n            stb=0;\n            for (int u=0;u<L;u++){\n \n                if (a[u]=='?' || b[u]=='?'){\n                    if (sta>stb){\n                        if (a[u]=='?')\n                            a[u]='0';\n                        if (b[u]=='?')\n                            b[u]='9';\n                    } else {\n                        if (a[u]=='?')\n                            a[u]='9';\n                        if (b[u]=='?')\n                            b[u]='0';\n                    }\n                }\n                else {\n                    if (sta==stb){\n                        sta=a[u]-'0';\n                        stb=b[u]-'0';\n                    }\n                }\n \n            }\n            return new String(a)+" "+new String(b);\n        }\n \n        \n        log("Can change the world");\n        String pre="";\n        if (option>0){\n            pre=A.substring(0,option);\n        }\n        log("pre:"+pre);\n        int amin,amax,bmin,bmax;\n        if (a[option]=='?'){\n            amin=0;\n            amax=9;\n        } else {\n            amin=a[option]-'0';\n            amax=a[option]-'0';\n            \n        }\n        if (b[option]=='?'){\n            bmin=0;\n            bmax=9;\n        } else {\n            bmin=b[option]-'0';\n            bmax=b[option]-'0';\n            \n        }\n        BigInteger diff=null;\n        BigInteger gE=null,gF=null;\n        String ge="",gf="";\n        for (int x=amin;x<=amax;x++)\n            for (int y=bmin;y<=bmax;y++){\n                String[] tx=new String[]{x+mina[option+1],x+maxa[option+1]};\n                String[] ty=new String[]{y+minb[option+1],y+maxb[option+1]};\n                for (String e:tx)\n                    for (String f:ty){\n                        if (diff==null){\n                            BigInteger E=new BigInteger(e);\n                            BigInteger F=new BigInteger(f);\n                            diff=E.subtract(F);\n                            diff=diff.abs();\n                            gE=E;\n                            gF=F;\n                            ge=e;\n                            gf=f;\n                        } else {\n                            BigInteger E=new BigInteger(e);\n                            BigInteger F=new BigInteger(f);\n                            BigInteger delta=E.subtract(F);\n                            delta=delta.abs();\n                            if (delta.compareTo(diff)<0){\n                                diff=delta;\n                                gE=E;\n                                gF=F;\n                                ge=e;\n                                gf=f;\n                                \n                            } else if (delta.compareTo(diff)==0){\n                                if (E.compareTo(gE)<0){\n                                    gE=E;\n                                    gF=F;\n                                    ge=e;\n                                    gf=f;\n                                } else if (E.compareTo(gE)==0){\n                                    if (F.compareTo(gF)<0){\n                                        gE=E;\n                                        gF=F;\n                                        ge=e;\n                                        gf=f;\n                                    }\n                                }\n                                \n                            }\n                        }\n                    }\n            \n                \n            }\n        return (pre+ge)+" "+(pre+gf);\n        \n        \n        \n        \n        \n \n    }\n    \n    ArrayList<String > generate(String u){\n        ArrayList<String> world=new ArrayList<String>();\n        if (u.length()==1){\n            if (u.charAt(0)=='?'){\n                for (int v=0;v<10;v++)\n                    world.add(""+v);\n                return world;\n            }\n            world.add(u);\n            return world;\n        }\n        ArrayList<String> tmp=generate(u.substring(1,u.length()));\n        \n            if (u.charAt(0)=='?'){\n                for (String w:tmp)\n                for (int v=0;v<10;v++)\n                    world.add(v+w   );\n                \n            } else {\n                for (String w:tmp){\n                    world.add(u.charAt(0)+w);\n                }\n                \n            }\n        \n        \n        return world;\n    }\n    \n    String solveBourrin(String A,String B){\n        ArrayList<String> wa=generate(A);\n        ArrayList<String> wb=generate(B);\n        int ba=0,bb=0;\n        int diff=-1;\n        String sa=null,sb="";\n        for (String a:wa)\n            for (String b:wb){\n                Integer xa=Integer.parseInt(a);\n                Integer xb=Integer.parseInt(b);\n                if (diff==-1){\n                    diff=Math.abs(xa-xb);\n                    sa=a;\n                    sb=b;\n                    ba=xa;\n                    bb=xb;\n                } else {\n                    int delta=Math.abs(xa-xb);\n                    if (delta<diff){\n                        diff=delta;\n                        sa=a;\n                        sb=b;\n                        ba=xa;\n                        bb=xb;\n \n                        \n                    }  else if (delta==diff){\n                        if (xa<ba){\n                            sa=a;\n                            sb=b;\n                            ba=xa;\n                            bb=xb;\n                            \n                        } else if (ba==xa && xb<bb){\n                            sa=a;\n                            sb=b;\n                            ba=xa;\n                            bb=xb;\n                        }\n                        \n                    }\n                    \n                }\n            }\n        return sa+" "+sb;\n    }\n \n    \n    String solve(String A,String B){\n \n        int L=A.length();\n        char[] a;\n        char[] b;\n        String ta,tb;\n        a=A.toCharArray();\n        b=B.toCharArray();\n        int sta=0,stb=0;\n        \n \n        boolean divergent=false;\n        int option=-1;\n        int divPoint=-1;\n        for (int u=0;u<L && !divergent;u++){\n            if (a[u]!='?' && b[u]!='?' && a[u]!=b[u]) {\n                divergent=true;\n                divPoint=u;\n            } if (!divergent && (a[u]=='?' || b[u]=='?')){\n                option=u;\n            }\n        }\n \n        String[] mina=new String[L];\n        String[] minb=new String[L];\n        String[] maxa=new String[L];\n        String[] maxb=new String[L];\n \n        for (int u=L-1;u>=0;u--){\n            if (u==L-1){\n                \n                if (a[u]=='?')\n                    mina[u]="0";\n                else\n                    mina[u]=""+a[u];\n                if (b[u]=='?')\n                    minb[u]="0";\n                else\n                    minb[u]=""+b[u];\n \n                if (a[u]=='?')\n                    maxa[u]="9";\n                else\n                    maxa[u]=""+a[u];\n                if (b[u]=='?')\n                    maxb[u]="9";\n                else\n                    maxb[u]=""+b[u];\n            } else {\n                \n                if (a[u]=='?'){\n                    mina[u]="0"+mina[u+1];\n                    maxa[u]="9"+maxa[u+1];\n                } else {\n                    mina[u]=a[u]+mina[u+1];\n                    maxa[u]=a[u]+maxa[u+1];\n                }\n \n                if (b[u]=='?'){\n                    minb[u]="0"+minb[u+1];\n                    maxb[u]="9"+maxb[u+1];\n                } else {\n                    minb[u]=b[u]+minb[u+1];\n                    maxb[u]=b[u]+maxb[u+1];\n                }\n            }\n        }\n \n        if (!divergent){\n            \n            for (int u=0;u<L;u++){\n                if (a[u]=='?' && b[u]=='?'){\n                    a[u]='0';\n                    b[u]='0';\n                } else {\n                    if (a[u]=='?')\n                        a[u]=b[u];\n                    if (b[u]=='?')\n                        b[u]=a[u];\n                }\n \n            }\n            return new String(a)+" "+new String(b);\n        }\n \n        log("Divergent");\n \n        \n        \n        if (option==-1){\n            \n            log("But no option");\n            sta=0;\n            stb=0;\n            for (int u=0;u<L;u++){\n \n                if (a[u]=='?' || b[u]=='?'){\n                    if (sta>stb){\n                        if (a[u]=='?')\n                            a[u]='0';\n                        if (b[u]=='?')\n                            b[u]='9';\n                    } else {\n                        if (a[u]=='?')\n                            a[u]='9';\n                        if (b[u]=='?')\n                            b[u]='0';\n                    }\n                }\n                else {\n                    if (sta==stb){\n                        sta=a[u]-'0';\n                        stb=b[u]-'0';\n                    }\n                }\n \n            }\n            return new String(a)+" "+new String(b);\n        }\n \n        \n        log("Can change the world");\n        String pre="";\n        if (option>0){\n            pre=A.substring(0,option);\n        }\n        log("pre:"+pre);\n        int amin,amax,bmin,bmax;\n        if (a[option]=='?'){\n            amin=0;\n            amax=9;\n        } else {\n            amin=a[option]-'0';\n            amax=a[option]-'0';\n            \n        }\n        if (b[option]=='?'){\n            bmin=0;\n            bmax=9;\n        } else {\n            bmin=b[option]-'0';\n            bmax=b[option]-'0';\n            \n        }\n        BigInteger diff=null;\n        BigInteger gE=null,gF=null;\n        String ge="",gf="";\n        for (int x=amin;x<=amax;x++)\n            for (int y=bmin;y<=bmax;y++){\n                String[] tx=new String[]{x+mina[option+1],x+maxa[option+1]};\n                String[] ty=new String[]{y+minb[option+1],y+maxb[option+1]};\n                for (String e:tx)\n                    for (String f:ty){\n                        if (diff==null){\n                            BigInteger E=new BigInteger(e);\n                            BigInteger F=new BigInteger(f);\n                            diff=E.subtract(F);\n                            diff=diff.abs();\n                            gE=E;\n                            gF=F;\n                            ge=e;\n                            gf=f;\n                        } else {\n                            BigInteger E=new BigInteger(e);\n                            BigInteger F=new BigInteger(f);\n                            BigInteger delta=E.subtract(F);\n                            delta=delta.abs();\n                            if (delta.compareTo(diff)<0){\n                                diff=delta;\n                                gE=E;\n                                gF=F;\n                                ge=e;\n                                gf=f;\n                                \n                            } else if (delta.compareTo(diff)==0){\n                                if (E.compareTo(gE)<0){\n                                    gE=E;\n                                    gF=F;\n                                    ge=e;\n                                    gf=f;\n                                } else if (E.compareTo(gE)==0){\n                                    if (F.compareTo(gF)<0){\n                                        gE=E;\n                                        gF=F;\n                                        ge=e;\n                                        gf=f;\n                                    }\n                                }\n                                \n                            }\n                        }\n                    }\n            \n                \n            }\n        return (pre+ge)+" "+(pre+gf);\n        \n        \n        \n \n    }\n \n    String solveKO(String A,String B){\n \n        int L=A.length();\n        char[] a;\n        char[] b;\n        String ta,tb;\n        a=A.toCharArray();\n        b=B.toCharArray();\n        int sta=0,stb=0;\n        \n        for (int u=0;u<L;u++){\n \n            if (a[u]=='?' || b[u]=='?'){\n                if (sta==stb){\n                    \n                    if (a[u]=='?' && b[u]=='?'){\n                        a[u]='0';\n                        b[u]='0';\n                    } else {\n                        if (a[u]=='?')\n                            a[u]=b[u];\n                        else\n                            b[u]=a[u];\n                    }\n \n                } else {\n                    \n                    if (sta>stb){\n                        if (a[u]=='?')\n                            a[u]='0';\n                        if (b[u]=='?')\n                            b[u]='9';\n \n                    } else {\n                        if (a[u]=='?')\n                            a[u]='9';\n                        if (b[u]=='?')\n                            b[u]='0';\n \n \n                    }\n \n \n                }\n            }\n \n            else {\n                \n                if (sta==stb){\n                    sta=a[u]-'0';\n                    stb=b[u]-'0';\n                }\n            }\n \n        }\n        \n        \n \n        return new String(a)+" "+new String(b);\n    }\n \n    String solveOld(String A,String B){\n        int L=A.length();\n        char[] a;\n        char[] b;\n        String ta,tb;\n        BigInteger ba,bb;\n        BigInteger op1=null,op2=null,op3=null;\n \n        \n \n        \n        \n        a=A.toCharArray();\n        b=B.toCharArray();\n        for (int u=0;u<L;u++){\n            if (a[u]=='?'){\n                if (b[u]=='?'){\n                    a[u]='0';\n                    b[u]='9';\n                } else {\n                    a[u]=b[u];\n                }\n            } else {\n                if (b[u]=='?')\n                    b[u]=9;\n            }\n        }\n        ta=new String(a);\n        tb=new String(b);\n \n        if (ta.compareTo(tb)>0){\n            ba=new BigInteger(ta);\n            bb=new BigInteger(tb);\n            op1=ba.subtract(bb);\n        }\n \n \n        \n        a=A.toCharArray();\n        b=B.toCharArray();\n        for (int u=0;u<L;u++){\n            if (a[u]=='?')\n                a[u]='0';\n            if (b[u]=='?'){\n                b[u]='9';\n            }\n            {\n            }\n \n        }\n        ta=new String(ta);\n        tb=new String(tb);\n \n        if (ta.compareTo(tb)>0){\n            ba=new BigInteger(ta);\n            bb=new BigInteger(tb);\n            op1=ba.subtract(bb);\n        }\n \n \n \n \n \n        \n \n \n \n        return null;\n    }\n \n \n \n \n    \n    StringTokenizer st;\n    BufferedReader in;\n    BufferedWriter out;\n \n \n \n \n    void process() throws Exception {\n        Locale.setDefault(Locale.US);\n \n \n \n \n        \n        File inputFile=new File("B.in");\n \n \n \n        \n        PrintWriter outputFile= new PrintWriter("B.out","UTF-8");\n \n \n \n        Scanner sc=new Scanner(inputFile);\n        sc.useLocale(Locale.US);\n \n        int T=sc.nextInt();\n        for (int t=1;t<=T;t++){\n \n            String A=sc.next();\n            String B=sc.next();\n \n            String ss=""+solveBourrin(A,B);\n            System.out.println("Case #"+t+": "+ss);\n            outputFile.println("Case #"+t+": "+ss);\n \n \n        }\n \n \n \n        sc.close();\n        outputFile.close();\n \n \n    }\n \n \n \n    public static void main(String[] args) throws Exception {\n        GCJ_CloseMatch J=new GCJ_CloseMatch();\n \n        J.process();\n \n \n    }\n \n \n \n \n \n \n }\n
vincentbelrose	<>	0	<>	3264486_5633382285312000_vincentbelrose_b.java	<>	import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.File;\n import java.io.PrintWriter;\n import java.math.BigInteger;\n import java.util.ArrayList;\n import java.util.Locale;\n import java.util.Random;\n import java.util.Scanner;\n \n \n public class B {\n \n    static boolean verb=true;\n    static void log(Object X){if (verb) System.err.println(X);}\n    static void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+" ");System.err.println("");}}\n    static void log(int[] X){if (verb) {for (int U:X) System.err.print(U+" ");System.err.println("");}}\n    static void logWln(Object X){if (verb) System.err.print(X);}\n    static void info(Object o){ System.out.println(o);}\n    static void output(Object o){outputWln(""+o+"\n");  }\n    static void outputWln(Object o){try {out.write(""+ o);} catch (Exception e) {}}\n \n    static boolean ok(String s){\n        for (int i=0;i+1<s.length();i++)\n            if (s.charAt(i)>s.charAt(i+1))  \n                return false;\n        return true;\n    }\n \n    static String solveBourrin(long n){\n        for (long x=n;x>0;x--){\n            String s=""+x;\n            if (ok(s))\n                return s;\n        }\n        return "";\n    }\n \n    static void test(){\n        log("testing");\n        for (int i=1;i<1000000;i++){\n            String a=solveBourrin(i);\n            String b=solve(i);\n            if (!a.equals(b)){\n                log("Error");\n                log("i:"+i);\n                log(a+" "+b);\n                return;\n            }\n        }\n        log("done");\n    }\n \n    static String solve(long n){\n        String s=""+n;\n        int L=s.length();\n        if (L==1)\n            return s;\n \n        if (ok(s))\n            return s;\n \n        \n \n \n \n \n \n        char[] mem=new char[L];\n        \n        boolean flag=false;\n        int i=0;\n        while (i<L){\n            char c=s.charAt(i);\n            if (flag)\n                mem[i]='9';\n            else {\n                if (i+1<L){\n                    char d=s.charAt(i+1);\n                    if (c<=d)\n                        mem[i]=c;\n                    else {\n                        flag=true;\n                        \n                        while (i-1>=0 && mem[i-1]==c)\n                            i--;\n                        mem[i]=(char)(c-1);\n                    }\n                } \n            }\n            i++;\n        }\n \n        String res="";\n        i=0;\n        while (mem[i]=='0')\n            i++;\n        while (i<L) \n            res+=mem[i++];\n        return res;\n \n    }\n \n    \n    static BufferedWriter out;\n \n    static void process() throws Exception {\n        Locale.setDefault(Locale.US);\n \n \n        File inputFile=new File("B.in");\n        PrintWriter outputFile= new PrintWriter("B.out","UTF-8");\n        Scanner sc=new Scanner(inputFile);\n        sc.useLocale(Locale.US);\n \n        \n \n        \n        \n        int T=sc.nextInt();\n        for (int t=1;t<=T;t++){\n \n            long n=sc.nextLong();\n            String ss=""+solve(n);\n            System.out.println("Case #"+t+": "+ss);\n            outputFile.println("Case #"+t+": "+ss);\n \n \n        }\n         \n \n \n        sc.close();\n        outputFile.close();\n \n \n    }\n \n \n \n    public static void main(String[] args) throws Exception {\n \n \n        process();\n \n \n    }\n \n \n \n \n \n \n }\n
hs484	<>	1	<>	10224486_5718606851604480_hs484_gcj.java	<>	package gcj2016.r2.a;\n \n import java.io.File;\n import java.io.FileNotFoundException;\n import java.io.PrintWriter;\n import java.util.Arrays;\n import java.util.Scanner;\n \n public class GCJ {\n \n    public static void tr(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n \n    public static void main(String[] args) throws Throwable {\n        long start = System.currentTimeMillis();\n \n        String pkg = new Object(){}.getClass().getEnclosingClass().getPackage().getName().replace('.', '/');\n        String dir = "src/" + pkg;\n \n        String filename = "";\n \n \n        if (true) { filename = "A-small-attempt0.in"; }\n \n \n        Scanner sc = null;\n        try {\n            sc = new Scanner(new File(dir + "/" + filename));\n        } catch (FileNotFoundException e) {\n            tr(e.getMessage());\n            return;\n        }\n        PrintWriter fout = new PrintWriter(new File(dir + "/" + filename + ".res"));\n \n        GCJ obj = new GCJ();\n        int T = sc.nextInt();\n        for (int t = 0; t < T; t++) {\n            fout.write(String.format("Case #%d: ", (t + 1)));\n            obj.solve(sc, fout);\n            fout.flush();\n        }\n        fout.flush();\n        fout.close();\n        long end = System.currentTimeMillis();\n        tr((end - start) + "ms");\n    }\n    \n    static final String IMPOSSIBLE = "IMPOSSIBLE";\n    \n    void solve(Scanner sc, PrintWriter out) {\n        int N = sc.nextInt();\n        int R = sc.nextInt();\n        int P = sc.nextInt();\n        int S = sc.nextInt();\n        \n        char[] t = new char[1 << N];\n        int p = 0;\n        for (int i = 0; i < R; i++) t[p++] = 'R';\n        for (int i = 0; i < P; i++) t[p++] = 'P';\n        for (int i = 0; i < S; i++) t[p++] = 'S';\n        Arrays.sort(t);\n        do {\n            tr(new String(t));\n            if (check(t)) {\n                out.println(new String(t));\n                return;\n            }\n        } while (nextPermutation(t));\n        out.println(IMPOSSIBLE);\n        return;\n    }\n    \n    boolean check(char[] t) {\n        char[] work = t.clone();\n        int p = t.length;\n        int np = 0;\n        while (p > 1) {\n            for (int i = 0; i < p; i += 2) {\n                if (work[i] == work[i+1]) return false;\n                work[np++] = win(work[i], work[i+1]);\n            }\n            p = np;\n            np = 0;\n        }\n        return true;\n    }\n    \n    char win(char c1, char c2) {\n        if (c1 == c2) return c1;\n        if (c1 == 'R' && c2 == 'P') return c2;\n        if (c1 == 'P' && c2 == 'S') return c2;\n        if (c1 == 'S' && c2 == 'R') return c2;\n        return c1;\n    }\n    \n    static boolean nextPermutation(char[] is) {\n        int n = is.length;\n        for (int i = n - 1; i > 0; i--) {\n            if (is[i - 1] < is[i]) {\n                int j = n;\n                while (is[i - 1] >= is[--j])\n                    ;\n                swap(is, i - 1, j);\n                rev(is, i, n);\n                return true;\n            }\n        }\n        rev(is, 0, n);\n        return false;\n    }\n \n    static void swap(char[] is, int i, int j) {\n        char t = is[i]; is[i] = is[j]; is[j] = t;\n    }\n \n    static void rev(char[] is, int s, int t) {\n        while (s < --t) swap(is, s++, t);\n    }\n    \n }\n
hs484	<>	1	<>	10224486_5718447400943616_hs484_gcj.java	<>	package gcj2016.r2.d;\n \n import java.io.File;\n import java.io.FileNotFoundException;\n import java.io.PrintWriter;\n import java.util.Arrays;\n import java.util.Scanner;\n \n public class GCJ {\n \n    public static void tr(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n \n    public static void main(String[] args) throws Throwable {\n        long start = System.currentTimeMillis();\n \n        String pkg = new Object(){}.getClass().getEnclosingClass().getPackage().getName().replace('.', '/');\n        String dir = "src/" + pkg;\n \n        String filename = "";\n \n \n        if (true) { filename = "D-small-attempt0.in"; }\n \n \n        Scanner sc = null;\n        try {\n            sc = new Scanner(new File(dir + "/" + filename));\n        } catch (FileNotFoundException e) {\n            tr(e.getMessage());\n            return;\n        }\n        PrintWriter fout = new PrintWriter(new File(dir + "/" + filename + ".res"));\n \n        GCJ obj = new GCJ();\n        int T = sc.nextInt();\n        for (int t = 0; t < T; t++) {\n            fout.write(String.format("Case #%d: ", (t + 1)));\n            obj.solve(sc, fout);\n            fout.flush();\n        }\n        fout.flush();\n        fout.close();\n        long end = System.currentTimeMillis();\n        tr((end - start) + "ms");\n    }\n    \n    void solve(Scanner sc, PrintWriter out) {\n        int N = sc.nextInt();\n        boolean[][] t = new boolean[N][N];\n        for (int i = 0; i < N; i++) {\n            char[] cs = sc.next().toCharArray();\n            for (int j = 0; j < N; j++) {\n                t[i][j] = cs[j] == '1';\n            }\n        }\n        int X = 0;\n        for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) if (!t[i][j]) X++;\n        \n        int[] rs = new int[X];\n        int[] cs = new int[X];\n        {\n            int x = 0;\n            for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) if (!t[i][j]) {\n                rs[x] = i;\n                cs[x] = j;\n                x++;\n            }\n        }\n        int ans = X;\n        for (int set = 0; set < (1 << X); set++) {\n            for (int i = 0; i < X; i++) if ((set >> i & 1) == 1) { t[rs[i]][cs[i]] = true; }\n            if (check(t)) {\n                ans = Math.min(ans, Integer.bitCount(set));\n            }\n            for (int i = 0; i < X; i++) if ((set >> i & 1) == 1) { t[rs[i]][cs[i]] = false; }\n        }\n        out.println(ans);\n    }\n    boolean check(boolean[][] t) {\n        boolean[] already = new boolean[t.length];\n        try {\n            int[] perm = new int[t.length];\n            for (int i = 0; i < t.length; i++) perm[i] = i;\n            do {\n                Arrays.fill(already, false);\n                dfs(t, already, 0, perm);\n            } while (nextPermutation(perm));\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n    void dfs(boolean[][] t, boolean[] already, int n, int[] perm) throws Exception {\n        if (t.length == n) {\n            return ;\n        }\n        \n        boolean none = true;\n        for (int i = 0; i < t.length; i++) {\n            if (t[perm[n]][i] && !already[i]) {\n                none = false;\n                already[i] = true;\n                dfs(t, already, n+1, perm);\n                already[i] = false;\n            }\n        }\n        if (none) throw new Exception();\n    }\n    \n    static boolean nextPermutation(int[] is) {\n        int n = is.length;\n        for (int i = n - 1; i > 0; i--) {\n            if (is[i - 1] < is[i]) {\n                int j = n;\n                while (is[i - 1] >= is[--j])\n                    ;\n                swap(is, i - 1, j);\n                rev(is, i, n);\n                return true;\n            }\n        }\n        rev(is, 0, n);\n        return false;\n    }\n \n    static void swap(int[] is, int i, int j) {\n        int t = is[i]; is[i] = is[j]; is[j] = t;\n    }\n \n    static void rev(int[] is, int s, int t) {\n        while (s < --t) swap(is, s++, t);\n    }\n }\n
hs484	<>	1	<>	10224486_5677604812095488_hs484_gcj.java	<>	package gcj2016.r2.b;\n \n import java.io.File;\n import java.io.FileNotFoundException;\n import java.io.PrintWriter;\n import java.util.Arrays;\n import java.util.Scanner;\n \n public class GCJ {\n \n    public static void tr(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n \n    public static void main(String[] args) throws Throwable {\n        long start = System.currentTimeMillis();\n \n        String pkg = new Object(){}.getClass().getEnclosingClass().getPackage().getName().replace('.', '/');\n        String dir = "src/" + pkg;\n \n        String filename = "";\n \n \n        if (true) { filename = "B-small-attempt2.in"; }\n \n \n        Scanner sc = null;\n        try {\n            sc = new Scanner(new File(dir + "/" + filename));\n        } catch (FileNotFoundException e) {\n            tr(e.getMessage());\n            return;\n        }\n        PrintWriter fout = new PrintWriter(new File(dir + "/" + filename + ".res"));\n \n        GCJ obj = new GCJ();\n        int T = sc.nextInt();\n        for (int t = 0; t < T; t++) {\n            fout.write(String.format("Case #%d: ", (t + 1)));\n            obj.solve(sc, fout);\n            fout.flush();\n        }\n        fout.flush();\n        fout.close();\n        long end = System.currentTimeMillis();\n        tr((end - start) + "ms");\n    }\n    \n    void solve(Scanner sc, PrintWriter out) {\n        int N = sc.nextInt();\n        int K = sc.nextInt();\n        double[] P = new double[N];\n        for (int i = 0; i < N; i++) P[i] = sc.nextDouble();\n        Arrays.sort(P);\n        double ans = naive(P, K);\n        double[] PP = new double[K];\n        for (int i = 0; i < K/2; i++) {\n            PP[i] = P[i];\n            PP[K-1-i] = P[N - 1 - i];\n        }\n        out.printf("%.8f%n", ans);\n    }\n    \n    double naive(double[] P, int K) {\n        int N = P.length;\n        double best = 0;\n        double[] PP = new double[K];\n        int p = (1 << K) - 1;\n        do {\n            int sp = 0;\n            for (int i = 0; i < N; i++) {\n                if ((p >> i & 1) == 1) {\n                    PP[sp++] = P[i];\n                }\n            }\n            double ans = calc(PP);\n            best = Math.max(best, ans);\n        } while( (p = next_combination(p)) < (1 << N) );\n        return best;\n    }\n    \n    static int next_combination(int p) {\n        int lsb = p & -p;\n        int rem = p + lsb;\n        int rit = rem & ~p;\n        return rem | (((rit / lsb) >> 1) - 1);\n    }\n    \n    double calc(double[] P) {\n        int N = P.length;\n        double[][] dp = new double[N+1][N+1];\n        dp[0][0] = 1.0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                dp[i+1][j+1] += dp[i][j] * P[i];\n                dp[i+1][j]   += dp[i][j] * (1.0 - P[i]);\n            }\n        }\n        return dp[N][N/2];\n    }\n    \n }\n
AhmedFathyAly	<>	7	<>	10224486_5718447400943616_AhmedFathyAly_main.java	<>	import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.FileInputStream;\n import java.io.FileWriter;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.StringTokenizer;\n \n public class Main\n {\n \n    \n    InputReader in;\n    StringTokenizer tok;\n    StringBuilder ans;\n \n    \n    int n;\n    boolean[][] originalG, g;\n    ArrayList<ArrayList<Integer>> perms;\n    private ArrayList<Integer> currentPermutation;\n \n    public static void main(String[] args) throws Exception\n    {\n        Main sol = new Main();\n        sol.begin();\n \n    }\n \n    private void begin() throws IOException\n    {\n        \n        boolean file = true;\n        if (file)\n            in = new InputReader(new FileInputStream("D-small-attempt1.in"));\n        else\n            in = new InputReader(System.in);\n        ans = new StringBuilder();\n \n        \n        int nCases = in.nextInt();\n        for (int cas = 1; cas <= nCases; cas++)\n        {\n            n = in.nextInt();\n            originalG = new boolean[n][n];\n            for (int worker = 0; worker < n; worker++)\n            {\n                String str = in.next();\n                for (int c = 0; c < str.length(); c++)\n                    if (str.charAt(c) == '1')\n                        originalG[worker][c] = true;\n            }\n \n            ans.append("Case #" + cas + ": ");\n            ans.append(solve());\n            ans.append("\n");\n        }\n \n        \n        System.out.println("\nOutput: ");\n        System.out.println(ans.toString());\n        BufferedWriter out = new BufferedWriter(new FileWriter("output.txt"));\n        out.write(ans.toString());\n        out.close();\n \n        \n        System.out.println("\nTest: ");\n    }\n \n    private int solve()\n    {\n        \n        perms = new ArrayList<>();\n        generate(new ArrayList<Integer>());\n \n        \n        int maskLength = 1 << (n * n);\n        int minCost = Integer.MAX_VALUE;\n        for (int mask = 0; mask < maskLength; mask++)\n        {\n            g = new boolean[n][n];\n            int cost = 0;\n            boolean ignore = false;\n            for (int worker = 0; worker < n; worker++)\n                for (int machine = 0; machine < n; machine++)\n                {\n                    boolean bit = getBit(mask, worker, machine);\n                    if (originalG[worker][machine] && bit)\n                        ignore = true;\n                    if (!originalG[worker][machine] && bit)\n                        cost++;\n                    g[worker][machine] = originalG[worker][machine] || bit;\n                }\n \n            if (!ignore )\n                if (valid())\n                    minCost = Math.min(cost, minCost);\n        }\n \n        return minCost;\n    }\n \n    private boolean valid()\n    {\n        \n        for (ArrayList<Integer> permutation : perms)\n        {\n            currentPermutation = permutation;\n            if (!valid(0, 0))\n                return false;\n        }\n        return true;\n    }\n \n    private boolean valid(int workerIdx, int machineMask)\n    {\n        \n        if (workerIdx == n)\n            return true;\n \n        \n        boolean found = false;\n        int worker = currentPermutation.get(workerIdx);\n        for (int machine = 0; machine < n; machine++)\n            if (g[worker][machine] && ((machineMask & (1 << machine)) == 0))\n            {\n                boolean can = valid(workerIdx + 1, machineMask | (1 << machine));\n                if (can)\n                    found = true;\n                else\n                    return false;\n            }\n \n        return found;\n    }\n \n    private boolean getBit(int mask, int worker, int machine)\n    {\n        int pos = worker * n + machine;\n        return (mask & (1 << pos)) != 0;\n    }\n \n    private void generate(ArrayList<Integer> l)\n    {\n        \n        if (l.size() == n)\n        {\n            perms.add(l);\n            return;\n        }\n \n        for (int i = 0; i < n; i++)\n            if (!l.contains(i))\n            {\n                ArrayList<Integer> newL = new ArrayList<>(l);\n                newL.add(i);\n                generate(newL);\n            }\n \n    }\n \n }\n \n class InputReader\n {\n    BufferedReader reader;\n    StringTokenizer tok;\n \n    public InputReader(InputStream stream)\n    {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tok = new StringTokenizer("");\n    }\n \n    public String next()\n    {\n        while (!tok.hasMoreTokens())\n            try\n            {\n                tok = new StringTokenizer(reader.readLine());\n            } catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n        return tok.nextToken();\n    }\n \n    public int nextInt()\n    {\n        return Integer.parseInt(next());\n    }\n }
AhmedFathyAly	<>	7	<>	10224486_5718606851604480_AhmedFathyAly_main.java	<>	import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.FileInputStream;\n import java.io.FileWriter;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.util.StringTokenizer;\n \n public class Main\n {\n \n    \n    InputReader in;\n    StringTokenizer tok;\n    StringBuilder ans;\n \n    \n    int n, r, p, s;\n    private String best;\n \n    public static void main(String[] args) throws Exception\n    {\n        Main sol = new Main();\n        sol.begin();\n \n    }\n \n    private void begin() throws IOException\n    {\n        \n        boolean file = true;\n        if (file)\n            in = new InputReader(new FileInputStream("A-small-attempt0 (1).in"));\n        else\n            in = new InputReader(System.in);\n        ans = new StringBuilder();\n \n        \n        int nCases = in.nextInt();\n        for (int cas = 1; cas <= nCases; cas++)\n        {\n            n = in.nextInt();\n            r = in.nextInt();\n            p = in.nextInt();\n            s = in.nextInt();\n \n            ans.append("Case #" + cas + ": ");\n            ans.append(solve());\n            ans.append("\n");\n        }\n \n        \n        System.out.println("\nOutput: ");\n        System.out.println(ans.toString());\n        BufferedWriter out = new BufferedWriter(new FileWriter("output.txt"));\n        out.write(ans.toString());\n        out.close();\n \n        \n        System.out.println("\nTest: ");\n \n        System.out.println(valid("PSRS"));\n    }\n \n    private Object solve()\n    {\n        best = "";\n        f("", r, p, s);\n        return best.length() > 0 ? best : "IMPOSSIBLE";\n    }\n \n    private void f(String str, int r, int p, int s)\n    {\n        \n        if (r == 0 && p == 0 && s == 0)\n        {\n            if (valid(str))\n                if (best.length() == 0 || str.compareTo(best) < 0)\n                    best = str;\n            return;\n        }\n \n        if (r > 0)\n            f(str + "R", r - 1, p, s);\n        if (p > 0)\n            f(str + "P", r, p - 1, s);\n        if (s > 0)\n            f(str + "S", r, p, s - 1);\n    }\n \n    private boolean valid(String str)\n    {\n        \n        String current = str + "";\n        while (current.length() > 1)\n        {\n            StringBuilder strb = new StringBuilder();\n            int i = 0;\n            while (i + 1 < current.length())\n            {\n                strb.append("" + compete(current.charAt(i), current.charAt(i + 1)));\n                i += 2;\n            }\n            current = strb.toString();\n            if (current.contains("X"))\n                return false;\n        }\n \n        return true;\n    }\n \n    private char compete(char a, char b)\n    {\n        if ((a == 'R' && b == 'P') || (a == 'P' && b == 'R'))\n            return 'P';\n        else if ((a == 'R' && b == 'S') || (a == 'S' && b == 'R'))\n            return 'R';\n        else if ((a == 'P' && b == 'S') || (a == 'S' && b == 'P'))\n            return 'S';\n        else\n            return 'X';\n    }\n \n }\n \n class InputReader\n {\n    BufferedReader reader;\n    StringTokenizer tok;\n \n    public InputReader(InputStream stream)\n    {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tok = new StringTokenizer("");\n    }\n \n    public String next()\n    {\n        while (!tok.hasMoreTokens())\n            try\n            {\n                tok = new StringTokenizer(reader.readLine());\n            } catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n        return tok.nextToken();\n    }\n \n    public int nextInt()\n    {\n        return Integer.parseInt(next());\n    }\n }
AhmedFathyAly	<>	7	<>	10224486_5677604812095488_AhmedFathyAly_main.java	<>	import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.FileInputStream;\n import java.io.FileWriter;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.StringTokenizer;\n \n public class Main\n {\n \n    \n    InputReader in;\n    StringTokenizer tok;\n    StringBuilder ans;\n \n    \n    int n, k;\n    double[] p;\n \n    public static void main(String[] args) throws Exception\n    {\n        Main sol = new Main();\n        sol.begin();\n \n    }\n \n    private void begin() throws IOException\n    {\n        \n        boolean file = true;\n        if (file)\n            in = new InputReader(new FileInputStream("B-small-attempt0 (1).in"));\n        else\n            in = new InputReader(System.in);\n        ans = new StringBuilder();\n \n        \n        int nCases = in.nextInt();\n        for (int cas = 1; cas <= nCases; cas++)\n        {\n            n = in.nextInt();\n            k = in.nextInt();\n            p = new double[n];\n            for (int i = 0; i < n; i++)\n                p[i] = Double.parseDouble(in.next());\n \n            ans.append("Case #" + cas + ": ");\n            ans.append(solve());\n            ans.append("\n");\n        }\n \n        \n        System.out.println("\nOutput: ");\n        System.out.println(ans.toString());\n        BufferedWriter out = new BufferedWriter(new FileWriter("output.txt"));\n        out.write(ans.toString());\n        out.close();\n \n        \n        System.out.println("\nTest: ");\n    }\n \n    private double solve()\n    {\n        double max = 0;\n \n        for (int mask = 0; mask < (1 << n); mask++)\n        {\n            ArrayList<Integer> chosen = new ArrayList<>();\n            for (int i = 0; i < n; i++)\n                if ((mask & (1 << i)) != 0)\n                    chosen.add(i);\n            if (chosen.size() == k)\n                max = Math.max(max, getP(chosen));\n        }\n \n        return max;\n    }\n \n    private double getP(ArrayList<Integer> chosen)\n    {\n        \n        double dp[][] = new double[k + 1][k + 2];\n        dp[0][0] = 1.0;\n        for (int i = 0; i < k; i++)\n            for (int count = 0; count < k; count++)\n            {\n                \n                dp[i + 1][count] += dp[i][count] * (1 - p[chosen.get(i)]);\n            \n                \n                dp[i + 1][count + 1] += dp[i][count] * p[chosen.get(i)];\n            }\n \n        return dp[k][k/2];\n    }\n \n }\n \n class InputReader\n {\n    BufferedReader reader;\n    StringTokenizer tok;\n \n    public InputReader(InputStream stream)\n    {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tok = new StringTokenizer("");\n    }\n \n    public String next()\n    {\n        while (!tok.hasMoreTokens())\n            try\n            {\n                tok = new StringTokenizer(reader.readLine());\n            } catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n        return tok.nextToken();\n    }\n \n    public int nextInt()\n    {\n        return Integer.parseInt(next());\n    }\n }
tsukuno	<>	17	<>	10224486_5718606851604480_tsukuno_main.java	<>	import java.util.*;\n \n public class Main {\n \n   public static void main(String args[]) {\n     (new Main()).solve();\n   }\n \n   void solve() {\n \n     Scanner cin = new Scanner(System.in);\n \n     int T = cin.nextInt();\n     for(int C=1; C<=T; ++C) {\n \n       int N = cin.nextInt();\n       int R = cin.nextInt();\n       int P = cin.nextInt();\n       int S = cin.nextInt();\n \n       int ans = -1;\n \n       for(int k=0; k<3; ++k) {\n         int init[] = new int[3];\n         init[k] = 1;\n         for(int i=0; i<N; ++i) {\n           int next[] = new int[3];\n           for(int j=0; j<3; ++j) {\n             next[j] = init[j] + init[(j + 1) % 3];\n           }\n           init = next;\n         }\n         if( init[0] == R && init[1] == P && init[2] == S ) {\n           ans = k;\n           break;\n         }\n       }\n \n       System.out.println("Case #" + C + ": " + gen(ans, N));\n \n     }\n \n   }\n \n   String gen(int ans, int depth) {\n     if( ans == -1 ) {\n       return "IMPOSSIBLE";\n     }\n \n     if( depth == 1 ) {\n       if( ans == 0 ) { return "RS"; }\n       if( ans == 1 ) { return "PR"; }\n       if( ans == 2 ) { return "PS"; }\n       throw new RuntimeException("implementation error");\n     }\n \n     String a = gen(ans, depth - 1);\n     String b = gen((ans + 2) % 3, depth - 1);\n \n     \n     if( a.compareTo(b) < 0 ) { return a + b; }\n     return b + a;\n \n   }\n \n }\n
tsukuno	<>	17	<>	10224486_5677604812095488_tsukuno_main.java	<>	import java.util.*;\n \n public class Main {\n \n   public static void main(String args[]) {\n     (new Main()).solve();\n   }\n \n   void solve() {\n \n     Scanner cin = new Scanner(System.in);\n \n     int T = cin.nextInt();\n     for(int C=1; C<=T; ++C) {\n \n       int N = cin.nextInt();\n       int K = cin.nextInt();\n \n       double prob[] = new double[N];\n       for(int i=0; i<N; ++i) {\n         prob[i] = cin.nextDouble();\n       }\n \n       double ans = 0.0;\n \n       int max = 1 << N;\n       for(int i=0; i<max; ++i) {\n         if( Integer.bitCount(i) != K ) { continue; }\n         ans = Math.max(ans, solve(prob, i, N, K));\n       }\n \n       System.out.println("Case #" + C + ": " + ans);\n \n     }\n \n   }\n \n   double solve(double prob[], int state, int N, int K) {\n     double ret[] = new double[] { 1.0 };\n     for(int i=0; i<N; ++i) {\n       if( (state & (1 << i)) != 0 ) {\n         ret = update(ret, prob[i]);\n       }\n     }\n     return ret[K / 2];\n   }\n \n   double[] update(double a[], double prob) {\n     double ret[] = new double[ a.length + 1 ];\n     for(int i=0; i<a.length; ++i) {\n       ret[i] += a[i] * prob;\n       ret[i + 1] += a[i] * (1 - prob);\n     }\n     return ret;\n   }\n \n }\n
tsukuno	<>	17	<>	10224486_5723605790883840_tsukuno_main.java	<>	import java.util.*;\n \n public class Main {\n \n   public static void main(String args[]) {\n     (new Main()).solve();\n   }\n \n   void solve() {\n \n     Scanner cin = new Scanner(System.in);\n \n     int T = cin.nextInt();\n     for(int C=1; C<=T; ++C) {\n \n       int r = cin.nextInt();\n       int c = cin.nextInt();\n       int pair[][] = new int[r + c][2];\n       for(int i=0; i<r+c; ++i) {\n         pair[i][0] = cin.nextInt() - 1;\n         pair[i][1] = cin.nextInt() - 1;\n       }\n \n       int max = 1 << (r * c);\n       String ans[] = null;\n \n       for(int i=0; i<max; ++i) {\n         if( solve(r, c, i, pair) ) {\n           ans = format(i, r, c);\n           break;\n         }\n       }\n \n       System.out.println("Case #" + C + ":");\n \n       if( ans == null ) { System.out.println("IMPOSSIBLE"); }\n       else {\n         for(int i=0; i<r; ++i) {\n           System.out.println(ans[i]);\n         }\n       }\n \n     }\n \n   }\n \n   final int UP = 0;\n   final int DN = 1;\n   final int LE = 2;\n   final int RI = 3;\n \n   boolean solve(int r, int c, int state, int pair[][]) {\n \n     int all = (r + c) * 2;\n     int res[] = new int[all];\n     for(int i=0; i<all; ++i) { res[i] = -1; }\n \n     for(int i=0; i<all; ++i) {\n       \n       if( res[i] >= 0 ) { continue; }\n       \n       if( 0 <= i && i < c ) {\n         res[i] = enter(0, i, UP, r, c, state);\n       }\n       \n       if( c <= i && i < c + r ) {\n         res[i] = enter(i - c, c - 1, RI, r, c, state);\n       }\n       \n       if( c + r <= i && i < c + r + c ) {\n         res[i] = enter(r - 1, c + r + c - 1 - i, DN, r, c, state);\n       }\n       \n       if( c + r + c <= i ) {\n         res[i] = enter(c + r + c + r - 1 - i, 0, LE, r, c, state);\n       }\n       res[ res[i] ] = i;\n     }\n \n     for( int p[] : pair ) {\n       if( res[ p[0] ] != p[1] ) { return false; }\n     }\n \n     return true;\n \n   }\n \n   \n   \n   \n   \n   \n   \n   \n   \n \n   int enter(int Y, int X, int dir, int r, int c, int state) {\n     \n     if( Y == -1 ) {\n       return X;\n     }\n     if( X == c ) {\n       return Y + c;\n     }\n     if( Y == r ) {\n       return c + r + c - 1 - X;\n     }\n     if( X == -1 ) {\n       return c + r + c + r - 1 - Y;\n     }\n     \n     if( (state & (1 << (Y * c + X))) == 0 ) {\n       switch(dir) {\n       case UP:\n         return enter(Y, X - 1, RI, r, c, state);\n       case DN:\n         return enter(Y, X + 1, LE, r, c, state);\n       case LE:\n         return enter(Y - 1, X, DN, r, c, state);\n       case RI:\n         return enter(Y + 1, X, UP, r, c, state);\n       }\n     }\n     \n     else {\n       switch(dir) {\n       case UP:\n         return enter(Y, X + 1, LE, r, c, state);\n       case DN:\n         return enter(Y, X - 1, RI, r, c, state);\n       case LE:\n         return enter(Y + 1, X, UP, r, c, state);\n       case RI:\n         return enter(Y - 1, X, DN, r, c, state);\n       }\n     }\n     throw new RuntimeException("implementation error");\n   }\n \n   String[] format(int state, int r, int c) {\n     String ret[] = new String[r];\n     String tmp = "";\n     for(int i=0; i<r*c; ++i) {\n       tmp += (state & (1 << i)) == 0 ? "/" : "\\";\n       if( i % c == c - 1 ) {\n         ret[i / c] = tmp;\n         tmp = "";\n       }\n     }\n     return ret;\n   }\n \n }\n
tsukuno	<>	17	<>	11254486_5648941810974720_tsukuno_main.java	<>	import java.util.*;\n \n public class Main {\n \n   public static void main(String args[]) {\n     (new Main()).solve();\n   }\n \n   void solve() {\n \n     Scanner cin = new Scanner(System.in);\n \n     int req[][] = new int[10][26];\n     String part[] = new String[] { "ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE" };\n     for(int i=0; i<10; ++i) {\n       for(int j=0; j<part[i].length(); ++j) {\n         ++req[i][ part[i].charAt(j) - 'A' ];\n       }\n     }\n \n     int T = cin.nextInt();\n     for(int C=1; C<=T; ++C) {\n \n       String S = cin.next();\n       int count[] = new int[26];\n       for(int i=0; i<S.length(); ++i) {\n         ++count[ S.charAt(i) - 'A' ];\n       }\n \n       int result[] = new int[10];\n \n       \n       if( count[ 'Z' - 'A' ] > 0 ) {\n         result[0] = count[ 'Z' - 'A' ];\n         for(int i=0; i<26; ++i) {\n           count[i] -= result[0] * req[0][i];\n         }\n       }\n \n       \n       if( count[ 'W' - 'A' ] > 0 ) {\n         result[2] = count[ 'W' - 'A' ];\n         for(int i=0; i<26; ++i) {\n           count[i] -= result[2] * req[2][i];\n         }\n       }\n \n       \n       if( count[ 'G' - 'A' ] > 0 ) {\n         result[8] = count[ 'G' - 'A' ];\n         for(int i=0; i<26; ++i) {\n           count[i] -= result[8] * req[8][i];\n         }\n       }\n \n       \n       if( count[ 'H' - 'A' ] > 0 ) {\n         result[3] = count[ 'H' - 'A' ];\n         if( count[ 'T' - 'A' ] != result[3] ) { throw new RuntimeException("Implementation Failure: 283"); }\n         for(int i=0; i<26; ++i) {\n           count[i] -= result[3] * req[3][i];\n         }\n       }\n \n       \n       if( count[ 'R' - 'A' ] > 0 ) {\n         result[4] = count[ 'R' - 'A' ];\n         for(int i=0; i<26; ++i) {\n           count[i] -= result[4] * req[4][i];\n         }\n       }\n \n       \n       if( count[ 'O' - 'A' ] > 0 ) {\n         result[1] = count[ 'O' - 'A' ];\n         for(int i=0; i<26; ++i) {\n           count[i] -= result[1] * req[1][i];\n         }\n       }\n \n       \n       if( count[ 'F' - 'A' ] > 0 ) {\n         result[5] = count[ 'F' - 'A' ];\n         for(int i=0; i<26; ++i) {\n           count[i] -= result[5] * req[5][i];\n         }\n       }\n \n       \n       if( count[ 'V' - 'A' ] > 0 ) {\n         result[7] = count[ 'V' - 'A' ];\n         for(int i=0; i<26; ++i) {\n           count[i] -= result[7] * req[7][i];\n         }\n       }\n \n       \n       if( count[ 'S' - 'A' ] > 0 ) {\n         result[6] = count[ 'S' - 'A' ];\n         for(int i=0; i<26; ++i) {\n           count[i] -= result[6] * req[6][i];\n         }\n       }\n \n       \n       if( count[ 'I' - 'A' ] > 0 ) {\n         result[9] = count[ 'I' - 'A' ];\n         for(int i=0; i<26; ++i) {\n           count[i] -= result[9] * req[9][i];\n         }\n       }\n \n       String ans = "";\n       for(int i=0; i<10; ++i) {\n         for(int j=0; j<result[i]; ++j) {\n           ans += i;\n         }\n       }\n \n       System.out.println("Case #" + C + ": " + ans);\n \n       for(int i=0; i<26; ++i) {\n         if( count[i] != 0 ) { throw new RuntimeException("Implementation Error or Input Error: ALL: " + i); }\n       }\n \n     }\n \n   }\n \n }\n
eatmore	<>	24	<>	10224486_5718447400943616_eatmore_d.java	<>	import static java.lang.Double.parseDouble;\n import static java.lang.Integer.parseInt;\n import static java.lang.Long.parseLong;\n import static java.lang.Math.min;\n import static java.lang.System.exit;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStreamReader;\n import java.io.OutputStreamWriter;\n import java.io.PrintWriter;\n import java.util.StringTokenizer;\n \n public class D {\n \n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n    static int test;\n \n    static void sortBy(int a[], int v1[], int v2[]) {\n        int n = a.length;\n        if (n == 0) {\n            return;\n        }\n        for (int i = 1; i < n; i++) {\n            int j = i;\n            int ca = a[i];\n            int cv1 = v1[ca], cv2 = v2[ca];\n            do {\n                int nj = (j - 1) >> 1;\n                int na = a[nj];\n                if (cv1 < v1[na] || (cv1 == v1[na] && cv2 <= v2[na])) {\n                    break;\n                }\n                a[j] = na;\n                j = nj;\n            } while (j != 0);\n            a[j] = ca;\n        }\n        int ca = a[0];\n        for (int i = n - 1; i > 0; i--) {\n            int j = 0;\n            while ((j << 1) + 2 + Integer.MIN_VALUE < i + Integer.MIN_VALUE) {\n                j <<= 1;\n                int aj1 = a[j + 1], aj2 = a[j + 2];\n                j += (v1[aj2] > v1[aj1] || (v1[aj2] == v1[aj1] && v2[aj2] > v2[aj1])) ? 2 : 1;\n            }\n            if ((j << 1) + 2 == i) {\n                j = (j << 1) + 1;\n            }\n            int na = a[i];\n            a[i] = ca;\n            ca = na;\n            int cv1 = v1[ca], cv2 = v2[ca];\n            while (j != 0 && (v1[a[j]] < cv1 || (v1[a[j]] == cv1 && v2[a[j]] < cv2))) {\n                j = (j - 1) >> 1;\n            }\n            while (j != 0) {\n                na = a[j];\n                a[j] = ca;\n                ca = na;\n                j = (j - 1) >> 1;\n            }\n        }\n        a[0] = ca;\n    }\n \n    static int n;\n    static boolean can[][];\n    static boolean seenI[], seenJ[];\n    static int nComps;\n    static int sizeI[], sizeJ[];\n    static int nGroups;\n    static int groupSize[], groupSizeI[], groupSizeJ[];\n    static int ans[];\n    static int groupSelected1[];\n    static int selection1;\n \n    static void solve() throws Exception {\n        n = nextInt();\n        can = new boolean[n][n];\n        for (int i = 0; i < n; i++) {\n            String l = next();\n            for (int j = 0; j < n; j++) {\n                can[i][j] = l.charAt(j) != '0';\n            }\n        }\n        seenI = new boolean[n];\n        seenJ = new boolean[n];\n        nComps = 0;\n        sizeI = new int[n];\n        sizeJ = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (!seenI[i]) {\n                dfs(i);\n                ++nComps;\n            }\n        }\n        int compId[] = new int[nComps];\n        for (int i = 0; i < nComps; i++) {\n            compId[i] = i;\n        }\n        sortBy(compId, sizeI, sizeJ);\n        nGroups = 0;\n        groupSize = new int[nComps];\n        groupSizeI = new int[nComps];\n        groupSizeJ = new int[nComps];\n        for (int i = 0; i < nComps; i++) {\n            if (i == 0 || sizeI[compId[i]] != sizeI[compId[i - 1]] || sizeJ[compId[i]] != sizeJ[compId[i - 1]]) {\n                groupSizeI[nGroups] = sizeI[compId[i]];\n                groupSizeJ[nGroups] = sizeJ[compId[i]];\n                groupSize[nGroups] = 1;\n                ++nGroups;\n            } else {\n                ++groupSize[nGroups - 1];\n            }\n        }\n        int sizeProduct = 1;\n        for (int i = 0; i < nGroups; i++) {\n            sizeProduct *= (groupSize[i] + 1);\n        }\n        ans = new int[sizeProduct];\n        groupSelected1 = new int[nGroups];\n        go1(0, 0, 0, 0);\n        int theAns = ans[sizeProduct - 1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (can[i][j]) {\n                    --theAns;\n                }\n            }\n        }\n        printCase();\n        out.println(theAns);\n    }\n \n    static void go1(int cur, int selection, int curSizeI, int curSizeJ) {\n        if (cur == nGroups) {\n            int cans = curSizeI >= curSizeJ ? curSizeI * curSizeI : Integer.MAX_VALUE;\n            selection1 = selection;\n            cans = min(cans, go2(0, 0));\n            ans[selection] = cans;\n            return;\n        }\n        selection *= groupSize[cur] + 1;\n        for (groupSelected1[cur] = 0; groupSelected1[cur] <= groupSize[cur]; groupSelected1[cur]++) {\n            go1(cur + 1, selection, curSizeI, curSizeJ);\n            ++selection;\n            curSizeI += groupSizeI[cur];\n            curSizeJ += groupSizeJ[cur];\n        }\n    }\n \n    static int go2(int cur, int selection) {\n        if (cur == nGroups) {\n            return (selection == 0 || selection == selection1 ||\n                ans[selection] == Integer.MAX_VALUE || ans[selection1 - selection] == Integer.MAX_VALUE) ?\n                Integer.MAX_VALUE : ans[selection] + ans[selection1 - selection];\n        }\n        selection *= groupSize[cur] + 1;\n        int cans = Integer.MAX_VALUE;\n        for (int i = 0; i <= groupSelected1[cur]; i++) {\n            cans = min(cans, go2(cur + 1, selection));\n            ++selection;\n        }\n        return cans;\n    }\n \n    static void dfs(int i) {\n        seenI[i] = true;\n        ++sizeI[nComps];\n        for (int j = 0; j < n; j++) {\n            if (can[i][j] && !seenJ[j]) {\n                seenJ[j] = true;\n                ++sizeJ[nComps];\n                for (int ni = 0; ni < n; ni++) {\n                    if (can[ni][j] && !seenI[ni]) {\n                        dfs(ni);\n                    }\n                }\n            }\n        }\n    }\n \n    static void printCase() {\n        out.print("Case #" + test + ": ");\n    }\n \n    static void printlnCase() {\n        out.println("Case #" + test + ":");\n    }\n \n    static int nextInt() throws IOException {\n        return parseInt(next());\n    }\n \n    static long nextLong() throws IOException {\n        return parseLong(next());\n    }\n \n    static double nextDouble() throws IOException {\n        return parseDouble(next());\n    }\n \n    static String next() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n \n    public static void main(String[] args) {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n            int tests = nextInt();\n            for (test = 1; test <= tests; test++) {\n                solve();\n            }\n            in.close();\n            out.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            exit(1);\n        }\n    }\n }
eatmore	<>	24	<>	10224486_5718606851604480_eatmore_a.java	<>	import static java.lang.Double.parseDouble;\n import static java.lang.Integer.parseInt;\n import static java.lang.Long.parseLong;\n import static java.lang.System.exit;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStreamReader;\n import java.io.OutputStreamWriter;\n import java.io.PrintWriter;\n import java.util.StringTokenizer;\n \n public class A {\n \n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n    static int test;\n \n    static void solve() throws Exception {\n        int n = nextInt();\n        int r = nextInt();\n        int p = nextInt();\n        int s = nextInt();\n        String sr = "R";\n        String sp = "P";\n        String ss = "S";\n        for (int i = 0; i < n; i++) {\n            int nn = 1 << (n - i - 1);\n            if (r > nn || p > nn || s > nn) {\n                printCase();\n                out.println("IMPOSSIBLE");\n                return;\n            }\n            int t = nn - p;\n            p = nn - s;\n            s = nn - r;\n            r = t;\n            String st = sr.compareTo(ss) > 0 ? ss + sr : sr + ss;\n            ss = ss.compareTo(sp) > 0 ? sp + ss : ss + sp;\n            sp = sp.compareTo(sr) > 0 ? sr + sp : sp + sr;\n            sr = st;\n        }\n        printCase();\n        out.println(r > 0 ? sr : p > 0 ? sp : ss);\n    }\n \n    static void printCase() {\n        out.print("Case #" + test + ": ");\n    }\n \n    static void printlnCase() {\n        out.println("Case #" + test + ":");\n    }\n \n    static int nextInt() throws IOException {\n        return parseInt(next());\n    }\n \n    static long nextLong() throws IOException {\n        return parseLong(next());\n    }\n \n    static double nextDouble() throws IOException {\n        return parseDouble(next());\n    }\n \n    static String next() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n \n    public static void main(String[] args) {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n            int tests = nextInt();\n            for (test = 1; test <= tests; test++) {\n                solve();\n            }\n            in.close();\n            out.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            exit(1);\n        }\n    }\n }
eatmore	<>	24	<>	10224486_5677604812095488_eatmore_b.java	<>	import static java.lang.Double.parseDouble;\n import static java.lang.Integer.parseInt;\n import static java.lang.Long.parseLong;\n import static java.lang.Math.max;\n import static java.lang.System.exit;\n import static java.util.Arrays.fill;\n import static java.util.Arrays.sort;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStreamReader;\n import java.io.OutputStreamWriter;\n import java.io.PrintWriter;\n import java.util.Locale;\n import java.util.StringTokenizer;\n \n public class B {\n \n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n    static int test;\n \n    static void solve() throws Exception {\n        int n = nextInt();\n        int k = nextInt();\n        double p[] = new double[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = nextDouble();\n        }\n        sort(p);\n        double ans = 0;\n        double dyn[] = new double[k + 1];\n        for (int left = 0; left <= k; left++) {\n            int right = k - left;\n            fill(dyn, 0);\n            dyn[0] = 1;\n            for (int i = 0; i < left; i++) {\n                double cp = p[i], cq = 1 - cp;\n                for (int j = i + 1; j > 0; j--) {\n                    dyn[j] = dyn[j] * cq + dyn[j - 1] * cp;\n                }\n                dyn[0] = dyn[0] * cq;\n            }\n            for (int i = left; i < k; i++) {\n                double cp = p[i - left + n - right], cq = 1 - cp;\n                for (int j = i + 1; j > 0; j--) {\n                    dyn[j] = dyn[j] * cq + dyn[j - 1] * cp;\n                }\n                dyn[0] = dyn[0] * cq;\n            }\n            double sum = 0;\n            for (int i = 0; i <= k; i++) {\n                sum += dyn[i];\n            }\n            ans = max(ans, dyn[k / 2] / sum);\n        }\n        printCase();\n        out.printf(Locale.US, "%.9f\n", ans);\n    }\n \n    static void printCase() {\n        out.print("Case #" + test + ": ");\n    }\n \n    static void printlnCase() {\n        out.println("Case #" + test + ":");\n    }\n \n    static int nextInt() throws IOException {\n        return parseInt(next());\n    }\n \n    static long nextLong() throws IOException {\n        return parseLong(next());\n    }\n \n    static double nextDouble() throws IOException {\n        return parseDouble(next());\n    }\n \n    static String next() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n \n    public static void main(String[] args) {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n            int tests = nextInt();\n            for (test = 1; test <= tests; test++) {\n                solve();\n            }\n            in.close();\n            out.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            exit(1);\n        }\n    }\n }
eatmore	<>	24	<>	11254486_5648941810974720_eatmore_a.java	<>	import static java.lang.Double.parseDouble;\n import static java.lang.Integer.parseInt;\n import static java.lang.Long.parseLong;\n import static java.lang.System.exit;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStreamReader;\n import java.io.OutputStreamWriter;\n import java.io.PrintWriter;\n import java.util.StringTokenizer;\n \n public class A {\n    \n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n    static int test;\n    \n    static final String DIGITS[] = {"ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE"};\n    static final char UNIQUE[] = {'Z', 'O', 'W', 'R', 'U', 'F', 'X', 'S', 'G', 'I'};\n    \n    static void solve() throws Exception {\n        String s = next();\n        int counts[] = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            ++counts[s.charAt(i) - 'A'];\n        }\n        int ans[] = new int[10];\n        for (int ii = 0; ii < 10; ii++) {\n            int i = ii < 5 ? 2 * ii : 2 * ii - 9;\n            ans[i] = counts[UNIQUE[i] - 'A'];\n            if (ans[i] < 0) {\n                throw new AssertionError();\n            }\n            for (int j = 0; j < DIGITS[i].length(); j++) {\n                counts[DIGITS[i].charAt(j) - 'A'] -= ans[i];\n            }\n        }\n        for (int i = 0; i < 26; i++) {\n            if (counts[i] != 0) {\n                throw new AssertionError();\n            }\n        }\n        printCase();\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < ans[i]; j++) {\n                out.print((char) (i + '0'));\n            }\n        }\n        out.println();\n    }\n    \n    static void printCase() {\n        out.print("Case #" + test + ": ");\n    }\n    \n    static void printlnCase() {\n        out.println("Case #" + test + ":");\n    }\n    \n    static int nextInt() throws IOException {\n        return parseInt(next());\n    }\n \n    static long nextLong() throws IOException {\n        return parseLong(next());\n    }\n \n    static double nextDouble() throws IOException {\n        return parseDouble(next());\n    }\n \n    static String next() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n \n    public static void main(String[] args) {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n            int tests = nextInt();\n            for (test = 1; test <= tests; test++) {\n                solve();\n            }\n            in.close();\n            out.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            exit(1);\n        }\n    }\n }
eatmore	<>	24	<>	10224486_5723605790883840_eatmore_c.java	<>	import static java.lang.Double.parseDouble;\n import static java.lang.Integer.parseInt;\n import static java.lang.Long.parseLong;\n import static java.lang.Math.min;\n import static java.lang.System.exit;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStreamReader;\n import java.io.OutputStreamWriter;\n import java.io.PrintWriter;\n import java.util.StringTokenizer;\n \n public class C {\n \n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n    static int test;\n \n    static final int DI[] = {1, 0, -1, 0};\n    static final int DJ[] = {0, -1, 0, 1};\n \n    static void solve() throws Exception {\n        int n = nextInt();\n        int m = nextInt();\n \n        int p = 2 * (n + m);\n        int pair[] = new int[p];\n        int next[] = new int[p];\n        int prev[] = new int[p];\n        for (int i = 0; i < p; i++) {\n            pair[i] = nextInt() - 1;\n            next[i] = (i + 1) % p;\n            prev[(i + 1) % p] = i;\n        }\n        boolean h[][] = new boolean[n + 1][m];\n        boolean v[][] = new boolean[n][m + 1];\n        char ans[][] = new char[n][m];\n        for (int i = 0; i < p / 2; i++) {\n            for (int j = 0;; j += 2) {\n                if (j == p) {\n                    printlnCase();\n                    out.println("IMPOSSIBLE");\n                    return;\n                }\n                if (pair[j] < 0 || (next[pair[j]] != pair[j + 1] && prev[pair[j]] != pair[j + 1])) {\n                    continue;\n                }\n                if (next[pair[j]] != pair[j + 1]) {\n                    int t = pair[j];\n                    pair[j] = pair[j + 1];\n                    pair[j + 1] = t;\n                }\n                int ci, cj, cd;\n                if (pair[j] < m) {\n                    ci = -1; cj = pair[j]; cd = 0;\n                } else if (pair[j] < n + m) {\n                    ci = pair[j] - m; cj = m; cd = 1;\n                } else if (pair[j] < n + 2 * m) {\n                    ci = n; cj = m - 1 - (pair[j] - (n + m)); cd = 2;\n                } else {\n                    ci = n - 1 - (pair[j] - (n + 2 * m)); cj = -1; cd = 3;\n                }\n                int ti, tj, td;\n                if (pair[j + 1] < m) {\n                    ti = -1; tj = pair[j + 1]; td = 2;\n                } else if (pair[j + 1] < n + m) {\n                    ti = pair[j + 1] - m; tj = m; td = 3;\n                } else if (pair[j + 1] < n + 2 * m) {\n                    ti = n; tj = m - 1 - (pair[j + 1] - (n + m)); td = 0;\n                } else {\n                    ti = n - 1 - (pair[j + 1] - (n + 2 * m)); tj = -1; td = 1;\n                }\n \n                while (true) {\n                    int ni = ci + DI[cd], nj = cj + DJ[cd];\n \n                    boolean a[];\n                    int ai;\n                    if ((cd & 1) == 0) {\n                        a = h[min(ci, ni) + 1];\n                        ai = cj;\n \n                    } else {\n                        a = v[ci];\n                        ai = min(cj, nj) + 1;\n \n                    }\n                    if (a[ai]) {\n                        printlnCase();\n                        out.println("IMPOSSIBLE");\n                        return;\n                    }\n                    a[ai] = true;\n                    ci = ni; cj = nj;\n                    if (ci == ti && cj == tj && cd == td) {\n \n                        break;\n                    }\n                    if (ci < 0 || ci >= n || cj < 0 || cj >= m) {\n                        \n                        printlnCase();\n                        out.println("IMPOSSIBLE");\n                        return;\n                    }\n                    int nd = (cd + 3) & 3;\n                    ni = ci + DI[nd]; nj = cj + DJ[nd];\n \n                    if ((nd & 1) == 0) {\n                        a = h[min(ci, ni) + 1];\n                        ai = cj;\n \n                    } else {\n                        a = v[ci];\n                        ai = min(cj, nj) + 1;\n \n                    }\n                    if (!a[ai]) {\n                        ans[ci][cj] = (cd & 1) == 0 ? '\\' : '/';\n                        cd = nd;\n                        continue;\n                    }\n                    nd = (cd + 1) & 3;\n                    ni = ci + DI[nd]; nj = cj + DJ[nd];\n \n                    if ((nd & 1) == 0) {\n                        a = h[min(ci, ni) + 1];\n                        ai = cj;\n \n                    } else {\n                        a = v[ci];\n                        ai = min(cj, nj) + 1;\n \n                    }\n                    if (!a[ai]) {\n                        ans[ci][cj] = (cd & 1) == 0 ? '/' : '\\';\n                        cd = nd;\n                        continue;\n                    }\n                    printlnCase();\n                    out.println("IMPOSSIBLE");\n                    return;\n                }\n                next[prev[pair[j]]] = next[pair[j]];\n                prev[next[pair[j]]] = prev[pair[j]];\n                next[pair[j]] = -1;\n                prev[pair[j]] = -1;\n                pair[j] = -1;\n                next[prev[pair[j + 1]]] = next[pair[j + 1]];\n                prev[next[pair[j + 1]]] = prev[pair[j + 1]];\n                next[pair[j + 1]] = -1;\n                prev[pair[j + 1]] = -1;\n                pair[j + 1] = -1;\n                break;\n            }\n        }\n        printlnCase();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                out.print(ans[i][j] == 0 ? '/' : ans[i][j]);\n            }\n            out.println();\n        }\n    }\n \n    static void printCase() {\n        out.print("Case #" + test + ": ");\n    }\n \n    static void printlnCase() {\n        out.println("Case #" + test + ":");\n    }\n \n    static int nextInt() throws IOException {\n        return parseInt(next());\n    }\n \n    static long nextLong() throws IOException {\n        return parseLong(next());\n    }\n \n    static double nextDouble() throws IOException {\n        return parseDouble(next());\n    }\n \n    static String next() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n \n    public static void main(String[] args) {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n            int tests = nextInt();\n            for (test = 1; test <= tests; test++) {\n                solve();\n            }\n            in.close();\n            out.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            exit(1);\n        }\n    }\n }
nickbuelich	<>	26	<>	11254486_5648941810974720_nickbuelich_a.java	<>	import java.io.File;\n import java.io.PrintWriter;\n import java.util.HashSet;\n import java.util.LinkedList;\n import java.util.Scanner;\n \n \n public class A {\n    static String[] nums = {"ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE"};\n    public static void main(String[] args) throws Exception {\n        \n        \n        Scanner sc = new Scanner(new File("A.in"));\n        PrintWriter out = new PrintWriter(new File("A.out"));\n        int T = sc.nextInt();\n        for(int t=1;t<=T;t++){\n            String in = sc.next();\n            int[] used = new int[10];\n            int[] have = new int[128];\n            for(int a=0;a<in.length();a++){\n                 have[in.charAt(a)]++;\n            }\n            \n            \n            while(have['Z'] > 0){\n                have['Z']--;\n                have['E']--;\n                have['R']--;\n                have['O']--;\n                used[0]++;\n            }\n            \n            \n            while(have['X'] > 0){\n                have['S']--;\n                have['I']--;\n                have['X']--;\n                used[6]++;\n            }\n            \n            \n            while(have['W'] > 0){\n                have['T']--;\n                have['W']--;\n                have['O']--;\n                used[2]++;\n            }\n            \n            \n            while(have['U'] > 0){\n                have['F']--;\n                have['O']--;\n                have['U']--;\n                have['R']--;\n                used[4]++;\n            }\n            \n            \n            while(have['F'] > 0){\n                have['F']--;\n                have['I']--;\n                have['V']--;\n                have['E']--;\n                used[5]++;\n            }\n            \n            \n            \n            while(have['V'] > 0){\n                have['S']--;\n                have['E']--;\n                have['V']--;\n                have['E']--;\n                have['N']--;\n                used[7]++;\n            }\n            \n            \n            while(have['O'] > 0){\n                have['O']--;\n                have['N']--;\n                have['E']--;\n                used[1]++;\n            }\n            \n            \n            while(have['N'] > 0){\n                have['N']--;\n                have['I']--;\n                have['N']--;\n                have['E']--;\n                used[9]++;\n            }\n            \n            \n            while(have['G'] > 0){\n                have['E']--;\n                have['I']--;\n                have['G']--;\n                have['H']--;\n                have['T']--;\n                used[8]++;\n            }\n            \n            \n            while(have['T'] > 0){\n                have['T']--;\n                have['H']--;\n                have['R']--;\n                have['E']--;\n                have['E']--;\n                used[3]++;\n            }\n            \n            \n            StringBuilder S = new StringBuilder();\n            for(int a=0;a<used.length;a++){\n                while(used[a] !=0){\n                    used[a]--;\n                    S.append(a);\n                }\n            }\n            String ans = S.toString();\n            \n            System.out.printf("Case #%d: %s%n",t,ans);\n            out.printf("Case #%d: %s%n",t,ans);\n        }\n        \n        out.close();\n    }\n }\n
nickbuelich	<>	26	<>	11254486_5686313294495744_nickbuelich_c.java	<>	import java.io.File;\n import java.io.PrintWriter;\n import java.util.HashSet;\n import java.util.LinkedList;\n import java.util.Scanner;\n \n \n public class C {\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(new File("C.in"));\n        PrintWriter out = new PrintWriter("C.out");\n        int T = sc.nextInt();\n        for(int t=1;t<=T;t++){\n            int N = sc.nextInt();\n            int ans = 0;\n            String[] LEFT = new String[N];\n            String[] RIGHT = new String[N];\n            \n            for(int a=0;a<N;a++){\n                LEFT[a] = sc.next();\n                RIGHT[a] = sc.next();\n            }\n            \n            for(int mask = 0; mask<1<<N;mask++){\n                LinkedList<String> L = new LinkedList<String>();\n                LinkedList<String> R = new LinkedList<String>();\n                HashSet<String> BAD = new HashSet<String>();\n                for(int a=0;a<N;a++){\n                    if(((mask>>a)&1)==1){\n                        L.add(LEFT[a]);\n                        R.add(RIGHT[a]);\n                    }\n                    else{\n                        BAD.add(LEFT[a]+" "+RIGHT[a]);\n                    }\n                } \n                HashSet<String> ALL = new HashSet<String>();\n                for(String l : L){\n                    for(String r : R){\n                        ALL.add(l+" "+r);\n                    }\n                }\n \n \n \n \n \n                int found = 0;\n                for(String a : ALL){\n                    if(BAD.contains(a)){\n                        found++;\n                    }\n                }\n                ans = Math.max(ans,found);\n            }\n            \n            \n            System.out.printf("Case #%d: %s\n",t,ans);\n            out.printf("Case #%d: %s\n",t,ans);\n        }\n        \n        out.close();\n    }\n }\n
nickbuelich	<>	26	<>	3264486_5654742835396608_nickbuelich_c.java	<>	import java.io.File;\n import java.io.PrintWriter;\n import java.util.PriorityQueue;\n import java.util.Scanner;\n \n public class C {\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(new File("C.in"));\n        PrintWriter out = new PrintWriter(new File("C.out"));\n        int T = sc.nextInt();\n        for(int t=1;t<=T;t++){\n            int N = sc.nextInt();\n            int K = sc.nextInt();\n            PriorityQueue<Integer> PQ = new PriorityQueue<Integer>();\n            PQ.add(-N);\n            int min = 0;\n            int max = 0;\n            for(int a=0;a<K;a++){\n                int cur = -PQ.poll();\n                max = cur/2;\n                min = (cur-1)/2;\n                PQ.add(-min);\n                PQ.add(-max);\n            }\n            String ans = max+" "+min;\n            System.out.printf("Case #%d: %s%n", t, ans);\n            out.printf("Case #%d: %s%n", t, ans);\n        }\n        out.close();\n    }\n }\n
nickbuelich	<>	26	<>	11254486_5695413893988352_nickbuelich_b.java	<>	import java.io.File;\n import java.io.PrintWriter;\n import java.util.Collections;\n import java.util.LinkedList;\n import java.util.Scanner;\n \n \n public class B {\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(new File("B.in"));\n        PrintWriter out = new PrintWriter(new File("B.out"));\n        int T = sc.nextInt();\n        for(int t=1;t<=T;t++){\n            char[] A = sc.next().toCharArray();\n            char[] B = sc.next().toCharArray();\n            String AA = String.valueOf(A);\n            String BB = String.valueOf(B);\n            int delta = Integer.MAX_VALUE;\n            \n            for(int a=0;a<999;a++){\n                char[] tempA = A.clone();\n                if(tempA.length>0&&tempA[0]=='?'){\n                    tempA[0] = (char)('0' + ((a/100)%10));\n                }\n                if(tempA.length>1&&tempA[1]=='?'){\n                    tempA[1] = (char)('0' + ((a/10)%10));\n                }\n                if(tempA.length>2&&tempA[2]=='?'){\n                    tempA[2] = (char)('0' + (a%10));\n                }\n                for(int b=0;b<999;b++){\n                    char[] tempB = B.clone();\n                    if(tempB.length>0&&tempB[0]=='?'){\n                        tempB[0] = (char)('0' + ((b/100)%10));\n                    }\n                    if(tempB.length>1&&tempB[1]=='?'){\n                        tempB[1] = (char)('0' + ((b/10)%10));\n                    }\n                    if(tempB.length>2&&tempB[2]=='?'){\n                        tempB[2] = (char)('0' + (b%10));\n                    }\n                    \n                    int AAA = Integer.parseInt(String.valueOf(tempA));\n                    int BBB = Integer.parseInt(String.valueOf(tempB));\n                    int diff = Math.abs(AAA-BBB);\n                    if(diff<delta){\n                        delta=diff;\n                        AA=String.valueOf(tempA);\n                        BB=String.valueOf(tempB);\n                    }\n                }\n            }\n            System.out.printf("Case #%d: %s %s%n",t,AA,BB);\n            out.printf("Case #%d: %s %s%n",t,AA,BB);\n        }\n        \n        out.close();\n    }\n }\n
Ratmir15	<>	27	<>	11254486_5648941810974720_Ratmir15_solution.java	<>	package codejam.y2016.r2.z1;\n \n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.PrintWriter;\n import java.util.*;\n \n public class Solution {\n     static String [] bank = {"ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE"};\n \n     public static void main(String[] args) throws FileNotFoundException {\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n         FileInputStream fileInputStream = new FileInputStream("/Users/ratmir/Downloads/A-small-attempt0 (2).in");\n         \n         Scanner sc = new Scanner(fileInputStream);\n         FileOutputStream outputStream = new FileOutputStream("/Users/ratmir/Documents/code/hackerrank/algs/src/codejam/y2016/r2/z1/z1.txt");\n         PrintWriter printWriter = new PrintWriter(outputStream);\n \n \n \n         List<Map<Character, Integer>> lst = new ArrayList<Map<Character, Integer>>();\n         for (int i=0;i<bank.length;i++) {\n             Map<Character, Integer> mm = new HashMap<Character, Integer>();\n             for (int j=0;j<bank[i].length();j++) {\n                 char key = bank[i].charAt(j);\n                 if (!mm.containsKey(key)) {\n                     mm.put(key, 0);\n                 }\n                 mm.put(key, mm.get(key)+1);\n             }\n             lst.add(mm);\n         }\n         System.out.println(lst);\n         int tn = sc.nextInt();\n         for (int ti = 1; ti <= tn; ti++) {\n             String s = sc.next();\n             String result = "";\n             Map<Character, Integer> mm = new HashMap<Character, Integer>();\n             List<Integer> list = new ArrayList<Integer>();\n             for (int j = 0; j < s.length(); j++) {\n                     char key = s.charAt(j);\n                     if (!mm.containsKey(key)) {\n                         mm.put(key, 0);\n                     }\n                     mm.put(key, mm.get(key) + 1);\n             }\n             if (mm.containsKey('Z')) {\n                 Integer z = mm.get('Z');\n                 for (int i=0;i<z;i++) {\n                     list.add(0);\n                 }\n                 remove(mm, 0, z, lst);\n             }\n             if (mm.containsKey('W')) {\n                 Integer z = mm.get('W');\n                 for (int i=0;i<z;i++) {\n                     list.add(2);\n                 }\n                 remove(mm, 2, z, lst);\n             }\n             if (mm.containsKey('G')) {\n                 Integer z = mm.get('G');\n                 for (int i=0;i<z;i++) {\n                     list.add(8);\n                 }\n                 remove(mm, 8, z, lst);\n             }\n             if (mm.containsKey('X')) {\n                 Integer z = mm.get('X');\n                 for (int i=0;i<z;i++) {\n                     list.add(6);\n                 }\n                 remove(mm, 6, z, lst);\n             }\n             if (mm.containsKey('U')) {\n                 Integer z = mm.get('U');\n                 for (int i=0;i<z;i++) {\n                     list.add(4);\n                 }\n                 remove(mm, 4, z, lst);\n             }\n             if (mm.containsKey('R')) {\n                 Integer z = mm.get('R');\n                 for (int i=0;i<z;i++) {\n                     list.add(3);\n                 }\n                 remove(mm, 3, z, lst);\n             }\n             if (mm.containsKey('S')) {\n                 Integer z = mm.get('S');\n                 for (int i=0;i<z;i++) {\n                     list.add(7);\n                 }\n                 remove(mm, 7, z, lst);\n             }\n             if (mm.containsKey('O')) {\n                 Integer z = mm.get('O');\n                 for (int i=0;i<z;i++) {\n                     list.add(1);\n                 }\n                 remove(mm, 1, z, lst);\n             }\n             if (mm.containsKey('V')) {\n                 Integer z = mm.get('V');\n                 for (int i=0;i<z;i++) {\n                     list.add(5);\n                 }\n                 remove(mm, 5, z, lst);\n             }\n             if (mm.containsKey('I')) {\n                 Integer z = mm.get('I');\n                 for (int i=0;i<z;i++) {\n                     list.add(9);\n                 }\n                 remove(mm, 9, z, lst);\n             }\n             Collections.sort(list);\n             StringBuilder sb = new StringBuilder();\n             for (Integer integer : list) {\n                 sb.append(integer);\n             }\n             String res = "Case #" + ti + ": " + sb.toString();\n             printWriter.write(res + "\n");\n             System.out.println(res);\n         }\n         printWriter.close();\n     }\n \n     private static void remove(Map<Character, Integer> mm, int i, Integer z, List<Map<Character, Integer>> lst) {\n         Map<Character, Integer> map = lst.get(i);\n         for (Map.Entry<Character, Integer> entry : map.entrySet()) {\n             Integer integer = mm.get(entry.getKey());\n             if (integer==z) {\n                 mm.remove(entry.getKey());\n             } else {\n                 mm.put(entry.getKey(), integer - z);\n             }\n         }\n     }\n }\n
Ratmir15	<>	27	<>	3264486_5654742835396608_Ratmir15_solution.java	<>	package codejam.y2017.qualification.z3;\n \n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.PrintWriter;\n import java.util.Scanner;\n \n public class Solution {\n \n     public static void main(String[] args) throws FileNotFoundException {\n         Scanner sc = new Scanner(System.in);\n         FileOutputStream outputStream = new FileOutputStream("/Users/ratmir/Documents/code/hackerrank/algs/src/codejam/y2017/qualification/z3/output.txt");\n         PrintWriter printWriter = new PrintWriter(outputStream);\n         int tn = sc.nextInt();\n         for (int ti = 1; ti <= tn; ti++) {\n             int n = sc.nextInt();\n             int k = sc.nextInt();\n             boolean[] field = new boolean[n + 2];\n             field[0] = true;\n             field[n + 1] = true;\n             int cmin = 0;\n             int cmax = 0;\n             for (int i=0;i<k;i++) {\n                 cmin = 0;\n                 cmax = 0;\n                 int idx = 0;\n                 for (int j=1;j<n+1;j++) {\n                     if (!field[j]) {\n                         int leftEmpty = 0;\n                         while (!field[j-leftEmpty-1]) {\n                             leftEmpty++;\n                         }\n                         int rightEmpty = 0;\n                         while (!field[j+rightEmpty+1]) {\n                             rightEmpty++;\n                         }\n                         int mn = Math.min(leftEmpty, rightEmpty);\n                         int mx = Math.max(leftEmpty, rightEmpty);\n                         if (mn>cmin) {\n                             cmin = mn;\n                             cmax = mx;\n                             idx = j;\n                         } else {\n                             if (mn==cmin && mx>cmax) {\n                                 cmin = mn;\n                                 cmax = mx;\n                                 idx = j;\n                             }\n                         }\n                     }\n                 }\n                 field[idx] = true;\n             }\n             String s = "Case #" + ti + ": " + cmax+" "+cmin;\n             printWriter.write(s + "\n");\n             System.out.println(s);\n         }\n         printWriter.close();\n     }\n \n }\n
Ratmir15	<>	27	<>	11254486_5695413893988352_Ratmir15_solution.java	<>	package codejam.y2016.r2.z2;\n \n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.PrintWriter;\n import java.util.*;\n \n public class Solution {\n \n     public static void main(String[] args) throws FileNotFoundException {\n         FileInputStream fileInputStream = new FileInputStream("/Users/ratmir/Downloads/B-small-attempt0 (2).in");\n         \n         Scanner sc = new Scanner(fileInputStream);\n         FileOutputStream outputStream = new FileOutputStream("/Users/ratmir/Documents/code/hackerrank/algs/src/codejam/y2016/r2/z2/z2.txt");\n         PrintWriter printWriter = new PrintWriter(outputStream);\n \n \n \n         int tn = sc.nextInt();\n         sc.nextLine();\n         for (int ti = 1; ti <= tn; ti++) {\n             String s = sc.nextLine();\n             String[] strings = s.split(" ");\n             int mx = (int) Math.pow(10, strings[0].length());\n             int v1 = -1;\n             int v2 = -1;\n             String x1 = "";\n             String x2 = "";\n             for (int n1=0;n1<mx;n1++) {\n                 for (int n2=0; n2<mx;n2++) {\n                     String s1 = String.valueOf(mx+n1);\n                     String s2 = String.valueOf(mx+n2);\n                     boolean flag = true;\n                     for (int i=0;i<strings[0].length();i++) {\n                         if ((strings[0].charAt(i)=='?') || (strings[0].charAt(i)==s1.charAt(i+1))) {\n \n                         } else {\n                             flag = false;\n                         }\n                     }\n                     for (int i=0;i<strings[1].length();i++) {\n                         if ((strings[1].charAt(i)=='?') || (strings[1].charAt(i)==s2.charAt(i+1))) {\n \n                         } else {\n                             flag = false;\n                         }\n                     }\n                     if (flag) {\n                         int dv = Math.abs(v1-v2);\n                         int dn = Math.abs(n1-n2);\n                         boolean doit = v1==-1;\n                         if (!doit && (dn<dv)) {\n                             doit = true;\n                         }\n                         if (!doit && (dn==dv) && (n1<v1)) {\n                             doit = true;\n                         }\n                         if (!doit && (dn==dv) && (n1==v1) && (n2<v2)) {\n                             doit = true;\n                         }\n                         if (doit) {\n                             v1 = n1;\n                             v2 = n2;\n                             x1 = s1.substring(1);\n                             x2 = s2.substring(1);\n                         }\n                     }\n                 }\n             }\n             String res = "Case #" + ti + ": " + x1+" "+x2;\n             printWriter.write(res + "\n");\n             System.out.println(res);\n         }\n         printWriter.close();\n     }\n \n }\n
Ratmir15	<>	27	<>	3264486_5633382285312000_Ratmir15_solution.java	<>	package codejam.y2017.qualification.z2;\n \n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.PrintWriter;\n import java.util.Scanner;\n \n public class Solution {\n \n     public static void main(String[] args) throws FileNotFoundException {\n         Scanner sc = new Scanner(System.in);\n         FileOutputStream outputStream = new FileOutputStream("/Users/ratmir/Documents/code/hackerrank/algs/src/codejam/y2017/qualification/z2/output.txt");\n         PrintWriter printWriter = new PrintWriter(outputStream);\n         int tn = sc.nextInt();\n         sc.nextLine();\n         boolean [] tidy = new boolean[1001];\n         int [] answers = new int[1001];\n         int lastTidy = 1;\n         for (int i=1;i<=1000;i++) {\n             String s = String.valueOf(i);\n             tidy[i] = true;\n             for (int j=0;j<s.length()-1;j++) {\n                 if (s.charAt(j)>s.charAt(j+1)) {\n                     tidy[i] = false;\n                     break;\n                 }\n             }\n             if (tidy[i]) {\n                 lastTidy = i;\n             }\n             answers[i] = lastTidy;\n         }\n         for (int ti = 1; ti <= tn; ti++) {\n             int n = sc.nextInt();\n             String s = "Case #" + ti + ": " + answers[n];\n             printWriter.write(s + "\n");\n             System.out.println(s);\n         }\n         printWriter.close();\n     }\n \n }\n
stolis	<>	29	<>	3264486_5633382285312000_stolis_tidynumbers.java	<>	package year2017.qualification;\n \n import java.io.File;\n import java.io.PrintWriter;\n import java.util.Scanner;\n \n public class TidyNumbers {\n     \n     public static void main(String[] args) throws Exception {\n         File inputFile = new File("B-small-attempt0.in");\n         Scanner in = new Scanner(inputFile);\n         File outputFile = new File("output.txt");\n         PrintWriter out = new PrintWriter(outputFile);\n \n         int T = in.nextInt();\n         for (int t=0; t<T; t++) {\n             char[] c = in.next().toCharArray();\n             for (int i=c.length-2; i>=0; i--) {\n                 if (c[i] > c[i+1]) {\n                     c[i]--;\n                     for (int j=i+1; j<c.length; j++) {\n                         c[j] = '9';\n                     }\n                 }\n             }\n             int offset = (c[0] == '0') ? 1 : 0;\n             String answer = new String(c, offset, c.length - offset);\n             \n             out.println("Case #"+(t+1)+": "+answer);\n         }\n \n         out.close();\n     }\n     \n }\n
stolis	<>	29	<>	10224486_5677604812095488_stolis_redtapecommittee.java	<>	package year2016.round2;\n \n import java.io.File;\n import java.io.PrintWriter;\n import java.util.Locale;\n import java.util.Scanner;\n \n public class RedTapeCommittee {\n     \n     public static void main(String[] args) throws Exception {\n         Locale.setDefault(Locale.ENGLISH);\n         File inputFile = new File("B-small-attempt0.in");\n         Scanner in = new Scanner(inputFile);\n         File outputFile = new File("output.txt");\n         PrintWriter out = new PrintWriter(outputFile);\n \n         int T = in.nextInt();\n         for (int t=0; t<T; t++) {\n             int N = in.nextInt();\n             int K = in.nextInt();\n             double[] P = new double[N];\n             for (int n=0; n<N; n++) {\n                 P[n] = in.nextDouble();\n             }\n             double best = 0;\n             int limit = 1<<N;\n             for (int mask=0; mask<limit; mask++) {\n                 if (Integer.bitCount(mask) == K) {\n                     int bits[] = new int[K];\n                     int next = 0;\n                     for (int i=0; i<N; i++) {\n                         if ((mask & (1<<i)) != 0) {\n                             bits[next++] = i;\n                         }\n                     }\n \n                     double pst = 0;\n                     int limit2 = 1<<K;\n                     for (int m=0; m<limit2; m++) {\n                         if (Integer.bitCount(m) == K/2) {\n                             double p = 1;\n                             for (int k=0; k<K; k++) {\n                                 if ((m&(1<<k)) != 0) {\n                                     p *= P[bits[k]];\n                                 } else {\n                                     p *= 1-P[bits[k]];\n                                 }\n                             }\n                             pst += p;\n                         }\n                     }\n                     best = Math.max(best, pst);\n                 }\n             }\n             \n             out.println("Case #"+(t+1)+": "+best);\n         }\n \n         out.close();\n     }\n     \n }\n
stolis	<>	29	<>	10224486_5718447400943616_stolis_freeformfactory.java	<>	package year2016.round2;\n \n import java.io.File;\n import java.io.PrintWriter;\n import java.util.Arrays;\n import java.util.Scanner;\n \n public class FreeformFactory {\n     \n     public static void main(String[] args) throws Exception {\n         File inputFile = new File("D-small-attempt1.in");\n         Scanner in = new Scanner(inputFile);\n         File outputFile = new File("output.txt");\n         PrintWriter out = new PrintWriter(outputFile);\n \n         int T = in.nextInt();\n         for (int t=0; t<T; t++) {\n             int N = in.nextInt();\n             boolean[][] skill = new boolean[N][N];\n             for (int n=0; n<N; n++) {\n                 String s = in.next();\n                 for (int i=0; i<N; i++) {\n                     skill[n][i] = s.charAt(i) == '1';\n                 }\n             }\n             int limit = 1 << N*N;\n             int best = N*N;\n             main: for (int mask=0; mask<limit; mask++) {\n                 int cost = 0;\n                 for (int n=0; n<N; n++) {\n                     for (int i=0; i<N; i++) {\n                         boolean knows = ((1 << (n*N+i)) & mask) != 0;\n                         if (skill[n][i]) {\n                             if (!knows) {\n                                 continue main;\n                             }\n                         } else {\n                             if (knows) {\n                                 cost++;\n                             }\n                         }\n                     }\n                 }\n \n                 for (int s=0; s<N; s++) {\n                     int first = -1;\n                     int scount = 0;\n                     for (int n=0; n<N; n++) {\n                         boolean knows = ((1 << (n*N+s)) & mask) != 0;\n                         if (knows) {\n                             first = n;\n                             scount++;\n                         }\n                     }\n                     if (first == -1) {\n                         continue main;\n                     }\n                     for (int i=0; i<N; i++) {\n                         boolean knows = ((1 << (first*N+i)) & mask) != 0;\n                         if (knows) {\n                             scount--;\n                         }\n                     }\n                     if (scount != 0) {\n                         continue main;\n                     }\n                     for (int n=0; n<N; n++) {\n                         boolean knows = ((1 << (n*N+s)) & mask) != 0;\n                         if (knows) {\n                             for (int i=0; i<N; i++) {\n                                 boolean fknows = ((1 << (first*N+i)) & mask) != 0;\n                                 knows =  ((1 << (n*N+i)) & mask) != 0;\n                                 if (fknows != knows) {\n                                     continue main;\n                                 }\n                             }\n                         }\n                     }\n                 }\n                 \n                 best = Math.min(cost, best);\n             }\n             out.println("Case #"+(t+1)+": "+best);\n         }\n \n         out.close();\n     }\n     \n }\n
stolis	<>	29	<>	10224486_5718606851604480_stolis_ratherperplexingshowdown.java	<>	package year2016.round2;\n \n import java.io.File;\n import java.io.PrintWriter;\n import java.util.Scanner;\n \n public class RatherPerplexingShowdown {\n     \n     public static void main(String[] args) throws Exception {\n         File inputFile = new File("A-small-attempt0.in");\n         Scanner in = new Scanner(inputFile);\n         File outputFile = new File("output.txt");\n         PrintWriter out = new PrintWriter(outputFile);\n \n         String[][] answers = new String[13][3];\n         answers[0] = new String[] {"P", "R", "S"};\n         for (int n=1; n<=12; n++) {\n             \n             String s1 = answers[n-1][0] + answers[n-1][1];\n             String s2 = answers[n-1][1] + answers[n-1][0];\n             answers[n][0] = s1.compareTo(s2) < 0 ? s1 : s2;\n             \n             s1 = answers[n-1][1] + answers[n-1][2];\n             s2 = answers[n-1][2] + answers[n-1][1];\n             answers[n][1] = s1.compareTo(s2) < 0 ? s1 : s2;\n             \n             s1 = answers[n-1][2] + answers[n-1][0];\n             s2 = answers[n-1][0] + answers[n-1][2];\n             answers[n][2] = s1.compareTo(s2) < 0 ? s1 : s2;            \n         }\n \n         int T = in.nextInt();\n         for (int t=0; t<T; t++) {\n             int N = in.nextInt();\n             int R = in.nextInt();\n             int P = in.nextInt();\n             int S = in.nextInt();\n             String best = null;\n             for (int i=0; i<3; i++) {\n                 String cand = answers[N][i];\n                 int[] stats = new int[3];\n                 for (char c : cand.toCharArray()) {\n                     if (c == 'R') {\n                         stats[0]++;\n                     } else if (c == 'P') {\n                         stats[1]++;\n                     } else {\n                         stats[2]++;\n                     }\n                 }\n                 if (stats[0] == R && stats[1] == P && stats[2] == S) {\n                     if (best == null || cand.compareTo(best) < 0) {\n                         best = cand;\n                     }\n                 }\n             }\n             String answer = (best == null) ? "IMPOSSIBLE" : best;\n             out.println("Case #"+(t+1)+": "+answer);\n         }\n \n         out.close();\n     }\n     \n }\n
yo35	<>	31	<>	3264486_5633382285312000_yo35_base.java	<>	package exo2;\n \n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.PrintStream;\n import java.util.Collection;\n import java.util.Scanner;\n \n public class Base {\n    \n    \n    \n    \n    \n    public static String implode(int[] array) {\n        return implode(" ", array);\n    }\n    \n    public static String implode(long[] array) {\n        return implode(" ", array);\n    }\n    \n    public static String implode(Object[] array) {\n        return implode(" ", array);\n    }\n    \n    public static String implode(Collection<?> collection) {\n        return implode(" ", collection);\n    }\n    \n    public static String implode(String glue, int[] array) {\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<array.length; ++i) {\n            if(i > 0) {\n                sb.append(glue);\n            }\n            sb.append(array[i]);\n        }\n        return sb.toString();\n    }\n    \n    public static String implode(String glue, long[] array) {\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<array.length; ++i) {\n            if(i > 0) {\n                sb.append(glue);\n            }\n            sb.append(array[i]);\n        }\n        return sb.toString();\n    }\n    \n    public static String implode(String glue, Object[] array) {\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<array.length; ++i) {\n            if(i > 0) {\n                sb.append(glue);\n            }\n            sb.append(array[i].toString());\n        }\n        return sb.toString();\n    }\n    \n    public static String implode(String glue, Collection<?> collection) {\n        StringBuilder sb = new StringBuilder();\n        boolean isFirst = true;\n        for(Object obj : collection) {\n            if(isFirst) {\n                isFirst = false;\n            }\n            else {\n                sb.append(glue);\n            }\n            sb.append(obj.toString());\n        }\n        return sb.toString();\n    }\n    \n    \n    \n    \n    \n    private interface Config {\n        void debug(String text);\n        Scanner input();\n        PrintStream output();\n        void done();\n    }\n    \n    private static Config CURRENT_CONFIG;\n    \n    protected static void debug(String text) {\n        CURRENT_CONFIG.debug(text);\n    }\n    \n    protected static Scanner input() {\n        return CURRENT_CONFIG.input();\n    }\n    \n    protected static PrintStream output() {\n        return CURRENT_CONFIG.output();\n    }\n    \n    protected static void done() {\n        CURRENT_CONFIG.done();\n    }\n \n    private static final String ECLIPSE_PREFIX = "src";\n    private static final String BASE_PATH = ECLIPSE_PREFIX + File.separator + Base.class.getPackage().getName() + File.separator; \n    \n    private static abstract class AbstractConfig implements Config {\n        \n        private Scanner _input;\n        private final boolean _debugEnabled;\n        \n        public AbstractConfig(boolean debugEnabled) {\n            _debugEnabled = debugEnabled;\n        }\n        \n        protected abstract String getInputFile();\n        \n        @Override\n        public Scanner input() {\n            if(_input == null) {\n                String source = BASE_PATH + getInputFile();\n                try {\n                    _input = new Scanner(new FileInputStream(source));\n                }\n                catch(FileNotFoundException e) {\n                    throw new IllegalArgumentException("File " + source + " cannot be read.");\n                }\n            }\n            return _input;\n        }\n    \n        @Override\n        public void done() {\n            if(_input != null) {\n                _input.close();\n                _input = null;\n            }\n        }\n        \n        @Override\n        public void debug(String text) {\n            if(_debugEnabled) {\n                if(text.indexOf("\n") < 0) {\n                    System.out.println("[DEBUG] " + text);\n                }\n                else {\n                    System.out.println("[DEBUG][BEGIN]");\n                    System.out.print(text);\n                    if(!"\n".equals(text.charAt(text.length()-1))) {\n                        System.out.println();\n                    }\n                    System.out.println("[DEBUG][END]");\n                }\n            }\n        }\n    }\n    \n    private static abstract class DevConfig extends AbstractConfig {\n        \n        public DevConfig(boolean debugEnabled) {\n            super(debugEnabled);\n        }\n \n        @Override\n        public PrintStream output() {\n            return System.out;\n        }\n        \n    }\n    \n    private static abstract class ProdConfig extends AbstractConfig {\n        \n        private PrintStream _output;\n        \n        public ProdConfig(boolean debugEnabled) {\n            super(debugEnabled);\n        }\n        \n        protected abstract String getOutputFile();\n        \n        @Override\n        public PrintStream output() {\n            if(_output == null) {\n                String target = BASE_PATH + getOutputFile() + ".txt";\n                try {\n                    _output = new PrintStream(target);\n                }\n                catch(FileNotFoundException e) {\n                    throw new IllegalArgumentException("File " + target + " cannot be written.");\n                }\n            }\n            return _output;\n        }\n        \n        @Override\n        public void done() {\n            if(_output == null) {\n                System.out.println("[ERROR] No output");\n            }\n            else {\n                _output.close();\n                _output = null;\n                System.out.println("[DONE]");\n            }\n            super.done();\n        }\n    }\n    \n    protected static void configTest(final int index, boolean debugEnabled) {\n        installConfig(new DevConfig(debugEnabled) {\n    \n            @Override\n            protected String getInputFile() {\n                return "test" + index;\n            }\n        });\n    }\n    \n    protected static void configSmall(final int index, boolean debugEnabled) {\n        System.out.println("Processing small problem (attempt " + index + ")...");\n        installConfig(new ProdConfig(debugEnabled) {\n    \n            @Override\n            protected String getInputFile() {\n                return "small" + index;\n            }\n    \n            @Override\n            protected String getOutputFile() {\n                return "output-small" + index;\n            }\n        });\n    }\n    \n    protected static void configLarge(boolean debugEnabled) {\n        System.out.println("Processing large problem...");\n        installConfig(new ProdConfig(debugEnabled) {\n    \n            @Override\n            protected String getInputFile() {\n                return "large";\n            }\n    \n            @Override\n            protected String getOutputFile() {\n                return "output-large";\n            }\n        });\n    }\n    \n    private static void installConfig(Config config) {\n        if(CURRENT_CONFIG != null) {\n            throw new IllegalStateException("I/O config already defined.");\n        }\n        CURRENT_CONFIG = config;\n    }\n }\n
yo35	<>	31	<>	11254486_5648941810974720_yo35_base.java	<>	package exo1;\n \n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.PrintStream;\n import java.util.Collection;\n import java.util.Scanner;\n \n public class Base {\n    \n    \n    \n    \n    \n    public static String implode(int[] array) {\n        return implode(" ", array);\n    }\n    \n    public static String implode(long[] array) {\n        return implode(" ", array);\n    }\n    \n    public static String implode(Object[] array) {\n        return implode(" ", array);\n    }\n    \n    public static String implode(Collection<?> collection) {\n        return implode(" ", collection);\n    }\n    \n    public static String implode(String glue, int[] array) {\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<array.length; ++i) {\n            if(i > 0) {\n                sb.append(glue);\n            }\n            sb.append(array[i]);\n        }\n        return sb.toString();\n    }\n    \n    public static String implode(String glue, long[] array) {\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<array.length; ++i) {\n            if(i > 0) {\n                sb.append(glue);\n            }\n            sb.append(array[i]);\n        }\n        return sb.toString();\n    }\n    \n    public static String implode(String glue, Object[] array) {\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<array.length; ++i) {\n            if(i > 0) {\n                sb.append(glue);\n            }\n            sb.append(array[i].toString());\n        }\n        return sb.toString();\n    }\n    \n    public static String implode(String glue, Collection<?> collection) {\n        StringBuilder sb = new StringBuilder();\n        boolean isFirst = true;\n        for(Object obj : collection) {\n            if(isFirst) {\n                isFirst = false;\n            }\n            else {\n                sb.append(glue);\n            }\n            sb.append(obj.toString());\n        }\n        return sb.toString();\n    }\n    \n    \n    \n    \n    \n    private interface Config {\n        void debug(String text);\n        Scanner input();\n        PrintStream output();\n        void done();\n    }\n    \n    private static Config CURRENT_CONFIG;\n    \n    protected static void debug(String text) {\n        CURRENT_CONFIG.debug(text);\n    }\n    \n    protected static Scanner input() {\n        return CURRENT_CONFIG.input();\n    }\n    \n    protected static PrintStream output() {\n        return CURRENT_CONFIG.output();\n    }\n    \n    protected static void done() {\n        CURRENT_CONFIG.done();\n    }\n \n    private static final String ECLIPSE_PREFIX = "src";\n    private static final String BASE_PATH = ECLIPSE_PREFIX + File.separator + Base.class.getPackage().getName() + File.separator; \n    \n    private static abstract class AbstractConfig implements Config {\n        \n        private Scanner _input;\n        private final boolean _debugEnabled;\n        \n        public AbstractConfig(boolean debugEnabled) {\n            _debugEnabled = debugEnabled;\n        }\n        \n        protected abstract String getInputFile();\n        \n        @Override\n        public Scanner input() {\n            if(_input == null) {\n                String source = BASE_PATH + getInputFile();\n                try {\n                    _input = new Scanner(new FileInputStream(source));\n                }\n                catch(FileNotFoundException e) {\n                    throw new IllegalArgumentException("File " + source + " cannot be read.");\n                }\n            }\n            return _input;\n        }\n    \n        @Override\n        public void done() {\n            if(_input != null) {\n                _input.close();\n                _input = null;\n            }\n        }\n        \n        @Override\n        public void debug(String text) {\n            if(_debugEnabled) {\n                if(text.indexOf("\n") < 0) {\n                    System.out.println("[DEBUG] " + text);\n                }\n                else {\n                    System.out.println("[DEBUG][BEGIN]");\n                    System.out.print(text);\n                    if(!"\n".equals(text.charAt(text.length()-1))) {\n                        System.out.println();\n                    }\n                    System.out.println("[DEBUG][END]");\n                }\n            }\n        }\n    }\n    \n    private static abstract class DevConfig extends AbstractConfig {\n        \n        public DevConfig(boolean debugEnabled) {\n            super(debugEnabled);\n        }\n \n        @Override\n        public PrintStream output() {\n            return System.out;\n        }\n        \n    }\n    \n    private static abstract class ProdConfig extends AbstractConfig {\n        \n        private PrintStream _output;\n        \n        public ProdConfig(boolean debugEnabled) {\n            super(debugEnabled);\n        }\n        \n        protected abstract String getOutputFile();\n        \n        @Override\n        public PrintStream output() {\n            if(_output == null) {\n                String target = BASE_PATH + getOutputFile() + ".txt";\n                try {\n                    _output = new PrintStream(target);\n                }\n                catch(FileNotFoundException e) {\n                    throw new IllegalArgumentException("File " + target + " cannot be written.");\n                }\n            }\n            return _output;\n        }\n        \n        @Override\n        public void done() {\n            if(_output == null) {\n                System.out.println("[ERROR] No output");\n            }\n            else {\n                _output.close();\n                _output = null;\n                System.out.println("[DONE]");\n            }\n            super.done();\n        }\n    }\n    \n    protected static void configTest(final int index, boolean debugEnabled) {\n        installConfig(new DevConfig(debugEnabled) {\n    \n            @Override\n            protected String getInputFile() {\n                return "test" + index;\n            }\n        });\n    }\n    \n    protected static void configSmall(final int index, boolean debugEnabled) {\n        System.out.println("Processing small problem (attempt " + index + ")...");\n        installConfig(new ProdConfig(debugEnabled) {\n    \n            @Override\n            protected String getInputFile() {\n                return "small" + index;\n            }\n    \n            @Override\n            protected String getOutputFile() {\n                return "output-small" + index;\n            }\n        });\n    }\n    \n    protected static void configLarge(boolean debugEnabled) {\n        System.out.println("Processing large problem...");\n        installConfig(new ProdConfig(debugEnabled) {\n    \n            @Override\n            protected String getInputFile() {\n                return "large";\n            }\n    \n            @Override\n            protected String getOutputFile() {\n                return "output-large";\n            }\n        });\n    }\n    \n    private static void installConfig(Config config) {\n        if(CURRENT_CONFIG != null) {\n            throw new IllegalStateException("I/O config already defined.");\n        }\n        CURRENT_CONFIG = config;\n    }\n }\n
yo35	<>	31	<>	11254486_5695413893988352_yo35_base.java	<>	package exo2;\n \n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.PrintStream;\n import java.util.Collection;\n import java.util.Scanner;\n \n public class Base {\n    \n    \n    \n    \n    \n    public static String implode(int[] array) {\n        return implode(" ", array);\n    }\n    \n    public static String implode(long[] array) {\n        return implode(" ", array);\n    }\n    \n    public static String implode(Object[] array) {\n        return implode(" ", array);\n    }\n    \n    public static String implode(Collection<?> collection) {\n        return implode(" ", collection);\n    }\n    \n    public static String implode(String glue, int[] array) {\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<array.length; ++i) {\n            if(i > 0) {\n                sb.append(glue);\n            }\n            sb.append(array[i]);\n        }\n        return sb.toString();\n    }\n    \n    public static String implode(String glue, long[] array) {\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<array.length; ++i) {\n            if(i > 0) {\n                sb.append(glue);\n            }\n            sb.append(array[i]);\n        }\n        return sb.toString();\n    }\n    \n    public static String implode(String glue, Object[] array) {\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<array.length; ++i) {\n            if(i > 0) {\n                sb.append(glue);\n            }\n            sb.append(array[i].toString());\n        }\n        return sb.toString();\n    }\n    \n    public static String implode(String glue, Collection<?> collection) {\n        StringBuilder sb = new StringBuilder();\n        boolean isFirst = true;\n        for(Object obj : collection) {\n            if(isFirst) {\n                isFirst = false;\n            }\n            else {\n                sb.append(glue);\n            }\n            sb.append(obj.toString());\n        }\n        return sb.toString();\n    }\n    \n    \n    \n    \n    \n    private interface Config {\n        void debug(String text);\n        Scanner input();\n        PrintStream output();\n        void done();\n    }\n    \n    private static Config CURRENT_CONFIG;\n    \n    protected static void debug(String text) {\n        CURRENT_CONFIG.debug(text);\n    }\n    \n    protected static Scanner input() {\n        return CURRENT_CONFIG.input();\n    }\n    \n    protected static PrintStream output() {\n        return CURRENT_CONFIG.output();\n    }\n    \n    protected static void done() {\n        CURRENT_CONFIG.done();\n    }\n \n    private static final String ECLIPSE_PREFIX = "src";\n    private static final String BASE_PATH = ECLIPSE_PREFIX + File.separator + Base.class.getPackage().getName() + File.separator; \n    \n    private static abstract class AbstractConfig implements Config {\n        \n        private Scanner _input;\n        private final boolean _debugEnabled;\n        \n        public AbstractConfig(boolean debugEnabled) {\n            _debugEnabled = debugEnabled;\n        }\n        \n        protected abstract String getInputFile();\n        \n        @Override\n        public Scanner input() {\n            if(_input == null) {\n                String source = BASE_PATH + getInputFile();\n                try {\n                    _input = new Scanner(new FileInputStream(source));\n                }\n                catch(FileNotFoundException e) {\n                    throw new IllegalArgumentException("File " + source + " cannot be read.");\n                }\n            }\n            return _input;\n        }\n    \n        @Override\n        public void done() {\n            if(_input != null) {\n                _input.close();\n                _input = null;\n            }\n        }\n        \n        @Override\n        public void debug(String text) {\n            if(_debugEnabled) {\n                if(text.indexOf("\n") < 0) {\n                    System.out.println("[DEBUG] " + text);\n                }\n                else {\n                    System.out.println("[DEBUG][BEGIN]");\n                    System.out.print(text);\n                    if(!"\n".equals(text.charAt(text.length()-1))) {\n                        System.out.println();\n                    }\n                    System.out.println("[DEBUG][END]");\n                }\n            }\n        }\n    }\n    \n    private static abstract class DevConfig extends AbstractConfig {\n        \n        public DevConfig(boolean debugEnabled) {\n            super(debugEnabled);\n        }\n \n        @Override\n        public PrintStream output() {\n            return System.out;\n        }\n        \n    }\n    \n    private static abstract class ProdConfig extends AbstractConfig {\n        \n        private PrintStream _output;\n        \n        public ProdConfig(boolean debugEnabled) {\n            super(debugEnabled);\n        }\n        \n        protected abstract String getOutputFile();\n        \n        @Override\n        public PrintStream output() {\n            if(_output == null) {\n                String target = BASE_PATH + getOutputFile() + ".txt";\n                try {\n                    _output = new PrintStream(target);\n                }\n                catch(FileNotFoundException e) {\n                    throw new IllegalArgumentException("File " + target + " cannot be written.");\n                }\n            }\n            return _output;\n        }\n        \n        @Override\n        public void done() {\n            if(_output == null) {\n                System.out.println("[ERROR] No output");\n            }\n            else {\n                _output.close();\n                _output = null;\n                System.out.println("[DONE]");\n            }\n            super.done();\n        }\n    }\n    \n    protected static void configTest(final int index, boolean debugEnabled) {\n        installConfig(new DevConfig(debugEnabled) {\n    \n            @Override\n            protected String getInputFile() {\n                return "test" + index;\n            }\n        });\n    }\n    \n    protected static void configSmall(final int index, boolean debugEnabled) {\n        System.out.println("Processing small problem (attempt " + index + ")...");\n        installConfig(new ProdConfig(debugEnabled) {\n    \n            @Override\n            protected String getInputFile() {\n                return "small" + index;\n            }\n    \n            @Override\n            protected String getOutputFile() {\n                return "output-small" + index;\n            }\n        });\n    }\n    \n    protected static void configLarge(boolean debugEnabled) {\n        System.out.println("Processing large problem...");\n        installConfig(new ProdConfig(debugEnabled) {\n    \n            @Override\n            protected String getInputFile() {\n                return "large";\n            }\n    \n            @Override\n            protected String getOutputFile() {\n                return "output-large";\n            }\n        });\n    }\n    \n    private static void installConfig(Config config) {\n        if(CURRENT_CONFIG != null) {\n            throw new IllegalStateException("I/O config already defined.");\n        }\n        CURRENT_CONFIG = config;\n    }\n }\n
Yarin	<>	35	<>	10224486_5718447400943616_Yarin_d.java	<>	package round2;\n \n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.util.ArrayList;\n import java.util.List;\n \n public class D {\n     public static void main(String[] args) throws FileNotFoundException {\n         Kattio io;\n \n \n \n         io = new Kattio(new FileInputStream("round2/D-small-attempt0.in"), new FileOutputStream("round2/D-small-0.out"));\n \n \n         int cases = io.getInt();\n         for (int i = 1; i <= cases; i++) {\n             io.print("Case #" + i + ": ");\n             new D().solve(io);\n             io.flush();\n         }\n         io.close();\n     }\n \n     public boolean check(boolean[][] m) {\n         int n = m.length; \n         for (int i = 0; i < n; i++) {\n             \n             int mcnt = 0; \n             for (int j = 0; j < n; j++) {\n                 if (m[i][j]) mcnt++;\n             }\n             ArrayList<BipartiteMatching.Edge> edges = new ArrayList<>();\n             for (int k = 0; k < n; k++) {\n                 if (i == k) continue;\n                 for (int j = 0; j < n; j++) {\n                     if (m[k][j] && m[i][j]) edges.add(new BipartiteMatching.Edge(k, j));\n                 }\n             }\n             \n             List<BipartiteMatching.Edge> matching = BipartiteMatching.findMaximumMatching(edges);\n             if (matching.size() == mcnt) return false;\n         }\n         return true;\n     }\n \n     private void solve(Kattio io) {\n         int n = io.getInt();\n         boolean m[][] = new boolean[n][n];\n         for (int i = 0; i < n; i++) {\n             String s = io.getWord();\n             for (int j = 0; j < n; j++) {\n                 m[i][j] = s.charAt(j) == '1';\n             }\n         }\n \n         int best = n*n;\n         if (check(m)) best=0;\n \n         int n2 = n*n;\n         for (int i = 0; i < (1 << n2); i++) {\n             boolean m2[][] = new boolean[n][n];\n             int cnt = 0;\n             for (int j = 0; j < n2 ; j++) {\n                 int y = j/n, x = j%n;\n                 m2[y][x] = m[y][x];\n                 if (((1<<j) & i)>0) {\n                     cnt++;\n                     m2[y][x] = true;\n                 }\n             }\n             if (cnt < best) {\n                 if (check(m2)) best = cnt;\n             }\n         }\n \n         io.println(best);\n     }\n }\n
Yarin	<>	35	<>	10224486_5677604812095488_Yarin_b.java	<>	package round2;\n \n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.util.Arrays;\n \n public class B {\n     public static void main(String[] args) throws FileNotFoundException {\n         Kattio io;\n \n \n \n         io = new Kattio(new FileInputStream("round2/B-small-attempt0.in"), new FileOutputStream("round2/B-small-0.out"));\n \n \n         int cases = io.getInt();\n         for (int i = 1; i <= cases; i++) {\n             io.print("Case #" + i + ": ");\n             new B().solve(io);\n         }\n         io.close();\n     }\n \n     private double evenProb(double[] p) {\n         int k = p.length/2;\n         double[] yes = new double[k+1];\n         yes[0] = 1.0;\n         for (int i = 0; i < p.length; i++) {\n             double[] oldyes = yes;\n             yes = new double[k+1];\n             for (int j = 0; j <= k; j++) {\n                 yes[j] = oldyes[j] * (1-p[i]) + (j > 0 ? oldyes[j-1]*p[i] : 0);\n             }\n         }\n         return yes[k];\n     }\n \n     private void solve(Kattio io) {\n         int N = io.getInt(), K = io.getInt();\n         double max = 0.0;\n         double p[] = new double[N];\n         double best[] = null;\n         for (int i = 0; i < N; i++) {\n             p[i] = io.getDouble();\n         }\n         Arrays.sort(p);\n \n         for (int mask = 0; mask < (1 << N); mask++) {\n             double pselected[] = new double[K];\n             int cnt = 0;\n             for (int i = 0; i < N; i++) {\n                 if (((1<<i)&mask)>0) {\n                     if (cnt < K) {\n                         pselected[cnt] = p[i];\n                     }\n                     cnt++;\n                 }\n             }\n             if (cnt == K) {\n                 double v = evenProb(pselected);\n                 if (v > max) {\n                     max = v;\n                     best = pselected.clone();\n                 }\n             }\n         }\n         io.println(String.format("%.10f", max));\n \n \n         \n     }\n }\n
Yarin	<>	35	<>	10224486_5718447400943616_Yarin_bipartitematching.java	<>	package round2;\n \n import java.util.ArrayList;\n import java.util.List;\n \n public class BipartiteMatching {\n     \n \n     public static class Edge {\n         private final int a, b;\n \n         public int getA() {\n             return a;\n         }\n \n         public int getB() {\n             return b;\n         }\n \n         public Edge(int a, int b) {\n             this.a = a;\n             this.b = b;\n         }\n     }\n \n     public static List<Edge> findMaximumMatching(List<Edge> e) {\n         int n = e.size(), aSize = 0, bSize = 0;\n         boolean augmented = true;\n         for (int i = 0; i < n; i++) {\n             aSize = Math.max(aSize, e.get(i).getA() + 1);\n             bSize = Math.max(bSize, e.get(i).getB() + 1);\n         }\n         List<List<Integer>> a = new ArrayList<List<Integer>>(aSize);\n         for (int i = 0; i < aSize; i++) {\n             a.add(new ArrayList<Integer>());\n         }\n         int[] ba = new int[bSize], asat = new int[aSize], q = new int[aSize];\n         for (int i = 0; i < bSize; i++) {\n             ba[i] = -1;\n         }\n         for (int i = 0; i < n; i++) {\n             a.get(e.get(i).getA()).add(e.get(i).getB());\n         }\n         while (augmented) {\n             augmented = false;\n             int head = 0, tail = 0;\n             int[] aprev = new int[aSize], bprev = new int[bSize];\n             for (int i = 0; i < aSize; i++) {\n                 aprev[i] = -1;\n             }\n             for (int i = 0; i < bSize; i++) {\n                 bprev[i] = -1;\n             }\n             for (int i = 0; i < aSize; i++) {\n                 if (asat[i] == 0) {\n                     q[tail++] = i;\n                 }\n             }\n             while (head < tail && !augmented) {\n                 int x = q[head++];\n                 for (int i = 0; i < a.get(x).size() && !augmented; i++) {\n                     int y = a.get(x).get(i), w = ba[y];\n                     if (x == w) {\n                         continue;\n                     }\n                     if (w >= 0) {\n                         if (bprev[y] < 0) {\n                             bprev[y] = x;\n                         }\n                         if (aprev[w] < 0) {\n                             aprev[q[tail++] = w] = y;\n                         }\n                     } else {\n                         ba[y] = x;\n                         while ((y = aprev[x]) >= 0) {\n                             ba[y] = x = bprev[y];\n                         }\n                         asat[x] = 1;\n                         augmented = true;\n                     }\n                 }\n             }\n         }\n         List<Edge> result = new ArrayList<Edge>();\n         for (int i = 0; i < bSize; i++) {\n             if (ba[i] >= 0) {\n                 result.add(new Edge(ba[i], i));\n             }\n         }\n         return result;\n     }\n }\n
Yarin	<>	35	<>	10224486_5677604812095488_Yarin_kattio.java	<>	package round2;\n \n import java.io.BufferedOutputStream;\n import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n import java.io.PrintWriter;\n import java.util.StringTokenizer;\n \n public class Kattio extends PrintWriter {\n     public Kattio(InputStream i) {\n         super(new BufferedOutputStream(System.out));\n         r = new BufferedReader(new InputStreamReader(i));\n     }\n \n     public Kattio(InputStream i, OutputStream o) {\n         super(new BufferedOutputStream(o));\n         r = new BufferedReader(new InputStreamReader(i));\n     }\n \n     public boolean hasMoreTokens() {\n         return peekToken() != null;\n     }\n \n     public int getInt() {\n         return Integer.parseInt(nextToken());\n     }\n \n     public double getDouble() {\n         return Double.parseDouble(nextToken());\n     }\n \n     public long getLong() {\n         return Long.parseLong(nextToken());\n     }\n \n     public String getWord() {\n         return nextToken();\n     }\n \n \n     private BufferedReader r;\n     private String line;\n     private StringTokenizer st;\n     private String token;\n \n     private String peekToken() {\n         if (token == null)\n             try {\n                 while (st == null || !st.hasMoreTokens()) {\n                     line = r.readLine();\n                     if (line == null) return null;\n                     st = new StringTokenizer(line);\n                 }\n                 token = st.nextToken();\n             } catch (IOException e) {\n             }\n         return token;\n     }\n \n     private String nextToken() {\n         String ans = peekToken();\n         token = null;\n         return ans;\n     }\n }\n
victorxu	<>	43	<>	10224486_5677604812095488_victorxu_redtape.java	<>	import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.FileReader;\n import java.io.FileWriter;\n import java.io.IOException;\n import java.io.PrintWriter;\n \n \n public class RedTape {\n    public static void main(String[] args) throws IOException{\n        BufferedReader buf = new BufferedReader(new FileReader("redtape.in"));\n        PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("redtape.out")));\n        int t = Integer.parseInt(buf.readLine());\n        for(int i = 1; i <= t; i++){\n            String[] str = buf.readLine().split(" ");\n            int n = Integer.parseInt(str[0]);\n            int k = Integer.parseInt(str[1]);\n            String[] str2 = buf.readLine().split(" ");\n            double[] in = new double[n];\n            for(int j = 0; j < n; j++) in[j] = Double.parseDouble(str2[j]);\n            double[] prb = new double[k+1];\n            prb[0] = 1.0;\n            System.out.println(i);\n            out.println("Case #" + i + ": " + search(0,prb,k,0,n,in));\n        }\n        out.close();\n    }\n    public static double search(int i, double[] prb, int k, int j, int n, double[] input){\n        if(i == k){\n            return prb[k/2];\n        }\n        double max = 0;\n        for(int c = j; c < n - k + i + 1; c++){\n            double[] prb2 = new double[k+1];\n            for(int d = 0; d < k+1; d++){\n                \n                prb2[d] = prb[d] * (1 - input[c]);\n                if(d > 0) prb2[d] += prb[d-1] * input[c];\n            }\n            double val = search(i+1, prb2, k, c+1, n, input);\n            if(val > max) max = val;\n        }\n        return max;\n    }\n }\n
victorxu	<>	43	<>	10224486_5718447400943616_victorxu_factory.java	<>	import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.FileReader;\n import java.io.FileWriter;\n import java.io.IOException;\n import java.io.PrintWriter;\n import java.util.HashSet;\n \n \n public class Factory {\n    public static void main(String[] args) throws IOException{\n        BufferedReader buf = new BufferedReader(new FileReader("factory.in"));\n        PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("factory.out")));\n        int t = Integer.parseInt(buf.readLine());\n        for(int i = 1; i <= t; i++){\n            int n = Integer.parseInt(buf.readLine());\n            char[][] workers = new char[n][n];\n            for(int j = 0; j < n; j++){\n                workers[j] = buf.readLine().toCharArray();\n            }\n            int freew = 0;\n            int needw = 0;\n            HashSet<Pair> plus = new HashSet<Pair>();\n            HashSet<Pair> minus = new HashSet<Pair>();\n            int sum = 0;\n            for(int j = 0; j < n; j++){\n                for(int k = 0; k < n; k++){\n                    if(workers[j][k] == '1') sum--;\n                }\n            }\n            boolean[] checked = new boolean[n];\n            boolean[] checkedm = new boolean[n];\n            for(int j = 0; j < n; j++){\n                if(checked[j]) continue;\n                Pair comb = new Pair(0,0);\n                searchWorker(checked,checkedm,j,workers,n,comb);\n                if(comb.a > comb.b) {\n                    if(comb.a == 1) freew++;\n                    else {\n                        plus.add(comb);\n                    }\n                } else if (comb.a == comb.b){\n                    sum = sum + comb.a * comb.a;\n                } else {\n                    needw = needw + comb.b - comb.a;\n                    minus.add(comb);\n                }\n            }\n            System.out.println(needw - freew);\n            int best = optSearch(plus, minus, needw-freew);\n            out.println("Case #" + i + ": " + (best + sum));\n        }\n        out.close();\n    }\n    public static int optSearch (HashSet<Pair> plus, HashSet<Pair> minus, int need){\n        if(need <= 0){\n            int sum = -need;\n            for(Pair p : plus){\n                int max = Math.max(p.a, p.b);\n                sum = sum + max * max;\n            }\n            for(Pair p : minus){\n                int max = Math.max(p.a, p.b);\n                sum = sum + max * max;\n            }\n            return sum;\n        }\n        int best = 999999999;\n        for(Pair p : plus){\n            for(Pair q : minus){\n                int plusv = p.a - p.b;\n                int minusv = q.b - q.a;\n                HashSet<Pair> plus2 = new HashSet<Pair>();\n                HashSet<Pair> minus2 = new HashSet<Pair>();\n                for(Pair p2 : plus) plus2.add(p2);\n                for(Pair q2 : minus) minus2.add(q2);\n                if(plusv > minusv){\n                    minus2.remove(q);\n                    plus2.remove(p);\n                    plus2.add(new Pair(p.a + q.a, p.b + q.b));\n                    int v = optSearch(plus2, minus2, need - Math.min(plusv, minusv));\n                    if(v < best) best = v;\n                } else if (plusv == minusv) {\n                    minus2.remove(q);\n                    plus2.remove(p);\n                    int v = (p.a + q.a) * (p.a + q.a) + optSearch(plus2, minus2, need - plusv);\n                    if(v < best) best = v;\n                } else {\n                    plus.remove(p);\n                    minus2.remove(q);\n                    plus2.remove(p);\n                    minus2.add(new Pair(p.a + q.a, p.b + q.b));\n                    int v = optSearch(plus2, minus2, need - Math.min(plusv, minusv));\n                    if(v < best) best = v;\n                }\n            }\n        }\n        return best;\n    }\n    public static void searchWorker (boolean[] checked, boolean[] checkedm, int w, char[][] workers, int n, Pair counts){\n        checked[w] = true;\n        counts.a = counts.a + 1;\n        for(int i = 0; i < n; i++){\n            if(workers[w][i] == '1' && checkedm[i] == false){\n                checkedm[i] = true;\n                counts.b = counts.b + 1;\n                for(int j = 0; j < n; j++){\n                    if(workers[j][i] == '1' && checked[j] == false){\n                        searchWorker(checked, checkedm, j, workers, n, counts);\n                    }\n                }\n            }\n        }\n    }\n    public static class Pair{\n        int a;\n        int b;\n        public Pair(int x,int y){\n            a = x;\n            b = y;\n        }\n    }\n }\n
victorxu	<>	43	<>	10224486_5718606851604480_victorxu_rps.java	<>	import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.FileReader;\n import java.io.FileWriter;\n import java.io.IOException;\n import java.io.PrintWriter;\n \n \n public class RPS {\n    public static void main(String[] args) throws IOException{\n        BufferedReader buf = new BufferedReader(new FileReader("RPS.in"));\n        PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("RPS.out")));\n        int t = Integer.parseInt(buf.readLine());\n        for(int i = 1; i <= t; i++){\n            String[] str = buf.readLine().split(" ");\n            int n = Integer.parseInt(str[0]);\n            int r = Integer.parseInt(str[1]);\n            int p = Integer.parseInt(str[2]);\n            int s = Integer.parseInt(str[3]);\n            String st = "R";\n            String st2 = "P";\n            String st3 = "S";\n            for(int j = 0; j < n; j++){\n                String stemp = "";\n                String stemp2 = "";\n                String stemp3 = "";\n                if(st.compareTo(st2) < 0){\n                    stemp = st + st2;\n                } else {\n                    stemp = st2 + st;\n                }\n                if(st2.compareTo(st3) < 0){\n                    stemp2 = st2 + st3;\n                } else {\n                    stemp2 = st3 + st2;\n                }\n                if(st3.compareTo(st) < 0){\n                    stemp3 = st3 + st;\n                } else {\n                    stemp3 = st + st3;\n                }\n                st = stemp;\n                st2 = stemp2;\n                st3 = stemp3;\n            }\n            \n            out.print("Case #" + i + ": ");\n            int countr = 0;\n            int countp = 0;\n            int counts = 0;\n            for(int j = 0; j < st.length(); j++){\n                if(st.charAt(j) == 'R'){\n                    countr++;\n                } else if(st.charAt(j) == 'P'){\n                    countp++;\n                } else if(st.charAt(j) == 'S'){\n                    counts++;\n                }\n            }\n            if (countr == r && countp == p && counts == s){\n                out.println(st);\n            } else {\n                countr = 0;\n                countp = 0;\n                counts = 0;\n                for(int j = 0; j < st.length(); j++){\n                    if(st2.charAt(j) == 'R'){\n                        countr++;\n                    } else if(st2.charAt(j) == 'P'){\n                        countp++;\n                    } else if(st2.charAt(j) == 'S'){\n                        counts++;\n                    }\n                }\n                if (countr == r && countp == p && counts == s){\n                    out.println(st2);\n                } else {\n                    countr = 0;\n                    countp = 0;\n                    counts = 0;\n                    for(int j = 0; j < st.length(); j++){\n                        if(st3.charAt(j) == 'R'){\n                            countr++;\n                        } else if(st3.charAt(j) == 'P'){\n                            countp++;\n                        } else if(st3.charAt(j) == 'S'){\n                            counts++;\n                        }\n                    }\n                    if (countr == r && countp == p && counts == s){\n                        out.println(st3);\n                    } else {\n                        out.println("IMPOSSIBLE");\n                    }\n                }\n            }\n        }\n        out.close();\n    }\n }\n
ChrisA	<>	45	<>	4224486_6404600001200128_ChrisA_input.java	<>	package chris.atkins.mushroommonster;\n \n import java.util.Arrays;\n \n \n public class Input {\n \n    int caseNumber;\n    int[] roundValues;\n    int numberOfRounds;\n \n \n    public Input(final int caseNumber, final int[] roundValues, final int numberOfRounds) {\n        super();\n        this.caseNumber = caseNumber;\n        this.roundValues = roundValues;\n        this.numberOfRounds = numberOfRounds;\n    }\n \n \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + this.caseNumber;\n        result = prime * result + this.numberOfRounds;\n        result = prime * result + Arrays.hashCode(this.roundValues);\n        return result;\n    }\n \n \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        final Input other = (Input) obj;\n        if (this.caseNumber != other.caseNumber)\n            return false;\n        if (this.numberOfRounds != other.numberOfRounds)\n            return false;\n        if (!Arrays.equals(this.roundValues, other.roundValues))\n            return false;\n        return true;\n    }\n \n \n    @Override\n    public String toString() {\n        return "Input [caseNumber=" + this.caseNumber + ", roundValues=" + Arrays.toString(this.roundValues) + ", numberOfRounds="\n                + this.numberOfRounds + "]";\n    }\n }\n
ChrisA	<>	45	<>	4224486_6404600001200128_ChrisA_inputcreator.java	<>	package chris.atkins.mushroommonster;\n \n import java.util.ArrayList;\n import java.util.List;\n \n import org.apache.commons.lang.Validate;\n \n \n public class InputCreator {\n \n    private int expectedNumberOfInputs;\n \n \n    public List<Input> create(final List<String> inputLines) {\n        final List<Input> inputList = new ArrayList<>((inputLines.size() - 1) / 2);\n        boolean openingLine = true;\n        boolean firstLineOfInput = true;\n        int caseNumber = 0;\n        String firstLine = null;\n \n        for (final String line : inputLines) {\n            if (openingLine) {\n                openingLine = false;\n                this.expectedNumberOfInputs = Integer.parseInt(line);\n            } else {\n                if (firstLineOfInput) {\n                    firstLine = line;\n                    caseNumber++;\n                } else {\n                    inputList.add(createNewInputFromLine(caseNumber, line, firstLine));\n                }\n                firstLineOfInput = !firstLineOfInput;\n            }\n        }\n        Validate.isTrue(this.expectedNumberOfInputs == inputList.size());\n        return inputList;\n    }\n \n \n    private Input createNewInputFromLine(final int caseNumber, final String secondLine, final String firstLine) {\n        final String[] split = secondLine.split(" ");\n        final int expectedRounds = Integer.parseInt(firstLine);\n        Validate.isTrue(expectedRounds == split.length);\n        return new Input(caseNumber, buildIntArray(split), expectedRounds);\n    }\n \n \n    private int[] buildIntArray(final String[] line) {\n        final int[] arr = new int[line.length];\n        for (int i = 0; i < line.length; i++) {\n            arr[i] = Integer.parseInt(line[i]);\n        }\n        return arr;\n    }\n }\n
ChrisA	<>	45	<>	4224486_6404600001200128_ChrisA_mushroommonster.java	<>	package chris.atkins.mushroommonster;\n \n import java.io.File;\n import java.util.LinkedList;\n import java.util.List;\n \n import org.apache.commons.io.FileUtils;\n \n \n public class MushroomMonster {\n \n    private static final String outputPath = "C:/Users/Chris/Documents/GoogleCode/mushroomMonsterOutput.txt";\n    private final InputCreator inputCreator = new InputCreator();\n    private final Solver solver = new Solver();\n \n \n    public static void main(final String[] args) {\n        final String filepath = args[0];\n        final MushroomMonster mushroomMonster = new MushroomMonster();\n \n        try {\n            mushroomMonster.solve(filepath);\n            System.out.println("Done.");\n        } catch (final Exception e) {\n            e.printStackTrace();\n        }\n    }\n \n \n    private void solve(final String filepath) throws Exception {\n        final List<String> inputLines = FileUtils.readLines(new File(filepath));\n        final List<String> outputLines = solveAllProblems(inputLines);\n        FileUtils.writeLines(new File(outputPath), outputLines, "\n");\n    }\n \n \n    List<String> solveAllProblems(final List<String> inputLines) {\n        final List<Input> inputs = this.inputCreator.create(inputLines);\n        final List<Output> outputs = this.solver.solve(inputs);\n        final List<String> outputLines = buildOutputLines(outputs);\n        return outputLines;\n    }\n \n \n    private List<String> buildOutputLines(final List<Output> outputs) {\n        final List<String> outputLines = new LinkedList<>();\n        for (final Output output : outputs) {\n            outputLines.add(OutputTranslator.translateToLine(output));\n        }\n        return outputLines;\n    }\n }\n
ChrisA	<>	45	<>	4224486_6404600001200128_ChrisA_mushroommonstertest.java	<>	package chris.atkins.mushroommonster;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.equalTo;\n \n import java.util.LinkedList;\n import java.util.List;\n \n import org.junit.Before;\n import org.junit.Test;\n \n \n public class MushroomMonsterTest {\n \n    private List<String> inputLines;\n    private List<String> expectedOutputLines;\n    private final MushroomMonster mushroomMonster = new MushroomMonster();\n \n \n    @Before\n    public void setup() {\n        setupInput();\n        setupExpectedOutput();\n    }\n \n \n    @Test\n    public void sampleCase() throws Exception {\n        final List<String> result = this.mushroomMonster.solveAllProblems(this.inputLines);\n        assertThat(result, equalTo(this.expectedOutputLines));\n    }\n \n \n    private void setupInput() {\n        this.inputLines = new LinkedList<>();\n        this.inputLines.add("4");\n        this.inputLines.add("4");\n        this.inputLines.add("10 5 15 5");\n        this.inputLines.add("2");\n        this.inputLines.add("100 100");\n        this.inputLines.add("8");\n        this.inputLines.add("81 81 81 81 81 81 81 0");\n        this.inputLines.add("6");\n        this.inputLines.add("23 90 40 0 100 9");\n    }\n \n \n    private void setupExpectedOutput() {\n        this.expectedOutputLines = new LinkedList<>();\n        this.expectedOutputLines.add("Case #1: 15 25");\n        this.expectedOutputLines.add("Case #2: 0 0");\n        this.expectedOutputLines.add("Case #3: 81 567");\n        this.expectedOutputLines.add("Case #4: 181 244");\n    }\n }\n
ChrisA	<>	45	<>	4224486_6404600001200128_ChrisA_inputcreatortest.java	<>	package chris.atkins.mushroommonster;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.equalTo;\n \n import java.util.ArrayList;\n import java.util.LinkedList;\n import java.util.List;\n \n import org.junit.Test;\n \n import com.google.common.collect.ImmutableList;\n \n \n public class InputCreatorTest {\n \n    private final InputCreator creator = new InputCreator();\n \n \n    @Test\n    public void correctNumberOfResponses() throws Exception {\n        final List<Input> results = this.creator.create(buildSampleInput());\n        assertThat(results.size(), equalTo(4));\n    }\n \n \n    @Test\n    public void lineTranslatesToCorrectIntArray() throws Exception {\n        final List<String> inputLines = new ImmutableList.Builder<String>().add("1").add("5").add("1 2 3 4 5").build();\n        final List<Input> expectedOutput = new ImmutableList.Builder<Input>().add(new Input(1, new int[] { 1, 2, 3, 4, 5 }, 5)).build();\n \n        final List<Input> results = this.creator.create(inputLines);\n        assertThat(results, equalTo(expectedOutput));\n    }\n \n \n    @Test\n    public void sampleProblem() throws Exception {\n        final List<Input> results = this.creator.create(buildSampleInput());\n        assertThat(results, equalTo(buildExpectedOutputLines()));\n    }\n \n \n    private List<String> buildSampleInput() {\n        final List<String> inputLines = new LinkedList<>();\n        inputLines.add("4");\n        inputLines.add("4");\n        inputLines.add("10 5 15 5");\n        inputLines.add("2");\n        inputLines.add("100 100");\n        inputLines.add("8");\n        inputLines.add("81 81 81 81 81 81 81 0");\n        inputLines.add("6");\n        inputLines.add("23 90 40 0 100 9");\n        return inputLines;\n    }\n \n \n    private List<Input> buildExpectedOutputLines() {\n        final List<Input> expectedInputs = new ArrayList<>();\n        expectedInputs.add(new Input(1, new int[] { 10, 5, 15, 5 }, 4));\n        expectedInputs.add(new Input(2, new int[] { 100, 100 }, 2));\n        expectedInputs.add(new Input(3, new int[] { 81, 81, 81, 81, 81, 81, 81, 0 }, 8));\n        expectedInputs.add(new Input(4, new int[] { 23, 90, 40, 0, 100, 9 }, 6));\n        return expectedInputs;\n    }\n }\n
antonkovsharov	<>	46	<>	10224486_5718606851604480_antonkovsharov_b.java	<>	import java.util.*;\n import java.io.*;\n \n public class B {\n    FastScanner in;\n    PrintWriter out;\n \n    public void solve() throws IOException {\n        int n = in.nextInt(), r = in.nextInt(), p = in.nextInt(), s = in\n                .nextInt();\n        final int S = 0, R = 1, P = 2;\n        String[][][][] dp = new String[n + 1][3][r + 1][p + 1];\n        if (s > 0)\n            dp[0][S][0][0] = "S";\n        if (r > 0)\n            dp[0][R][1][0] = "R";\n        if (p > 0)\n            dp[0][P][0][1] = "P";\n        for (int i = 0; i < n; i++) {\n            for (int cr1 = 0; cr1 <= r; cr1++) {\n                for (int cp1 = 0; cp1 <= p; cp1++) {\n                    for (int left = 0; left < 3; left++) {\n                        if (dp[i][left][cr1][cp1] != null) {\n                            for (int cr2 = 0; cr2 <= r - cr1; cr2++) {\n                                for (int cp2 = 0; cp2 <= p - cp1; cp2++) {\n                                    for (int right = 0; right < 3; right++) {\n                                        if (left != right) {\n                                            if (dp[i][right][cr2][cp2] != null) {\n                                                String str = dp[i][left][cr1][cp1]\n                                                        + dp[i][right][cr2][cp2];\n                                                int win = 0;\n                                                if (left == S) {\n                                                    win = (right == P) ? left : right;\n                                                } else if (left == P) {\n                                                    win = (right == R) ? left : right;\n                                                } else if (left == R) {\n                                                    win = (right == S) ? left : right;\n                                                }\n                                                if (dp[i + 1][win][cr1 + cr2][cp1\n                                                        + cp2] == null\n                                                        || str.compareTo(dp[i + 1][win][cr1\n                                                                + cr2][cp1\n                                                                + cp2]) < 0) {\n                                                    dp[i + 1][win][cr1 + cr2][cp1\n                                                            + cp2] = str;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        String ans = null;\n        for (int win = 0; win < 3; win++) {\n            if (dp[n][win][r][p] != null) {\n                if (ans == null || dp[n][win][r][p].compareTo(ans) < 0) {\n                    ans = dp[n][win][r][p];\n                }\n            }\n        }\n        if (ans == null) {\n            out.println("IMPOSSIBLE");\n        } else {\n            out.println(ans);\n        }\n    }\n \n    public void run() {\n        try {\n            in = new FastScanner(new File("a.in"));\n            out = new PrintWriter(new File("a.out"));\n \n            int tests = in.nextInt();\n            for (int i = 0; i < tests; i++) {\n                out.print("Case #" + (i + 1) + ": ");\n                solve();\n            }\n \n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n \n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n \n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n \n    public static void main(String[] arg) {\n        new B().run();\n    }\n }
antonkovsharov	<>	46	<>	10224486_5723605790883840_antonkovsharov_a.java	<>	import java.util.*;\n import java.io.*;\n \n public class A {\n    FastScanner in;\n    PrintWriter out;\n \n    int r, c;\n    int rowCnt;\n    int colCnt;\n \n    final int UP = 0, RIGHT = 1, DOWN = 2, LEFT = 3;\n \n    int get(int i, int j, int dir) {\n        if (dir == UP) {\n            return i * c + j;\n        } else if (dir == DOWN) {\n            return (i + 1) * c + j;\n        } else if (dir == LEFT) {\n            return rowCnt + i * (c + 1) + j;\n        } else {\n            return rowCnt + i * (c + 1) + (j + 1);\n        }\n    }\n \n    void add(ArrayList<Integer>[] g, int a, int b) {\n        g[a].add(b);\n        g[b].add(a);\n    }\n \n    ArrayList<Integer>[] g;\n \n    void go(int v, boolean[] was) {\n        was[v] = true;\n        for (int u : g[v]) {\n            if (!was[u]) {\n                go(u, was);\n            }\n        }\n    }\n \n    public void solve() throws IOException {\n        out.println();\n        r = in.nextInt();\n        c = in.nextInt();\n        rowCnt = (r + 1) * c;\n        colCnt = (c + 1) * r;\n        int cntV = rowCnt + colCnt;\n        int n = r + c;\n        int[] real = new int[2 * (r + c)];\n        int p = 0;\n        for (int j = 0; j < c; j++) {\n            real[p++] = get(0, j, UP);\n        }\n        for (int i = 0; i < r; i++) {\n            real[p++] = get(i, c - 1, RIGHT);\n        }\n        for (int j = c - 1; j >= 0; j--) {\n            real[p++] = get(r - 1, j, DOWN);\n        }\n        for (int i = r - 1; i >= 0; i--) {\n            real[p++] = get(i, 0, LEFT);\n        }\n        boolean[] border = new boolean[cntV];\n        for (int x : real) {\n            border[x] = true;\n        }\n        int[] a = new int[n];\n        int[] b = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = real[in.nextInt() - 1];\n            b[i] = real[in.nextInt() - 1];\n        }\n        int countProfiles = 1 << (r * c);\n        for (int pr = 0; pr < countProfiles; pr++) {\n            g = new ArrayList[cntV];\n            for (int i = 0; i < cntV; i++) {\n                g[i] = new ArrayList<>();\n            }\n            char[][] map = new char[r][c];\n            int ptr = 0;\n            for (int i = 0; i < r; i++) {\n                for (int j = 0; j < c; j++) {\n                    int[] id = new int[4];\n                    for (int ii = 0; ii < 4; ii++) {\n                        id[ii] = get(i, j, ii);\n                    }\n                    if (((pr >> ptr) & 1) != 0) {\n                        map[i][j] = '/';\n                        add(g, id[UP], id[LEFT]);\n                        add(g, id[RIGHT], id[DOWN]);\n                    } else {\n                        map[i][j] = '\\';\n                        add(g, id[UP], id[RIGHT]);\n                        add(g, id[LEFT], id[DOWN]);\n                    }\n                    ptr++;\n                }\n            }\n            boolean ok = true;\n            boolean[] was = new boolean[cntV];\n            for (int i = 0; i < n; i++) {\n                Arrays.fill(was, false);\n                go(a[i], was);\n                for (int x : real) {\n                    if (x == a[i] || x == b[i]) {\n                        if (!was[x]) {\n                            ok = false;\n                            break;\n                        }\n                    } else {\n                        if (was[x]) {\n                            ok = false;\n                            break;\n                        }\n                    }\n                }\n                if (!ok) {\n                    break;\n                }\n            }\n            if (ok) {\n                for (char[] c : map) {\n                    out.println(new String(c));\n                }\n                return;\n            }\n        }\n        out.println("IMPOSSIBLE");\n    }\n \n    public void run() {\n        try {\n            in = new FastScanner(new File("a.in"));\n            out = new PrintWriter(new File("a.out"));\n \n            int tests = in.nextInt();\n            for (int i = 0; i < tests; i++) {\n                out.print("Case #" + (i + 1) + ": ");\n                solve();\n            }\n \n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n \n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n \n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n \n    public static void main(String[] arg) {\n        new A().run();\n    }\n }
antonkovsharov	<>	46	<>	10224486_5718447400943616_antonkovsharov_d.java	<>	import java.util.*;\n import java.io.*;\n \n public class D {\n    FastScanner in;\n    PrintWriter out;\n \n    int n;\n    int[][] a;\n    int ans;\n    boolean[] wasWorker;\n    boolean[] wasMachine;\n    \n    boolean calc(int id) {\n        if (id == n) {\n            return true;\n        }\n        for (int i = 0; i < n; i++) {\n            if (!wasWorker[i]) {\n                wasWorker[i] = true;\n                boolean found = false;\n                for (int j = 0; j < n; j++) {\n                    if (a[i][j] == 1 && !wasMachine[j]) {\n                        found = true;\n                        wasMachine[j] = true;\n                        if (!calc(id + 1)) {\n                            return false;\n                        }\n                        wasMachine[j] = false;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n                wasWorker[i] = false;\n            }\n        }\n        return true;\n    }\n    \n    void go(int ci, int cj, int add) {\n        if (ci == n) {\n            wasWorker = new boolean[n];\n            wasMachine = new boolean[n];\n            if (calc(0)) {\n                ans = Math.min(ans, add);\n            }\n            return;\n        }\n        if (cj == n) {\n            go(ci + 1, 0, add);\n            return;\n        }\n        go(ci, cj + 1, add);\n        if (a[ci][cj] == 0) {\n            a[ci][cj] = 1;\n            go(ci, cj + 1, add + 1);\n            a[ci][cj] = 0;\n        }\n    }\n    \n    public void solve() throws IOException {\n        n = in.nextInt();\n        a = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            char[] c = in.next().toCharArray();\n            for (int j = 0; j < n; j++) {\n                a[i][j] = c[j] - '0';\n            }\n        }\n        ans = n * n;\n        go(0, 0, 0);\n        out.println(ans);\n    }\n \n    public void run() {\n        try {\n            in = new FastScanner(new File("a.in"));\n            out = new PrintWriter(new File("a.out"));\n \n            int tests = in.nextInt();\n            for (int i = 0; i < tests; i++) {\n                out.print("Case #" + (i + 1) + ": ");\n                solve();\n            }\n \n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n \n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n \n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n \n    public static void main(String[] arg) {\n        new D().run();\n    }\n }
antonkovsharov	<>	46	<>	10224486_5677604812095488_antonkovsharov_c.java	<>	import java.util.*;\n import java.io.*;\n \n public class C {\n    FastScanner in;\n    PrintWriter out;\n \n    public void solve() throws IOException {\n        int n = in.nextInt(), k = in.nextInt();\n        double[] p = new double[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = in.nextDouble();\n        }\n        Arrays.sort(p);\n        double ans = 0;\n        for (int l = 0; l <= k; l++) {\n            int r = k - l;\n            double[] ps = new double[k];\n            int ptr = 0;\n            for (int i = 0; i < l; i++) {\n                ps[ptr++] = p[i];\n            }\n            for (int i = n - r; i < n; i++) {\n                ps[ptr++] = p[i];\n            }\n            int balanceZero = k;\n            int maxBalance = 2 * k;\n            double[][] dp = new double[k + 1][maxBalance + 1];\n            dp[0][balanceZero] = 1;\n            for (int i = 0; i < k; i++) {\n                for (int j = 0; j <= maxBalance; j++) {\n                    if (dp[i][j] != 0) {\n                        dp[i + 1][j + 1] += dp[i][j] * ps[i];\n                        dp[i + 1][j - 1] += dp[i][j] * (1 - ps[i]);\n                    }\n                }\n            }\n            if (dp[k][balanceZero] > ans) {\n                ans = dp[k][balanceZero];\n            }\n        }\n        out.println(ans);\n    }\n \n    public void run() {\n        try {\n            in = new FastScanner(new File("a.in"));\n            out = new PrintWriter(new File("a.out"));\n \n            int tests = in.nextInt();\n            for (int i = 0; i < tests; i++) {\n                out.print("Case #" + (i + 1) + ": ");\n                solve();\n            }\n \n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n \n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n \n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n \n    public static void main(String[] arg) {\n        new C().run();\n    }\n }
piroz	<>	47	<>	10224486_5723605790883840_piroz_main.java	<>	package c;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.PrintWriter;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Scanner;\n import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.FutureTask;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n public class Main {\n \n    public static void main(String[] args) throws Exception {\n        Solver<Object> solver = Solver.getInstance("C-small-attempt1.in");\n        Scanner sc = solver.getScanner();\n        int casenum = sc.nextInt();\n        for(int caseid=0;caseid<casenum;caseid++) {\n            int h = sc.nextInt();\n            int w = sc.nextInt();\n            int n = (h + w) * 2;\n            int[] a = new int[n];\n            for(int i=0;i<n;i++) {\n                a[i] = sc.nextInt();\n            }\n            Task task = new Task(h,w,a);\n            solver.addTask(task);\n        }\n        solver.finish();\n    }\n \n }\n class Task implements Callable<Object> {\n    int h,w;\n    int[] a;\n    \n    public Task(int h, int w, int[] a) {\n        super();\n        this.h = h;\n        this.w = w;\n        this.a = a;\n    }\n \n    @Override\n    public Object call() throws Exception {\n        int n = (h + w) * 2;\n        int m = h + w;\n        boolean[][] edge = new boolean[n][n];\n        for(int i=0;i<m;i++) {\n            int u = a[i*2] - 1;\n            int v = a[i*2+1] - 1;\n            edge[u][v] = edge[v][u] = true;\n        }\n        ArrayList<Pair> al = new ArrayList<>();\n        int count = 0;\n        for(int i=0;i<n;i++) {\n            int u = i;\n            int v = (i + 1) % n;\n            int size = 0;\n            if (edge[u][v]) {\n                int u_ = u;\n                while(edge[u][v]) {\n                    count++;\n                    edge[u][v] = edge[v][u] = false;\n                    size++;\n                    u = (u + n - 1) % n;\n                    v = (v + 1) % n;\n                }\n                al.add(new Pair(u_,size));\n            }\n        }\n        if (count != m) {\n            return "IMPOSSIBLE";\n        }\n        char[][] map = new char[h][w];\n        for(int i=0;i<h;i++) {\n            Arrays.fill(map[i], '/');\n        }\n        for(Pair p: al) {\n \n            int oi,oj;\n            if (p.a < w) {\n                oi = 0;\n                oj = p.a + 1;\n            }else if(p.a < w + h) {\n                oi = 1 + (p.a - w);\n                oj = w;\n            }else if(p.a < w + h + w) {\n                oi = h;\n                oj = w - 1 - (p.a - w - h);\n            }else{\n                oi = h - 1 - (p.a - w - h - w);\n                oj = 0;\n            }\n            for(int i=oi-p.b;i<=oi+p.b;i++) {\n                for(int j=oj-p.b;j<=oj+p.b;j++) {\n                    if (i < 0 || i >= h || j < 0 || j >= w) {\n                        continue;\n                    }\n                    double i2 = i + 0.5;\n                    double j2 = j + 0.5;\n                    if (Math.abs(oi - i2) + Math.abs(oj - j2) <= p.b + 0.1) {\n                        if ((oi - i2) * (oj - j2) < 0) {\n                            map[i][j] = '\\';\n                        }\n                    }\n                }\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<h;i++) {\n            if (i > 0) {\n                sb.append('\n');\n            }\n            for(int j=0;j<w;j++) {\n                sb.append(map[i][j]);\n            }\n        }\n        return sb.toString();\n    }\n    \n    \n }\n class Pair {\n    int a,b;\n \n    public Pair(int a, int b) {\n        super();\n        this.a = a;\n        this.b = b;\n    }\n    \n    public String toString() {\n        return "(" + a + "," + b + ")";\n    }\n    \n }\n interface Solver<R> {\n    public Scanner getScanner();\n    public void addTask(Callable<R> task);\n    public void finish();\n    public static <T> Solver<T> getInstance(String filename) throws IOException {\n        if (filename == null) {\n            return new DebugSolver<>();\n        }else{\n            return new ConcurrentSolver<>(filename);\n        }\n    }\n }\n class DebugSolver<R> implements Solver<R> {\n    private ArrayList<Callable<R>> tasks = new ArrayList<>();\n    public DebugSolver() {\n        \n    }\n    public Scanner getScanner() {\n        return new Scanner(System.in);\n    }\n    public void addTask(Callable<R> task) {\n        tasks.add(task);\n    }\n    public void finish() {\n        for(int i=0;i<tasks.size();i++) {\n            try {\n                long stime = System.nanoTime();\n                System.out.println("Case #" + (i+1) + ":\n" + tasks.get(i).call());\n                System.out.println((System.nanoTime() - stime) / 1000000 + " ms");\n            } catch (Exception e) {\n                e.printStackTrace();\n                return;\n            }\n        }\n    }\n }\n class ConcurrentSolver<R> implements Solver<R>{\n    private ExecutorService es = Executors.newFixedThreadPool(4,(runnable)->new Thread(null, runnable, "", 16L * 1024L * 1024L)); \n    private ArrayList<FutureTask<R>> tasks = new ArrayList<>();\n    private Scanner sc;\n    private PrintWriter pw;\n    public ConcurrentSolver(String filename) throws IOException {\n        if (filename == null) {\n            sc = new Scanner(System.in);\n            pw = new PrintWriter(System.out);\n        }else{\n            sc = new Scanner(new File(filename));\n            Matcher matcher = Pattern.compile("(.+)\\.in").matcher(filename);\n            String filenameOut;\n            if (matcher.matches()) {\n                filenameOut = matcher.group(1) + ".out";\n            }else{\n                filenameOut = "out.txt";\n            }\n            pw = new PrintWriter(new File(filenameOut));\n        }\n    }\n    public Scanner getScanner() {\n        return sc;\n    }\n    public void addTask(Callable<R> task) {\n        FutureTask<R> futureTask = new FutureTask<>(new TaskWrapper(tasks.size() + 1, task));\n        tasks.add(futureTask);\n        es.submit(futureTask);\n    }\n    public void finish() {\n        for(int i=0;i<tasks.size();i++) {\n            try {\n                pw.print("Case #" + (i+1) + ":\n" + tasks.get(i).get() + "\n");\n            } catch (InterruptedException | ExecutionException e) {\n                e.printStackTrace();\n            }\n        }\n        pw.flush();\n        es.shutdown();\n    }\n    class TaskWrapper implements Callable<R> {\n        int id;\n        Callable<R> c;\n        public TaskWrapper(int caseId,Callable<R> c) {\n            this.id = caseId;\n            this.c = c;\n        }\n        public R call() throws Exception {\n            System.out.println("Start #" + id);\n            long stime = System.nanoTime();\n            R res = c.call();\n            System.out.println("End #" + id + " (" + (System.nanoTime() - stime) / 1000000 + "ms)");\n            return res;\n        }\n    }\n }\n
piroz	<>	47	<>	10224486_5677604812095488_piroz_main.java	<>	package b;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.PrintWriter;\n import java.util.ArrayList;\n import java.util.Scanner;\n import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.FutureTask;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n public class Main {\n \n    public static void main(String[] args) throws Exception {\n        Solver<Object> solver = Solver.getInstance("B-small-attempt0.in");\n        Scanner sc = solver.getScanner();\n        int casenum = sc.nextInt();\n        for(int caseid=0;caseid<casenum;caseid++) {\n            int n = sc.nextInt();\n            int k = sc.nextInt();\n            double[] p = new double[n];\n            for(int i=0;i<n;i++) {\n                p[i] = sc.nextDouble();\n            }\n            Task task = new Task(n,k,p);\n            solver.addTask(task);\n        }\n        solver.finish();\n    }\n \n }\n class Task implements Callable<Object> {\n    int n,k;\n    double[] p;\n    \n    public Task(int n, int k, double[] p) {\n        super();\n        this.n = n;\n        this.k = k;\n        this.p = p;\n    }\n \n    @Override\n    public Object call() throws Exception {\n        double max = 0;\n        for(int i=0;i<1<<n;i++) {\n            if (Integer.bitCount(i) != k) {\n                continue;\n            }\n            ArrayList<Double> al = new ArrayList<>();\n            for(int j=0;j<n;j++) {\n                if ((i >> j & 1) == 1) { \n                    al.add(p[j]);\n                }\n            }\n            double ans = 0;\n            for(int m=0;m<1<<k;m++) {\n                if (Integer.bitCount(m) != k / 2) {\n                    continue;\n                }\n                double pi = 1;\n                for(int j=0;j<k;j++) {\n                    if ((m >> j & 1) == 0) {\n                        pi *= al.get(j);\n                    }else{\n                        pi *= (1 - al.get(j));\n                    }\n                }\n                ans += pi;\n            }\n            max = Math.max(max, ans);\n        }\n        return String.format("%7f", max);\n    }\n    \n }\n \n interface Solver<R> {\n    public Scanner getScanner();\n    public void addTask(Callable<R> task);\n    public void finish();\n    public static <T> Solver<T> getInstance(String filename) throws IOException {\n        if (filename == null) {\n            return new DebugSolver<>();\n        }else{\n            return new ConcurrentSolver<>(filename);\n        }\n    }\n }\n class DebugSolver<R> implements Solver<R> {\n    private ArrayList<Callable<R>> tasks = new ArrayList<>();\n    public DebugSolver() {\n        \n    }\n    public Scanner getScanner() {\n        return new Scanner(System.in);\n    }\n    public void addTask(Callable<R> task) {\n        tasks.add(task);\n    }\n    public void finish() {\n        for(int i=0;i<tasks.size();i++) {\n            try {\n                long stime = System.nanoTime();\n                System.out.println("Case #" + (i+1) + ": " + tasks.get(i).call());\n                System.out.println((System.nanoTime() - stime) / 1000000 + " ms");\n            } catch (Exception e) {\n                e.printStackTrace();\n                return;\n            }\n        }\n    }\n }\n class ConcurrentSolver<R> implements Solver<R>{\n    private ExecutorService es = Executors.newFixedThreadPool(4,(runnable)->new Thread(null, runnable, "", 16L * 1024L * 1024L)); \n    private ArrayList<FutureTask<R>> tasks = new ArrayList<>();\n    private Scanner sc;\n    private PrintWriter pw;\n    public ConcurrentSolver(String filename) throws IOException {\n        if (filename == null) {\n            sc = new Scanner(System.in);\n            pw = new PrintWriter(System.out);\n        }else{\n            sc = new Scanner(new File(filename));\n            Matcher matcher = Pattern.compile("(.+)\\.in").matcher(filename);\n            String filenameOut;\n            if (matcher.matches()) {\n                filenameOut = matcher.group(1) + ".out";\n            }else{\n                filenameOut = "out.txt";\n            }\n            pw = new PrintWriter(new File(filenameOut));\n        }\n    }\n    public Scanner getScanner() {\n        return sc;\n    }\n    public void addTask(Callable<R> task) {\n        FutureTask<R> futureTask = new FutureTask<>(new TaskWrapper(tasks.size() + 1, task));\n        tasks.add(futureTask);\n        es.submit(futureTask);\n    }\n    public void finish() {\n        for(int i=0;i<tasks.size();i++) {\n            try {\n                pw.println("Case #" + (i+1) + ": " + tasks.get(i).get());\n            } catch (InterruptedException | ExecutionException e) {\n                e.printStackTrace();\n            }\n        }\n        pw.flush();\n        es.shutdown();\n    }\n    class TaskWrapper implements Callable<R> {\n        int id;\n        Callable<R> c;\n        public TaskWrapper(int caseId,Callable<R> c) {\n            this.id = caseId;\n            this.c = c;\n        }\n        public R call() throws Exception {\n            System.out.println("Start #" + id);\n            long stime = System.nanoTime();\n            R res = c.call();\n            System.out.println("End #" + id + " (" + (System.nanoTime() - stime) / 1000000 + "ms)");\n            return res;\n        }\n    }\n }\n
piroz	<>	47	<>	10224486_5718606851604480_piroz_main.java	<>	package a;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.PrintWriter;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Scanner;\n import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.FutureTask;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n public class Main {\n \n    public static void main(String[] args) throws Exception {\n        Solver<Object> solver = Solver.getInstance("A-small-attempt0.in");\n        Scanner sc = solver.getScanner();\n        int casenum = sc.nextInt();\n        for(int caseid=0;caseid<casenum;caseid++) {\n            int n = sc.nextInt();\n            int[] a = new int[3];\n            for(int i=0;i<3;i++) {\n                a[i] = sc.nextInt();\n            }\n            Task task = new Task(n,a);\n            solver.addTask(task);\n        }\n        solver.finish();\n    }\n \n }\n class Task implements Callable<Object> {\n    public static final String rps = "RPS";\n    \n    int n;\n    int[] a;\n    \n    public Task(int n, int[] a) {\n        super();\n        this.n = n;\n        this.a = a;\n    }\n \n    @Override\n    public Object call() throws Exception {\n        ArrayList<String> ans = new ArrayList<>();\n        for(int i=0;i<3;i++) {\n            String s = generate(n, rps.charAt(i));\n            int[] count = new int[3];\n            for(int j=0;j<s.length();j++) {\n                count[map(s.charAt(j))]++;\n            }\n            if (Arrays.equals(a, count)) {\n                ans.add(s);\n            }\n        }\n        if (ans.size() == 0) {\n            return "IMPOSSIBLE";\n        }\n        ans.sort(null);\n        return ans.get(0);\n    }\n    \n    static String generate(int n,char winner) {\n        if (n == 0) {\n            return String.valueOf(winner);\n        }\n        String s1 = generate(n - 1, winner);\n        String s2 = generate(n - 1, lose(winner));\n        if (s1.compareTo(s2) < 0) {\n            return s1 + s2;\n        }else{\n            return s2 + s1;\n        }\n    }\n    \n    static int map(char c) {\n        if (c == 'R') {\n            return 0;\n        }else if(c == 'P') {\n            return 1;\n        }else{\n            return 2;\n        }\n    }\n    \n    static char lose(char c) {\n        return rps.charAt((map(c)+1)%3);\n    }\n    \n    static boolean nextPermutation(int[] p) {\n        for(int a=p.length-2;a>=0;--a) {\n            if(p[a]<p[a+1]) {\n                for(int b=p.length-1;;--b) {\n                    if(p[b]>p[a]) {\n                        int t = p[a];\n                        p[a] = p[b];\n                        p[b] = t;\n                        for(++a, b=p.length-1;a<b;++a,--b) {\n                            t = p[a];\n                            p[a] = p[b];\n                            p[b] = t;\n                        }\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n }\n \n interface Solver<R> {\n    public Scanner getScanner();\n    public void addTask(Callable<R> task);\n    public void finish();\n    public static <T> Solver<T> getInstance(String filename) throws IOException {\n        if (filename == null) {\n            return new DebugSolver<>();\n        }else{\n            return new ConcurrentSolver<>(filename);\n        }\n    }\n }\n class DebugSolver<R> implements Solver<R> {\n    private ArrayList<Callable<R>> tasks = new ArrayList<>();\n    public DebugSolver() {\n        \n    }\n    public Scanner getScanner() {\n        return new Scanner(System.in);\n    }\n    public void addTask(Callable<R> task) {\n        tasks.add(task);\n    }\n    public void finish() {\n        for(int i=0;i<tasks.size();i++) {\n            try {\n                long stime = System.nanoTime();\n                System.out.println("Case #" + (i+1) + ": " + tasks.get(i).call());\n                System.out.println((System.nanoTime() - stime) / 1000000 + " ms");\n            } catch (Exception e) {\n                e.printStackTrace();\n                return;\n            }\n        }\n    }\n }\n class ConcurrentSolver<R> implements Solver<R>{\n    private ExecutorService es = Executors.newFixedThreadPool(4,(runnable)->new Thread(null, runnable, "", 16L * 1024L * 1024L)); \n    private ArrayList<FutureTask<R>> tasks = new ArrayList<>();\n    private Scanner sc;\n    private PrintWriter pw;\n    public ConcurrentSolver(String filename) throws IOException {\n        if (filename == null) {\n            sc = new Scanner(System.in);\n            pw = new PrintWriter(System.out);\n        }else{\n            sc = new Scanner(new File(filename));\n            Matcher matcher = Pattern.compile("(.+)\\.in").matcher(filename);\n            String filenameOut;\n            if (matcher.matches()) {\n                filenameOut = matcher.group(1) + ".out";\n            }else{\n                filenameOut = "out.txt";\n            }\n            pw = new PrintWriter(new File(filenameOut));\n        }\n    }\n    public Scanner getScanner() {\n        return sc;\n    }\n    public void addTask(Callable<R> task) {\n        FutureTask<R> futureTask = new FutureTask<>(new TaskWrapper(tasks.size() + 1, task));\n        tasks.add(futureTask);\n        es.submit(futureTask);\n    }\n    public void finish() {\n        for(int i=0;i<tasks.size();i++) {\n            try {\n                pw.println("Case #" + (i+1) + ": " + tasks.get(i).get());\n            } catch (InterruptedException | ExecutionException e) {\n                e.printStackTrace();\n            }\n        }\n        pw.flush();\n        es.shutdown();\n    }\n    class TaskWrapper implements Callable<R> {\n        int id;\n        Callable<R> c;\n        public TaskWrapper(int caseId,Callable<R> c) {\n            this.id = caseId;\n            this.c = c;\n        }\n        public R call() throws Exception {\n            System.out.println("Start #" + id);\n            long stime = System.nanoTime();\n            R res = c.call();\n            System.out.println("End #" + id + " (" + (System.nanoTime() - stime) / 1000000 + "ms)");\n            return res;\n        }\n    }\n }\n
trold	<>	60	<>	10224486_5677604812095488_trold_b.java	<>	\n import java.io.*;\n import java.util.*;\n \n public class B {\n    int getInt(BufferedReader in) throws IOException {\n        return Integer.parseInt(in.readLine());\n    }   \n    int[] getInts(BufferedReader in) throws IOException {\n        String[] words = in.readLine().split(" ");\n        int[] ret = new int[words.length];\n        for (int i = 0 ; i < words.length ; i++) ret[i] = Integer.parseInt(words[i]);\n        return ret;\n    }\n \n    double[] getDoubles(BufferedReader in) throws IOException {\n        String[] words = in.readLine().split(" ");\n        double[] ret = new double[words.length];\n        for (int i = 0 ; i < words.length ; i++) ret[i] = Double.parseDouble(words[i]);\n        return ret;\n    }\n \n    void inc(int[] idx, int p) {\n        idx[p]++;\n        if (p == idx.length - 1) return;\n        if (idx[p] == idx[p+1]) {\n            if (p == 0) idx[p] = 0;\n            else idx[p] = idx[p-1]+1;\n            inc(idx, p + 1);\n        }\n    }\n \n    String compute(int M, double[] P) {\n        int N = P.length;\n        int[] idx = new int[M];\n        for (int i = 0 ; i < M ; i++) idx[i] = i;\n        double max = 0;\n        do {\n            double[] V = new double[M+1];\n            V[0] = 1;\n            for (int i = 0 ; i < M ; i++) {\n                for (int j = i ; j >= 0 ; j--) {\n                    V[j+1] += V[j] * P[idx[i]];\n                    V[j] *= (1 - P[idx[i]]);\n                }\n            }\n            max = Math.max(max, V[M/2]);\n            inc(idx, 0);\n        } while (idx[M-1] < N);\n        return max+"";\n    }\n \n    void run(String[] args) {\n        try {\n            BufferedReader in = new BufferedReader(new FileReader(args[0]));\n            PrintStream out = new PrintStream(args[0] + ".out");\n            int T = getInt(in);\n            for (int t = 1 ; t <= T ; t++) {\n                int[] nums = getInts(in);\n                double[] probs = getDoubles(in);\n                out.printf("Case #%d: %s\n", t, compute(nums[1], probs));\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n \n    public static void main (String[] args) {\n        new B().run(args);\n    }\n }\n
trold	<>	60	<>	11254486_5686313294495744_trold_c.java	<>	\n import java.io.*;\n import java.util.*;\n \n class FlowGraph {\n    class FlowEdge {\n        int lo, f, hi, xor;\n        FlowEdge(int fr, int to) { xor = fr ^ to; }\n        int other(int i) { return i ^ xor; }\n        int res(int i, int j) { return i < j ? hi-f : f-lo; }\n    }\n    int N;\n    List<Set<FlowEdge>> edgelists;\n    Map<Integer,FlowEdge> edges = new HashMap<Integer,FlowEdge>();\n    FlowEdge get(int i, int j) {\n        int key = (Math.min(i, j) << 16) + Math.max(i, j);\n        FlowEdge e = edges.get(key);\n        if (e == null) {\n            e = new FlowEdge(i,j);\n            edges.put(key, e);\n            edgelists.get(i).add(e);\n            edgelists.get(j).add(e);\n        }\n        return e;\n    }\n    FlowGraph(int N) {\n        this.N = N; edgelists = new ArrayList<Set<FlowEdge>>();\n        for (int i = 0 ; i < N ; i++) edgelists.add(new HashSet<FlowEdge>());\n    }\n    int flow(int i, int j) { FlowEdge e = get(i,j); return i < j ? e.f : -e.f; }\n    void cap(int i, int j, int cap) { FlowEdge e = get(i,j); if (i < j) e.hi = cap; else e.lo = -cap; }\n    void add(int i, int j, int d) { FlowEdge e = get(i,j); if (i < j) e.f += d; else e.f -= d; }\n    void clear() { for (Set<FlowEdge> set : edgelists) for (FlowEdge e : set) e.f = 0; }\n    int edKarp(int s, int t) {\n        int total = 0;\n        while (true) {\n            FlowEdge[] b = new FlowEdge[N];\n            List<Integer> bfs = new ArrayList<Integer>();\n            bfs.add(s);\n outer:     for (int idx = 0 ; idx < bfs.size() ; idx++) {\n                int i = bfs.get(idx);\n                for (FlowEdge e : edgelists.get(i)) {\n                    int j = e.other(i);\n                    if (e.res(i,j) > 0 && b[j] == null) {\n                        b[j] = e;\n                        if (j == t) break outer;\n                        bfs.add(j);\n                    }\n                }\n            }\n            if (b[t] == null) return total;\n            int df = Integer.MAX_VALUE;\n            for (int to = t ; to != s ;) {\n                int from = b[to].other(to);\n                df = Math.min(df, b[to].res(from, to));\n                to = from;\n            }\n            total += df;\n            for (int to = t ; to != s ;) {\n                int from = b[to].other(to);\n                if (from < to) b[to].f += df; else b[to].f -= df;\n                to = from;\n            }\n        }\n    }\n }\n \n public class C {\n    int getInt(BufferedReader in) throws IOException {\n        return Integer.parseInt(in.readLine());\n    }   \n    int[] getInts(BufferedReader in) throws IOException {\n        String[] words = in.readLine().split(" ");\n        int[] ret = new int[words.length];\n        for (int i = 0 ; i < words.length ; i++) ret[i] = Integer.parseInt(words[i]);\n        return ret;\n    }\n \n    String compute(int[][] D, int A, int B) {\n        int N = A+B+2;\n        int s = N - 1;\n        int t = N - 2;\n        FlowGraph G = new FlowGraph(N);\n        for (int i = 0 ; i < A ; i++) G.cap(s, i, 1);\n        for (int i = 0 ; i < B ; i++) G.cap(A+i, t, 1);\n        for (int[] e : D) G.cap(e[0], e[1]+A, 1);\n        return D.length-A-B+G.edKarp(s,t) +"";\n    }\n \n    void run(String[] args) {\n        try {\n            BufferedReader in = new BufferedReader(new FileReader(args[0]));\n            PrintStream out = new PrintStream(args[0] + ".out");\n            int T = getInt(in);\n            for (int t = 1 ; t <= T ; t++) {\n                Map<String,Integer> A = new HashMap<>();\n                Map<String,Integer> B = new HashMap<>();\n                int N = getInt(in);\n                int[][] D = new int[N][2];\n                for (int i = 0 ; i < N ; i++) {\n                    String[] w = in.readLine().split(" ");\n                    if (!A.containsKey(w[0])) A.put(w[0], A.size());\n                    if (!B.containsKey(w[1])) B.put(w[1], B.size());\n                    D[i][0] = A.get(w[0]);\n                    D[i][1] = B.get(w[1]);\n                }\n                out.printf("Case #%d: %s\n", t, compute(D, A.size(), B.size()));\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n \n    public static void main (String[] args) {\n        new C().run(args);\n    }\n }\n
trold	<>	60	<>	11254486_5648941810974720_trold_a.java	<>	\n import java.io.*;\n import java.util.*;\n \n public class A {\n    int getInt(BufferedReader in) throws IOException {\n        return Integer.parseInt(in.readLine());\n    }   \n    int[] getInts(BufferedReader in) throws IOException {\n        String[] words = in.readLine().split(" ");\n        int[] ret = new int[words.length];\n        for (int i = 0 ; i < words.length ; i++) ret[i] = Integer.parseInt(words[i]);\n        return ret;\n    }\n \n    String[] NUM = {"ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE"};\n \n    String compute(int[] sig) {\n        boolean found = false;\n        for (int i : sig) {\n            if (i > 0) found = true;\n            if (i < 0) return null;\n        }\n        if (!found) return "";\n        for (int d = 0 ; d <= 9 ; d++) {\n            int[] ds = sig.clone();\n            for (char c : NUM[d].toCharArray()) ds[c-'A']--;\n            String s = compute(ds);\n            if (s != null) return d + s;\n        }\n        return null;\n    }\n \n    void run(String[] args) {\n        try {\n            BufferedReader in = new BufferedReader(new FileReader(args[0]));\n            PrintStream out = new PrintStream(args[0] + ".out");\n            int T = getInt(in);\n            for (int t = 1 ; t <= T ; t++) {\n                String s = in.readLine();\n                int[] sig = new int[30];\n                for (char c : s.toCharArray()) {\n                    sig[c-'A']++;\n                }\n                out.printf("Case #%d: %s\n", t, compute(sig));\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n \n    public static void main (String[] args) {\n        new A().run(args);\n    }\n }\n
dalex	<>	61	<>	10224486_5718606851604480_dalex_main.java	<>	import java.io.OutputStream;\n import java.io.FilenameFilter;\n import java.util.Locale;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.FileInputStream;\n import java.io.File;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.PrintWriter;\n import java.util.Arrays;\n import java.io.BufferedWriter;\n import java.util.InputMismatchException;\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.List;\n import java.io.Writer;\n import java.io.OutputStreamWriter;\n import java.io.InputStream;\n \n \n public class Main {\n     public static void main(String[] args) {\n         Locale.setDefault(Locale.US);\n         InputStream inputStream;\n         try {\n             final String regex = "A-(small|large).*[.]in";\n             File directory = new File(".");\n             File[] candidates = directory.listFiles(new FilenameFilter() {\n                 public boolean accept(File dir, String name) {\n                     return name.matches(regex);\n                 }\n             });\n             File toRun = null;\n             for (File candidate : candidates) {\n                 if (toRun == null || candidate.lastModified() > toRun.lastModified())\n                     toRun = candidate;\n             }\n             inputStream = new FileInputStream(toRun);\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n         OutputStream outputStream;\n         try {\n             outputStream = new FileOutputStream("a.out");\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n         InputReader in = new InputReader(inputStream);\n         OutputWriter out = new OutputWriter(outputStream);\n         TaskA solver = new TaskA();\n         int testCount = Integer.parseInt(in.next());\n         for (int i = 1; i <= testCount; i++)\n             solver.solve(i, in, out);\n         out.close();\n     }\n \n     static class TaskA {\n         static final char[] v = "RPS".toCharArray();\n \n         public void solve(int testNumber, InputReader in, OutputWriter out) {\n             out.printFormat("Case #%d: ", testNumber);\n             int n = in.readInt();\n             int R = in.readInt();\n             int P = in.readInt();\n             int S = in.readInt();\n             char[] a = new char[1 << n];\n             List<Integer> have = new ArrayList<>();\n             List<String> winStrings = new ArrayList<>();\n             int[] cnt = new int[256];\n             for (char winnerChar : v) {\n                 have.clear();\n                 have.add(0);\n                 Arrays.fill(a, (char) 0);\n                 a[0] = winnerChar;\n                 cnt['R'] = R;\n                 cnt['S'] = S;\n                 cnt['P'] = P;\n                 cnt[winnerChar]--;\n                 for (int d = (1 << n) / 2; d >= 1; d /= 2) {\n                     int sz = have.size();\n                     for (int i = 0; i < sz; i++) {\n                         int pos = have.get(i);\n                         int loserPos = pos ^ d;\n                         char loserChar = loserFor(a[pos]);\n                         a[loserPos] = loserChar;\n                         have.add(loserPos);\n                         cnt[loserChar]--;\n                     }\n                 }\n                 if (cnt['R'] == 0 && cnt['S'] == 0 && cnt['P'] == 0) {\n                     winStrings.add(new String(a));\n                 }\n             }\n             if (winStrings.isEmpty()) {\n                 out.printLine("IMPOSSIBLE");\n             } else {\n                 String min = null;\n                 for (String s : winStrings) {\n                     String t = process(s);\n                     if (min == null || t.compareTo(min) < 0) {\n                         min = t;\n                     }\n                 }\n                 out.printLine(min);\n             }\n         }\n \n         private String process(String s) {\n             int n = s.length();\n             if ((n & (n - 1)) != 0) {\n                 throw new IllegalArgumentException();\n             }\n             StringBuilder sb = new StringBuilder();\n             for (int d = 1; d < n; d *= 2) {\n                 sb.setLength(0);\n                 for (int i = 0; i < n; i += 2 * d) {\n                     String a = s.substring(i, i + d);\n                     String b = s.substring(i + d, i + 2 * d);\n                     if (a.compareTo(b) > 0) {\n                         String t = a;\n                         a = b;\n                         b = t;\n                     }\n                     sb.append(a);\n                     sb.append(b);\n                 }\n                 s = sb.toString();\n             }\n             return s;\n         }\n \n         private char loserFor(char c) {\n             if (c == 'R') return 'S';\n             if (c == 'S') return 'P';\n             if (c == 'P') return 'R';\n             throw new IllegalArgumentException();\n         }\n \n     }\n \n     static class InputReader {\n         private InputStream stream;\n         private byte[] buf = new byte[1024];\n         private int curChar;\n         private int numChars;\n         private SpaceCharFilter filter;\n \n         public InputReader(InputStream stream) {\n             this.stream = stream;\n         }\n \n         public int read() {\n             if (numChars == -1)\n                 throw new InputMismatchException();\n             if (curChar >= numChars) {\n                 curChar = 0;\n                 try {\n                     numChars = stream.read(buf);\n                 } catch (IOException e) {\n                     throw new InputMismatchException();\n                 }\n                 if (numChars <= 0)\n                     return -1;\n             }\n             return buf[curChar++];\n         }\n \n         public int readInt() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             int sgn = 1;\n             if (c == '-') {\n                 sgn = -1;\n                 c = read();\n             }\n             int res = 0;\n             do {\n                 if (c < '0' || c > '9')\n                     throw new InputMismatchException();\n                 res *= 10;\n                 res += c - '0';\n                 c = read();\n             } while (!isSpaceChar(c));\n             return res * sgn;\n         }\n \n         public String readString() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             StringBuilder res = new StringBuilder();\n             do {\n                 if (Character.isValidCodePoint(c))\n                     res.appendCodePoint(c);\n                 c = read();\n             } while (!isSpaceChar(c));\n             return res.toString();\n         }\n \n         public boolean isSpaceChar(int c) {\n             if (filter != null)\n                 return filter.isSpaceChar(c);\n             return isWhitespace(c);\n         }\n \n         public static boolean isWhitespace(int c) {\n             return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n         }\n \n         public String next() {\n             return readString();\n         }\n \n         public interface SpaceCharFilter {\n             public boolean isSpaceChar(int ch);\n \n         }\n \n     }\n \n     static class OutputWriter {\n         private final PrintWriter writer;\n \n         public OutputWriter(OutputStream outputStream) {\n             writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n         }\n \n         public OutputWriter(Writer writer) {\n             this.writer = new PrintWriter(writer);\n         }\n \n         public void print(Object... objects) {\n             for (int i = 0; i < objects.length; i++) {\n                 if (i != 0)\n                     writer.print(' ');\n                 writer.print(objects[i]);\n             }\n         }\n \n         public void printLine(Object... objects) {\n             print(objects);\n             writer.println();\n         }\n \n         public void printFormat(String format, Object... objects) {\n             writer.printf(format, objects);\n         }\n \n         public void close() {\n             writer.close();\n         }\n \n     }\n }\n \n
dalex	<>	61	<>	10224486_5723605790883840_dalex_main.java	<>	import java.io.OutputStream;\n import java.io.FilenameFilter;\n import java.util.Locale;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.FileInputStream;\n import java.io.File;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.PrintWriter;\n import java.util.Arrays;\n import java.io.BufferedWriter;\n import java.util.InputMismatchException;\n import java.io.IOException;\n import java.io.Writer;\n import java.io.OutputStreamWriter;\n import java.io.InputStream;\n \n \n public class Main {\n     public static void main(String[] args) {\n         Locale.setDefault(Locale.US);\n         InputStream inputStream;\n         try {\n             final String regex = "C-(small|large).*[.]in";\n             File directory = new File(".");\n             File[] candidates = directory.listFiles(new FilenameFilter() {\n                 public boolean accept(File dir, String name) {\n                     return name.matches(regex);\n                 }\n             });\n             File toRun = null;\n             for (File candidate : candidates) {\n                 if (toRun == null || candidate.lastModified() > toRun.lastModified())\n                     toRun = candidate;\n             }\n             inputStream = new FileInputStream(toRun);\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n         OutputStream outputStream;\n         try {\n             outputStream = new FileOutputStream("c.out");\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n         InputReader in = new InputReader(inputStream);\n         OutputWriter out = new OutputWriter(outputStream);\n         TaskC solver = new TaskC();\n         int testCount = Integer.parseInt(in.next());\n         for (int i = 1; i <= testCount; i++)\n             solver.solve(i, in, out);\n         out.close();\n     }\n \n     static class TaskC {\n         final String dir = "URDL";\n \n         public void solve(int testNumber, InputReader in, OutputWriter out) {\n             out.printFormat("Case #%d:\n", testNumber);\n             int n = in.readInt();\n             int m = in.readInt();\n             int t = 2 * (n + m);\n             int[] A = new int[t / 2];\n             int[] B = new int[t / 2];\n             for (int i = 0; i < t / 2; i++) {\n                 A[i] = in.readInt() - 1;\n                 B[i] = in.readInt() - 1;\n             }\n             int[] posX = new int[t];\n             int[] posY = new int[t];\n             int z = 0;\n             for (int c = 1; c <= m; c++) {\n                 posX[z] = 0;\n                 posY[z] = c;\n                 z++;\n             }\n             for (int r = 1; r <= n; r++) {\n                 posX[z] = r;\n                 posY[z] = m + 1;\n                 z++;\n             }\n             for (int c = m; c >= 1; c--) {\n                 posX[z] = n + 1;\n                 posY[z] = c;\n                 z++;\n             }\n             for (int r = n; r >= 1; r--) {\n                 posX[z] = r;\n                 posY[z] = 0;\n                 z++;\n             }\n             if (z != t) {\n                 throw new IllegalStateException();\n             }\n             char[][] a = new char[n + 2][m + 2];\n             boolean[][][] vis = new boolean[4][n + 2][m + 2];\n             for (int mask = 0; mask < (1 << (n * m)); mask++) {\n                 for (int bit = 0; bit < n * m; bit++) {\n                     int r = bit / m;\n                     int c = bit % m;\n                     r++;\n                     c++;\n                     if ((mask & (1 << bit)) != 0) {\n                         a[r][c] = '/';\n                     } else {\n                         a[r][c] = '\\';\n                     }\n                 }\n                 if (good(a, vis, n, m, posX, posY, A, B)) {\n                     for (int i = 1; i <= n; i++) {\n                         for (int j = 1; j <= m; j++) {\n                             out.print(a[i][j]);\n                         }\n                         out.printLine();\n                     }\n                     return;\n                 }\n             }\n             out.printLine("IMPOSSIBLE");\n         }\n \n         private boolean good(char[][] a, boolean[][][] vis, int n, int m, int[] posX, int[] posY, int[] A, int[] B) {\n             ArrayUtils.fill(vis, false);\n             for (int i = 0; i < A.length; i++) {\n                 int start = A[i];\n                 int finish = B[i];\n                 int sx = posX[start];\n                 int sy = posY[start];\n                 int fx = posX[finish];\n                 int fy = posY[finish];\n                 int partStart = getPart(sx, sy, n, m);\n                 int partFinish = getPart(fx, fy, n, m);\n                 switch (dir.charAt(partStart)) {\n                     case 'U':\n                         sx--;\n                         break;\n                     case 'D':\n                         sx++;\n                         break;\n                     case 'L':\n                         sy--;\n                         break;\n                     case 'R':\n                         sy++;\n                         break;\n                     default:\n                         throw new IllegalStateException();\n                 }\n                 switch (dir.charAt(partFinish)) {\n                     case 'U':\n                         fx--;\n                         break;\n                     case 'D':\n                         fx++;\n                         break;\n                     case 'L':\n                         fy--;\n                         break;\n                     case 'R':\n                         fy++;\n                         break;\n                     default:\n                         throw new IllegalStateException();\n                 }\n                 partStart = (partStart + 2) % 4;\n                 partFinish = (partFinish + 2) % 4;\n                 if (!dfs(sx, sy, partStart,\n                         fx, fy, partFinish,\n                         a, vis, n, m)) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n \n         private int getPart(int x, int y, int n, int m) {\n             if (x == 0) {\n                 return dir.indexOf('D');\n             }\n             if (x == n + 1) {\n                 return dir.indexOf('U');\n             }\n             if (y == 0) {\n                 return dir.indexOf('R');\n             }\n             if (y == m + 1) {\n                 return dir.indexOf('L');\n             }\n             throw new IllegalArgumentException();\n         }\n \n         private boolean dfs(int x, int y, int p, int fx, int fy, int fp, char[][] a, boolean[][][] vis, int n, int m) {\n             if (x <= 0 || x >= n + 1) return false;\n             if (y <= 0 || y >= m + 1) return false;\n             if (x == fx && y == fy && p == fp) {\n                 return true;\n             }\n             if (vis[p][x][y]) {\n                 return false;\n             }\n             vis[p][x][y] = true;\n             boolean res = false;\n             if (dir.charAt(p) == 'U') {\n                 res |= dfs(x - 1, y, (p + 2) % 4, fx, fy, fp, a, vis, n, m);\n                 if (a[x][y] == '/') {\n                     res |= dfs(x, y, (p + 3) % 4, fx, fy, fp, a, vis, n, m);\n                 }\n                 if (a[x][y] == '\\') {\n                     res |= dfs(x, y, (p + 1) % 4, fx, fy, fp, a, vis, n, m);\n                 }\n             }\n             if (dir.charAt(p) == 'D') {\n                 res |= dfs(x + 1, y, (p + 2) % 4, fx, fy, fp, a, vis, n, m);\n                 if (a[x][y] == '/') {\n                     res |= dfs(x, y, (p + 3) % 4, fx, fy, fp, a, vis, n, m);\n                 }\n                 if (a[x][y] == '\\') {\n                     res |= dfs(x, y, (p + 1) % 4, fx, fy, fp, a, vis, n, m);\n                 }\n             }\n             if (dir.charAt(p) == 'L') {\n                 res |= dfs(x, y - 1, (p + 2) % 4, fx, fy, fp, a, vis, n, m);\n                 if (a[x][y] == '/') {\n                     res |= dfs(x, y, (p + 1) % 4, fx, fy, fp, a, vis, n, m);\n                 }\n                 if (a[x][y] == '\\') {\n                     res |= dfs(x, y, (p + 3) % 4, fx, fy, fp, a, vis, n, m);\n                 }\n             }\n             if (dir.charAt(p) == 'R') {\n                 res |= dfs(x, y + 1, (p + 2) % 4, fx, fy, fp, a, vis, n, m);\n                 if (a[x][y] == '/') {\n                     res |= dfs(x, y, (p + 1) % 4, fx, fy, fp, a, vis, n, m);\n                 }\n                 if (a[x][y] == '\\') {\n                     res |= dfs(x, y, (p + 3) % 4, fx, fy, fp, a, vis, n, m);\n                 }\n             }\n             return res;\n         }\n \n     }\n \n     static class ArrayUtils {\n         public static void fill(boolean[][] array, boolean value) {\n             for (boolean[] row : array)\n                 Arrays.fill(row, value);\n         }\n \n         public static void fill(boolean[][][] array, boolean value) {\n             for (boolean[][] row : array)\n                 fill(row, value);\n         }\n \n     }\n \n     static class OutputWriter {\n         private final PrintWriter writer;\n \n         public OutputWriter(OutputStream outputStream) {\n             writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n         }\n \n         public OutputWriter(Writer writer) {\n             this.writer = new PrintWriter(writer);\n         }\n \n         public void print(Object... objects) {\n             for (int i = 0; i < objects.length; i++) {\n                 if (i != 0)\n                     writer.print(' ');\n                 writer.print(objects[i]);\n             }\n         }\n \n         public void printLine() {\n             writer.println();\n         }\n \n         public void printLine(Object... objects) {\n             print(objects);\n             writer.println();\n         }\n \n         public void print(char i) {\n             writer.print(i);\n         }\n \n         public void printFormat(String format, Object... objects) {\n             writer.printf(format, objects);\n         }\n \n         public void close() {\n             writer.close();\n         }\n \n     }\n \n     static class InputReader {\n         private InputStream stream;\n         private byte[] buf = new byte[1024];\n         private int curChar;\n         private int numChars;\n         private SpaceCharFilter filter;\n \n         public InputReader(InputStream stream) {\n             this.stream = stream;\n         }\n \n         public int read() {\n             if (numChars == -1)\n                 throw new InputMismatchException();\n             if (curChar >= numChars) {\n                 curChar = 0;\n                 try {\n                     numChars = stream.read(buf);\n                 } catch (IOException e) {\n                     throw new InputMismatchException();\n                 }\n                 if (numChars <= 0)\n                     return -1;\n             }\n             return buf[curChar++];\n         }\n \n         public int readInt() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             int sgn = 1;\n             if (c == '-') {\n                 sgn = -1;\n                 c = read();\n             }\n             int res = 0;\n             do {\n                 if (c < '0' || c > '9')\n                     throw new InputMismatchException();\n                 res *= 10;\n                 res += c - '0';\n                 c = read();\n             } while (!isSpaceChar(c));\n             return res * sgn;\n         }\n \n         public String readString() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             StringBuilder res = new StringBuilder();\n             do {\n                 if (Character.isValidCodePoint(c))\n                     res.appendCodePoint(c);\n                 c = read();\n             } while (!isSpaceChar(c));\n             return res.toString();\n         }\n \n         public boolean isSpaceChar(int c) {\n             if (filter != null)\n                 return filter.isSpaceChar(c);\n             return isWhitespace(c);\n         }\n \n         public static boolean isWhitespace(int c) {\n             return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n         }\n \n         public String next() {\n             return readString();\n         }\n \n         public interface SpaceCharFilter {\n             public boolean isSpaceChar(int ch);\n \n         }\n \n     }\n }\n \n
dalex	<>	61	<>	10224486_5677604812095488_dalex_main.java	<>	import java.io.OutputStream;\n import java.io.FilenameFilter;\n import java.util.Locale;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.FileInputStream;\n import java.io.File;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.PrintWriter;\n import java.io.BufferedWriter;\n import java.util.InputMismatchException;\n import java.io.IOException;\n import java.io.Writer;\n import java.io.OutputStreamWriter;\n import java.io.InputStream;\n \n \n public class Main {\n     public static void main(String[] args) {\n         Locale.setDefault(Locale.US);\n         InputStream inputStream;\n         try {\n             final String regex = "B-(small|large).*[.]in";\n             File directory = new File(".");\n             File[] candidates = directory.listFiles(new FilenameFilter() {\n                 public boolean accept(File dir, String name) {\n                     return name.matches(regex);\n                 }\n             });\n             File toRun = null;\n             for (File candidate : candidates) {\n                 if (toRun == null || candidate.lastModified() > toRun.lastModified())\n                     toRun = candidate;\n             }\n             inputStream = new FileInputStream(toRun);\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n         OutputStream outputStream;\n         try {\n             outputStream = new FileOutputStream("b.out");\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n         InputReader in = new InputReader(inputStream);\n         OutputWriter out = new OutputWriter(outputStream);\n         TaskB solver = new TaskB();\n         int testCount = Integer.parseInt(in.next());\n         for (int i = 1; i <= testCount; i++)\n             solver.solve(i, in, out);\n         out.close();\n     }\n \n     static class TaskB {\n         public void solve(int testNumber, InputReader in, OutputWriter out) {\n             out.printFormat("Case #%d: ", testNumber);\n             int n = in.readInt();\n             int k = in.readInt();\n             double[] p = new double[n];\n             for (int i = 0; i < n; i++) {\n                 p[i] = in.readDouble();\n             }\n             if (k % 2 != 0) {\n                 throw new IllegalArgumentException();\n             }\n             double stupid = stupid(n, k, p);\n             out.printFormat("%.15f\n", stupid);\n \n \n         }\n \n         private double stupid(int n, int k, double[] p) {\n             double max = -1.0;\n             int[] arr = new int[n];\n             int length;\n             double[][] dp = new double[k + 1][k + 1];\n             for (int mask = 0; mask < (1 << n); mask++) {\n                 if (Integer.bitCount(mask) == k) {\n                     length = 0;\n                     for (int i = 0; i < n; i++)\n                         if ((mask & (1 << i)) != 0) {\n                             arr[length++] = i;\n                         }\n                     dp[0][0] = 1.0;\n                     for (int i = 0; i < length; i++) {\n                         dp[i + 1][0] = dp[i][0] * p[arr[i]];\n                         for (int j = 0; j <= i; j++) {\n                             dp[i + 1][j + 1] = dp[i][j + 1] * p[arr[i]] + dp[i][j] * (1.0 - p[arr[i]]);\n                         }\n                     }\n                     max = Math.max(max, dp[length][k / 2]);\n                 }\n             }\n             return max;\n         }\n \n     }\n \n     static class InputReader {\n         private InputStream stream;\n         private byte[] buf = new byte[1024];\n         private int curChar;\n         private int numChars;\n         private SpaceCharFilter filter;\n \n         public InputReader(InputStream stream) {\n             this.stream = stream;\n         }\n \n         public int read() {\n             if (numChars == -1)\n                 throw new InputMismatchException();\n             if (curChar >= numChars) {\n                 curChar = 0;\n                 try {\n                     numChars = stream.read(buf);\n                 } catch (IOException e) {\n                     throw new InputMismatchException();\n                 }\n                 if (numChars <= 0)\n                     return -1;\n             }\n             return buf[curChar++];\n         }\n \n         public int readInt() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             int sgn = 1;\n             if (c == '-') {\n                 sgn = -1;\n                 c = read();\n             }\n             int res = 0;\n             do {\n                 if (c < '0' || c > '9')\n                     throw new InputMismatchException();\n                 res *= 10;\n                 res += c - '0';\n                 c = read();\n             } while (!isSpaceChar(c));\n             return res * sgn;\n         }\n \n         public String readString() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             StringBuilder res = new StringBuilder();\n             do {\n                 if (Character.isValidCodePoint(c))\n                     res.appendCodePoint(c);\n                 c = read();\n             } while (!isSpaceChar(c));\n             return res.toString();\n         }\n \n         public boolean isSpaceChar(int c) {\n             if (filter != null)\n                 return filter.isSpaceChar(c);\n             return isWhitespace(c);\n         }\n \n         public static boolean isWhitespace(int c) {\n             return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n         }\n \n         public double readDouble() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             int sgn = 1;\n             if (c == '-') {\n                 sgn = -1;\n                 c = read();\n             }\n             double res = 0;\n             while (!isSpaceChar(c) && c != '.') {\n                 if (c == 'e' || c == 'E')\n                     return res * Math.pow(10, readInt());\n                 if (c < '0' || c > '9')\n                     throw new InputMismatchException();\n                 res *= 10;\n                 res += c - '0';\n                 c = read();\n             }\n             if (c == '.') {\n                 c = read();\n                 double m = 1;\n                 while (!isSpaceChar(c)) {\n                     if (c == 'e' || c == 'E')\n                         return res * Math.pow(10, readInt());\n                     if (c < '0' || c > '9')\n                         throw new InputMismatchException();\n                     m /= 10;\n                     res += (c - '0') * m;\n                     c = read();\n                 }\n             }\n             return res * sgn;\n         }\n \n         public String next() {\n             return readString();\n         }\n \n         public interface SpaceCharFilter {\n             public boolean isSpaceChar(int ch);\n \n         }\n \n     }\n \n     static class OutputWriter {\n         private final PrintWriter writer;\n \n         public OutputWriter(OutputStream outputStream) {\n             writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n         }\n \n         public OutputWriter(Writer writer) {\n             this.writer = new PrintWriter(writer);\n         }\n \n         public void printFormat(String format, Object... objects) {\n             writer.printf(format, objects);\n         }\n \n         public void close() {\n             writer.close();\n         }\n \n     }\n }\n \n
mikigergely	<>	62	<>	10224486_5718606851604480_mikigergely_p1.java	<>	package round2.p1;\n \n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.File;\n import java.io.FileReader;\n import java.io.FileWriter;\n \n public class P1\n {\n    private static String goodLineUp;\n    \n    private static void calculate( int N, int R, int P, int S, BufferedWriter bw, int n ) throws Exception\n    {\n        goodLineUp = null;\n        \n        checkLineUps( R, P, S, "" );\n        \n        bw.append( "Case #"+n+": " + ( goodLineUp == null ? "IMPOSSIBLE" : goodLineUp ) + "\n" );\n        bw.flush();\n    }\n    \n    private static void checkLineUps( int R, int P, int S, String lineUp )\n    {\n        if ( goodLineUp != null )\n            return;\n        \n        if ( R == 0 && P == 0 && S == 0 )\n        {\n            if ( check( lineUp ) )\n                goodLineUp = lineUp;\n            return;\n        }\n            \n        if ( P != 0 )\n            checkLineUps( R, P-1, S, lineUp + "P" );\n        if ( R != 0 )\n            checkLineUps( R-1, P, S, lineUp + "R" );\n        if ( S != 0 )\n            checkLineUps( R, P, S-1, lineUp + "S" );\n    }\n    \n    private static boolean check( String lineUp )\n    {\n        if ( lineUp.length() == 1 )\n            return true;\n        \n        String nextLineUp = "";\n        for ( int i = 0; i < lineUp.length() / 2; i++ )\n        {\n            char p1 = lineUp.charAt( i*2 );\n            char p2 = lineUp.charAt( i*2 + 1 );\n            if ( p1 == p2 )\n                return false;\n            if ( p1 == 'R' && p2 == 'S' )\n                nextLineUp += 'R';\n            if ( p1 == 'R' && p2 == 'P' )\n                nextLineUp += 'P';\n            if ( p1 == 'P' && p2 == 'S' )\n                nextLineUp += 'S';\n            if ( p1 == 'P' && p2 == 'R' )\n                nextLineUp += 'P';\n            if ( p1 == 'S' && p2 == 'R' )\n                nextLineUp += 'R';\n            if ( p1 == 'S' && p2 == 'P' )\n                nextLineUp += 'S';\n        }\n        \n        return check( nextLineUp );\n    }\n    \n    public static void main( String[] args ) throws Exception\n    {\n        File inputFile = new File( "src/round2/p1/input.txt" );\n        FileReader fr = new FileReader( inputFile );\n        BufferedReader br = new BufferedReader( fr );\n        \n        int numOfTestCases = Integer.parseInt( br.readLine() );\n        \n        File outputFile = new File( "src/round2/p1/output.txt" );\n        outputFile.delete();\n        outputFile.createNewFile();\n        FileWriter fw = new FileWriter( outputFile );\n        BufferedWriter bw = new BufferedWriter( fw );\n        \n        for ( int i = 0; i < numOfTestCases; i++ )\n        {\n            String[] data = br.readLine().split( " " );\n            \n            int N = Integer.parseInt( data[0] );\n            int R = Integer.parseInt( data[1] );\n            int P = Integer.parseInt( data[2] );\n            int S = Integer.parseInt( data[3] );\n            \n            calculate( N, R, P, S, bw, i+1 );\n        }\n        \n        bw.flush();\n        fw.flush();\n        \n        br.close();\n        bw.close();\n        fw.close();\n    }\n }\n
mikigergely	<>	62	<>	10224486_5718447400943616_mikigergely_p4.java	<>	package round2.p4;\n \n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.File;\n import java.io.FileReader;\n import java.io.FileWriter;\n import java.util.Arrays;\n import java.util.HashSet;\n import java.util.LinkedList;\n import java.util.Set;\n \n import org.apache.commons.lang3.builder.EqualsBuilder;\n import org.apache.commons.lang3.builder.HashCodeBuilder;\n \n public class P4\n {\n    private static class Input\n    {\n        boolean[][] abilities;\n        int money;\n        \n        @Override\n        public int hashCode()\n        {\n            return new HashCodeBuilder()\n                    .append( abilities )\n                    .append( money )\n                    .hashCode();\n        }\n        \n        @Override\n        public boolean equals( Object obj ) {\n            Input other = (Input)obj;\n            return new EqualsBuilder()\n                    .append( abilities, other.abilities )\n                    .append( money, other.money )\n                    .isEquals();\n        }\n    }\n    \n    private static Set<Input> checked;\n    \n    private static void calculate( int N, boolean[][] abilities, BufferedWriter bw, int n ) throws Exception\n    {\n        System.out.println( n );\n        \n        checked = new HashSet<Input>();\n        \n        Input init = new Input();\n        init.abilities = abilities;\n        init.money = 0;\n        LinkedList<Input> queue = new LinkedList<Input>( Arrays.asList( init ) );\n        \n        int minMoney = check( N, queue );\n        \n        bw.append( "Case #"+n+": " + minMoney + "\n" );\n        bw.flush();\n    }\n    \n    private static int check( int N, LinkedList<Input> queue )\n    {\n        while ( true )\n        {\n            Input input = queue.pop();\n            if ( !checked.add( input ) )\n                continue;\n            \n            if ( works( N, input.abilities, new HashSet<Integer>(), new HashSet<Integer>() ) )\n                return input.money;\n            \n            for ( int i = 0; i < N; i++ )\n                for ( int j = 0; j < N; j++ )\n                    if ( !input.abilities[i][j] )\n                    {\n                        boolean[][] abilitiesCopy = new boolean[N][N];\n                        for ( int d1 = 0; d1 < N; d1++ )\n                            for ( int d2 = 0; d2 < N; d2++ )\n                                abilitiesCopy[d1][d2] = input.abilities[d1][d2];\n                        abilitiesCopy[i][j] = true;\n                        \n                        Input newInput = new Input();\n                        newInput.abilities = abilitiesCopy;\n                        newInput.money = input.money + 1;\n                        queue.add( newInput );\n                    }\n        }\n    }\n    \n    private static boolean works( int N, boolean[][] abilities, Set<Integer> in, Set<Integer> machine )\n    {\n        for ( int i = 0; i < N; i++ )\n        {\n            if ( in.contains( i ) )\n                continue;\n            \n            Set<Integer> inCopy = new HashSet<>( in );\n            inCopy.add( i );\n            \n            boolean canFindWork = false;\n            for ( int j = 0; j < N; j++ )\n            {\n                if ( !abilities[i][j] || machine.contains( j ) )\n                    continue;\n                canFindWork = true;\n                Set<Integer> machineCopy = new HashSet<>( machine );\n                machineCopy.add( j );\n                if ( !works( N, abilities, inCopy, machineCopy ) )\n                    return false;\n            }\n            if ( !canFindWork )\n                return false;\n        }\n        \n        return true;\n    }\n    \n    public static void main( String[] args ) throws Exception\n    {\n        File inputFile = new File( "src/round2/p4/input.txt" );\n        FileReader fr = new FileReader( inputFile );\n        BufferedReader br = new BufferedReader( fr );\n        \n        int numOfTestCases = Integer.parseInt( br.readLine() );\n        \n        File outputFile = new File( "src/round2/p4/output.txt" );\n        outputFile.delete();\n        outputFile.createNewFile();\n        FileWriter fw = new FileWriter( outputFile );\n        BufferedWriter bw = new BufferedWriter( fw );\n        \n        for ( int i = 0; i < numOfTestCases; i++ )\n        {\n            String data = br.readLine();\n            \n            int N = Integer.parseInt( data );\n            boolean[][] abilities = new boolean[N][N];\n            \n            for ( int j = 0; j < N; j++ )\n            {\n                String ability = br.readLine();\n                for ( int k = 0; k < N; k++ )\n                    abilities[j][k] = ability.charAt( k ) == '1';\n            }\n            \n            calculate( N, abilities, bw, i+1 );\n        }\n        \n        bw.flush();\n        fw.flush();\n        \n        br.close();\n        bw.close();\n        fw.close();\n    }\n }\n
mikigergely	<>	62	<>	10224486_5677604812095488_mikigergely_p2.java	<>	package round2.p2;\n \n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.File;\n import java.io.FileReader;\n import java.io.FileWriter;\n import java.util.ArrayList;\n import java.util.List;\n \n public class P2\n {\n    private static double maxTieChance;\n    \n    private static void calculate( int N, int K, double[] chances, BufferedWriter bw, int n ) throws Exception\n    {\n        maxTieChance = 0;\n        check( N, K, chances, 0, new ArrayList<Double>() );\n        \n        bw.append( "Case #"+n+": " + maxTieChance + "\n" );\n        bw.flush();\n    }\n    \n    private static void check( int N, int K, double[] chances, int pos, List<Double> members )\n    {\n        if ( members.size() == K )\n        {\n            double tieChance = getTieChance( members, 0, 0, 0, 1.0 );\n            if ( tieChance > maxTieChance )\n                maxTieChance = tieChance;\n        }\n        \n        if ( pos == chances.length )\n            return;\n        \n        {\n            List<Double> nextMembers = new ArrayList<>( members );\n            nextMembers.add( chances[pos] );\n            check( N, K, chances, pos + 1, nextMembers );\n        }\n        \n        {\n            List<Double> nextMembers = new ArrayList<>( members );\n            check( N, K, chances, pos + 1, nextMembers );\n        }\n    }\n    \n    private static double getTieChance( List<Double> members, int pos, int yes, int no, double chance )\n    {\n        if ( pos == members.size() )\n            return ( yes == no ? chance : 0 );\n        double memberChance = members.get( pos );\n        return\n            getTieChance( members, pos+1, yes+1, no, chance*memberChance ) +\n            getTieChance( members, pos+1, yes, no+1, chance*(1 - memberChance) );\n    }\n    \n    public static void main( String[] args ) throws Exception\n    {\n        File inputFile = new File( "src/round2/p2/input.txt" );\n        FileReader fr = new FileReader( inputFile );\n        BufferedReader br = new BufferedReader( fr );\n        \n        int numOfTestCases = Integer.parseInt( br.readLine() );\n        \n        File outputFile = new File( "src/round2/p2/output.txt" );\n        outputFile.delete();\n        outputFile.createNewFile();\n        FileWriter fw = new FileWriter( outputFile );\n        BufferedWriter bw = new BufferedWriter( fw );\n        \n        for ( int i = 0; i < numOfTestCases; i++ )\n        {\n            String[] data = br.readLine().split( " " );\n            \n            int N = Integer.parseInt( data[0] );\n            int K = Integer.parseInt( data[1] );\n            \n            String[] sChances = br.readLine().split( " " );\n            double[] chances = new double[N];\n            for ( int j = 0; j < N; j++ )\n                chances[j] = Double.parseDouble( sChances[j] );\n            \n            calculate( N, K, chances, bw, i+1 );\n        }\n        \n        bw.flush();\n        fw.flush();\n        \n        br.close();\n        bw.close();\n        fw.close();\n    }\n }\n
mikigergely	<>	62	<>	11254486_5648941810974720_mikigergely_p1.java	<>	package round1b.p1;\n \n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.File;\n import java.io.FileReader;\n import java.io.FileWriter;\n import java.util.HashMap;\n import java.util.Map;\n \n public class P1\n {\n    private static void calculate( String S, BufferedWriter bw, int n ) throws Exception\n    {\n        Map<Character, Integer> letters = new HashMap<>();\n        for ( char c : S.toCharArray() )\n        {\n            int soFar = letters.containsKey( c ) ? letters.get( c ) : 0;\n            letters.put( c, soFar + 1 );\n        }\n        \n        int[] numbers = new int[10];\n        \n        if ( letters.containsKey( 'Z' ) && letters.get( 'Z' ) > 0 )\n        {\n            int numZ = letters.get( 'Z' );\n            numbers[0] = numZ;\n            letters.remove( 'Z' );\n            letters.put( 'E', letters.get( 'E' ) - numZ );\n            letters.put( 'R', letters.get( 'R' ) - numZ );\n            letters.put( 'O', letters.get( 'O' ) - numZ );\n        }\n        \n        if ( letters.containsKey( 'W' ) && letters.get( 'W' ) > 0 )\n        {\n            int numW = letters.get( 'W' );\n            numbers[2] = numW;\n            letters.remove( 'W' );\n            letters.put( 'T', letters.get( 'T' ) - numW );\n            letters.put( 'O', letters.get( 'O' ) - numW );\n        }\n        \n        if ( letters.containsKey( 'X' ) && letters.get( 'X' ) > 0 )\n        {\n            int numX = letters.get( 'X' );\n            numbers[6] = numX;\n            letters.remove( 'X' );\n            letters.put( 'S', letters.get( 'S' ) - numX );\n            letters.put( 'I', letters.get( 'I' ) - numX );\n        }\n        \n        if ( letters.containsKey( 'G' ) && letters.get( 'G' ) > 0 )\n        {\n            int numG = letters.get( 'G' );\n            numbers[8] = numG;\n            letters.remove( 'G' );\n            letters.put( 'E', letters.get( 'E' ) - numG );\n            letters.put( 'I', letters.get( 'I' ) - numG );\n            letters.put( 'H', letters.get( 'H' ) - numG );\n            letters.put( 'T', letters.get( 'T' ) - numG );\n        }\n        \n        if ( letters.containsKey( 'T' ) && letters.get( 'T' ) > 0 )\n        {\n            int numT = letters.get( 'T' );\n            numbers[3] = numT;\n            letters.remove( 'T' );\n            letters.put( 'H', letters.get( 'H' ) - numT );\n            letters.put( 'R', letters.get( 'R' ) - numT );\n            letters.put( 'E', letters.get( 'E' ) - numT*2 );\n        }\n        \n        if ( letters.containsKey( 'R' ) && letters.get( 'R' ) > 0 )\n        {\n            int numR = letters.get( 'R' );\n            numbers[4] = numR;\n            letters.remove( 'R' );\n            letters.put( 'F', letters.get( 'F' ) - numR );\n            letters.put( 'O', letters.get( 'O' ) - numR );\n            letters.put( 'U', letters.get( 'U' ) - numR );\n        }\n        \n        if ( letters.containsKey( 'O' ) && letters.get( 'O' ) > 0 )\n        {\n            int numO = letters.get( 'O' );\n            numbers[1] = numO;\n            letters.remove( 'O' );\n            letters.put( 'N', letters.get( 'N' ) - numO );\n            letters.put( 'E', letters.get( 'E' ) - numO );\n        }\n        \n        if ( letters.containsKey( 'F' ) && letters.get( 'F' ) > 0 )\n        {\n            int numF = letters.get( 'F' );\n            numbers[5] = numF;\n            letters.remove( 'F' );\n            letters.put( 'I', letters.get( 'I' ) - numF );\n            letters.put( 'V', letters.get( 'V' ) - numF );\n            letters.put( 'E', letters.get( 'E' ) - numF );\n        }\n        \n        if ( letters.containsKey( 'S' ) && letters.get( 'S' ) > 0 )\n        {\n            int numS = letters.get( 'S' );\n            numbers[7] = numS;\n            letters.remove( 'S' );\n            letters.put( 'E', letters.get( 'E' ) - numS*2 );\n            letters.put( 'V', letters.get( 'V' ) - numS );\n            letters.put( 'N', letters.get( 'N' ) - numS );\n        }\n        \n        if ( letters.containsKey( 'I' ) && letters.get( 'I' ) > 0 )\n        {\n            int numI = letters.get( 'I' );\n            numbers[9] = numI;\n            letters.remove( 'I' );\n            letters.put( 'E', letters.get( 'E' ) - numI );\n            letters.put( 'N', letters.get( 'N' ) - numI*2 );\n        }\n        \n        String result = "";\n        for ( int i = 0; i < 10; i++ )\n            for ( int j = 0; j < numbers[i]; j++ )\n                result += i;\n        System.out.println( letters );\n        \n        bw.append( "Case #" + n + ": " + result + "\n" );\n        bw.flush();\n    }\n    \n    public static void main( String[] args ) throws Exception\n    {\n        File inputFile = new File( "src/round1b/p1/input.txt" );\n        FileReader fr = new FileReader( inputFile );\n        BufferedReader br = new BufferedReader( fr );\n        \n        int numOfTestCases = Integer.parseInt( br.readLine() );\n        \n        File outputFile = new File( "src/round1b/p1/output.txt" );\n        outputFile.delete();\n        outputFile.createNewFile();\n        FileWriter fw = new FileWriter( outputFile );\n        BufferedWriter bw = new BufferedWriter( fw );\n        \n        for ( int i = 0; i < numOfTestCases; i++ )\n        {\n            String S = br.readLine();\n            \n            calculate( S, bw, i+1 );\n        }\n        \n        bw.flush();\n        fw.flush();\n        \n        br.close();\n        bw.close();\n        fw.close();\n    }\n }\n
migueldurazo	<>	65	<>	3264486_5633382285312000_migueldurazo_handler.java	<>	\n package durazom.util;\n \n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.List;\n \n \n public class Handler {\n     \n     public static void run( String inputFile, String outputFile, Case thisCase )\n             throws IOException{\n         \n         run( inputFile, outputFile, thisCase, 1);\n         \n     }\n     \n     public static void run( String inputFile, String outputFile, Case thisCase,\n             int linesPerCase ) throws IOException{\n         \n         List<String> cases = Reader.readFile(inputFile, linesPerCase);\n         List<String> outputLines = new ArrayList<>();\n         \n         if( cases.size() > 0 ){\n             cases.stream().map((c) -> thisCase.solve(c)).forEach((solved) -> {\n                 outputLines.add(solved);\n             });\n         }else{\n             outputLines.add( thisCase.solve("") );\n         }\n         \n         Writer.write(outputFile, outputLines);\n     }\n     \n }\n
migueldurazo	<>	65	<>	3264486_5633382285312000_migueldurazo_reader.java	<>	\n package durazom.util;\n \n import java.io.BufferedReader;\n import java.io.FileNotFoundException;\n import java.io.FileReader;\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.List;\n \n \n public class Reader {\n \n     public static List<String> readFile(String inputFile, int linesPerCase) throws FileNotFoundException, IOException {\n \n         List<String> cases = new ArrayList<String>();\n \n         if (inputFile != null) {\n \n             BufferedReader reader = new BufferedReader(new FileReader(inputFile));\n \n             String line = "";\n \n             int lineCount = 0;\n             String lines = "";\n             while ((line = reader.readLine()) != null) {\n                 lineCount++;\n                 lines += lines.length()>0?"\n"+line:line;\n                 if( lineCount%linesPerCase == 0 ){\n                     cases.add(lines);\n                     lines = "";\n                 }\n             }\n \n             reader.close();\n             \n         }\n \n         return cases;\n \n     }\n \n }\n
migueldurazo	<>	65	<>	3264486_5633382285312000_migueldurazo_case.java	<>	\n package durazom.util;\n \n \n public interface Case {\n     \n     public String solve(String line);\n     \n }\n
migueldurazo	<>	65	<>	3264486_5633382285312000_migueldurazo_writer.java	<>	\n package durazom.util;\n \n import java.io.BufferedWriter;\n import java.io.FileWriter;\n import java.io.IOException;\n import java.util.List;\n \n \n public class Writer {\n     \n     public static void write( String outputFile, List<String> outputLines ) throws IOException{\n         \n         if( outputFile != null ){\n                     \n \n             try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile))) {\n                 for( String line : outputLines ){\n                     \n                     writer.write(line+"\n");\n                     \n                 }\n             }\n \n         }\n         \n     }\n     \n }\n
migueldurazo	<>	65	<>	3264486_5633382285312000_migueldurazo_tidynumberscase.java	<>	\n package durazom.tidynumbers;\n \n import durazom.util.Case;\n import java.math.BigInteger;\n \n \n public class TidyNumbersCase implements Case {\n \n     int cases = 1;\n     \n     @Override\n     public String solve(String caseString) {\n         \n         \n         char[] number = caseString.toCharArray();\n         String resultingNumber = caseString;\n         \n         \n         \n         int chosenDigitIndex = 0;\n         boolean foundDecrease = false;\n         for( int i = 0 ; i < number.length-1 ; i++ ){\n             \n             if( Integer.parseInt( number[i]+"" ) > Integer.parseInt( number[i+1]+"" )){\n                 chosenDigitIndex = i;\n                 foundDecrease = true;\n                 break;\n             }\n             \n         }\n         \n         \n         if(foundDecrease)\n         {\n             resultingNumber = "";\n         \n             while( chosenDigitIndex > 0 && number[chosenDigitIndex-1] == number[chosenDigitIndex]  ){\n \n                 chosenDigitIndex--;\n             }\n \n             \n \n             if( number[chosenDigitIndex]!='1' ){\n \n                 for(  int i = 0 ; i < number.length ; i++ ){\n \n                     if( i == chosenDigitIndex ){\n \n                         resultingNumber+= Integer.parseInt( number[i]+"" )-1;\n \n                     }else{\n \n                         if( i < chosenDigitIndex ){\n \n                             resultingNumber+= number[i];\n \n                         }else{\n \n                             resultingNumber+= '9';\n \n                         }\n \n                     }\n \n                 }\n \n             }else{\n \n                 for(  int i = 0 ; i < number.length-1 ; i++ ){\n \n                     resultingNumber+= '9';\n \n                 }\n \n             }\n         \n         }\n         \n         String result = "Case #"+(cases++)+": ";\n         \n         result += resultingNumber;\n         \n         return result;\n         \n     } \n }\n
Ajlohr	<>	68	<>	11254486_5695413893988352_Ajlohr_probb.java	<>	package Round1B;\n \n import java.util.Scanner;\n import java.util.TreeMap;\n \n public class ProbB {\n    \n    static long mindist=Long.MAX_VALUE;\n    static String minC;\n    static String minJ;\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        long t = sc.nextInt();\n        for(int curcase=1;curcase<=t;curcase++)\n        {\n        String C = sc.next();\n        String J = sc.next();\n        mindist=Long.MAX_VALUE;\n        recurse(C.toCharArray(),J.toCharArray(),0,0);\n        System.out.println("Case #"+curcase+": "+minC+" "+minJ);        \n        }\n        \n    }\n    \n    public static void recurse(char[] C,char[] J,int earlQ,int bigger)\n    {\n        if(earlQ == C.length)\n        {\n            String CC = new String(C);\n            String JJ = new String(J);\n            long dist = Math.abs(Long.parseLong(CC)-Long.parseLong(JJ));\n \n            if(dist<mindist)\n            {\n                mindist = dist;minC = CC;minJ = JJ;\n            }\n            if((dist==mindist)&&(Long.parseLong(CC)<Long.parseLong(minC)))\n            {\n                minC = CC;minJ = JJ;\n            }\n            if((dist==mindist)&&(Long.parseLong(CC)==Long.parseLong(minC))&&(Long.parseLong(JJ)<Long.parseLong(minJ)))\n            {\n                minC = CC;minJ = JJ;\n            }\n            return;\n        }\n        if((C[earlQ]!='?')&&(J[earlQ]!='?'))\n        {\n            if((bigger==0)&&(C[earlQ]!= J[earlQ]))\n            {\n                bigger = C[earlQ]-J[earlQ];\n            }\n            recurse(C,J,earlQ+1,bigger);\n            return;\n        }\n        if((C[earlQ]!='?')&&(J[earlQ]=='?'))\n        {\n            if( bigger==0){\n            if(C[earlQ]>'0')\n            {\n                J[earlQ] = (char) (C[earlQ]-1);\n                recurse(C,J,earlQ+1,1);\n            }else\n            {\n                J[earlQ] = '9';\n                recurse(C,J,earlQ+1,-1);\n            }\n            J[earlQ] = C[earlQ];\n            recurse(C,J,earlQ+1,0);\n            if(C[earlQ]<'9')\n            {\n                J[earlQ] = (char) (C[earlQ]+1);\n                recurse(C,J,earlQ+1,-1);\n            }else{\n                J[earlQ] = '0';\n                recurse(C,J,earlQ+1,1);\n            }\n            J[earlQ] ='?';\n            }\n            if(bigger>0)\n            {\n                J[earlQ] = '9';\n                recurse(C,J,earlQ+1,bigger);\n                J[earlQ] ='?';\n            }\n            if(bigger<0)\n            {\n                J[earlQ] = '0';\n                recurse(C,J,earlQ+1,bigger);\n                J[earlQ] ='?';              \n            }           \n \n                return;\n        }\n        if((C[earlQ]=='?')&&(J[earlQ]!='?'))\n        {\n            if(bigger ==0)\n            {\n            if(J[earlQ]>'0')\n            {\n                C[earlQ] = (char) (J[earlQ]-1);\n                recurse(C,J,earlQ+1,-1);\n            }else\n            {\n                C[earlQ] ='9';\n                recurse(C,J,earlQ+1,1);\n            }\n            C[earlQ] = J[earlQ];\n            recurse(C,J,earlQ+1,bigger);\n            if(J[earlQ]<'9')\n            {\n                C[earlQ] = (char) (J[earlQ]+1);\n                recurse(C,J,earlQ+1,1);\n            }else{\n                C[earlQ] = '0';\n                recurse(C,J,earlQ+1,-1);\n            }\n            \n            C[earlQ] ='?';}\n        if(bigger>0)\n        {\n            C[earlQ] = '0';\n            recurse(C,J,earlQ+1,bigger);\n            C[earlQ] ='?';\n        }\n        if(bigger<0)\n        {\n            C[earlQ] = '9';\n            recurse(C,J,earlQ+1,bigger);\n            C[earlQ] ='?';              \n        }           \n \n            return;\n        }\n        if(bigger==0){\n        C[earlQ] = '0';\n        J[earlQ] = '0';\n        recurse(C,J,earlQ+1,bigger);\n \n        C[earlQ] = '1';\n        J[earlQ] = '0';\n        recurse(C,J,earlQ+1,1);\n \n        C[earlQ] = '0';\n        J[earlQ] = '1';\n        recurse(C,J,earlQ+1,-1);\n        \n        }\n        if(bigger<0){\n        C[earlQ] = '9';\n        J[earlQ] = '0';\n        recurse(C,J,earlQ+1,bigger);}\n        if(bigger>0){\n        C[earlQ] = '0';\n        J[earlQ] = '9';\n        recurse(C,J,earlQ+1,bigger);}\n        C[earlQ] ='?';\n        J[earlQ] ='?';\n    }\n \n }\n
Ajlohr	<>	68	<>	11254486_5648941810974720_Ajlohr_proba.java	<>	package Round1B;\n \n import java.util.Scanner;\n \n public class ProbA {\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        long t = sc.nextInt();\n        for(int curcase=1;curcase<=t;curcase++)\n        {\n        String S = sc.next();\n        char[] lettercount = new char[256];\n        for(int i=0;i<S.length();i++)\n        {\n            lettercount[S.charAt(i)]++;\n        }\n        int[] numbercount= new int[10];\n        reduce(lettercount,numbercount,"ZERO",0,'Z');\n        reduce(lettercount,numbercount,"SIX",6,'X');\n        reduce(lettercount,numbercount,"FOUR",4,'U');\n        reduce(lettercount,numbercount,"THREE",3,'R');\n        reduce(lettercount,numbercount,"SEVEN",7,'S');\n        reduce(lettercount,numbercount,"EIGHT",8,'G');\n        reduce(lettercount,numbercount,"TWO",2,'T');\n        reduce(lettercount,numbercount,"ONE",1,'O');\n        reduce(lettercount,numbercount,"FIVE",5,'V');\n        reduce(lettercount,numbercount,"NINE",9,'I');\n        String out = "";\n        for(int i=0;i<10;i++)\n        {\n            if(numbercount[i]>0)\n            {\n                numbercount[i]--;\n                out+=i;\n                i--;\n            }\n        }\n        System.out.println("Case #"+curcase+": "+out);      \n        }\n        \n    }\n    public static void reduce(char[] lets,int[] nums,String S, int num,char unique)\n    {       \n        while(lets[unique]>0)\n    {\n            for(int i=0;i<S.length();i++)\n            {\n                lets[S.charAt(i)]--;\n            }\n        nums[num]++;\n    }\n    }\n }\n
Ajlohr	<>	68	<>	11254486_5686313294495744_Ajlohr_probc.java	<>	package Round1B;\n \n import java.util.HashSet;\n import java.util.Scanner;\n \n public class ProbC {\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        long t = sc.nextInt();\n        for(int curcase=1;curcase<=t;curcase++)\n        {\n            int n =sc.nextInt();\n            String[] sofara = new String[0];\n            String[] sofarb= new String[0];\n            for(int i=0;i<n;i++)\n            {\n                \n                String first = sc.next();\n                String last = sc.next();\n                String[] newa = new String[i+1];\n                String[] newb= new String[i+1];\n                for(int j=0;j<i;j++)\n                {\n                    newa[j] = sofara[j];\n                    newb[j] = sofarb[j];\n                }\n                newa[i] = first;\n                newb[i] = last;\n                int bestconflicts = numcheats(newa,newb);\n                String[] bestnewa = newa.clone();\n                String[] bestnewb = newb.clone();\n                for(int j=i-1;j>=0;j--)\n                {\n                    String[] cura = newa.clone();\n                    String[] curb = newb.clone();\n                    for(int k=j;k<i;k++){\n                    String swap = cura[k];\n                    cura[k] = cura[k+1];\n                    cura[k+1] = swap;\n                    swap = curb[k];\n                    curb[k] = curb[k+1];\n                    curb[k+1] = swap;}\n                    if(numcheats(cura,curb)>bestconflicts)\n                    {\n                        bestconflicts = numcheats(cura,curb);\n                        bestnewa = cura.clone();\n                        bestnewb = curb.clone();\n                    }\n                }\n                sofara = bestnewa;\n                sofarb = bestnewb;\n            }\n            \n        System.out.println("Case #"+curcase+": "+numcheats(sofara,sofarb));     \n        }\n        \n    }\n    public static int numcheats(String[] a,String[] b)\n    {\n        HashSet<String> as = new HashSet<String>();\n        HashSet<String> bs = new HashSet<String>();\n        int ret = 0;\n        for(int i=0;i<a.length;i++)\n        {\n            if((as.contains(a[i]))&&(bs.contains(b[i])))\n            {\n                ret++;\n            }\n            else\n            {\n                as.add(a[i]);bs.add(b[i]);\n            }\n        }\n        return ret;\n \n    }\n \n }\n
Arup	<>	70	<>	10224486_5718447400943616_Arup_dsmalll.java	<>	import java.util.*;\n \n public class dsmalll {\n     public static int n;\n     public static boolean[][] work;\n     public static void main(String[] args) {\n         \n         Scanner stdin = new Scanner(System.in);\n         int numCases = stdin.nextInt();\n         \n         for (int loop=1; loop<=numCases; loop++) {\n             \n             n = stdin.nextInt();\n             work = new boolean[n][n];\n             for (int i=0; i<n; i++) {\n                 String s = stdin.next();\n                 for (int j=0; j<n; j++)\n                     work[i][j] = (s.charAt(j) == '1');\n             }\n             \n             \n             int mask = 0;\n             for (int i=0; i<n; i++)\n                 for (int j=0; j<n; j++)\n                     if (work[i][j])\n                         mask += (1<<(n*i+j));\n             \n             \n             int res = 16;\n             for (int i=0; i<(1<<(n*n)); i++) {\n                 \n                 if ((i&mask) > 0) continue;\n                 \n                 boolean[][] newwork = new boolean[n][n];\n                 for (int j=0; j<n; j++)\n                     for (int k=0; k<n; k++)\n                         newwork[j][k] = work[j][k];\n                 \n                 for (int j=0; j<n; j++)\n                     for (int k=0; k<n; k++)\n                         if ((i & (1<<(j*n+k))) > 0)\n                             newwork[j][k] = true;\n                 \n                 if (valid(newwork)) res = Math.min(res, Integer.bitCount(i));\n             }\n             \n             System.out.println("Case #"+loop+": "+res);\n         }\n     }\n     \n     public static boolean valid(boolean[][] grid) {\n         \n         \n         boolean[] marked = new boolean[grid.length];\n         for (int i=0; i<grid.length; i++) {\n             \n             ArrayList<Integer> me = new ArrayList<Integer>();\n             for (int j=0; j<grid.length; j++)\n                 if (grid[i][j])\n                     me.add(j);\n             \n             for (int j=0; j<me.size(); j++)\n                 marked[me.get(j)] = true;\n             \n             int match = me.size();\n             int eq = 0;\n             for (int j=0; j<grid.length; j++) {\n                 \n                 ArrayList<Integer> tmp = new ArrayList<Integer>();\n                 for (int k=0; k<grid.length; k++)\n                     if (grid[j][k])\n                         tmp.add(k);\n                 \n                 if (equal(me, tmp)) eq++;\n             }\n             if (eq != match) return false;\n \n         }\n         \n         for (int i=0; i<marked.length; i++)\n             if (!marked[i])\n                 return false;\n         return true;\n     }\n     \n     public static boolean equal(ArrayList<Integer> a, ArrayList<Integer> b) {\n         \n        if (a.size() != b.size()) return false; \n        for (int i=0; i<a.size(); i++)\n            if (!a.get(i).equals(b.get(i)))\n                return false;\n        return true;\n     }\n }\n
Arup	<>	70	<>	10224486_5677604812095488_Arup_bsmall.java	<>	\n import java.util.*;\n \n public class bsmall {\n     \n     public static void main(String[] args) {\n         \n         Scanner stdin = new Scanner(System.in);\n         int numCases = stdin.nextInt();\n         \n         for (int loop=1; loop<=numCases; loop++) {\n             \n             int n = stdin.nextInt();\n             int k = stdin.nextInt();\n             double[] p = new double[n];\n             for (int i=0; i<n; i++)\n                 p[i] = stdin.nextDouble();\n             \n             double res = 0;\n             for (int i=1; i<(1<<n); i++) {        \n                 if (Integer.bitCount(i) != k) continue;\n \n                 double tmp = 0;\n                 for (int mask=i; mask>0; mask = ((mask-1)&i) ) {\n                     \n                     if (Integer.bitCount(mask) != k/2) continue;\n                     \n                     double thisP = 1;\n                     for (int j=0; j<n; j++) {\n                         if ((mask&(1<<j)) > 0)\n                             thisP = thisP*p[j];\n                         else if ((i&(1<<j)) > 0)\n                             thisP = thisP*(1-p[j]);\n                  \n                     }\n                     tmp += thisP;\n                 }\n                 res = Math.max(res, tmp);\n             }\n             \n             System.out.printf("Case #%d: %.9f\n", loop, res);\n         }\n     }\n }
Arup	<>	70	<>	10224486_5718606851604480_Arup_a.java	<>	import java.util.*;\n \n public class a {\n     \n     public static HashMap<String,String> map;\n     public static void main(String[] args) {\n         \n         map = new HashMap<String,String>();\n         map.put("P", "PR");\n         map.put("S", "PS");\n         map.put("R", "RS");\n         \n         String[] pWins = new String[13];\n         \n         \n         \n         \n         \n         Scanner stdin = new Scanner(System.in);\n         int numCases = stdin.nextInt();\n         \n         for (int loop=1; loop<=numCases; loop++) {\n             \n             int n = stdin.nextInt();\n             int r = stdin.nextInt();\n             int p = stdin.nextInt();\n             int s = stdin.nextInt();\n             \n             String res1 = solve(n,'P', 0);\n             String res2 = solve(n,'R', 0);\n             String res3 = solve(n,'S', 0);\n             \n             String res = resolve(res1, res2, res3, r, p, s);\n             \n             if (res == null)\n                 System.out.println("Case #"+loop+": IMPOSSIBLE");\n             else\n                 System.out.println("Case #"+loop+": "+res);\n             \n         }\n     }\n     \n     public static String solve(int n, char start, int k) {\n         \n         if (n == k) return ""+start;\n         String left = null;\n         String right = null;\n         if (start == 'P') {\n             left = solve(n, 'P', k+1);\n             right = solve(n, 'R', k+1);\n         }\n         else if (start == 'R') {\n             left = solve(n, 'R', k+1);\n             right = solve(n, 'S', k+1);\n         }\n         else {\n             left = solve(n, 'S', k+1);\n             right = solve(n, 'P', k+1);\n         }\n         \n         if (left.compareTo(right) < 0) return left+right;\n         else return right+left;\n             \n     }\n     \n     public static String resolve(String res1, String res2, String res3, int r, int p, int s) {\n         \n         int[] cnt1 = countF(res1);\n         int[] cnt2 = countF(res2);\n         int[] cnt3 = countF(res3);\n         \n         if (cnt1[0] != r || cnt1[1] != p || cnt1[2] != s) res1 = null;\n         if (cnt2[0] != r || cnt2[1] != p || cnt2[2] != s) res2 = null;\n         if (cnt3[0] != r || cnt3[1] != p || cnt3[2] != s) res3 = null;\n         \n         if (res1 == null && res2 == null && res3 == null) return null;\n         \n         if (res1 == null && res2 == null) return res3;\n         if (res1 == null && res3 == null) return res2;\n         if (res2 == null && res3 == null) return res1;\n         if (res1 == null) {\n             if (res2.compareTo(res3) < 0) return res2;\n             return res3;\n         }\n         if (res2 == null) {\n             if (res1.compareTo(res3) < 0) return res1;\n             return res3;\n         }\n         if (res3 == null) {\n             if (res1.compareTo(res2) < 0) return res1;\n             return res2;\n         }\n         \n         if (res1.compareTo(res2) < 0 && res1.compareTo(res3) < 0) return res1;\n         if (res2.compareTo(res3) < 0) return res2;\n         return res3;\n     }\n     \n     public static int[] countF(String s) {\n         int[] cnt = new int[3];\n         cnt[0] = count(s, 'R');\n         cnt[1] = count(s, 'P');\n         cnt[2] = count(s, 'S');\n         return cnt;\n     }\n     \n     public static int count(String s, char c) {\n         int res = 0;\n         for (int i=0; i<s.length(); i++)\n             if (s.charAt(i)==c)\n                 res++;\n         return res;\n     }\n }\n
