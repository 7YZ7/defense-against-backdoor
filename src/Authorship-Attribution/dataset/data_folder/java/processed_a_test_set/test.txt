package Round1B;\n  \n  \n  public class ProbB {\n     \n     static long mindist=Long.MAX_VALUE;\n     static String minC;\n     static String minJ;\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         long t = sc.nextInt();\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n         String C = sc.next();\n         String J = sc.next();\n         mindist=Long.MAX_VALUE;\n         recurse(C.toCharArray(),J.toCharArray(),0,0);\n         System.out.println("Case #"+curcase+": "+minC+" "+minJ);        \n         }\n         \n     }\n     \n     public static void recurse(char[] C,char[] J,int earlQ,int bigger)\n     {\n         if(earlQ == C.length)\n         {\n             String CC = new String(C);\n             String JJ = new String(J);\n             long dist = Math.abs(Long.parseLong(CC)-Long.parseLong(JJ));\n  \n             if(dist<mindist)\n             {\n                 mindist = dist;minC = CC;minJ = JJ;\n             }\n             if((dist==mindist)&&(Long.parseLong(CC)<Long.parseLong(minC)))\n             {\n                 minC = CC;minJ = JJ;\n             }\n             if((dist==mindist)&&(Long.parseLong(CC)==Long.parseLong(minC))&&(Long.parseLong(JJ)<Long.parseLong(minJ)))\n             {\n                 minC = CC;minJ = JJ;\n             }\n             return;\n         }\n         if((C[earlQ]!='?')&&(J[earlQ]!='?'))\n         {\n             if((bigger==0)&&(C[earlQ]!= J[earlQ]))\n             {\n                 bigger = C[earlQ]-J[earlQ];\n             }\n             recurse(C,J,earlQ+1,bigger);\n             return;\n         }\n         if((C[earlQ]!='?')&&(J[earlQ]=='?'))\n         {\n             if( bigger==0){\n             if(C[earlQ]>'0')\n             {\n                 J[earlQ] = (char) (C[earlQ]-1);\n                 recurse(C,J,earlQ+1,1);\n             }else\n             {\n                 J[earlQ] = '9';\n                 recurse(C,J,earlQ+1,-1);\n             }\n             J[earlQ] = C[earlQ];\n             recurse(C,J,earlQ+1,0);\n             if(C[earlQ]<'9')\n             {\n                 J[earlQ] = (char) (C[earlQ]+1);\n                 recurse(C,J,earlQ+1,-1);\n             }else{\n                 J[earlQ] = '0';\n                 recurse(C,J,earlQ+1,1);\n             }\n             J[earlQ] ='?';\n             }\n             if(bigger>0)\n             {\n                 J[earlQ] = '9';\n                 recurse(C,J,earlQ+1,bigger);\n                 J[earlQ] ='?';\n             }\n             if(bigger<0)\n             {\n                 J[earlQ] = '0';\n                 recurse(C,J,earlQ+1,bigger);\n                 J[earlQ] ='?';              \n             }           \n  \n                 return;\n         }\n         if((C[earlQ]=='?')&&(J[earlQ]!='?'))\n         {\n             if(bigger ==0)\n             {\n             if(J[earlQ]>'0')\n             {\n                 C[earlQ] = (char) (J[earlQ]-1);\n                 recurse(C,J,earlQ+1,-1);\n             }else\n             {\n                 C[earlQ] ='9';\n                 recurse(C,J,earlQ+1,1);\n             }\n             C[earlQ] = J[earlQ];\n             recurse(C,J,earlQ+1,bigger);\n             if(J[earlQ]<'9')\n             {\n                 C[earlQ] = (char) (J[earlQ]+1);\n                 recurse(C,J,earlQ+1,1);\n             }else{\n                 C[earlQ] = '0';\n                 recurse(C,J,earlQ+1,-1);\n             }\n             \n             C[earlQ] ='?';}\n         if(bigger>0)\n         {\n             C[earlQ] = '0';\n             recurse(C,J,earlQ+1,bigger);\n             C[earlQ] ='?';\n         }\n         if(bigger<0)\n         {\n             C[earlQ] = '9';\n             recurse(C,J,earlQ+1,bigger);\n             C[earlQ] ='?';              \n         }           \n  \n             return;\n         }\n         if(bigger==0){\n         C[earlQ] = '0';\n         J[earlQ] = '0';\n         recurse(C,J,earlQ+1,bigger);\n  \n         C[earlQ] = '1';\n         J[earlQ] = '0';\n         recurse(C,J,earlQ+1,1);\n  \n         C[earlQ] = '0';\n         J[earlQ] = '1';\n         recurse(C,J,earlQ+1,-1);\n         \n         }\n         if(bigger<0){\n         C[earlQ] = '9';\n         J[earlQ] = '0';\n         recurse(C,J,earlQ+1,bigger);}\n         if(bigger>0){\n         C[earlQ] = '0';\n         J[earlQ] = '9';\n         recurse(C,J,earlQ+1,bigger);}\n         C[earlQ] ='?';\n         J[earlQ] ='?';\n     }\n  \n  }\n <CODESPLIT> 18
package Round1B;\n  \n  \n  public class ProbA {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         long t = sc.nextInt();\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n         String S = sc.next();\n         char[] lettercount = new char[256];\n         for(int i=0;i<S.length();i++)\n         {\n             lettercount[S.charAt(i)]++;\n         }\n         int[] numbercount= new int[10];\n         reduce(lettercount,numbercount,"ZERO",0,'Z');\n         reduce(lettercount,numbercount,"SIX",6,'X');\n         reduce(lettercount,numbercount,"FOUR",4,'U');\n         reduce(lettercount,numbercount,"THREE",3,'R');\n         reduce(lettercount,numbercount,"SEVEN",7,'S');\n         reduce(lettercount,numbercount,"EIGHT",8,'G');\n         reduce(lettercount,numbercount,"TWO",2,'T');\n         reduce(lettercount,numbercount,"ONE",1,'O');\n         reduce(lettercount,numbercount,"FIVE",5,'V');\n         reduce(lettercount,numbercount,"NINE",9,'I');\n         String out = "";\n         for(int i=0;i<10;i++)\n         {\n             if(numbercount[i]>0)\n             {\n                 numbercount[i]--;\n                 out+=i;\n                 i--;\n             }\n         }\n         System.out.println("Case #"+curcase+": "+out);      \n         }\n         \n     }\n     public static void reduce(char[] lets,int[] nums,String S, int num,char unique)\n     {       \n         while(lets[unique]>0)\n     {\n             for(int i=0;i<S.length();i++)\n             {\n                 lets[S.charAt(i)]--;\n             }\n         nums[num]++;\n     }\n     }\n  }\n <CODESPLIT> 18
package Round1B;\n  \n  \n  public class ProbC {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         long t = sc.nextInt();\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             int n =sc.nextInt();\n             String[] sofara = new String[0];\n             String[] sofarb= new String[0];\n             for(int i=0;i<n;i++)\n             {\n                 \n                 String first = sc.next();\n                 String last = sc.next();\n                 String[] newa = new String[i+1];\n                 String[] newb= new String[i+1];\n                 for(int j=0;j<i;j++)\n                 {\n                     newa[j] = sofara[j];\n                     newb[j] = sofarb[j];\n                 }\n                 newa[i] = first;\n                 newb[i] = last;\n                 int bestconflicts = numcheats(newa,newb);\n                 String[] bestnewa = newa.clone();\n                 String[] bestnewb = newb.clone();\n                 for(int j=i-1;j>=0;j--)\n                 {\n                     String[] cura = newa.clone();\n                     String[] curb = newb.clone();\n                     for(int k=j;k<i;k++){\n                     String swap = cura[k];\n                     cura[k] = cura[k+1];\n                     cura[k+1] = swap;\n                     swap = curb[k];\n                     curb[k] = curb[k+1];\n                     curb[k+1] = swap;}\n                     if(numcheats(cura,curb)>bestconflicts)\n                     {\n                         bestconflicts = numcheats(cura,curb);\n                         bestnewa = cura.clone();\n                         bestnewb = curb.clone();\n                     }\n                 }\n                 sofara = bestnewa;\n                 sofarb = bestnewb;\n             }\n             \n         System.out.println("Case #"+curcase+": "+numcheats(sofara,sofarb));     \n         }\n         \n     }\n     public static int numcheats(String[] a,String[] b)\n     {\n         HashSet<String> as = new HashSet<String>();\n         HashSet<String> bs = new HashSet<String>();\n         int ret = 0;\n         for(int i=0;i<a.length;i++)\n         {\n             if((as.contains(a[i]))&&(bs.contains(b[i])))\n             {\n                 ret++;\n             }\n             else\n             {\n                 as.add(a[i]);bs.add(b[i]);\n             }\n         }\n         return ret;\n  \n     }\n  \n  }\n <CODESPLIT> 18
