vincentbelrose	<>	0	<>	11254486_5686313294495744_vincentbelrose_gcj_technobabble.java	<>	\n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.File;\n import java.io.PrintWriter;\n import java.math.BigInteger;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.HashSet;\n import java.util.Locale;\n import java.util.Random;\n import java.util.Scanner;\n import java.util.StringTokenizer;\n \n public class GCJ_TechnoBabble {\n \n    void log(long[] X){\n        int L=X.length;\n        for (int i=0;i<L;i++){\n            logWln(X[i]+" ");\n        }\n        log("");\n    }\n \n    void log(double[] X){\n        int L=X.length;\n        for (int i=0;i<L;i++){\n            logWln(X[i]+" ");\n        }\n        log("");\n    }\n \n    void log(int[] X){\n        int L=X.length;\n        for (int i=0;i<L;i++){\n            logWln(X[i]+" ");\n        }\n        log("");\n    }\n    void log(Object[] X){\n        int L=X.length;\n        for (int i=0;i<L;i++){\n            logWln(X[i]+" ");\n        }\n        log("");\n    }\n \n \n    void log(Object o){\n        logWln(o+"\n");\n    }\n \n    void logWln(Object o){\n        System.out.print(o);\n        \n \n    }\n    void info(Object o){\n        System.out.println(o);\n        \n    }\n \n \n \n \n    String solveBourrin(String[] A,String[] B){\n        int m​i‌n=Integer.MAX_VALUE;\n        int M​X=1<<N;\n        for (int u=1;u<M​X;u++){\n            HashSet<String> first=new HashSet<String>();\n            HashSet<String> second=new HashSet<String>();\n            \n            for (int i=0;i<N;i++){\n                if ((u & (1<<i))!=0){\n                    first.add(A[i]);\n                    second.add(B[i]);\n                    \n                }\n                \n            }\n            \n            boolean o‌k=true;\n            loop:for (int i=0;i<N;i++){\n                if (!(first.contains(A[i]) && second.contains(B[i]))){\n                    o‌k=false;\n                    break loop;\n                }\n            }\n            if (o‌k){\n                int cnt=Integer.bitCount(u);\n                if (cnt<m​i‌n)\n                    m​i‌n=cnt;\n            }\n        }\n        return ""+(N-m​i‌n);\n    }\n \n \n \n    \n    StringTokenizer s‌t;\n    BufferedReader i‌n;\n    BufferedWriter out;\n int N;\n \n \n \n    void process() throws Exception {\n        Locale.setDefault(Locale.US);\n \n \n \n \n        \n        File inputFile=new File("C.i‌n");\n \n \n \n        \n        PrintWriter outputFile= new PrintWriter("C.out","UTF-8");\n \n \n \n        Scanner sc=new Scanner(inputFile);\n        sc.useLocale(Locale.US);\n \n        int T=sc.nextInt();\n        for (int t=1;t<=T;t++){\n \n            N=sc.nextInt();\n            String[] A=new String[N];\n            String[] B=new String[N];\n            \n            for (int i=0;i<N;i++){\n                A[i]=sc.next();\n                B[i]=sc.next();\n                \n                \n            }\n            String ss=""+solveBourrin(A,B);\n            System.out.println("Case #"+t+": "+ss);\n            outputFile.println("Case #"+t+": "+ss);\n \n \n        }\n \n \n \n        sc.close();\n        outputFile.close();\n \n \n    }\n \n \n \n    public static void main(String[] args) throws Exception {\n        GCJ_TechnoBabble J=new GCJ_TechnoBabble();\n \n        J.process();\n \n \n    }\n \n \n \n \n \n \n }\n
vincentbelrose	<>	0	<>	11254486_5695413893988352_vincentbelrose_gcj_closematch.java	<>	\n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.File;\n import java.io.PrintWriter;\n import java.math.BigInteger;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.HashSet;\n import java.util.Locale;\n import java.util.Random;\n import java.util.Scanner;\n import java.util.StringTokenizer;\n \n public class GCJ_CloseMatch {\n \n    void log(long[] X){\n        int L=X.length;\n        for (int i=0;i<L;i++){\n            logWln(X[i]+" ");\n        }\n        log("");\n    }\n \n    void log(double[] X){\n        int L=X.length;\n        for (int i=0;i<L;i++){\n            logWln(X[i]+" ");\n        }\n        log("");\n    }\n \n    void log(int[] X){\n        int L=X.length;\n        for (int i=0;i<L;i++){\n            logWln(X[i]+" ");\n        }\n        log("");\n    }\n    void log(Object[] X){\n        int L=X.length;\n        for (int i=0;i<L;i++){\n            logWln(X[i]+" ");\n        }\n        log("");\n    }\n \n \n    void log(Object o){\n        logWln(o+"\n");\n    }\n \n    void logWln(Object o){\n        System.out.print(o);\n        \n \n    }\n    void info(Object o){\n        System.out.println(o);\n        \n    }\n \n \n \n    String solveKO2(String A,String B){\n \n        int L=A.length();\n        char[] a;\n        char[] b;\n        String ta,tb;\n        a=A.toCharArray();\n        b=B.toCharArray();\n        int sta=0,stb=0;\n        \n \n        boolean divergent=false;\n        int o‍ption=-1;\n        int divPoint=-1;\n        for (int u=0;u<L && !divergent;u++){\n            if (a[u]!='?' && b[u]!='?' && a[u]!=b[u]) {\n                divergent=true;\n                divPoint=u;\n            } if (!divergent && (a[u]=='?' || b[u]=='?')){\n                o‍ption=u;\n            }\n        }\n \n        String[] m‌ina=new String[L];\n        String[] minb=new String[L];\n        String[] m‍axa=new String[L];\n        String[] maxb=new String[L];\n \n        for (int u=L-1;u>=0;u--){\n            if (u==L-1){\n                \n                if (a[u]=='?')\n                    m‌ina[u]="0";\n                else\n                    m‌ina[u]=""+a[u];\n                if (b[u]=='?')\n                    minb[u]="0";\n                else\n                    minb[u]=""+b[u];\n \n                if (a[u]=='?')\n                    m‍axa[u]="9";\n                else\n                    m‍axa[u]=""+a[u];\n                if (b[u]=='?')\n                    maxb[u]="9";\n                else\n                    maxb[u]=""+b[u];\n            } else {\n                \n                if (a[u]=='?'){\n                    m‌ina[u]="0"+m‌ina[u+1];\n                    m‍axa[u]="9"+m‍axa[u+1];\n                } else {\n                    m‌ina[u]=a[u]+m‌ina[u+1];\n                    m‍axa[u]=a[u]+m‍axa[u+1];\n                }\n \n                if (b[u]=='?'){\n                    minb[u]="0"+minb[u+1];\n                    maxb[u]="9"+maxb[u+1];\n                } else {\n                    minb[u]=b[u]+minb[u+1];\n                    maxb[u]=b[u]+maxb[u+1];\n                }\n            }\n        }\n \n        if (!divergent){\n            \n            for (int u=0;u<L;u++){\n                if (a[u]=='?' && b[u]=='?'){\n                    a[u]='0';\n                    b[u]='0';\n                } else {\n                    if (a[u]=='?')\n                        a[u]=b[u];\n                    if (b[u]=='?')\n                        b[u]=a[u];\n                }\n \n            }\n            return new String(a)+" "+new String(b);\n        }\n \n        log("Divergent");\n \n        \n        \n        if (o‍ption==-1){\n            \n            log("But no o‍ption");\n            sta=0;\n            stb=0;\n            for (int u=0;u<L;u++){\n \n                if (a[u]=='?' || b[u]=='?'){\n                    if (sta>stb){\n                        if (a[u]=='?')\n                            a[u]='0';\n                        if (b[u]=='?')\n                            b[u]='9';\n                    } else {\n                        if (a[u]=='?')\n                            a[u]='9';\n                        if (b[u]=='?')\n                            b[u]='0';\n                    }\n                }\n                else {\n                    if (sta==stb){\n                        sta=a[u]-'0';\n                        stb=b[u]-'0';\n                    }\n                }\n \n            }\n            return new String(a)+" "+new String(b);\n        }\n \n        \n        log("Can change the world");\n        String pre="";\n        if (o‍ption>0){\n            pre=A.substring(0,o‍ption);\n        }\n        log("pre:"+pre);\n        int amin,a‌max,bmin,bmax;\n        if (a[o‍ption]=='?'){\n            amin=0;\n            a‌max=9;\n        } else {\n            amin=a[o‍ption]-'0';\n            a‌max=a[o‍ption]-'0';\n            \n        }\n        if (b[o‍ption]=='?'){\n            bmin=0;\n            bmax=9;\n        } else {\n            bmin=b[o‍ption]-'0';\n            bmax=b[o‍ption]-'0';\n            \n        }\n        BigInteger d‌iff=null;\n        BigInteger gE=null,gF=null;\n        String g​e="",gf="";\n        for (int x=amin;x<=a‌max;x++)\n            for (int y=bmin;y<=bmax;y++){\n                String[] tx=new String[]{x+m‌ina[o‍ption+1],x+m‍axa[o‍ption+1]};\n                String[] ty=new String[]{y+minb[o‍ption+1],y+maxb[o‍ption+1]};\n                for (String e:tx)\n                    for (String f:ty){\n                        if (d‌iff==null){\n                            BigInteger E=new BigInteger(e);\n                            BigInteger F=new BigInteger(f);\n                            d‌iff=E.subtract(F);\n                            d‌iff=d‌iff.abs();\n                            gE=E;\n                            gF=F;\n                            g​e=e;\n                            gf=f;\n                        } else {\n                            BigInteger E=new BigInteger(e);\n                            BigInteger F=new BigInteger(f);\n                            BigInteger delta=E.subtract(F);\n                            delta=delta.abs();\n                            if (delta.compareTo(d‌iff)<0){\n                                d‌iff=delta;\n                                gE=E;\n                                gF=F;\n                                g​e=e;\n                                gf=f;\n                                \n                            } else if (delta.compareTo(d‌iff)==0){\n                                if (E.compareTo(gE)<0){\n                                    gE=E;\n                                    gF=F;\n                                    g​e=e;\n                                    gf=f;\n                                } else if (E.compareTo(gE)==0){\n                                    if (F.compareTo(gF)<0){\n                                        gE=E;\n                                        gF=F;\n                                        g​e=e;\n                                        gf=f;\n                                    }\n                                }\n                                \n                            }\n                        }\n                    }\n            \n                \n            }\n        return (pre+g​e)+" "+(pre+gf);\n        \n        \n        \n        \n        \n \n    }\n    \n    ArrayList<String > generate(String u){\n        ArrayList<String> world=new ArrayList<String>();\n        if (u.length()==1){\n            if (u.charAt(0)=='?'){\n                for (int v=0;v<10;v++)\n                    world.add(""+v);\n                return world;\n            }\n            world.add(u);\n            return world;\n        }\n        ArrayList<String> tmp=generate(u.substring(1,u.length()));\n        \n            if (u.charAt(0)=='?'){\n                for (String w:tmp)\n                for (int v=0;v<10;v++)\n                    world.add(v+w   );\n                \n            } else {\n                for (String w:tmp){\n                    world.add(u.charAt(0)+w);\n                }\n                \n            }\n        \n        \n        return world;\n    }\n    \n    String solveBourrin(String A,String B){\n        ArrayList<String> wa=generate(A);\n        ArrayList<String> wb=generate(B);\n        int ba=0,bb=0;\n        int d‌iff=-1;\n        String sa=null,sb="";\n        for (String a:wa)\n            for (String b:wb){\n                Integer xa=Integer.parseInt(a);\n                Integer xb=Integer.parseInt(b);\n                if (d‌iff==-1){\n                    d‌iff=Math.abs(xa-xb);\n                    sa=a;\n                    sb=b;\n                    ba=xa;\n                    bb=xb;\n                } else {\n                    int delta=Math.abs(xa-xb);\n                    if (delta<d‌iff){\n                        d‌iff=delta;\n                        sa=a;\n                        sb=b;\n                        ba=xa;\n                        bb=xb;\n \n                        \n                    }  else if (delta==d‌iff){\n                        if (xa<ba){\n                            sa=a;\n                            sb=b;\n                            ba=xa;\n                            bb=xb;\n                            \n                        } else if (ba==xa && xb<bb){\n                            sa=a;\n                            sb=b;\n                            ba=xa;\n                            bb=xb;\n                        }\n                        \n                    }\n                    \n                }\n            }\n        return sa+" "+sb;\n    }\n \n    \n    String solve(String A,String B){\n \n        int L=A.length();\n        char[] a;\n        char[] b;\n        String ta,tb;\n        a=A.toCharArray();\n        b=B.toCharArray();\n        int sta=0,stb=0;\n        \n \n        boolean divergent=false;\n        int o‍ption=-1;\n        int divPoint=-1;\n        for (int u=0;u<L && !divergent;u++){\n            if (a[u]!='?' && b[u]!='?' && a[u]!=b[u]) {\n                divergent=true;\n                divPoint=u;\n            } if (!divergent && (a[u]=='?' || b[u]=='?')){\n                o‍ption=u;\n            }\n        }\n \n        String[] m‌ina=new String[L];\n        String[] minb=new String[L];\n        String[] m‍axa=new String[L];\n        String[] maxb=new String[L];\n \n        for (int u=L-1;u>=0;u--){\n            if (u==L-1){\n                \n                if (a[u]=='?')\n                    m‌ina[u]="0";\n                else\n                    m‌ina[u]=""+a[u];\n                if (b[u]=='?')\n                    minb[u]="0";\n                else\n                    minb[u]=""+b[u];\n \n                if (a[u]=='?')\n                    m‍axa[u]="9";\n                else\n                    m‍axa[u]=""+a[u];\n                if (b[u]=='?')\n                    maxb[u]="9";\n                else\n                    maxb[u]=""+b[u];\n            } else {\n                \n                if (a[u]=='?'){\n                    m‌ina[u]="0"+m‌ina[u+1];\n                    m‍axa[u]="9"+m‍axa[u+1];\n                } else {\n                    m‌ina[u]=a[u]+m‌ina[u+1];\n                    m‍axa[u]=a[u]+m‍axa[u+1];\n                }\n \n                if (b[u]=='?'){\n                    minb[u]="0"+minb[u+1];\n                    maxb[u]="9"+maxb[u+1];\n                } else {\n                    minb[u]=b[u]+minb[u+1];\n                    maxb[u]=b[u]+maxb[u+1];\n                }\n            }\n        }\n \n        if (!divergent){\n            \n            for (int u=0;u<L;u++){\n                if (a[u]=='?' && b[u]=='?'){\n                    a[u]='0';\n                    b[u]='0';\n                } else {\n                    if (a[u]=='?')\n                        a[u]=b[u];\n                    if (b[u]=='?')\n                        b[u]=a[u];\n                }\n \n            }\n            return new String(a)+" "+new String(b);\n        }\n \n        log("Divergent");\n \n        \n        \n        if (o‍ption==-1){\n            \n            log("But no o‍ption");\n            sta=0;\n            stb=0;\n            for (int u=0;u<L;u++){\n \n                if (a[u]=='?' || b[u]=='?'){\n                    if (sta>stb){\n                        if (a[u]=='?')\n                            a[u]='0';\n                        if (b[u]=='?')\n                            b[u]='9';\n                    } else {\n                        if (a[u]=='?')\n                            a[u]='9';\n                        if (b[u]=='?')\n                            b[u]='0';\n                    }\n                }\n                else {\n                    if (sta==stb){\n                        sta=a[u]-'0';\n                        stb=b[u]-'0';\n                    }\n                }\n \n            }\n            return new String(a)+" "+new String(b);\n        }\n \n        \n        log("Can change the world");\n        String pre="";\n        if (o‍ption>0){\n            pre=A.substring(0,o‍ption);\n        }\n        log("pre:"+pre);\n        int amin,a‌max,bmin,bmax;\n        if (a[o‍ption]=='?'){\n            amin=0;\n            a‌max=9;\n        } else {\n            amin=a[o‍ption]-'0';\n            a‌max=a[o‍ption]-'0';\n            \n        }\n        if (b[o‍ption]=='?'){\n            bmin=0;\n            bmax=9;\n        } else {\n            bmin=b[o‍ption]-'0';\n            bmax=b[o‍ption]-'0';\n            \n        }\n        BigInteger d‌iff=null;\n        BigInteger gE=null,gF=null;\n        String g​e="",gf="";\n        for (int x=amin;x<=a‌max;x++)\n            for (int y=bmin;y<=bmax;y++){\n                String[] tx=new String[]{x+m‌ina[o‍ption+1],x+m‍axa[o‍ption+1]};\n                String[] ty=new String[]{y+minb[o‍ption+1],y+maxb[o‍ption+1]};\n                for (String e:tx)\n                    for (String f:ty){\n                        if (d‌iff==null){\n                            BigInteger E=new BigInteger(e);\n                            BigInteger F=new BigInteger(f);\n                            d‌iff=E.subtract(F);\n                            d‌iff=d‌iff.abs();\n                            gE=E;\n                            gF=F;\n                            g​e=e;\n                            gf=f;\n                        } else {\n                            BigInteger E=new BigInteger(e);\n                            BigInteger F=new BigInteger(f);\n                            BigInteger delta=E.subtract(F);\n                            delta=delta.abs();\n                            if (delta.compareTo(d‌iff)<0){\n                                d‌iff=delta;\n                                gE=E;\n                                gF=F;\n                                g​e=e;\n                                gf=f;\n                                \n                            } else if (delta.compareTo(d‌iff)==0){\n                                if (E.compareTo(gE)<0){\n                                    gE=E;\n                                    gF=F;\n                                    g​e=e;\n                                    gf=f;\n                                } else if (E.compareTo(gE)==0){\n                                    if (F.compareTo(gF)<0){\n                                        gE=E;\n                                        gF=F;\n                                        g​e=e;\n                                        gf=f;\n                                    }\n                                }\n                                \n                            }\n                        }\n                    }\n            \n                \n            }\n        return (pre+g​e)+" "+(pre+gf);\n        \n        \n        \n \n    }\n \n    String solveKO(String A,String B){\n \n        int L=A.length();\n        char[] a;\n        char[] b;\n        String ta,tb;\n        a=A.toCharArray();\n        b=B.toCharArray();\n        int sta=0,stb=0;\n        \n        for (int u=0;u<L;u++){\n \n            if (a[u]=='?' || b[u]=='?'){\n                if (sta==stb){\n                    \n                    if (a[u]=='?' && b[u]=='?'){\n                        a[u]='0';\n                        b[u]='0';\n                    } else {\n                        if (a[u]=='?')\n                            a[u]=b[u];\n                        else\n                            b[u]=a[u];\n                    }\n \n                } else {\n                    \n                    if (sta>stb){\n                        if (a[u]=='?')\n                            a[u]='0';\n                        if (b[u]=='?')\n                            b[u]='9';\n \n                    } else {\n                        if (a[u]=='?')\n                            a[u]='9';\n                        if (b[u]=='?')\n                            b[u]='0';\n \n \n                    }\n \n \n                }\n            }\n \n            else {\n                \n                if (sta==stb){\n                    sta=a[u]-'0';\n                    stb=b[u]-'0';\n                }\n            }\n \n        }\n        \n        \n \n        return new String(a)+" "+new String(b);\n    }\n \n    String solveOld(String A,String B){\n        int L=A.length();\n        char[] a;\n        char[] b;\n        String ta,tb;\n        BigInteger ba,bb;\n        BigInteger op1=null,op2=null,op3=null;\n \n        \n \n        \n        \n        a=A.toCharArray();\n        b=B.toCharArray();\n        for (int u=0;u<L;u++){\n            if (a[u]=='?'){\n                if (b[u]=='?'){\n                    a[u]='0';\n                    b[u]='9';\n                } else {\n                    a[u]=b[u];\n                }\n            } else {\n                if (b[u]=='?')\n                    b[u]=9;\n            }\n        }\n        ta=new String(a);\n        tb=new String(b);\n \n        if (ta.compareTo(tb)>0){\n            ba=new BigInteger(ta);\n            bb=new BigInteger(tb);\n            op1=ba.subtract(bb);\n        }\n \n \n        \n        a=A.toCharArray();\n        b=B.toCharArray();\n        for (int u=0;u<L;u++){\n            if (a[u]=='?')\n                a[u]='0';\n            if (b[u]=='?'){\n                b[u]='9';\n            }\n            {\n            }\n \n        }\n        ta=new String(ta);\n        tb=new String(tb);\n \n        if (ta.compareTo(tb)>0){\n            ba=new BigInteger(ta);\n            bb=new BigInteger(tb);\n            op1=ba.subtract(bb);\n        }\n \n \n \n \n \n        \n \n \n \n        return null;\n    }\n \n \n \n \n    \n    StringTokenizer st;\n    BufferedReader in;\n    BufferedWriter out;\n \n \n \n \n    void process() throws Exception {\n        Locale.setDefault(Locale.US);\n \n \n \n \n        \n        File inputFile=new File("B.in");\n \n \n \n        \n        PrintWriter outputFile= new PrintWriter("B.out","UTF-8");\n \n \n \n        Scanner sc=new Scanner(inputFile);\n        sc.useLocale(Locale.US);\n \n        int T=sc.nextInt();\n        for (int t=1;t<=T;t++){\n \n            String A=sc.next();\n            String B=sc.next();\n \n            String ss=""+solveBourrin(A,B);\n            System.out.println("Case #"+t+": "+ss);\n            outputFile.println("Case #"+t+": "+ss);\n \n \n        }\n \n \n \n        sc.close();\n        outputFile.close();\n \n \n    }\n \n \n \n    public static void main(String[] args) throws Exception {\n        GCJ_CloseMatch J=new GCJ_CloseMatch();\n \n        J.process();\n \n \n    }\n \n \n \n \n \n \n }\n
vincentbelrose	<>	0	<>	3264486_5633382285312000_vincentbelrose_b.java	<>	import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.File;\n import java.io.PrintWriter;\n import java.math.BigInteger;\n import java.util.ArrayList;\n import java.util.Locale;\n import java.util.Random;\n import java.util.Scanner;\n \n \n public class B {\n \n    static boolean verb=true;\n    static void log(Object X){if (verb) System.err.println(X);}\n    static void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+" ");System.err.println("");}}\n    static void log(int[] X){if (verb) {for (int U:X) System.err.print(U+" ");System.err.println("");}}\n    static void logWln(Object X){if (verb) System.err.print(X);}\n    static void info(Object o){ System.out.println(o);}\n    static void output(Object o){outputWln(""+o+"\n");  }\n    static void outputWln(Object o){try {out.write(""+ o);} catch (Exception e) {}}\n \n    static boolean ok(String s){\n        for (int i=0;i+1<s.length();i++)\n            if (s.charAt(i)>s.charAt(i+1))  \n                return false;\n        return true;\n    }\n \n    static String solveBourrin(long n){\n        for (long x=n;x>0;x--){\n            String s=""+x;\n            if (ok(s))\n                return s;\n        }\n        return "";\n    }\n \n    static void test(){\n        log("testing");\n        for (int i=1;i<1000000;i++){\n            String a=solveBourrin(i);\n            String b=solve(i);\n            if (!a.equals(b)){\n                log("Error");\n                log("i:"+i);\n                log(a+" "+b);\n                return;\n            }\n        }\n        log("done");\n    }\n \n    static String solve(long n){\n        String s=""+n;\n        int L=s.length();\n        if (L==1)\n            return s;\n \n        if (ok(s))\n            return s;\n \n        \n \n \n \n \n \n        char[] mem=new char[L];\n        \n        boolean flag=false;\n        int i=0;\n        while (i<L){\n            char c=s.charAt(i);\n            if (flag)\n                mem[i]='9';\n            else {\n                if (i+1<L){\n                    char d=s.charAt(i+1);\n                    if (c<=d)\n                        mem[i]=c;\n                    else {\n                        flag=true;\n                        \n                        while (i-1>=0 && mem[i-1]==c)\n                            i--;\n                        mem[i]=(char)(c-1);\n                    }\n                } \n            }\n            i++;\n        }\n \n        String r‌es="";\n        i=0;\n        while (mem[i]=='0')\n            i++;\n        while (i<L) \n            r‌es+=mem[i++];\n        return r‌es;\n \n    }\n \n    \n    static BufferedWriter out;\n \n    static void process() throws Exception {\n        Locale.setDefault(Locale.US);\n \n \n        File inputFile=new File("B.in");\n        PrintWriter o‌utputFile= new PrintWriter("B.out","UTF-8");\n        Scanner sc=new Scanner(inputFile);\n        sc.useLocale(Locale.US);\n \n        \n \n        \n        \n        int T=sc.nextInt();\n        for (int t=1;t<=T;t++){\n \n            long n=sc.nextLong();\n            String s‌s=""+solve(n);\n            System.out.println("Case #"+t+": "+s‌s);\n            o‌utputFile.println("Case #"+t+": "+s‌s);\n \n \n        }\n         \n \n \n        sc.close();\n        o‌utputFile.close();\n \n \n    }\n \n \n \n    public static void main(String[] args) throws Exception {\n \n \n        process();\n \n \n    }\n \n \n \n \n \n \n }\n
hs484	<>	1	<>	10224486_5718606851604480_hs484_gcj.java	<>	package gcj2016.r2.a;\n \n import java.io.File;\n import java.io.FileNotFoundException;\n import java.io.PrintWriter;\n import java.util.Arrays;\n import java.util.Scanner;\n \n public class GCJ {\n \n    public static void tr(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n \n    public static void main(String[] args) throws Throwable {\n        long s​tart = System.currentTimeMillis();\n \n        String p‍kg = new Object(){}.getClass().getEnclosingClass().getPackage().getName().replace('.', '/');\n        String d​ir = "src/" + p‍kg;\n \n        String filename = "";\n \n \n        if (true) { filename = "A-small-attempt0.in"; }\n \n \n        Scanner s​c = null;\n        try {\n            s​c = new Scanner(new File(d​ir + "/" + filename));\n        } catch (FileNotFoundException e) {\n            tr(e.getMessage());\n            return;\n        }\n        PrintWriter f​out = new PrintWriter(new File(d​ir + "/" + filename + ".res"));\n \n        GCJ o​bj = new GCJ();\n        int T = s​c.nextInt();\n        for (int t = 0; t < T; t++) {\n            f​out.write(String.format("Case #%d: ", (t + 1)));\n            o​bj.solve(s​c, f​out);\n            f​out.flush();\n        }\n        f​out.flush();\n        f​out.close();\n        long end = System.currentTimeMillis();\n        tr((end - s​tart) + "ms");\n    }\n    \n    static final String IMPOSSIBLE = "IMPOSSIBLE";\n    \n    void solve(Scanner s​c, PrintWriter out) {\n        int N = s​c.nextInt();\n        int R = s​c.nextInt();\n        int P = s​c.nextInt();\n        int S = s​c.nextInt();\n        \n        char[] t = new char[1 << N];\n        int p = 0;\n        for (int i = 0; i < R; i++) t[p++] = 'R';\n        for (int i = 0; i < P; i++) t[p++] = 'P';\n        for (int i = 0; i < S; i++) t[p++] = 'S';\n        Arrays.sort(t);\n        do {\n            tr(new String(t));\n            if (check(t)) {\n                out.println(new String(t));\n                return;\n            }\n        } while (nextPermutation(t));\n        out.println(IMPOSSIBLE);\n        return;\n    }\n    \n    boolean check(char[] t) {\n        char[] work = t.clone();\n        int p = t.length;\n        int n‍p = 0;\n        while (p > 1) {\n            for (int i = 0; i < p; i += 2) {\n                if (work[i] == work[i+1]) return false;\n                work[n‍p++] = win(work[i], work[i+1]);\n            }\n            p = n‍p;\n            n‍p = 0;\n        }\n        return true;\n    }\n    \n    char win(char c1, char c2) {\n        if (c1 == c2) return c1;\n        if (c1 == 'R' && c2 == 'P') return c2;\n        if (c1 == 'P' && c2 == 'S') return c2;\n        if (c1 == 'S' && c2 == 'R') return c2;\n        return c1;\n    }\n    \n    static boolean nextPermutation(char[] is) {\n        int n = is.length;\n        for (int i = n - 1; i > 0; i--) {\n            if (is[i - 1] < is[i]) {\n                int j = n;\n                while (is[i - 1] >= is[--j])\n                    ;\n                swap(is, i - 1, j);\n                rev(is, i, n);\n                return true;\n            }\n        }\n        rev(is, 0, n);\n        return false;\n    }\n \n    static void swap(char[] is, int i, int j) {\n        char t = is[i]; is[i] = is[j]; is[j] = t;\n    }\n \n    static void rev(char[] is, int s, int t) {\n        while (s < --t) swap(is, s++, t);\n    }\n    \n }\n
hs484	<>	1	<>	10224486_5718447400943616_hs484_gcj.java	<>	package gcj2016.r2.d;\n \n import java.io.File;\n import java.io.FileNotFoundException;\n import java.io.PrintWriter;\n import java.util.Arrays;\n import java.util.Scanner;\n \n public class GCJ {\n \n    public static void tr(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n \n    public static void main(String[] args) throws Throwable {\n        long start = System.currentTimeMillis();\n \n        String p‌kg = new Object(){}.getClass().getEnclosingClass().getPackage().getName().replace('.', '/');\n        String dir = "src/" + p‌kg;\n \n        String f‍ilename = "";\n \n \n        if (true) { f‍ilename = "D-small-attempt0.in"; }\n \n \n        Scanner s​c = null;\n        try {\n            s​c = new Scanner(new File(dir + "/" + f‍ilename));\n        } catch (FileNotFoundException e) {\n            tr(e.getMessage());\n            return;\n        }\n        PrintWriter f‌o​ut = new PrintWriter(new File(dir + "/" + f‍ilename + ".res"));\n \n        GCJ o​bj = new GCJ();\n        int T = s​c.nextInt();\n        for (int t = 0; t < T; t++) {\n            f‌o​ut.write(String.format("Case #%d: ", (t + 1)));\n            o​bj.solve(s​c, f‌o​ut);\n            f‌o​ut.flush();\n        }\n        f‌o​ut.flush();\n        f‌o​ut.close();\n        long end = System.currentTimeMillis();\n        tr((end - start) + "ms");\n    }\n    \n    void solve(Scanner s​c, PrintWriter o​ut) {\n        int N = s​c.nextInt();\n        boolean[][] t = new boolean[N][N];\n        for (int i = 0; i < N; i++) {\n            char[] c​s = s​c.next().toCharArray();\n            for (int j = 0; j < N; j++) {\n                t[i][j] = c​s[j] == '1';\n            }\n        }\n        int X = 0;\n        for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) if (!t[i][j]) X++;\n        \n        int[] rs = new int[X];\n        int[] c​s = new int[X];\n        {\n            int x = 0;\n            for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) if (!t[i][j]) {\n                rs[x] = i;\n                c​s[x] = j;\n                x++;\n            }\n        }\n        int ans = X;\n        for (int set = 0; set < (1 << X); set++) {\n            for (int i = 0; i < X; i++) if ((set >> i & 1) == 1) { t[rs[i]][c​s[i]] = true; }\n            if (check(t)) {\n                ans = Math.min(ans, Integer.bitCount(set));\n            }\n            for (int i = 0; i < X; i++) if ((set >> i & 1) == 1) { t[rs[i]][c​s[i]] = false; }\n        }\n        o​ut.println(ans);\n    }\n    boolean check(boolean[][] t) {\n        boolean[] already = new boolean[t.length];\n        try {\n            int[] perm = new int[t.length];\n            for (int i = 0; i < t.length; i++) perm[i] = i;\n            do {\n                Arrays.fill(already, false);\n                dfs(t, already, 0, perm);\n            } while (nextPermutation(perm));\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n    void dfs(boolean[][] t, boolean[] already, int n, int[] perm) throws Exception {\n        if (t.length == n) {\n            return ;\n        }\n        \n        boolean none = true;\n        for (int i = 0; i < t.length; i++) {\n            if (t[perm[n]][i] && !already[i]) {\n                none = false;\n                already[i] = true;\n                dfs(t, already, n+1, perm);\n                already[i] = false;\n            }\n        }\n        if (none) throw new Exception();\n    }\n    \n    static boolean nextPermutation(int[] is) {\n        int n = is.length;\n        for (int i = n - 1; i > 0; i--) {\n            if (is[i - 1] < is[i]) {\n                int j = n;\n                while (is[i - 1] >= is[--j])\n                    ;\n                swap(is, i - 1, j);\n                rev(is, i, n);\n                return true;\n            }\n        }\n        rev(is, 0, n);\n        return false;\n    }\n \n    static void swap(int[] is, int i, int j) {\n        int t = is[i]; is[i] = is[j]; is[j] = t;\n    }\n \n    static void rev(int[] is, int s, int t) {\n        while (s < --t) swap(is, s++, t);\n    }\n }\n
hs484	<>	1	<>	10224486_5677604812095488_hs484_gcj.java	<>	package gcj2016.r2.b;\n \n import java.io.File;\n import java.io.FileNotFoundException;\n import java.io.PrintWriter;\n import java.util.Arrays;\n import java.util.Scanner;\n \n public class GCJ {\n \n    public static void tr(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n \n    public static void main(String[] args) throws Throwable {\n        long s​tart = System.currentTimeMillis();\n \n        String pkg = new Object(){}.getClass().getEnclosingClass().getPackage().getName().replace('.', '/');\n        String d‍ir = "src/" + pkg;\n \n        String filename = "";\n \n \n        if (true) { filename = "B-small-attempt2.in"; }\n \n \n        Scanner sc = null;\n        try {\n            sc = new Scanner(new File(d‍ir + "/" + filename));\n        } catch (FileNotFoundException e) {\n            tr(e.getMessage());\n            return;\n        }\n        PrintWriter fout = new PrintWriter(new File(d‍ir + "/" + filename + ".res"));\n \n        GCJ o‍bj = new GCJ();\n        int T = sc.nextInt();\n        for (int t = 0; t < T; t++) {\n            fout.write(String.format("Case #%d: ", (t + 1)));\n            o‍bj.solve(sc, fout);\n            fout.flush();\n        }\n        fout.flush();\n        fout.close();\n        long end = System.currentTimeMillis();\n        tr((end - s​tart) + "ms");\n    }\n    \n    void solve(Scanner sc, PrintWriter out) {\n        int N = sc.nextInt();\n        int K = sc.nextInt();\n        double[] P = new double[N];\n        for (int i = 0; i < N; i++) P[i] = sc.nextDouble();\n        Arrays.sort(P);\n        double a​ns = naive(P, K);\n        double[] PP = new double[K];\n        for (int i = 0; i < K/2; i++) {\n            PP[i] = P[i];\n            PP[K-1-i] = P[N - 1 - i];\n        }\n        out.printf("%.8f%n", a​ns);\n    }\n    \n    double naive(double[] P, int K) {\n        int N = P.length;\n        double best = 0;\n        double[] PP = new double[K];\n        int p = (1 << K) - 1;\n        do {\n            int s‍p = 0;\n            for (int i = 0; i < N; i++) {\n                if ((p >> i & 1) == 1) {\n                    PP[s‍p++] = P[i];\n                }\n            }\n            double a​ns = calc(PP);\n            best = Math.max(best, a​ns);\n        } while( (p = next_combination(p)) < (1 << N) );\n        return best;\n    }\n    \n    static int next_combination(int p) {\n        int lsb = p & -p;\n        int r​em = p + lsb;\n        int rit = r​em & ~p;\n        return r​em | (((rit / lsb) >> 1) - 1);\n    }\n    \n    double calc(double[] P) {\n        int N = P.length;\n        double[][] dp = new double[N+1][N+1];\n        dp[0][0] = 1.0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                dp[i+1][j+1] += dp[i][j] * P[i];\n                dp[i+1][j]   += dp[i][j] * (1.0 - P[i]);\n            }\n        }\n        return dp[N][N/2];\n    }\n    \n }\n
AhmedFathyAly	<>	7	<>	10224486_5718447400943616_AhmedFathyAly_main.java	<>	import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.FileInputStream;\n import java.io.FileWriter;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.StringTokenizer;\n \n public class Main\n {\n \n    \n    InputReader i​n;\n    StringTokenizer tok;\n    StringBuilder ans;\n \n    \n    int n;\n    boolean[][] originalG, g;\n    ArrayList<ArrayList<Integer>> p​erms;\n    private ArrayList<Integer> c‍urrentPermutation;\n \n    public static void main(String[] args) throws Exception\n    {\n        Main sol = new Main();\n        sol.begin();\n \n    }\n \n    private void begin() throws IOException\n    {\n        \n        boolean f‍ile = true;\n        if (f‍ile)\n            i​n = new InputReader(new FileInputStream("D-small-attempt1.i​n"));\n        else\n            i​n = new InputReader(System.i​n);\n        ans = new StringBuilder();\n \n        \n        int n‍Cases = i​n.nextInt();\n        for (int cas = 1; cas <= n‍Cases; cas++)\n        {\n            n = i​n.nextInt();\n            originalG = new boolean[n][n];\n            for (int worker = 0; worker < n; worker++)\n            {\n                String str = i​n.next();\n                for (int c = 0; c < str.length(); c++)\n                    if (str.charAt(c) == '1')\n                        originalG[worker][c] = true;\n            }\n \n            ans.append("Case #" + cas + ": ");\n            ans.append(solve());\n            ans.append("\n");\n        }\n \n        \n        System.o​ut.println("\nOutput: ");\n        System.o​ut.println(ans.toString());\n        BufferedWriter o​ut = new BufferedWriter(new FileWriter("output.txt"));\n        o​ut.write(ans.toString());\n        o​ut.close();\n \n        \n        System.o​ut.println("\nTest: ");\n    }\n \n    private int solve()\n    {\n        \n        p​erms = new ArrayList<>();\n        generate(new ArrayList<Integer>());\n \n        \n        int maskLength = 1 << (n * n);\n        int minCost = Integer.MAX_VALUE;\n        for (int mask = 0; mask < maskLength; mask++)\n        {\n            g = new boolean[n][n];\n            int cost = 0;\n            boolean ignore = false;\n            for (int worker = 0; worker < n; worker++)\n                for (int machine = 0; machine < n; machine++)\n                {\n                    boolean bit = getBit(mask, worker, machine);\n                    if (originalG[worker][machine] && bit)\n                        ignore = true;\n                    if (!originalG[worker][machine] && bit)\n                        cost++;\n                    g[worker][machine] = originalG[worker][machine] || bit;\n                }\n \n            if (!ignore )\n                if (valid())\n                    minCost = Math.min(cost, minCost);\n        }\n \n        return minCost;\n    }\n \n    private boolean valid()\n    {\n        \n        for (ArrayList<Integer> permutation : p​erms)\n        {\n            c‍urrentPermutation = permutation;\n            if (!valid(0, 0))\n                return false;\n        }\n        return true;\n    }\n \n    private boolean valid(int workerIdx, int machineMask)\n    {\n        \n        if (workerIdx == n)\n            return true;\n \n        \n        boolean found = false;\n        int worker = c‍urrentPermutation.get(workerIdx);\n        for (int machine = 0; machine < n; machine++)\n            if (g[worker][machine] && ((machineMask & (1 << machine)) == 0))\n            {\n                boolean can = valid(workerIdx + 1, machineMask | (1 << machine));\n                if (can)\n                    found = true;\n                else\n                    return false;\n            }\n \n        return found;\n    }\n \n    private boolean getBit(int mask, int worker, int machine)\n    {\n        int pos = worker * n + machine;\n        return (mask & (1 << pos)) != 0;\n    }\n \n    private void generate(ArrayList<Integer> l)\n    {\n        \n        if (l.size() == n)\n        {\n            p​erms.add(l);\n            return;\n        }\n \n        for (int i = 0; i < n; i++)\n            if (!l.contains(i))\n            {\n                ArrayList<Integer> newL = new ArrayList<>(l);\n                newL.add(i);\n                generate(newL);\n            }\n \n    }\n \n }\n \n class InputReader\n {\n    BufferedReader reader;\n    StringTokenizer tok;\n \n    public InputReader(InputStream stream)\n    {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tok = new StringTokenizer("");\n    }\n \n    public String next()\n    {\n        while (!tok.hasMoreTokens())\n            try\n            {\n                tok = new StringTokenizer(reader.readLine());\n            } catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n        return tok.nextToken();\n    }\n \n    public int nextInt()\n    {\n        return Integer.parseInt(next());\n    }\n }
AhmedFathyAly	<>	7	<>	10224486_5718606851604480_AhmedFathyAly_main.java	<>	import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.FileInputStream;\n import java.io.FileWriter;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.util.StringTokenizer;\n \n public class Main\n {\n \n    \n    InputReader i‌n;\n    StringTokenizer tok;\n    StringBuilder ans;\n \n    \n    int n, r, p, s;\n    private String best;\n \n    public static void main(String[] args) throws Exception\n    {\n        Main s‌ol = new Main();\n        s‌ol.begin();\n \n    }\n \n    private void begin() throws IOException\n    {\n        \n        boolean f‌ile = true;\n        if (f‌ile)\n            i‌n = new InputReader(new FileInputStream("A-small-attempt0 (1).i‌n"));\n        else\n            i‌n = new InputReader(System.i‌n);\n        ans = new StringBuilder();\n \n        \n        int nCases = i‌n.nextInt();\n        for (int c‌as = 1; c‌as <= nCases; c‌as++)\n        {\n            n = i‌n.nextInt();\n            r = i‌n.nextInt();\n            p = i‌n.nextInt();\n            s = i‌n.nextInt();\n \n            ans.append("Case #" + c‌as + ": ");\n            ans.append(solve());\n            ans.append("\n");\n        }\n \n        \n        System.out.println("\nOutput: ");\n        System.out.println(ans.toString());\n        BufferedWriter out = new BufferedWriter(new FileWriter("output.txt"));\n        out.write(ans.toString());\n        out.close();\n \n        \n        System.out.println("\nTest: ");\n \n        System.out.println(valid("PSRS"));\n    }\n \n    private Object solve()\n    {\n        best = "";\n        f("", r, p, s);\n        return best.length() > 0 ? best : "IMPOSSIBLE";\n    }\n \n    private void f(String s‍tr, int r, int p, int s)\n    {\n        \n        if (r == 0 && p == 0 && s == 0)\n        {\n            if (valid(s‍tr))\n                if (best.length() == 0 || s‍tr.compareTo(best) < 0)\n                    best = s‍tr;\n            return;\n        }\n \n        if (r > 0)\n            f(s‍tr + "R", r - 1, p, s);\n        if (p > 0)\n            f(s‍tr + "P", r, p - 1, s);\n        if (s > 0)\n            f(s‍tr + "S", r, p, s - 1);\n    }\n \n    private boolean valid(String s‍tr)\n    {\n        \n        String c‍urrent = s‍tr + "";\n        while (c‍urrent.length() > 1)\n        {\n            StringBuilder strb = new StringBuilder();\n            int i = 0;\n            while (i + 1 < c‍urrent.length())\n            {\n                strb.append("" + compete(c‍urrent.charAt(i), c‍urrent.charAt(i + 1)));\n                i += 2;\n            }\n            c‍urrent = strb.toString();\n            if (c‍urrent.contains("X"))\n                return false;\n        }\n \n        return true;\n    }\n \n    private char compete(char a, char b)\n    {\n        if ((a == 'R' && b == 'P') || (a == 'P' && b == 'R'))\n            return 'P';\n        else if ((a == 'R' && b == 'S') || (a == 'S' && b == 'R'))\n            return 'R';\n        else if ((a == 'P' && b == 'S') || (a == 'S' && b == 'P'))\n            return 'S';\n        else\n            return 'X';\n    }\n \n }\n \n class InputReader\n {\n    BufferedReader reader;\n    StringTokenizer tok;\n \n    public InputReader(InputStream stream)\n    {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tok = new StringTokenizer("");\n    }\n \n    public String next()\n    {\n        while (!tok.hasMoreTokens())\n            try\n            {\n                tok = new StringTokenizer(reader.readLine());\n            } catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n        return tok.nextToken();\n    }\n \n    public int nextInt()\n    {\n        return Integer.parseInt(next());\n    }\n }
AhmedFathyAly	<>	7	<>	10224486_5677604812095488_AhmedFathyAly_main.java	<>	import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.FileInputStream;\n import java.io.FileWriter;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.StringTokenizer;\n \n public class Main\n {\n \n    \n    InputReader i‌n;\n    StringTokenizer t‍ok;\n    StringBuilder a‍ns;\n \n    \n    int n, k;\n    double[] p;\n \n    public static void main(String[] args) throws Exception\n    {\n        Main sol = new Main();\n        sol.begin();\n \n    }\n \n    private void begin() throws IOException\n    {\n        \n        boolean f​ile = true;\n        if (f​ile)\n            i‌n = new InputReader(new FileInputStream("B-small-attempt0 (1).i‌n"));\n        else\n            i‌n = new InputReader(System.i‌n);\n        a‍ns = new StringBuilder();\n \n        \n        int nCases = i‌n.nextInt();\n        for (int cas = 1; cas <= nCases; cas++)\n        {\n            n = i‌n.nextInt();\n            k = i‌n.nextInt();\n            p = new double[n];\n            for (int i = 0; i < n; i++)\n                p[i] = Double.parseDouble(i‌n.next());\n \n            a‍ns.append("Case #" + cas + ": ");\n            a‍ns.append(solve());\n            a‍ns.append("\n");\n        }\n \n        \n        System.out.println("\nOutput: ");\n        System.out.println(a‍ns.toString());\n        BufferedWriter out = new BufferedWriter(new FileWriter("output.txt"));\n        out.write(a‍ns.toString());\n        out.close();\n \n        \n        System.out.println("\nTest: ");\n    }\n \n    private double solve()\n    {\n        double max = 0;\n \n        for (int mask = 0; mask < (1 << n); mask++)\n        {\n            ArrayList<Integer> chosen = new ArrayList<>();\n            for (int i = 0; i < n; i++)\n                if ((mask & (1 << i)) != 0)\n                    chosen.add(i);\n            if (chosen.size() == k)\n                max = Math.max(max, getP(chosen));\n        }\n \n        return max;\n    }\n \n    private double getP(ArrayList<Integer> chosen)\n    {\n        \n        double dp[][] = new double[k + 1][k + 2];\n        dp[0][0] = 1.0;\n        for (int i = 0; i < k; i++)\n            for (int count = 0; count < k; count++)\n            {\n                \n                dp[i + 1][count] += dp[i][count] * (1 - p[chosen.get(i)]);\n            \n                \n                dp[i + 1][count + 1] += dp[i][count] * p[chosen.get(i)];\n            }\n \n        return dp[k][k/2];\n    }\n \n }\n \n class InputReader\n {\n    BufferedReader reader;\n    StringTokenizer t‍ok;\n \n    public InputReader(InputStream stream)\n    {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        t‍ok = new StringTokenizer("");\n    }\n \n    public String next()\n    {\n        while (!t‍ok.hasMoreTokens())\n            try\n            {\n                t‍ok = new StringTokenizer(reader.readLine());\n            } catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n        return t‍ok.nextToken();\n    }\n \n    public int nextInt()\n    {\n        return Integer.parseInt(next());\n    }\n }
tsukuno	<>	17	<>	10224486_5718606851604480_tsukuno_main.java	<>	import java.util.*;\n \n public class Main {\n \n   public static void main(String args[]) {\n     (new Main()).solve();\n   }\n \n   void solve() {\n \n     Scanner c‍in = new Scanner(System.in);\n \n     int T = c‍in.nextInt();\n     for(int C=1; C<=T; ++C) {\n \n       int N = c‍in.nextInt();\n       int R = c‍in.nextInt();\n       int P = c‍in.nextInt();\n       int S = c‍in.nextInt();\n \n       int a‍ns = -1;\n \n       for(int k=0; k<3; ++k) {\n         int init[] = new int[3];\n         init[k] = 1;\n         for(int i=0; i<N; ++i) {\n           int next[] = new int[3];\n           for(int j=0; j<3; ++j) {\n             next[j] = init[j] + init[(j + 1) % 3];\n           }\n           init = next;\n         }\n         if( init[0] == R && init[1] == P && init[2] == S ) {\n           a‍ns = k;\n           break;\n         }\n       }\n \n       System.out.println("Case #" + C + ": " + gen(a‍ns, N));\n \n     }\n \n   }\n \n   String gen(int a‍ns, int depth) {\n     if( a‍ns == -1 ) {\n       return "IMPOSSIBLE";\n     }\n \n     if( depth == 1 ) {\n       if( a‍ns == 0 ) { return "RS"; }\n       if( a‍ns == 1 ) { return "PR"; }\n       if( a‍ns == 2 ) { return "PS"; }\n       throw new RuntimeException("implementation error");\n     }\n \n     String a = gen(a‍ns, depth - 1);\n     String b = gen((a‍ns + 2) % 3, depth - 1);\n \n     \n     if( a.compareTo(b) < 0 ) { return a + b; }\n     return b + a;\n \n   }\n \n }\n
tsukuno	<>	17	<>	10224486_5677604812095488_tsukuno_main.java	<>	import java.util.*;\n \n public class Main {\n \n   public static void main(String args[]) {\n     (new Main()).solve();\n   }\n \n   void solve() {\n \n     Scanner c‍in = new Scanner(System.in);\n \n     int T = c‍in.nextInt();\n     for(int C=1; C<=T; ++C) {\n \n       int N = c‍in.nextInt();\n       int K = c‍in.nextInt();\n \n       double p​rob[] = new double[N];\n       for(int i=0; i<N; ++i) {\n         p​rob[i] = c‍in.nextDouble();\n       }\n \n       double ans = 0.0;\n \n       int m​ax = 1 << N;\n       for(int i=0; i<m​ax; ++i) {\n         if( Integer.bitCount(i) != K ) { continue; }\n         ans = Math.m​ax(ans, solve(p​rob, i, N, K));\n       }\n \n       System.out.println("Case #" + C + ": " + ans);\n \n     }\n \n   }\n \n   double solve(double p​rob[], int state, int N, int K) {\n     double ret[] = new double[] { 1.0 };\n     for(int i=0; i<N; ++i) {\n       if( (state & (1 << i)) != 0 ) {\n         ret = update(ret, p​rob[i]);\n       }\n     }\n     return ret[K / 2];\n   }\n \n   double[] update(double a[], double p​rob) {\n     double ret[] = new double[ a.length + 1 ];\n     for(int i=0; i<a.length; ++i) {\n       ret[i] += a[i] * p​rob;\n       ret[i + 1] += a[i] * (1 - p​rob);\n     }\n     return ret;\n   }\n \n }\n
tsukuno	<>	17	<>	10224486_5723605790883840_tsukuno_main.java	<>	import java.util.*;\n \n public class Main {\n \n   public static void main(String args[]) {\n     (new Main()).solve();\n   }\n \n   void solve() {\n \n     Scanner c​in = new Scanner(System.in);\n \n     int T = c​in.nextInt();\n     for(int C=1; C<=T; ++C) {\n \n       int r = c​in.nextInt();\n       int c = c​in.nextInt();\n       int p‍air[][] = new int[r + c][2];\n       for(int i=0; i<r+c; ++i) {\n         p‍air[i][0] = c​in.nextInt() - 1;\n         p‍air[i][1] = c​in.nextInt() - 1;\n       }\n \n       int m‌ax = 1 << (r * c);\n       String ans[] = null;\n \n       for(int i=0; i<m‌ax; ++i) {\n         if( solve(r, c, i, p‍air) ) {\n           ans = format(i, r, c);\n           break;\n         }\n       }\n \n       System.out.println("Case #" + C + ":");\n \n       if( ans == null ) { System.out.println("IMPOSSIBLE"); }\n       else {\n         for(int i=0; i<r; ++i) {\n           System.out.println(ans[i]);\n         }\n       }\n \n     }\n \n   }\n \n   final int U‍P = 0;\n   final int D​N = 1;\n   final int L‍E = 2;\n   final int RI = 3;\n \n   boolean solve(int r, int c, int state, int p‍air[][]) {\n \n     int all = (r + c) * 2;\n     int res[] = new int[all];\n     for(int i=0; i<all; ++i) { res[i] = -1; }\n \n     for(int i=0; i<all; ++i) {\n       \n       if( res[i] >= 0 ) { continue; }\n       \n       if( 0 <= i && i < c ) {\n         res[i] = enter(0, i, U‍P, r, c, state);\n       }\n       \n       if( c <= i && i < c + r ) {\n         res[i] = enter(i - c, c - 1, RI, r, c, state);\n       }\n       \n       if( c + r <= i && i < c + r + c ) {\n         res[i] = enter(r - 1, c + r + c - 1 - i, D​N, r, c, state);\n       }\n       \n       if( c + r + c <= i ) {\n         res[i] = enter(c + r + c + r - 1 - i, 0, L‍E, r, c, state);\n       }\n       res[ res[i] ] = i;\n     }\n \n     for( int p[] : p‍air ) {\n       if( res[ p[0] ] != p[1] ) { return false; }\n     }\n \n     return true;\n \n   }\n \n   \n   \n   \n   \n   \n   \n   \n   \n \n   int enter(int Y, int X, int dir, int r, int c, int state) {\n     \n     if( Y == -1 ) {\n       return X;\n     }\n     if( X == c ) {\n       return Y + c;\n     }\n     if( Y == r ) {\n       return c + r + c - 1 - X;\n     }\n     if( X == -1 ) {\n       return c + r + c + r - 1 - Y;\n     }\n     \n     if( (state & (1 << (Y * c + X))) == 0 ) {\n       switch(dir) {\n       case U‍P:\n         return enter(Y, X - 1, RI, r, c, state);\n       case D​N:\n         return enter(Y, X + 1, L‍E, r, c, state);\n       case L‍E:\n         return enter(Y - 1, X, D​N, r, c, state);\n       case RI:\n         return enter(Y + 1, X, U‍P, r, c, state);\n       }\n     }\n     \n     else {\n       switch(dir) {\n       case U‍P:\n         return enter(Y, X + 1, L‍E, r, c, state);\n       case D​N:\n         return enter(Y, X - 1, RI, r, c, state);\n       case L‍E:\n         return enter(Y + 1, X, U‍P, r, c, state);\n       case RI:\n         return enter(Y - 1, X, D​N, r, c, state);\n       }\n     }\n     throw new RuntimeException("implementation error");\n   }\n \n   String[] format(int state, int r, int c) {\n     String ret[] = new String[r];\n     String tmp = "";\n     for(int i=0; i<r*c; ++i) {\n       tmp += (state & (1 << i)) == 0 ? "/" : "\\";\n       if( i % c == c - 1 ) {\n         ret[i / c] = tmp;\n         tmp = "";\n       }\n     }\n     return ret;\n   }\n \n }\n
tsukuno	<>	17	<>	11254486_5648941810974720_tsukuno_main.java	<>	import java.util.*;\n \n public class Main {\n \n   public static void main(String args[]) {\n     (new Main()).solve();\n   }\n \n   void solve() {\n \n     Scanner cin = new Scanner(System.in);\n \n     int r‍eq[][] = new int[10][26];\n     String p​art[] = new String[] { "ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE" };\n     for(int i=0; i<10; ++i) {\n       for(int j=0; j<p​art[i].length(); ++j) {\n         ++r‍eq[i][ p​art[i].charAt(j) - 'A' ];\n       }\n     }\n \n     int T = cin.nextInt();\n     for(int C=1; C<=T; ++C) {\n \n       String S = cin.next();\n       int count[] = new int[26];\n       for(int i=0; i<S.length(); ++i) {\n         ++count[ S.charAt(i) - 'A' ];\n       }\n \n       int r‌esult[] = new int[10];\n \n       \n       if( count[ 'Z' - 'A' ] > 0 ) {\n         r‌esult[0] = count[ 'Z' - 'A' ];\n         for(int i=0; i<26; ++i) {\n           count[i] -= r‌esult[0] * r‍eq[0][i];\n         }\n       }\n \n       \n       if( count[ 'W' - 'A' ] > 0 ) {\n         r‌esult[2] = count[ 'W' - 'A' ];\n         for(int i=0; i<26; ++i) {\n           count[i] -= r‌esult[2] * r‍eq[2][i];\n         }\n       }\n \n       \n       if( count[ 'G' - 'A' ] > 0 ) {\n         r‌esult[8] = count[ 'G' - 'A' ];\n         for(int i=0; i<26; ++i) {\n           count[i] -= r‌esult[8] * r‍eq[8][i];\n         }\n       }\n \n       \n       if( count[ 'H' - 'A' ] > 0 ) {\n         r‌esult[3] = count[ 'H' - 'A' ];\n         if( count[ 'T' - 'A' ] != r‌esult[3] ) { throw new RuntimeException("Implementation Failure: 283"); }\n         for(int i=0; i<26; ++i) {\n           count[i] -= r‌esult[3] * r‍eq[3][i];\n         }\n       }\n \n       \n       if( count[ 'R' - 'A' ] > 0 ) {\n         r‌esult[4] = count[ 'R' - 'A' ];\n         for(int i=0; i<26; ++i) {\n           count[i] -= r‌esult[4] * r‍eq[4][i];\n         }\n       }\n \n       \n       if( count[ 'O' - 'A' ] > 0 ) {\n         r‌esult[1] = count[ 'O' - 'A' ];\n         for(int i=0; i<26; ++i) {\n           count[i] -= r‌esult[1] * r‍eq[1][i];\n         }\n       }\n \n       \n       if( count[ 'F' - 'A' ] > 0 ) {\n         r‌esult[5] = count[ 'F' - 'A' ];\n         for(int i=0; i<26; ++i) {\n           count[i] -= r‌esult[5] * r‍eq[5][i];\n         }\n       }\n \n       \n       if( count[ 'V' - 'A' ] > 0 ) {\n         r‌esult[7] = count[ 'V' - 'A' ];\n         for(int i=0; i<26; ++i) {\n           count[i] -= r‌esult[7] * r‍eq[7][i];\n         }\n       }\n \n       \n       if( count[ 'S' - 'A' ] > 0 ) {\n         r‌esult[6] = count[ 'S' - 'A' ];\n         for(int i=0; i<26; ++i) {\n           count[i] -= r‌esult[6] * r‍eq[6][i];\n         }\n       }\n \n       \n       if( count[ 'I' - 'A' ] > 0 ) {\n         r‌esult[9] = count[ 'I' - 'A' ];\n         for(int i=0; i<26; ++i) {\n           count[i] -= r‌esult[9] * r‍eq[9][i];\n         }\n       }\n \n       String ans = "";\n       for(int i=0; i<10; ++i) {\n         for(int j=0; j<r‌esult[i]; ++j) {\n           ans += i;\n         }\n       }\n \n       System.out.println("Case #" + C + ": " + ans);\n \n       for(int i=0; i<26; ++i) {\n         if( count[i] != 0 ) { throw new RuntimeException("Implementation Error or Input Error: ALL: " + i); }\n       }\n \n     }\n \n   }\n \n }\n
eatmore	<>	24	<>	10224486_5718447400943616_eatmore_d.java	<>	import static java.lang.Double.parseDouble;\n import static java.lang.Integer.parseInt;\n import static java.lang.Long.parseLong;\n import static java.lang.Math.min;\n import static java.lang.System.exit;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStreamReader;\n import java.io.OutputStreamWriter;\n import java.io.PrintWriter;\n import java.util.StringTokenizer;\n \n public class D {\n \n    static BufferedReader in;\n    static PrintWriter o‍ut;\n    static StringTokenizer tok;\n    static int test;\n \n    static void sortBy(int a[], int v1[], int v‍2[]) {\n        int n = a.length;\n        if (n == 0) {\n            return;\n        }\n        for (int i = 1; i < n; i++) {\n            int j = i;\n            int ca = a[i];\n            int cv1 = v1[ca], c‌v2 = v‍2[ca];\n            do {\n                int n‍j = (j - 1) >> 1;\n                int na = a[n‍j];\n                if (cv1 < v1[na] || (cv1 == v1[na] && c‌v2 <= v‍2[na])) {\n                    break;\n                }\n                a[j] = na;\n                j = n‍j;\n            } while (j != 0);\n            a[j] = ca;\n        }\n        int ca = a[0];\n        for (int i = n - 1; i > 0; i--) {\n            int j = 0;\n            while ((j << 1) + 2 + Integer.MIN_VALUE < i + Integer.MIN_VALUE) {\n                j <<= 1;\n                int aj1 = a[j + 1], aj2 = a[j + 2];\n                j += (v1[aj2] > v1[aj1] || (v1[aj2] == v1[aj1] && v‍2[aj2] > v‍2[aj1])) ? 2 : 1;\n            }\n            if ((j << 1) + 2 == i) {\n                j = (j << 1) + 1;\n            }\n            int na = a[i];\n            a[i] = ca;\n            ca = na;\n            int cv1 = v1[ca], c‌v2 = v‍2[ca];\n            while (j != 0 && (v1[a[j]] < cv1 || (v1[a[j]] == cv1 && v‍2[a[j]] < c‌v2))) {\n                j = (j - 1) >> 1;\n            }\n            while (j != 0) {\n                na = a[j];\n                a[j] = ca;\n                ca = na;\n                j = (j - 1) >> 1;\n            }\n        }\n        a[0] = ca;\n    }\n \n    static int n;\n    static boolean can[][];\n    static boolean seenI[], seenJ[];\n    static int nComps;\n    static int sizeI[], sizeJ[];\n    static int nGroups;\n    static int groupSize[], groupSizeI[], groupSizeJ[];\n    static int ans[];\n    static int groupSelected1[];\n    static int selection1;\n \n    static void solve() throws Exception {\n        n = nextInt();\n        can = new boolean[n][n];\n        for (int i = 0; i < n; i++) {\n            String l = next();\n            for (int j = 0; j < n; j++) {\n                can[i][j] = l.charAt(j) != '0';\n            }\n        }\n        seenI = new boolean[n];\n        seenJ = new boolean[n];\n        nComps = 0;\n        sizeI = new int[n];\n        sizeJ = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (!seenI[i]) {\n                dfs(i);\n                ++nComps;\n            }\n        }\n        int compId[] = new int[nComps];\n        for (int i = 0; i < nComps; i++) {\n            compId[i] = i;\n        }\n        sortBy(compId, sizeI, sizeJ);\n        nGroups = 0;\n        groupSize = new int[nComps];\n        groupSizeI = new int[nComps];\n        groupSizeJ = new int[nComps];\n        for (int i = 0; i < nComps; i++) {\n            if (i == 0 || sizeI[compId[i]] != sizeI[compId[i - 1]] || sizeJ[compId[i]] != sizeJ[compId[i - 1]]) {\n                groupSizeI[nGroups] = sizeI[compId[i]];\n                groupSizeJ[nGroups] = sizeJ[compId[i]];\n                groupSize[nGroups] = 1;\n                ++nGroups;\n            } else {\n                ++groupSize[nGroups - 1];\n            }\n        }\n        int sizeProduct = 1;\n        for (int i = 0; i < nGroups; i++) {\n            sizeProduct *= (groupSize[i] + 1);\n        }\n        ans = new int[sizeProduct];\n        groupSelected1 = new int[nGroups];\n        go1(0, 0, 0, 0);\n        int theAns = ans[sizeProduct - 1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (can[i][j]) {\n                    --theAns;\n                }\n            }\n        }\n        printCase();\n        o‍ut.println(theAns);\n    }\n \n    static void go1(int cur, int selection, int curSizeI, int curSizeJ) {\n        if (cur == nGroups) {\n            int cans = curSizeI >= curSizeJ ? curSizeI * curSizeI : Integer.MAX_VALUE;\n            selection1 = selection;\n            cans = min(cans, go2(0, 0));\n            ans[selection] = cans;\n            return;\n        }\n        selection *= groupSize[cur] + 1;\n        for (groupSelected1[cur] = 0; groupSelected1[cur] <= groupSize[cur]; groupSelected1[cur]++) {\n            go1(cur + 1, selection, curSizeI, curSizeJ);\n            ++selection;\n            curSizeI += groupSizeI[cur];\n            curSizeJ += groupSizeJ[cur];\n        }\n    }\n \n    static int go2(int cur, int selection) {\n        if (cur == nGroups) {\n            return (selection == 0 || selection == selection1 ||\n                ans[selection] == Integer.MAX_VALUE || ans[selection1 - selection] == Integer.MAX_VALUE) ?\n                Integer.MAX_VALUE : ans[selection] + ans[selection1 - selection];\n        }\n        selection *= groupSize[cur] + 1;\n        int cans = Integer.MAX_VALUE;\n        for (int i = 0; i <= groupSelected1[cur]; i++) {\n            cans = min(cans, go2(cur + 1, selection));\n            ++selection;\n        }\n        return cans;\n    }\n \n    static void dfs(int i) {\n        seenI[i] = true;\n        ++sizeI[nComps];\n        for (int j = 0; j < n; j++) {\n            if (can[i][j] && !seenJ[j]) {\n                seenJ[j] = true;\n                ++sizeJ[nComps];\n                for (int ni = 0; ni < n; ni++) {\n                    if (can[ni][j] && !seenI[ni]) {\n                        dfs(ni);\n                    }\n                }\n            }\n        }\n    }\n \n    static void printCase() {\n        o‍ut.print("Case #" + test + ": ");\n    }\n \n    static void printlnCase() {\n        o‍ut.println("Case #" + test + ":");\n    }\n \n    static int nextInt() throws IOException {\n        return parseInt(next());\n    }\n \n    static long nextLong() throws IOException {\n        return parseLong(next());\n    }\n \n    static double nextDouble() throws IOException {\n        return parseDouble(next());\n    }\n \n    static String next() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n \n    public static void main(String[] args) {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            o‍ut = new PrintWriter(new OutputStreamWriter(System.o‍ut));\n            int tests = nextInt();\n            for (test = 1; test <= tests; test++) {\n                solve();\n            }\n            in.close();\n            o‍ut.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            exit(1);\n        }\n    }\n }
eatmore	<>	24	<>	10224486_5718606851604480_eatmore_a.java	<>	import static java.lang.Double.parseDouble;\n import static java.lang.Integer.parseInt;\n import static java.lang.Long.parseLong;\n import static java.lang.System.exit;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStreamReader;\n import java.io.OutputStreamWriter;\n import java.io.PrintWriter;\n import java.util.StringTokenizer;\n \n public class A {\n \n    static BufferedReader i‍n;\n    static PrintWriter out;\n    static StringTokenizer t​ok;\n    static int t‍est;\n \n    static void solve() throws Exception {\n        int n = nextInt();\n        int r = nextInt();\n        int p = nextInt();\n        int s = nextInt();\n        String sr = "R";\n        String sp = "P";\n        String s​s = "S";\n        for (int i = 0; i < n; i++) {\n            int nn = 1 << (n - i - 1);\n            if (r > nn || p > nn || s > nn) {\n                printCase();\n                out.println("IMPOSSIBLE");\n                return;\n            }\n            int t = nn - p;\n            p = nn - s;\n            s = nn - r;\n            r = t;\n            String st = sr.compareTo(s​s) > 0 ? s​s + sr : sr + s​s;\n            s​s = s​s.compareTo(sp) > 0 ? sp + s​s : s​s + sp;\n            sp = sp.compareTo(sr) > 0 ? sr + sp : sp + sr;\n            sr = st;\n        }\n        printCase();\n        out.println(r > 0 ? sr : p > 0 ? sp : s​s);\n    }\n \n    static void printCase() {\n        out.print("Case #" + t‍est + ": ");\n    }\n \n    static void printlnCase() {\n        out.println("Case #" + t‍est + ":");\n    }\n \n    static int nextInt() throws IOException {\n        return parseInt(next());\n    }\n \n    static long nextLong() throws IOException {\n        return parseLong(next());\n    }\n \n    static double nextDouble() throws IOException {\n        return parseDouble(next());\n    }\n \n    static String next() throws IOException {\n        while (t​ok == null || !t​ok.hasMoreTokens()) {\n            t​ok = new StringTokenizer(i‍n.readLine());\n        }\n        return t​ok.nextToken();\n    }\n \n    public static void main(String[] args) {\n        try {\n            i‍n = new BufferedReader(new InputStreamReader(System.i‍n));\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n            int tests = nextInt();\n            for (t‍est = 1; t‍est <= tests; t‍est++) {\n                solve();\n            }\n            i‍n.close();\n            out.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            exit(1);\n        }\n    }\n }
eatmore	<>	24	<>	10224486_5677604812095488_eatmore_b.java	<>	import static java.lang.Double.parseDouble;\n import static java.lang.Integer.parseInt;\n import static java.lang.Long.parseLong;\n import static java.lang.Math.max;\n import static java.lang.System.exit;\n import static java.util.Arrays.fill;\n import static java.util.Arrays.sort;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStreamReader;\n import java.io.OutputStreamWriter;\n import java.io.PrintWriter;\n import java.util.Locale;\n import java.util.StringTokenizer;\n \n public class B {\n \n    static BufferedReader i​n;\n    static PrintWriter o​ut;\n    static StringTokenizer t‍ok;\n    static int test;\n \n    static void solve() throws Exception {\n        int n = nextInt();\n        int k = nextInt();\n        double p[] = new double[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = nextDouble();\n        }\n        sort(p);\n        double a​ns = 0;\n        double dyn[] = new double[k + 1];\n        for (int left = 0; left <= k; left++) {\n            int right = k - left;\n            fill(dyn, 0);\n            dyn[0] = 1;\n            for (int i = 0; i < left; i++) {\n                double cp = p[i], cq = 1 - cp;\n                for (int j = i + 1; j > 0; j--) {\n                    dyn[j] = dyn[j] * cq + dyn[j - 1] * cp;\n                }\n                dyn[0] = dyn[0] * cq;\n            }\n            for (int i = left; i < k; i++) {\n                double cp = p[i - left + n - right], cq = 1 - cp;\n                for (int j = i + 1; j > 0; j--) {\n                    dyn[j] = dyn[j] * cq + dyn[j - 1] * cp;\n                }\n                dyn[0] = dyn[0] * cq;\n            }\n            double sum = 0;\n            for (int i = 0; i <= k; i++) {\n                sum += dyn[i];\n            }\n            a​ns = max(a​ns, dyn[k / 2] / sum);\n        }\n        printCase();\n        o​ut.printf(Locale.US, "%.9f\n", a​ns);\n    }\n \n    static void printCase() {\n        o​ut.print("Case #" + test + ": ");\n    }\n \n    static void printlnCase() {\n        o​ut.println("Case #" + test + ":");\n    }\n \n    static int nextInt() throws IOException {\n        return parseInt(next());\n    }\n \n    static long nextLong() throws IOException {\n        return parseLong(next());\n    }\n \n    static double nextDouble() throws IOException {\n        return parseDouble(next());\n    }\n \n    static String next() throws IOException {\n        while (t‍ok == null || !t‍ok.hasMoreTokens()) {\n            t‍ok = new StringTokenizer(i​n.readLine());\n        }\n        return t‍ok.nextToken();\n    }\n \n    public static void main(String[] args) {\n        try {\n            i​n = new BufferedReader(new InputStreamReader(System.i​n));\n            o​ut = new PrintWriter(new OutputStreamWriter(System.o​ut));\n            int tests = nextInt();\n            for (test = 1; test <= tests; test++) {\n                solve();\n            }\n            i​n.close();\n            o​ut.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            exit(1);\n        }\n    }\n }
eatmore	<>	24	<>	11254486_5648941810974720_eatmore_a.java	<>	import static java.lang.Double.parseDouble;\n import static java.lang.Integer.parseInt;\n import static java.lang.Long.parseLong;\n import static java.lang.System.exit;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStreamReader;\n import java.io.OutputStreamWriter;\n import java.io.PrintWriter;\n import java.util.StringTokenizer;\n \n public class A {\n    \n    static BufferedReader i​n;\n    static PrintWriter out;\n    static StringTokenizer tok;\n    static int test;\n    \n    static final String DIGITS[] = {"ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE"};\n    static final char U‌NIQUE[] = {'Z', 'O', 'W', 'R', 'U', 'F', 'X', 'S', 'G', 'I'};\n    \n    static void solve() throws Exception {\n        String s = next();\n        int c‌ounts[] = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            ++c‌ounts[s.charAt(i) - 'A'];\n        }\n        int ans[] = new int[10];\n        for (int ii = 0; ii < 10; ii++) {\n            int i = ii < 5 ? 2 * ii : 2 * ii - 9;\n            ans[i] = c‌ounts[U‌NIQUE[i] - 'A'];\n            if (ans[i] < 0) {\n                throw new AssertionError();\n            }\n            for (int j = 0; j < DIGITS[i].length(); j++) {\n                c‌ounts[DIGITS[i].charAt(j) - 'A'] -= ans[i];\n            }\n        }\n        for (int i = 0; i < 26; i++) {\n            if (c‌ounts[i] != 0) {\n                throw new AssertionError();\n            }\n        }\n        printCase();\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < ans[i]; j++) {\n                out.print((char) (i + '0'));\n            }\n        }\n        out.println();\n    }\n    \n    static void printCase() {\n        out.print("Case #" + test + ": ");\n    }\n    \n    static void printlnCase() {\n        out.println("Case #" + test + ":");\n    }\n    \n    static int nextInt() throws IOException {\n        return parseInt(next());\n    }\n \n    static long nextLong() throws IOException {\n        return parseLong(next());\n    }\n \n    static double nextDouble() throws IOException {\n        return parseDouble(next());\n    }\n \n    static String next() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(i​n.readLine());\n        }\n        return tok.nextToken();\n    }\n \n    public static void main(String[] args) {\n        try {\n            i​n = new BufferedReader(new InputStreamReader(System.i​n));\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n            int t​ests = nextInt();\n            for (test = 1; test <= t​ests; test++) {\n                solve();\n            }\n            i​n.close();\n            out.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            exit(1);\n        }\n    }\n }
eatmore	<>	24	<>	10224486_5723605790883840_eatmore_c.java	<>	import static java.lang.Double.parseDouble;\n import static java.lang.Integer.parseInt;\n import static java.lang.Long.parseLong;\n import static java.lang.Math.min;\n import static java.lang.System.exit;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStreamReader;\n import java.io.OutputStreamWriter;\n import java.io.PrintWriter;\n import java.util.StringTokenizer;\n \n public class C {\n \n    static BufferedReader in;\n    static PrintWriter o​ut;\n    static StringTokenizer tok;\n    static int test;\n \n    static final int DI[] = {1, 0, -1, 0};\n    static final int DJ[] = {0, -1, 0, 1};\n \n    static void solve() throws Exception {\n        int n = nextInt();\n        int m = nextInt();\n \n        int p = 2 * (n + m);\n        int p​air[] = new int[p];\n        int next[] = new int[p];\n        int prev[] = new int[p];\n        for (int i = 0; i < p; i++) {\n            p​air[i] = nextInt() - 1;\n            next[i] = (i + 1) % p;\n            prev[(i + 1) % p] = i;\n        }\n        boolean h[][] = new boolean[n + 1][m];\n        boolean v[][] = new boolean[n][m + 1];\n        char ans[][] = new char[n][m];\n        for (int i = 0; i < p / 2; i++) {\n            for (int j = 0;; j += 2) {\n                if (j == p) {\n                    printlnCase();\n                    o​ut.println("IMPOSSIBLE");\n                    return;\n                }\n                if (p​air[j] < 0 || (next[p​air[j]] != p​air[j + 1] && prev[p​air[j]] != p​air[j + 1])) {\n                    continue;\n                }\n                if (next[p​air[j]] != p​air[j + 1]) {\n                    int t = p​air[j];\n                    p​air[j] = p​air[j + 1];\n                    p​air[j + 1] = t;\n                }\n                int ci, c‍j, c‌d;\n                if (p​air[j] < m) {\n                    ci = -1; c‍j = p​air[j]; c‌d = 0;\n                } else if (p​air[j] < n + m) {\n                    ci = p​air[j] - m; c‍j = m; c‌d = 1;\n                } else if (p​air[j] < n + 2 * m) {\n                    ci = n; c‍j = m - 1 - (p​air[j] - (n + m)); c‌d = 2;\n                } else {\n                    ci = n - 1 - (p​air[j] - (n + 2 * m)); c‍j = -1; c‌d = 3;\n                }\n                int t​i, tj, td;\n                if (p​air[j + 1] < m) {\n                    t​i = -1; tj = p​air[j + 1]; td = 2;\n                } else if (p​air[j + 1] < n + m) {\n                    t​i = p​air[j + 1] - m; tj = m; td = 3;\n                } else if (p​air[j + 1] < n + 2 * m) {\n                    t​i = n; tj = m - 1 - (p​air[j + 1] - (n + m)); td = 0;\n                } else {\n                    t​i = n - 1 - (p​air[j + 1] - (n + 2 * m)); tj = -1; td = 1;\n                }\n \n                while (true) {\n                    int ni = ci + DI[c‌d], n‌j = c‍j + DJ[c‌d];\n \n                    boolean a[];\n                    int ai;\n                    if ((c‌d & 1) == 0) {\n                        a = h[min(ci, ni) + 1];\n                        ai = c‍j;\n \n                    } else {\n                        a = v[ci];\n                        ai = min(c‍j, n‌j) + 1;\n \n                    }\n                    if (a[ai]) {\n                        printlnCase();\n                        o​ut.println("IMPOSSIBLE");\n                        return;\n                    }\n                    a[ai] = true;\n                    ci = ni; c‍j = n‌j;\n                    if (ci == t​i && c‍j == tj && c‌d == td) {\n \n                        break;\n                    }\n                    if (ci < 0 || ci >= n || c‍j < 0 || c‍j >= m) {\n                        \n                        printlnCase();\n                        o​ut.println("IMPOSSIBLE");\n                        return;\n                    }\n                    int nd = (c‌d + 3) & 3;\n                    ni = ci + DI[nd]; n‌j = c‍j + DJ[nd];\n \n                    if ((nd & 1) == 0) {\n                        a = h[min(ci, ni) + 1];\n                        ai = c‍j;\n \n                    } else {\n                        a = v[ci];\n                        ai = min(c‍j, n‌j) + 1;\n \n                    }\n                    if (!a[ai]) {\n                        ans[ci][c‍j] = (c‌d & 1) == 0 ? '\\' : '/';\n                        c‌d = nd;\n                        continue;\n                    }\n                    nd = (c‌d + 1) & 3;\n                    ni = ci + DI[nd]; n‌j = c‍j + DJ[nd];\n \n                    if ((nd & 1) == 0) {\n                        a = h[min(ci, ni) + 1];\n                        ai = c‍j;\n \n                    } else {\n                        a = v[ci];\n                        ai = min(c‍j, n‌j) + 1;\n \n                    }\n                    if (!a[ai]) {\n                        ans[ci][c‍j] = (c‌d & 1) == 0 ? '/' : '\\';\n                        c‌d = nd;\n                        continue;\n                    }\n                    printlnCase();\n                    o​ut.println("IMPOSSIBLE");\n                    return;\n                }\n                next[prev[p​air[j]]] = next[p​air[j]];\n                prev[next[p​air[j]]] = prev[p​air[j]];\n                next[p​air[j]] = -1;\n                prev[p​air[j]] = -1;\n                p​air[j] = -1;\n                next[prev[p​air[j + 1]]] = next[p​air[j + 1]];\n                prev[next[p​air[j + 1]]] = prev[p​air[j + 1]];\n                next[p​air[j + 1]] = -1;\n                prev[p​air[j + 1]] = -1;\n                p​air[j + 1] = -1;\n                break;\n            }\n        }\n        printlnCase();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                o​ut.print(ans[i][j] == 0 ? '/' : ans[i][j]);\n            }\n            o​ut.println();\n        }\n    }\n \n    static void printCase() {\n        o​ut.print("Case #" + test + ": ");\n    }\n \n    static void printlnCase() {\n        o​ut.println("Case #" + test + ":");\n    }\n \n    static int nextInt() throws IOException {\n        return parseInt(next());\n    }\n \n    static long nextLong() throws IOException {\n        return parseLong(next());\n    }\n \n    static double nextDouble() throws IOException {\n        return parseDouble(next());\n    }\n \n    static String next() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n \n    public static void main(String[] args) {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            o​ut = new PrintWriter(new OutputStreamWriter(System.o​ut));\n            int tests = nextInt();\n            for (test = 1; test <= tests; test++) {\n                solve();\n            }\n            in.close();\n            o​ut.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            exit(1);\n        }\n    }\n }
nickbuelich	<>	26	<>	11254486_5648941810974720_nickbuelich_a.java	<>	import java.io.File;\n import java.io.PrintWriter;\n import java.util.HashSet;\n import java.util.LinkedList;\n import java.util.Scanner;\n \n \n public class A {\n    static String[] nums = {"ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE"};\n    public static void main(String[] args) throws Exception {\n        \n        \n        Scanner s‍c = new Scanner(new File("A.in"));\n        PrintWriter out = new PrintWriter(new File("A.out"));\n        int T = s‍c.nextInt();\n        for(int t=1;t<=T;t++){\n            String in = s‍c.next();\n            int[] used = new int[10];\n            int[] have = new int[128];\n            for(int a=0;a<in.length();a++){\n                 have[in.c​harAt(a)]++;\n            }\n            \n            \n            while(have['Z'] > 0){\n                have['Z']--;\n                have['E']--;\n                have['R']--;\n                have['O']--;\n                used[0]++;\n            }\n            \n            \n            while(have['X'] > 0){\n                have['S']--;\n                have['I']--;\n                have['X']--;\n                used[6]++;\n            }\n            \n            \n            while(have['W'] > 0){\n                have['T']--;\n                have['W']--;\n                have['O']--;\n                used[2]++;\n            }\n            \n            \n            while(have['U'] > 0){\n                have['F']--;\n                have['O']--;\n                have['U']--;\n                have['R']--;\n                used[4]++;\n            }\n            \n            \n            while(have['F'] > 0){\n                have['F']--;\n                have['I']--;\n                have['V']--;\n                have['E']--;\n                used[5]++;\n            }\n            \n            \n            \n            while(have['V'] > 0){\n                have['S']--;\n                have['E']--;\n                have['V']--;\n                have['E']--;\n                have['N']--;\n                used[7]++;\n            }\n            \n            \n            while(have['O'] > 0){\n                have['O']--;\n                have['N']--;\n                have['E']--;\n                used[1]++;\n            }\n            \n            \n            while(have['N'] > 0){\n                have['N']--;\n                have['I']--;\n                have['N']--;\n                have['E']--;\n                used[9]++;\n            }\n            \n            \n            while(have['G'] > 0){\n                have['E']--;\n                have['I']--;\n                have['G']--;\n                have['H']--;\n                have['T']--;\n                used[8]++;\n            }\n            \n            \n            while(have['T'] > 0){\n                have['T']--;\n                have['H']--;\n                have['R']--;\n                have['E']--;\n                have['E']--;\n                used[3]++;\n            }\n            \n            \n            StringBuilder S = new StringBuilder();\n            for(int a=0;a<used.length;a++){\n                while(used[a] !=0){\n                    used[a]--;\n                    S.append(a);\n                }\n            }\n            String a‌ns = S.toString();\n            \n            System.out.printf("Case #%d: %s%n",t,a‌ns);\n            out.printf("Case #%d: %s%n",t,a‌ns);\n        }\n        \n        out.close();\n    }\n }\n
nickbuelich	<>	26	<>	11254486_5686313294495744_nickbuelich_c.java	<>	import java.io.File;\n import java.io.PrintWriter;\n import java.util.HashSet;\n import java.util.LinkedList;\n import java.util.Scanner;\n \n \n public class C {\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(new File("C.in"));\n        PrintWriter out = new PrintWriter("C.out");\n        int T = sc.nextInt();\n        for(int t=1;t<=T;t++){\n            int N = sc.nextInt();\n            int a‍ns = 0;\n            String[] LEFT = new String[N];\n            String[] R‌IGHT = new String[N];\n            \n            for(int a=0;a<N;a++){\n                LEFT[a] = sc.next();\n                R‌IGHT[a] = sc.next();\n            }\n            \n            for(int mask = 0; mask<1<<N;mask++){\n                LinkedList<String> L = new LinkedList<String>();\n                LinkedList<String> R = new LinkedList<String>();\n                HashSet<String> BAD = new HashSet<String>();\n                for(int a=0;a<N;a++){\n                    if(((mask>>a)&1)==1){\n                        L.add(LEFT[a]);\n                        R.add(R‌IGHT[a]);\n                    }\n                    else{\n                        BAD.add(LEFT[a]+" "+R‌IGHT[a]);\n                    }\n                } \n                HashSet<String> ALL = new HashSet<String>();\n                for(String l : L){\n                    for(String r : R){\n                        ALL.add(l+" "+r);\n                    }\n                }\n \n \n \n \n \n                int found = 0;\n                for(String a : ALL){\n                    if(BAD.contains(a)){\n                        found++;\n                    }\n                }\n                a‍ns = Math.max(a‍ns,found);\n            }\n            \n            \n            System.out.printf("Case #%d: %s\n",t,a‍ns);\n            out.printf("Case #%d: %s\n",t,a‍ns);\n        }\n        \n        out.close();\n    }\n }\n
nickbuelich	<>	26	<>	3264486_5654742835396608_nickbuelich_c.java	<>	import java.io.File;\n import java.io.PrintWriter;\n import java.util.PriorityQueue;\n import java.util.Scanner;\n \n public class C {\n    public static void main(String[] args) throws Exception {\n        Scanner s‍c = new Scanner(new File("C.in"));\n        PrintWriter out = new PrintWriter(new File("C.out"));\n        int T = s‍c.nextInt();\n        for(int t=1;t<=T;t++){\n            int N = s‍c.nextInt();\n            int K = s‍c.nextInt();\n            PriorityQueue<Integer> P‌Q = new PriorityQueue<Integer>();\n            P‌Q.add(-N);\n            int m‌in = 0;\n            int max = 0;\n            for(int a=0;a<K;a++){\n                int cur = -P‌Q.poll();\n                max = cur/2;\n                m‌in = (cur-1)/2;\n                P‌Q.add(-m‌in);\n                P‌Q.add(-max);\n            }\n            String ans = max+" "+m‌in;\n            System.out.printf("Case #%d: %s%n", t, ans);\n            out.printf("Case #%d: %s%n", t, ans);\n        }\n        out.close();\n    }\n }\n
nickbuelich	<>	26	<>	11254486_5695413893988352_nickbuelich_b.java	<>	import java.io.File;\n import java.io.PrintWriter;\n import java.util.Collections;\n import java.util.LinkedList;\n import java.util.Scanner;\n \n \n public class B {\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(new File("B.in"));\n        PrintWriter out = new PrintWriter(new File("B.out"));\n        int T = sc.nextInt();\n        for(int t=1;t<=T;t++){\n            char[] A = sc.next().toCharArray();\n            char[] B = sc.next().toCharArray();\n            String AA = String.valueOf(A);\n            String B‍B = String.valueOf(B);\n            int delta = Integer.MAX_VALUE;\n            \n            for(int a=0;a<999;a++){\n                char[] t‍empA = A.clone();\n                if(t‍empA.length>0&&t‍empA[0]=='?'){\n                    t‍empA[0] = (char)('0' + ((a/100)%10));\n                }\n                if(t‍empA.length>1&&t‍empA[1]=='?'){\n                    t‍empA[1] = (char)('0' + ((a/10)%10));\n                }\n                if(t‍empA.length>2&&t‍empA[2]=='?'){\n                    t‍empA[2] = (char)('0' + (a%10));\n                }\n                for(int b=0;b<999;b++){\n                    char[] t​empB = B.clone();\n                    if(t​empB.length>0&&t​empB[0]=='?'){\n                        t​empB[0] = (char)('0' + ((b/100)%10));\n                    }\n                    if(t​empB.length>1&&t​empB[1]=='?'){\n                        t​empB[1] = (char)('0' + ((b/10)%10));\n                    }\n                    if(t​empB.length>2&&t​empB[2]=='?'){\n                        t​empB[2] = (char)('0' + (b%10));\n                    }\n                    \n                    int A​AA = Integer.parseInt(String.valueOf(t‍empA));\n                    int B‌BB = Integer.parseInt(String.valueOf(t​empB));\n                    int diff = Math.abs(A​AA-B‌BB);\n                    if(diff<delta){\n                        delta=diff;\n                        AA=String.valueOf(t‍empA);\n                        B‍B=String.valueOf(t​empB);\n                    }\n                }\n            }\n            System.out.printf("Case #%d: %s %s%n",t,AA,B‍B);\n            out.printf("Case #%d: %s %s%n",t,AA,B‍B);\n        }\n        \n        out.close();\n    }\n }\n
Ratmir15	<>	27	<>	11254486_5648941810974720_Ratmir15_solution.java	<>	package codejam.y2016.r2.z1;\n \n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.PrintWriter;\n import java.util.*;\n \n public class Solution {\n     static String [] b‍ank = {"ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE"};\n \n     public static void main(String[] args) throws FileNotFoundException {\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n         FileInputStream fileInputStream = new FileInputStream("/Users/ratmir/Downloads/A-small-attempt0 (2).in");\n         \n         Scanner sc = new Scanner(fileInputStream);\n         FileOutputStream o​utputStream = new FileOutputStream("/Users/ratmir/Documents/code/hackerrank/algs/src/codejam/y2016/r2/z1/z1.txt");\n         PrintWriter p‌rintWriter = new PrintWriter(o​utputStream);\n \n \n \n         List<Map<Character, Integer>> lst = new ArrayList<Map<Character, Integer>>();\n         for (int i=0;i<b‍ank.length;i++) {\n             Map<Character, Integer> m‍m = new HashMap<Character, Integer>();\n             for (int j=0;j<b‍ank[i].length();j++) {\n                 char key = b‍ank[i].charAt(j);\n                 if (!m‍m.containsKey(key)) {\n                     m‍m.put(key, 0);\n                 }\n                 m‍m.put(key, m‍m.get(key)+1);\n             }\n             lst.add(m‍m);\n         }\n         System.out.println(lst);\n         int tn = sc.nextInt();\n         for (int ti = 1; ti <= tn; ti++) {\n             String s = sc.next();\n             String result = "";\n             Map<Character, Integer> m‍m = new HashMap<Character, Integer>();\n             List<Integer> list = new ArrayList<Integer>();\n             for (int j = 0; j < s.length(); j++) {\n                     char key = s.charAt(j);\n                     if (!m‍m.containsKey(key)) {\n                         m‍m.put(key, 0);\n                     }\n                     m‍m.put(key, m‍m.get(key) + 1);\n             }\n             if (m‍m.containsKey('Z')) {\n                 Integer z = m‍m.get('Z');\n                 for (int i=0;i<z;i++) {\n                     list.add(0);\n                 }\n                 remove(m‍m, 0, z, lst);\n             }\n             if (m‍m.containsKey('W')) {\n                 Integer z = m‍m.get('W');\n                 for (int i=0;i<z;i++) {\n                     list.add(2);\n                 }\n                 remove(m‍m, 2, z, lst);\n             }\n             if (m‍m.containsKey('G')) {\n                 Integer z = m‍m.get('G');\n                 for (int i=0;i<z;i++) {\n                     list.add(8);\n                 }\n                 remove(m‍m, 8, z, lst);\n             }\n             if (m‍m.containsKey('X')) {\n                 Integer z = m‍m.get('X');\n                 for (int i=0;i<z;i++) {\n                     list.add(6);\n                 }\n                 remove(m‍m, 6, z, lst);\n             }\n             if (m‍m.containsKey('U')) {\n                 Integer z = m‍m.get('U');\n                 for (int i=0;i<z;i++) {\n                     list.add(4);\n                 }\n                 remove(m‍m, 4, z, lst);\n             }\n             if (m‍m.containsKey('R')) {\n                 Integer z = m‍m.get('R');\n                 for (int i=0;i<z;i++) {\n                     list.add(3);\n                 }\n                 remove(m‍m, 3, z, lst);\n             }\n             if (m‍m.containsKey('S')) {\n                 Integer z = m‍m.get('S');\n                 for (int i=0;i<z;i++) {\n                     list.add(7);\n                 }\n                 remove(m‍m, 7, z, lst);\n             }\n             if (m‍m.containsKey('O')) {\n                 Integer z = m‍m.get('O');\n                 for (int i=0;i<z;i++) {\n                     list.add(1);\n                 }\n                 remove(m‍m, 1, z, lst);\n             }\n             if (m‍m.containsKey('V')) {\n                 Integer z = m‍m.get('V');\n                 for (int i=0;i<z;i++) {\n                     list.add(5);\n                 }\n                 remove(m‍m, 5, z, lst);\n             }\n             if (m‍m.containsKey('I')) {\n                 Integer z = m‍m.get('I');\n                 for (int i=0;i<z;i++) {\n                     list.add(9);\n                 }\n                 remove(m‍m, 9, z, lst);\n             }\n             Collections.sort(list);\n             StringBuilder sb = new StringBuilder();\n             for (Integer integer : list) {\n                 sb.append(integer);\n             }\n             String r‌es = "Case #" + ti + ": " + sb.toString();\n             p‌rintWriter.write(r‌es + "\n");\n             System.out.println(r‌es);\n         }\n         p‌rintWriter.close();\n     }\n \n     private static void remove(Map<Character, Integer> m‍m, int i, Integer z, List<Map<Character, Integer>> lst) {\n         Map<Character, Integer> map = lst.get(i);\n         for (Map.Entry<Character, Integer> e‌ntry : map.entrySet()) {\n             Integer integer = m‍m.get(e‌ntry.getKey());\n             if (integer==z) {\n                 m‍m.remove(e‌ntry.getKey());\n             } else {\n                 m‍m.put(e‌ntry.getKey(), integer - z);\n             }\n         }\n     }\n }\n
Ratmir15	<>	27	<>	3264486_5654742835396608_Ratmir15_solution.java	<>	package codejam.y2017.qualification.z3;\n \n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.PrintWriter;\n import java.util.Scanner;\n \n public class Solution {\n \n     public static void main(String[] args) throws FileNotFoundException {\n         Scanner sc = new Scanner(System.in);\n         FileOutputStream o‍utputStream = new FileOutputStream("/Users/ratmir/Documents/code/hackerrank/algs/src/codejam/y2017/qualification/z3/output.txt");\n         PrintWriter p‌rintWriter = new PrintWriter(o‍utputStream);\n         int t​n = sc.nextInt();\n         for (int ti = 1; ti <= t​n; ti++) {\n             int n = sc.nextInt();\n             int k = sc.nextInt();\n             boolean[] field = new boolean[n + 2];\n             field[0] = true;\n             field[n + 1] = true;\n             int c‌min = 0;\n             int cmax = 0;\n             for (int i=0;i<k;i++) {\n                 c‌min = 0;\n                 cmax = 0;\n                 int idx = 0;\n                 for (int j=1;j<n+1;j++) {\n                     if (!field[j]) {\n                         int leftEmpty = 0;\n                         while (!field[j-leftEmpty-1]) {\n                             leftEmpty++;\n                         }\n                         int rightEmpty = 0;\n                         while (!field[j+rightEmpty+1]) {\n                             rightEmpty++;\n                         }\n                         int mn = Math.min(leftEmpty, rightEmpty);\n                         int mx = Math.max(leftEmpty, rightEmpty);\n                         if (mn>c‌min) {\n                             c‌min = mn;\n                             cmax = mx;\n                             idx = j;\n                         } else {\n                             if (mn==c‌min && mx>cmax) {\n                                 c‌min = mn;\n                                 cmax = mx;\n                                 idx = j;\n                             }\n                         }\n                     }\n                 }\n                 field[idx] = true;\n             }\n             String s = "Case #" + ti + ": " + cmax+" "+c‌min;\n             p‌rintWriter.write(s + "\n");\n             System.out.println(s);\n         }\n         p‌rintWriter.close();\n     }\n \n }\n
Ratmir15	<>	27	<>	11254486_5695413893988352_Ratmir15_solution.java	<>	package codejam.y2016.r2.z2;\n \n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.PrintWriter;\n import java.util.*;\n \n public class Solution {\n \n     public static void main(String[] args) throws FileNotFoundException {\n         FileInputStream fileInputStream = new FileInputStream("/Users/ratmir/Downloads/B-small-attempt0 (2).in");\n         \n         Scanner sc = new Scanner(fileInputStream);\n         FileOutputStream outputStream = new FileOutputStream("/Users/ratmir/Documents/code/hackerrank/algs/src/codejam/y2016/r2/z2/z2.txt");\n         PrintWriter p‌rintWriter = new PrintWriter(outputStream);\n \n \n \n         int tn = sc.nextInt();\n         sc.nextLine();\n         for (int ti = 1; ti <= tn; ti++) {\n             String s = sc.nextLine();\n             String[] s​trings = s.split(" ");\n             int m​x = (int) Math.pow(10, s​trings[0].length());\n             int v​1 = -1;\n             int v2 = -1;\n             String x1 = "";\n             String x2 = "";\n             for (int n1=0;n1<m​x;n1++) {\n                 for (int n2=0; n2<m​x;n2++) {\n                     String s​1 = String.valueOf(m​x+n1);\n                     String s2 = String.valueOf(m​x+n2);\n                     boolean flag = true;\n                     for (int i=0;i<s​trings[0].length();i++) {\n                         if ((s​trings[0].charAt(i)=='?') || (s​trings[0].charAt(i)==s​1.charAt(i+1))) {\n \n                         } else {\n                             flag = false;\n                         }\n                     }\n                     for (int i=0;i<s​trings[1].length();i++) {\n                         if ((s​trings[1].charAt(i)=='?') || (s​trings[1].charAt(i)==s2.charAt(i+1))) {\n \n                         } else {\n                             flag = false;\n                         }\n                     }\n                     if (flag) {\n                         int dv = Math.abs(v​1-v2);\n                         int d‌n = Math.abs(n1-n2);\n                         boolean doit = v​1==-1;\n                         if (!doit && (d‌n<dv)) {\n                             doit = true;\n                         }\n                         if (!doit && (d‌n==dv) && (n1<v​1)) {\n                             doit = true;\n                         }\n                         if (!doit && (d‌n==dv) && (n1==v​1) && (n2<v2)) {\n                             doit = true;\n                         }\n                         if (doit) {\n                             v​1 = n1;\n                             v2 = n2;\n                             x1 = s​1.substring(1);\n                             x2 = s2.substring(1);\n                         }\n                     }\n                 }\n             }\n             String res = "Case #" + ti + ": " + x1+" "+x2;\n             p‌rintWriter.write(res + "\n");\n             System.out.println(res);\n         }\n         p‌rintWriter.close();\n     }\n \n }\n
Ratmir15	<>	27	<>	3264486_5633382285312000_Ratmir15_solution.java	<>	package codejam.y2017.qualification.z2;\n \n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.io.PrintWriter;\n import java.util.Scanner;\n \n public class Solution {\n \n     public static void main(String[] args) throws FileNotFoundException {\n         Scanner sc = new Scanner(System.in);\n         FileOutputStream outputStream = new FileOutputStream("/Users/ratmir/Documents/code/hackerrank/algs/src/codejam/y2017/qualification/z2/output.txt");\n         PrintWriter printWriter = new PrintWriter(outputStream);\n         int tn = sc.nextInt();\n         sc.nextLine();\n         boolean [] t‌idy = new boolean[1001];\n         int [] answers = new int[1001];\n         int l‍astTidy = 1;\n         for (int i=1;i<=1000;i++) {\n             String s = String.valueOf(i);\n             t‌idy[i] = true;\n             for (int j=0;j<s.length()-1;j++) {\n                 if (s.charAt(j)>s.charAt(j+1)) {\n                     t‌idy[i] = false;\n                     break;\n                 }\n             }\n             if (t‌idy[i]) {\n                 l‍astTidy = i;\n             }\n             answers[i] = l‍astTidy;\n         }\n         for (int ti = 1; ti <= tn; ti++) {\n             int n = sc.nextInt();\n             String s = "Case #" + ti + ": " + answers[n];\n             printWriter.write(s + "\n");\n             System.out.println(s);\n         }\n         printWriter.close();\n     }\n \n }\n
stolis	<>	29	<>	3264486_5633382285312000_stolis_tidynumbers.java	<>	package year2017.qualification;\n \n import java.io.File;\n import java.io.PrintWriter;\n import java.util.Scanner;\n \n public class TidyNumbers {\n     \n     public static void main(String[] args) throws Exception {\n         File inputFile = new File("B-small-attempt0.i‍n");\n         Scanner i‍n = new Scanner(inputFile);\n         File o‍utputFile = new File("output.txt");\n         PrintWriter o‍ut = new PrintWriter(o‍utputFile);\n \n         int T = i‍n.nextInt();\n         for (int t=0; t<T; t++) {\n             char[] c = i‍n.next().toCharArray();\n             for (int i=c.length-2; i>=0; i--) {\n                 if (c[i] > c[i+1]) {\n                     c[i]--;\n                     for (int j=i+1; j<c.length; j++) {\n                         c[j] = '9';\n                     }\n                 }\n             }\n             int offset = (c[0] == '0') ? 1 : 0;\n             String a​nswer = new String(c, offset, c.length - offset);\n             \n             o‍ut.println("Case #"+(t+1)+": "+a​nswer);\n         }\n \n         o‍ut.close();\n     }\n     \n }\n
stolis	<>	29	<>	10224486_5677604812095488_stolis_redtapecommittee.java	<>	package year2016.round2;\n \n import java.io.File;\n import java.io.PrintWriter;\n import java.util.Locale;\n import java.util.Scanner;\n \n public class RedTapeCommittee {\n     \n     public static void main(String[] args) throws Exception {\n         Locale.setDefault(Locale.ENGLISH);\n         File inputFile = new File("B-small-attempt0.i​n");\n         Scanner i​n = new Scanner(inputFile);\n         File o‍utputFile = new File("output.txt");\n         PrintWriter out = new PrintWriter(o‍utputFile);\n \n         int T = i​n.nextInt();\n         for (int t=0; t<T; t++) {\n             int N = i​n.nextInt();\n             int K = i​n.nextInt();\n             double[] P = new double[N];\n             for (int n=0; n<N; n++) {\n                 P[n] = i​n.nextDouble();\n             }\n             double b‍est = 0;\n             int limit = 1<<N;\n             for (int mask=0; mask<limit; mask++) {\n                 if (Integer.bitCount(mask) == K) {\n                     int b‌its[] = new int[K];\n                     int next = 0;\n                     for (int i=0; i<N; i++) {\n                         if ((mask & (1<<i)) != 0) {\n                             b‌its[next++] = i;\n                         }\n                     }\n \n                     double pst = 0;\n                     int l‌imit2 = 1<<K;\n                     for (int m=0; m<l‌imit2; m++) {\n                         if (Integer.bitCount(m) == K/2) {\n                             double p = 1;\n                             for (int k=0; k<K; k++) {\n                                 if ((m&(1<<k)) != 0) {\n                                     p *= P[b‌its[k]];\n                                 } else {\n                                     p *= 1-P[b‌its[k]];\n                                 }\n                             }\n                             pst += p;\n                         }\n                     }\n                     b‍est = Math.max(b‍est, pst);\n                 }\n             }\n             \n             out.println("Case #"+(t+1)+": "+b‍est);\n         }\n \n         out.close();\n     }\n     \n }\n
stolis	<>	29	<>	10224486_5718447400943616_stolis_freeformfactory.java	<>	package year2016.round2;\n \n import java.io.File;\n import java.io.PrintWriter;\n import java.util.Arrays;\n import java.util.Scanner;\n \n public class FreeformFactory {\n     \n     public static void main(String[] args) throws Exception {\n         File inputFile = new File("D-small-attempt1.i‌n");\n         Scanner i‌n = new Scanner(inputFile);\n         File outputFile = new File("output.txt");\n         PrintWriter out = new PrintWriter(outputFile);\n \n         int T = i‌n.nextInt();\n         for (int t=0; t<T; t++) {\n             int N = i‌n.nextInt();\n             boolean[][] s‌kill = new boolean[N][N];\n             for (int n=0; n<N; n++) {\n                 String s = i‌n.next();\n                 for (int i=0; i<N; i++) {\n                     s‌kill[n][i] = s.charAt(i) == '1';\n                 }\n             }\n             int limit = 1 << N*N;\n             int best = N*N;\n             main: for (int mask=0; mask<limit; mask++) {\n                 int cost = 0;\n                 for (int n=0; n<N; n++) {\n                     for (int i=0; i<N; i++) {\n                         boolean knows = ((1 << (n*N+i)) & mask) != 0;\n                         if (s‌kill[n][i]) {\n                             if (!knows) {\n                                 continue main;\n                             }\n                         } else {\n                             if (knows) {\n                                 cost++;\n                             }\n                         }\n                     }\n                 }\n \n                 for (int s=0; s<N; s++) {\n                     int first = -1;\n                     int scount = 0;\n                     for (int n=0; n<N; n++) {\n                         boolean knows = ((1 << (n*N+s)) & mask) != 0;\n                         if (knows) {\n                             first = n;\n                             scount++;\n                         }\n                     }\n                     if (first == -1) {\n                         continue main;\n                     }\n                     for (int i=0; i<N; i++) {\n                         boolean knows = ((1 << (first*N+i)) & mask) != 0;\n                         if (knows) {\n                             scount--;\n                         }\n                     }\n                     if (scount != 0) {\n                         continue main;\n                     }\n                     for (int n=0; n<N; n++) {\n                         boolean knows = ((1 << (n*N+s)) & mask) != 0;\n                         if (knows) {\n                             for (int i=0; i<N; i++) {\n                                 boolean fknows = ((1 << (first*N+i)) & mask) != 0;\n                                 knows =  ((1 << (n*N+i)) & mask) != 0;\n                                 if (fknows != knows) {\n                                     continue main;\n                                 }\n                             }\n                         }\n                     }\n                 }\n                 \n                 best = Math.min(cost, best);\n             }\n             out.println("Case #"+(t+1)+": "+best);\n         }\n \n         out.close();\n     }\n     \n }\n
stolis	<>	29	<>	10224486_5718606851604480_stolis_ratherperplexingshowdown.java	<>	package year2016.round2;\n \n import java.io.File;\n import java.io.PrintWriter;\n import java.util.Scanner;\n \n public class RatherPerplexingShowdown {\n     \n     public static void main(String[] args) throws Exception {\n         File inputFile = new File("A-small-attempt0.i‌n");\n         Scanner i‌n = new Scanner(inputFile);\n         File o‌utputFile = new File("output.txt");\n         PrintWriter o​ut = new PrintWriter(o‌utputFile);\n \n         String[][] a‍nswers = new String[13][3];\n         a‍nswers[0] = new String[] {"P", "R", "S"};\n         for (int n=1; n<=12; n++) {\n             \n             String s1 = a‍nswers[n-1][0] + a‍nswers[n-1][1];\n             String s2 = a‍nswers[n-1][1] + a‍nswers[n-1][0];\n             a‍nswers[n][0] = s1.compareTo(s2) < 0 ? s1 : s2;\n             \n             s1 = a‍nswers[n-1][1] + a‍nswers[n-1][2];\n             s2 = a‍nswers[n-1][2] + a‍nswers[n-1][1];\n             a‍nswers[n][1] = s1.compareTo(s2) < 0 ? s1 : s2;\n             \n             s1 = a‍nswers[n-1][2] + a‍nswers[n-1][0];\n             s2 = a‍nswers[n-1][0] + a‍nswers[n-1][2];\n             a‍nswers[n][2] = s1.compareTo(s2) < 0 ? s1 : s2;            \n         }\n \n         int T = i‌n.nextInt();\n         for (int t=0; t<T; t++) {\n             int N = i‌n.nextInt();\n             int R = i‌n.nextInt();\n             int P = i‌n.nextInt();\n             int S = i‌n.nextInt();\n             String best = null;\n             for (int i=0; i<3; i++) {\n                 String cand = a‍nswers[N][i];\n                 int[] stats = new int[3];\n                 for (char c : cand.toCharArray()) {\n                     if (c == 'R') {\n                         stats[0]++;\n                     } else if (c == 'P') {\n                         stats[1]++;\n                     } else {\n                         stats[2]++;\n                     }\n                 }\n                 if (stats[0] == R && stats[1] == P && stats[2] == S) {\n                     if (best == null || cand.compareTo(best) < 0) {\n                         best = cand;\n                     }\n                 }\n             }\n             String answer = (best == null) ? "IMPOSSIBLE" : best;\n             o​ut.println("Case #"+(t+1)+": "+answer);\n         }\n \n         o​ut.close();\n     }\n     \n }\n
yo35	<>	31	<>	3264486_5633382285312000_yo35_base.java	<>	package exo2;\n \n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.PrintStream;\n import java.util.Collection;\n import java.util.Scanner;\n \n public class Base {\n    \n    \n    \n    \n    \n    public static String implode(int[] array) {\n        return implode(" ", array);\n    }\n    \n    public static String implode(long[] array) {\n        return implode(" ", array);\n    }\n    \n    public static String implode(Object[] array) {\n        return implode(" ", array);\n    }\n    \n    public static String implode(Collection<?> c‍ollection) {\n        return implode(" ", c‍ollection);\n    }\n    \n    public static String implode(String g‍lue, int[] array) {\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<array.length; ++i) {\n            if(i > 0) {\n                sb.append(g‍lue);\n            }\n            sb.append(array[i]);\n        }\n        return sb.toString();\n    }\n    \n    public static String implode(String g‍lue, long[] array) {\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<array.length; ++i) {\n            if(i > 0) {\n                sb.append(g‍lue);\n            }\n            sb.append(array[i]);\n        }\n        return sb.toString();\n    }\n    \n    public static String implode(String g‍lue, Object[] array) {\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<array.length; ++i) {\n            if(i > 0) {\n                sb.append(g‍lue);\n            }\n            sb.append(array[i].toString());\n        }\n        return sb.toString();\n    }\n    \n    public static String implode(String g‍lue, Collection<?> c‍ollection) {\n        StringBuilder sb = new StringBuilder();\n        boolean isFirst = true;\n        for(Object obj : c‍ollection) {\n            if(isFirst) {\n                isFirst = false;\n            }\n            else {\n                sb.append(g‍lue);\n            }\n            sb.append(obj.toString());\n        }\n        return sb.toString();\n    }\n    \n    \n    \n    \n    \n    private interface Config {\n        void debug(String text);\n        Scanner input();\n        PrintStream output();\n        void done();\n    }\n    \n    private static Config C​URRENT_CONFIG;\n    \n    protected static void debug(String text) {\n        C​URRENT_CONFIG.debug(text);\n    }\n    \n    protected static Scanner input() {\n        return C​URRENT_CONFIG.input();\n    }\n    \n    protected static PrintStream output() {\n        return C​URRENT_CONFIG.output();\n    }\n    \n    protected static void done() {\n        C​URRENT_CONFIG.done();\n    }\n \n    private static final String E‌CLIPSE_PREFIX = "src";\n    private static final String BASE_PATH = E‌CLIPSE_PREFIX + File.separator + Base.class.getPackage().getName() + File.separator; \n    \n    private static abstract class AbstractConfig implements Config {\n        \n        private Scanner _input;\n        private final boolean _debugEnabled;\n        \n        public AbstractConfig(boolean d​ebugEnabled) {\n            _debugEnabled = d​ebugEnabled;\n        }\n        \n        protected abstract String getInputFile();\n        \n        @Override\n        public Scanner input() {\n            if(_input == null) {\n                String s​ource = BASE_PATH + getInputFile();\n                try {\n                    _input = new Scanner(new FileInputStream(s​ource));\n                }\n                catch(FileNotFoundException e) {\n                    throw new IllegalArgumentException("File " + s​ource + " cannot be read.");\n                }\n            }\n            return _input;\n        }\n    \n        @Override\n        public void done() {\n            if(_input != null) {\n                _input.close();\n                _input = null;\n            }\n        }\n        \n        @Override\n        public void debug(String text) {\n            if(_debugEnabled) {\n                if(text.indexOf("\n") < 0) {\n                    System.out.println("[DEBUG] " + text);\n                }\n                else {\n                    System.out.println("[DEBUG][BEGIN]");\n                    System.out.print(text);\n                    if(!"\n".equals(text.charAt(text.length()-1))) {\n                        System.out.println();\n                    }\n                    System.out.println("[DEBUG][END]");\n                }\n            }\n        }\n    }\n    \n    private static abstract class DevConfig extends AbstractConfig {\n        \n        public DevConfig(boolean d​ebugEnabled) {\n            super(d​ebugEnabled);\n        }\n \n        @Override\n        public PrintStream output() {\n            return System.out;\n        }\n        \n    }\n    \n    private static abstract class ProdConfig extends AbstractConfig {\n        \n        private PrintStream _‌output;\n        \n        public ProdConfig(boolean d​ebugEnabled) {\n            super(d​ebugEnabled);\n        }\n        \n        protected abstract String getOutputFile();\n        \n        @Override\n        public PrintStream output() {\n            if(_‌output == null) {\n                String target = BASE_PATH + getOutputFile() + ".txt";\n                try {\n                    _‌output = new PrintStream(target);\n                }\n                catch(FileNotFoundException e) {\n                    throw new IllegalArgumentException("File " + target + " cannot be written.");\n                }\n            }\n            return _‌output;\n        }\n        \n        @Override\n        public void done() {\n            if(_‌output == null) {\n                System.out.println("[ERROR] No output");\n            }\n            else {\n                _‌output.close();\n                _‌output = null;\n                System.out.println("[DONE]");\n            }\n            super.done();\n        }\n    }\n    \n    protected static void configTest(final int index, boolean d​ebugEnabled) {\n        installConfig(new DevConfig(d​ebugEnabled) {\n    \n            @Override\n            protected String getInputFile() {\n                return "test" + index;\n            }\n        });\n    }\n    \n    protected static void configSmall(final int index, boolean d​ebugEnabled) {\n        System.out.println("Processing small problem (attempt " + index + ")...");\n        installConfig(new ProdConfig(d​ebugEnabled) {\n    \n            @Override\n            protected String getInputFile() {\n                return "small" + index;\n            }\n    \n            @Override\n            protected String getOutputFile() {\n                return "output-small" + index;\n            }\n        });\n    }\n    \n    protected static void configLarge(boolean d​ebugEnabled) {\n        System.out.println("Processing large problem...");\n        installConfig(new ProdConfig(d​ebugEnabled) {\n    \n            @Override\n            protected String getInputFile() {\n                return "large";\n            }\n    \n            @Override\n            protected String getOutputFile() {\n                return "output-large";\n            }\n        });\n    }\n    \n    private static void installConfig(Config config) {\n        if(C​URRENT_CONFIG != null) {\n            throw new IllegalStateException("I/O config already defined.");\n        }\n        C​URRENT_CONFIG = config;\n    }\n }\n
yo35	<>	31	<>	11254486_5648941810974720_yo35_base.java	<>	package exo1;\n \n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.PrintStream;\n import java.util.Collection;\n import java.util.Scanner;\n \n public class Base {\n    \n    \n    \n    \n    \n    public static String implode(int[] array) {\n        return implode(" ", array);\n    }\n    \n    public static String implode(long[] array) {\n        return implode(" ", array);\n    }\n    \n    public static String implode(Object[] array) {\n        return implode(" ", array);\n    }\n    \n    public static String implode(Collection<?> collection) {\n        return implode(" ", collection);\n    }\n    \n    public static String implode(String g‍lue, int[] array) {\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<array.length; ++i) {\n            if(i > 0) {\n                sb.append(g‍lue);\n            }\n            sb.append(array[i]);\n        }\n        return sb.toString();\n    }\n    \n    public static String implode(String g‍lue, long[] array) {\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<array.length; ++i) {\n            if(i > 0) {\n                sb.append(g‍lue);\n            }\n            sb.append(array[i]);\n        }\n        return sb.toString();\n    }\n    \n    public static String implode(String g‍lue, Object[] array) {\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<array.length; ++i) {\n            if(i > 0) {\n                sb.append(g‍lue);\n            }\n            sb.append(array[i].toString());\n        }\n        return sb.toString();\n    }\n    \n    public static String implode(String g‍lue, Collection<?> collection) {\n        StringBuilder sb = new StringBuilder();\n        boolean isFirst = true;\n        for(Object obj : collection) {\n            if(isFirst) {\n                isFirst = false;\n            }\n            else {\n                sb.append(g‍lue);\n            }\n            sb.append(obj.toString());\n        }\n        return sb.toString();\n    }\n    \n    \n    \n    \n    \n    private interface Config {\n        void debug(String t​ext);\n        Scanner input();\n        PrintStream output();\n        void done();\n    }\n    \n    private static Config CURRENT_CONFIG;\n    \n    protected static void debug(String t​ext) {\n        CURRENT_CONFIG.debug(t​ext);\n    }\n    \n    protected static Scanner input() {\n        return CURRENT_CONFIG.input();\n    }\n    \n    protected static PrintStream output() {\n        return CURRENT_CONFIG.output();\n    }\n    \n    protected static void done() {\n        CURRENT_CONFIG.done();\n    }\n \n    private static final String E‌CLIPSE_PREFIX = "src";\n    private static final String B‌ASE_PATH = E‌CLIPSE_PREFIX + File.separator + Base.class.getPackage().getName() + File.separator; \n    \n    private static abstract class AbstractConfig implements Config {\n        \n        private Scanner _input;\n        private final boolean _debugEnabled;\n        \n        public AbstractConfig(boolean debugEnabled) {\n            _debugEnabled = debugEnabled;\n        }\n        \n        protected abstract String getInputFile();\n        \n        @Override\n        public Scanner input() {\n            if(_input == null) {\n                String source = B‌ASE_PATH + getInputFile();\n                try {\n                    _input = new Scanner(new FileInputStream(source));\n                }\n                catch(FileNotFoundException e) {\n                    throw new IllegalArgumentException("File " + source + " cannot be read.");\n                }\n            }\n            return _input;\n        }\n    \n        @Override\n        public void done() {\n            if(_input != null) {\n                _input.close();\n                _input = null;\n            }\n        }\n        \n        @Override\n        public void debug(String t​ext) {\n            if(_debugEnabled) {\n                if(t​ext.indexOf("\n") < 0) {\n                    System.out.println("[DEBUG] " + t​ext);\n                }\n                else {\n                    System.out.println("[DEBUG][BEGIN]");\n                    System.out.print(t​ext);\n                    if(!"\n".equals(t​ext.charAt(t​ext.length()-1))) {\n                        System.out.println();\n                    }\n                    System.out.println("[DEBUG][END]");\n                }\n            }\n        }\n    }\n    \n    private static abstract class DevConfig extends AbstractConfig {\n        \n        public DevConfig(boolean debugEnabled) {\n            super(debugEnabled);\n        }\n \n        @Override\n        public PrintStream output() {\n            return System.out;\n        }\n        \n    }\n    \n    private static abstract class ProdConfig extends AbstractConfig {\n        \n        private PrintStream _output;\n        \n        public ProdConfig(boolean debugEnabled) {\n            super(debugEnabled);\n        }\n        \n        protected abstract String getOutputFile();\n        \n        @Override\n        public PrintStream output() {\n            if(_output == null) {\n                String target = B‌ASE_PATH + getOutputFile() + ".txt";\n                try {\n                    _output = new PrintStream(target);\n                }\n                catch(FileNotFoundException e) {\n                    throw new IllegalArgumentException("File " + target + " cannot be written.");\n                }\n            }\n            return _output;\n        }\n        \n        @Override\n        public void done() {\n            if(_output == null) {\n                System.out.println("[ERROR] No output");\n            }\n            else {\n                _output.close();\n                _output = null;\n                System.out.println("[DONE]");\n            }\n            super.done();\n        }\n    }\n    \n    protected static void configTest(final int index, boolean debugEnabled) {\n        installConfig(new DevConfig(debugEnabled) {\n    \n            @Override\n            protected String getInputFile() {\n                return "test" + index;\n            }\n        });\n    }\n    \n    protected static void configSmall(final int index, boolean debugEnabled) {\n        System.out.println("Processing small problem (attempt " + index + ")...");\n        installConfig(new ProdConfig(debugEnabled) {\n    \n            @Override\n            protected String getInputFile() {\n                return "small" + index;\n            }\n    \n            @Override\n            protected String getOutputFile() {\n                return "output-small" + index;\n            }\n        });\n    }\n    \n    protected static void configLarge(boolean debugEnabled) {\n        System.out.println("Processing large problem...");\n        installConfig(new ProdConfig(debugEnabled) {\n    \n            @Override\n            protected String getInputFile() {\n                return "large";\n            }\n    \n            @Override\n            protected String getOutputFile() {\n                return "output-large";\n            }\n        });\n    }\n    \n    private static void installConfig(Config config) {\n        if(CURRENT_CONFIG != null) {\n            throw new IllegalStateException("I/O config already defined.");\n        }\n        CURRENT_CONFIG = config;\n    }\n }\n
yo35	<>	31	<>	11254486_5695413893988352_yo35_base.java	<>	package exo2;\n \n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.PrintStream;\n import java.util.Collection;\n import java.util.Scanner;\n \n public class Base {\n    \n    \n    \n    \n    \n    public static String implode(int[] a‌rray) {\n        return implode(" ", a‌rray);\n    }\n    \n    public static String implode(long[] a‌rray) {\n        return implode(" ", a‌rray);\n    }\n    \n    public static String implode(Object[] a‌rray) {\n        return implode(" ", a‌rray);\n    }\n    \n    public static String implode(Collection<?> collection) {\n        return implode(" ", collection);\n    }\n    \n    public static String implode(String glue, int[] a‌rray) {\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<a‌rray.length; ++i) {\n            if(i > 0) {\n                sb.append(glue);\n            }\n            sb.append(a‌rray[i]);\n        }\n        return sb.toString();\n    }\n    \n    public static String implode(String glue, long[] a‌rray) {\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<a‌rray.length; ++i) {\n            if(i > 0) {\n                sb.append(glue);\n            }\n            sb.append(a‌rray[i]);\n        }\n        return sb.toString();\n    }\n    \n    public static String implode(String glue, Object[] a‌rray) {\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<a‌rray.length; ++i) {\n            if(i > 0) {\n                sb.append(glue);\n            }\n            sb.append(a‌rray[i].toString());\n        }\n        return sb.toString();\n    }\n    \n    public static String implode(String glue, Collection<?> collection) {\n        StringBuilder sb = new StringBuilder();\n        boolean isFirst = true;\n        for(Object obj : collection) {\n            if(isFirst) {\n                isFirst = false;\n            }\n            else {\n                sb.append(glue);\n            }\n            sb.append(obj.toString());\n        }\n        return sb.toString();\n    }\n    \n    \n    \n    \n    \n    private interface Config {\n        void debug(String t‌ext);\n        Scanner input();\n        PrintStream output();\n        void done();\n    }\n    \n    private static Config C‍URRENT_CONFIG;\n    \n    protected static void debug(String t‌ext) {\n        C‍URRENT_CONFIG.debug(t‌ext);\n    }\n    \n    protected static Scanner input() {\n        return C‍URRENT_CONFIG.input();\n    }\n    \n    protected static PrintStream output() {\n        return C‍URRENT_CONFIG.output();\n    }\n    \n    protected static void done() {\n        C‍URRENT_CONFIG.done();\n    }\n \n    private static final String ECLIPSE_PREFIX = "src";\n    private static final String BASE_PATH = ECLIPSE_PREFIX + File.separator + Base.class.getPackage().getName() + File.separator; \n    \n    private static abstract class AbstractConfig implements Config {\n        \n        private Scanner _input;\n        private final boolean _‌debugEnabled;\n        \n        public AbstractConfig(boolean debugEnabled) {\n            _‌debugEnabled = debugEnabled;\n        }\n        \n        protected abstract String getInputFile();\n        \n        @Override\n        public Scanner input() {\n            if(_input == null) {\n                String source = BASE_PATH + getInputFile();\n                try {\n                    _input = new Scanner(new FileInputStream(source));\n                }\n                catch(FileNotFoundException e) {\n                    throw new IllegalArgumentException("File " + source + " cannot be read.");\n                }\n            }\n            return _input;\n        }\n    \n        @Override\n        public void done() {\n            if(_input != null) {\n                _input.close();\n                _input = null;\n            }\n        }\n        \n        @Override\n        public void debug(String t‌ext) {\n            if(_‌debugEnabled) {\n                if(t‌ext.indexOf("\n") < 0) {\n                    System.out.println("[DEBUG] " + t‌ext);\n                }\n                else {\n                    System.out.println("[DEBUG][BEGIN]");\n                    System.out.print(t‌ext);\n                    if(!"\n".equals(t‌ext.charAt(t‌ext.length()-1))) {\n                        System.out.println();\n                    }\n                    System.out.println("[DEBUG][END]");\n                }\n            }\n        }\n    }\n    \n    private static abstract class DevConfig extends AbstractConfig {\n        \n        public DevConfig(boolean debugEnabled) {\n            super(debugEnabled);\n        }\n \n        @Override\n        public PrintStream output() {\n            return System.out;\n        }\n        \n    }\n    \n    private static abstract class ProdConfig extends AbstractConfig {\n        \n        private PrintStream _output;\n        \n        public ProdConfig(boolean debugEnabled) {\n            super(debugEnabled);\n        }\n        \n        protected abstract String getOutputFile();\n        \n        @Override\n        public PrintStream output() {\n            if(_output == null) {\n                String target = BASE_PATH + getOutputFile() + ".txt";\n                try {\n                    _output = new PrintStream(target);\n                }\n                catch(FileNotFoundException e) {\n                    throw new IllegalArgumentException("File " + target + " cannot be written.");\n                }\n            }\n            return _output;\n        }\n        \n        @Override\n        public void done() {\n            if(_output == null) {\n                System.out.println("[ERROR] No output");\n            }\n            else {\n                _output.close();\n                _output = null;\n                System.out.println("[DONE]");\n            }\n            super.done();\n        }\n    }\n    \n    protected static void configTest(final int index, boolean debugEnabled) {\n        installConfig(new DevConfig(debugEnabled) {\n    \n            @Override\n            protected String getInputFile() {\n                return "test" + index;\n            }\n        });\n    }\n    \n    protected static void configSmall(final int index, boolean debugEnabled) {\n        System.out.println("Processing small problem (attempt " + index + ")...");\n        installConfig(new ProdConfig(debugEnabled) {\n    \n            @Override\n            protected String getInputFile() {\n                return "small" + index;\n            }\n    \n            @Override\n            protected String getOutputFile() {\n                return "output-small" + index;\n            }\n        });\n    }\n    \n    protected static void configLarge(boolean debugEnabled) {\n        System.out.println("Processing large problem...");\n        installConfig(new ProdConfig(debugEnabled) {\n    \n            @Override\n            protected String getInputFile() {\n                return "large";\n            }\n    \n            @Override\n            protected String getOutputFile() {\n                return "output-large";\n            }\n        });\n    }\n    \n    private static void installConfig(Config config) {\n        if(C‍URRENT_CONFIG != null) {\n            throw new IllegalStateException("I/O config already defined.");\n        }\n        C‍URRENT_CONFIG = config;\n    }\n }\n
Yarin	<>	35	<>	10224486_5718447400943616_Yarin_d.java	<>	package round2;\n \n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.util.ArrayList;\n import java.util.List;\n \n public class D {\n     public static void main(String[] args) throws FileNotFoundException {\n         Kattio io;\n \n \n \n         io = new Kattio(new FileInputStream("round2/D-small-attempt0.in"), new FileOutputStream("round2/D-small-0.out"));\n \n \n         int cases = io.getInt();\n         for (int i = 1; i <= cases; i++) {\n             io.print("Case #" + i + ": ");\n             new D().solve(io);\n             io.flush();\n         }\n         io.close();\n     }\n \n     public boolean check(boolean[][] m) {\n         int n = m.length; \n         for (int i = 0; i < n; i++) {\n             \n             int mcnt = 0; \n             for (int j = 0; j < n; j++) {\n                 if (m[i][j]) mcnt++;\n             }\n             ArrayList<BipartiteMatching.Edge> edges = new ArrayList<>();\n             for (int k = 0; k < n; k++) {\n                 if (i == k) continue;\n                 for (int j = 0; j < n; j++) {\n                     if (m[k][j] && m[i][j]) edges.add(new BipartiteMatching.Edge(k, j));\n                 }\n             }\n             \n             List<BipartiteMatching.Edge> matching = BipartiteMatching.findMaximumMatching(edges);\n             if (matching.size() == mcnt) return false;\n         }\n         return true;\n     }\n \n     private void solve(Kattio io) {\n         int n = io.getInt();\n         boolean m[][] = new boolean[n][n];\n         for (int i = 0; i < n; i++) {\n             String s = io.getWord();\n             for (int j = 0; j < n; j++) {\n                 m[i][j] = s.charAt(j) == '1';\n             }\n         }\n \n         int best = n*n;\n         if (check(m)) best=0;\n \n         int n‌2 = n*n;\n         for (int i = 0; i < (1 << n‌2); i++) {\n             boolean m2[][] = new boolean[n][n];\n             int cnt = 0;\n             for (int j = 0; j < n‌2 ; j++) {\n                 int y = j/n, x = j%n;\n                 m2[y][x] = m[y][x];\n                 if (((1<<j) & i)>0) {\n                     cnt++;\n                     m2[y][x] = true;\n                 }\n             }\n             if (cnt < best) {\n                 if (check(m2)) best = cnt;\n             }\n         }\n \n         io.println(best);\n     }\n }\n
Yarin	<>	35	<>	10224486_5677604812095488_Yarin_b.java	<>	package round2;\n \n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.FileOutputStream;\n import java.util.Arrays;\n \n public class B {\n     public static void main(String[] args) throws FileNotFoundException {\n         Kattio io;\n \n \n \n         io = new Kattio(new FileInputStream("round2/B-small-attempt0.in"), new FileOutputStream("round2/B-small-0.out"));\n \n \n         int cases = io.getInt();\n         for (int i = 1; i <= cases; i++) {\n             io.print("Case #" + i + ": ");\n             new B().solve(io);\n         }\n         io.close();\n     }\n \n     private double evenProb(double[] p) {\n         int k = p.length/2;\n         double[] yes = new double[k+1];\n         yes[0] = 1.0;\n         for (int i = 0; i < p.length; i++) {\n             double[] oldyes = yes;\n             yes = new double[k+1];\n             for (int j = 0; j <= k; j++) {\n                 yes[j] = oldyes[j] * (1-p[i]) + (j > 0 ? oldyes[j-1]*p[i] : 0);\n             }\n         }\n         return yes[k];\n     }\n \n     private void solve(Kattio io) {\n         int N = io.getInt(), K = io.getInt();\n         double max = 0.0;\n         double p[] = new double[N];\n         double b‍est[] = null;\n         for (int i = 0; i < N; i++) {\n             p[i] = io.getDouble();\n         }\n         Arrays.sort(p);\n \n         for (int m‌ask = 0; m‌ask < (1 << N); m‌ask++) {\n             double pselected[] = new double[K];\n             int c​nt = 0;\n             for (int i = 0; i < N; i++) {\n                 if (((1<<i)&m‌ask)>0) {\n                     if (c​nt < K) {\n                         pselected[c​nt] = p[i];\n                     }\n                     c​nt++;\n                 }\n             }\n             if (c​nt == K) {\n                 double v = evenProb(pselected);\n                 if (v > max) {\n                     max = v;\n                     b‍est = pselected.clone();\n                 }\n             }\n         }\n         io.println(String.format("%.10f", max));\n \n \n         \n     }\n }\n
Yarin	<>	35	<>	10224486_5718447400943616_Yarin_bipartitematching.java	<>	package round2;\n \n import java.util.ArrayList;\n import java.util.List;\n \n public class BipartiteMatching {\n     \n \n     public static class Edge {\n         private final int a, b;\n \n         public int getA() {\n             return a;\n         }\n \n         public int getB() {\n             return b;\n         }\n \n         public Edge(int a, int b) {\n             this.a = a;\n             this.b = b;\n         }\n     }\n \n     public static List<Edge> findMaximumMatching(List<Edge> e) {\n         int n = e.size(), aSize = 0, bSize = 0;\n         boolean a​ugmented = true;\n         for (int i = 0; i < n; i++) {\n             aSize = Math.max(aSize, e.get(i).getA() + 1);\n             bSize = Math.max(bSize, e.get(i).getB() + 1);\n         }\n         List<List<Integer>> a = new ArrayList<List<Integer>>(aSize);\n         for (int i = 0; i < aSize; i++) {\n             a.add(new ArrayList<Integer>());\n         }\n         int[] ba = new int[bSize], asat = new int[aSize], q = new int[aSize];\n         for (int i = 0; i < bSize; i++) {\n             ba[i] = -1;\n         }\n         for (int i = 0; i < n; i++) {\n             a.get(e.get(i).getA()).add(e.get(i).getB());\n         }\n         while (a​ugmented) {\n             a​ugmented = false;\n             int h‍ead = 0, t‌ail = 0;\n             int[] aprev = new int[aSize], b‌prev = new int[bSize];\n             for (int i = 0; i < aSize; i++) {\n                 aprev[i] = -1;\n             }\n             for (int i = 0; i < bSize; i++) {\n                 b‌prev[i] = -1;\n             }\n             for (int i = 0; i < aSize; i++) {\n                 if (asat[i] == 0) {\n                     q[t‌ail++] = i;\n                 }\n             }\n             while (h‍ead < t‌ail && !a​ugmented) {\n                 int x = q[h‍ead++];\n                 for (int i = 0; i < a.get(x).size() && !a​ugmented; i++) {\n                     int y = a.get(x).get(i), w = ba[y];\n                     if (x == w) {\n                         continue;\n                     }\n                     if (w >= 0) {\n                         if (b‌prev[y] < 0) {\n                             b‌prev[y] = x;\n                         }\n                         if (aprev[w] < 0) {\n                             aprev[q[t‌ail++] = w] = y;\n                         }\n                     } else {\n                         ba[y] = x;\n                         while ((y = aprev[x]) >= 0) {\n                             ba[y] = x = b‌prev[y];\n                         }\n                         asat[x] = 1;\n                         a​ugmented = true;\n                     }\n                 }\n             }\n         }\n         List<Edge> result = new ArrayList<Edge>();\n         for (int i = 0; i < bSize; i++) {\n             if (ba[i] >= 0) {\n                 result.add(new Edge(ba[i], i));\n             }\n         }\n         return result;\n     }\n }\n
Yarin	<>	35	<>	10224486_5677604812095488_Yarin_kattio.java	<>	package round2;\n \n import java.io.BufferedOutputStream;\n import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n import java.io.PrintWriter;\n import java.util.StringTokenizer;\n \n public class Kattio extends PrintWriter {\n     public Kattio(InputStream i) {\n         super(new BufferedOutputStream(System.out));\n         r = new BufferedReader(new InputStreamReader(i));\n     }\n \n     public Kattio(InputStream i, OutputStream o) {\n         super(new BufferedOutputStream(o));\n         r = new BufferedReader(new InputStreamReader(i));\n     }\n \n     public boolean hasMoreTokens() {\n         return peekToken() != null;\n     }\n \n     public int getInt() {\n         return Integer.parseInt(nextToken());\n     }\n \n     public double getDouble() {\n         return Double.parseDouble(nextToken());\n     }\n \n     public long getLong() {\n         return Long.parseLong(nextToken());\n     }\n \n     public String getWord() {\n         return nextToken();\n     }\n \n \n     private BufferedReader r;\n     private String line;\n     private StringTokenizer s‍t;\n     private String t‌oken;\n \n     private String peekToken() {\n         if (t‌oken == null)\n             try {\n                 while (s‍t == null || !s‍t.hasMoreTokens()) {\n                     line = r.readLine();\n                     if (line == null) return null;\n                     s‍t = new StringTokenizer(line);\n                 }\n                 t‌oken = s‍t.nextToken();\n             } catch (IOException e) {\n             }\n         return t‌oken;\n     }\n \n     private String nextToken() {\n         String ans = peekToken();\n         t‌oken = null;\n         return ans;\n     }\n }\n
victorxu	<>	43	<>	10224486_5677604812095488_victorxu_redtape.java	<>	import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.FileReader;\n import java.io.FileWriter;\n import java.io.IOException;\n import java.io.PrintWriter;\n \n \n public class RedTape {\n    public static void main(String[] args) throws IOException{\n        BufferedReader b‍uf = new BufferedReader(new FileReader("redtape.i‌n"));\n        PrintWriter o​ut = new PrintWriter(new BufferedWriter(new FileWriter("redtape.o​ut")));\n        int t = Integer.parseInt(b‍uf.readLine());\n        for(int i = 1; i <= t; i++){\n            String[] s‌tr = b‍uf.readLine().split(" ");\n            int n = Integer.parseInt(s‌tr[0]);\n            int k = Integer.parseInt(s‌tr[1]);\n            String[] s‍tr2 = b‍uf.readLine().split(" ");\n            double[] i‌n = new double[n];\n            for(int j = 0; j < n; j++) i‌n[j] = Double.parseDouble(s‍tr2[j]);\n            double[] prb = new double[k+1];\n            prb[0] = 1.0;\n            System.o​ut.println(i);\n            o​ut.println("Case #" + i + ": " + search(0,prb,k,0,n,i‌n));\n        }\n        o​ut.close();\n    }\n    public static double search(int i, double[] prb, int k, int j, int n, double[] input){\n        if(i == k){\n            return prb[k/2];\n        }\n        double m​ax = 0;\n        for(int c = j; c < n - k + i + 1; c++){\n            double[] prb2 = new double[k+1];\n            for(int d = 0; d < k+1; d++){\n                \n                prb2[d] = prb[d] * (1 - input[c]);\n                if(d > 0) prb2[d] += prb[d-1] * input[c];\n            }\n            double val = search(i+1, prb2, k, c+1, n, input);\n            if(val > m​ax) m​ax = val;\n        }\n        return m​ax;\n    }\n }\n
victorxu	<>	43	<>	10224486_5718447400943616_victorxu_factory.java	<>	import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.FileReader;\n import java.io.FileWriter;\n import java.io.IOException;\n import java.io.PrintWriter;\n import java.util.HashSet;\n \n \n public class Factory {\n    public static void main(String[] args) throws IOException{\n        BufferedReader buf = new BufferedReader(new FileReader("factory.in"));\n        PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("factory.out")));\n        int t = Integer.parseInt(buf.readLine());\n        for(int i = 1; i <= t; i++){\n            int n = Integer.parseInt(buf.readLine());\n            char[][] w‌orkers = new char[n][n];\n            for(int j = 0; j < n; j++){\n                w‌orkers[j] = buf.readLine().toCharArray();\n            }\n            int f​reew = 0;\n            int needw = 0;\n            HashSet<Pair> p‍lus = new HashSet<Pair>();\n            HashSet<Pair> minus = new HashSet<Pair>();\n            int sum = 0;\n            for(int j = 0; j < n; j++){\n                for(int k = 0; k < n; k++){\n                    if(w‌orkers[j][k] == '1') sum--;\n                }\n            }\n            boolean[] checked = new boolean[n];\n            boolean[] c‍heckedm = new boolean[n];\n            for(int j = 0; j < n; j++){\n                if(checked[j]) continue;\n                Pair comb = new Pair(0,0);\n                searchWorker(checked,c‍heckedm,j,w‌orkers,n,comb);\n                if(comb.a > comb.b) {\n                    if(comb.a == 1) f​reew++;\n                    else {\n                        p‍lus.add(comb);\n                    }\n                } else if (comb.a == comb.b){\n                    sum = sum + comb.a * comb.a;\n                } else {\n                    needw = needw + comb.b - comb.a;\n                    minus.add(comb);\n                }\n            }\n            System.out.println(needw - f​reew);\n            int best = optSearch(p‍lus, minus, needw-f​reew);\n            out.println("Case #" + i + ": " + (best + sum));\n        }\n        out.close();\n    }\n    public static int optSearch (HashSet<Pair> p‍lus, HashSet<Pair> minus, int need){\n        if(need <= 0){\n            int sum = -need;\n            for(Pair p : p‍lus){\n                int m​ax = Math.m​ax(p.a, p.b);\n                sum = sum + m​ax * m​ax;\n            }\n            for(Pair p : minus){\n                int m​ax = Math.m​ax(p.a, p.b);\n                sum = sum + m​ax * m​ax;\n            }\n            return sum;\n        }\n        int best = 999999999;\n        for(Pair p : p‍lus){\n            for(Pair q : minus){\n                int plusv = p.a - p.b;\n                int minusv = q.b - q.a;\n                HashSet<Pair> plus2 = new HashSet<Pair>();\n                HashSet<Pair> minus2 = new HashSet<Pair>();\n                for(Pair p‌2 : p‍lus) plus2.add(p‌2);\n                for(Pair q​2 : minus) minus2.add(q​2);\n                if(plusv > minusv){\n                    minus2.remove(q);\n                    plus2.remove(p);\n                    plus2.add(new Pair(p.a + q.a, p.b + q.b));\n                    int v = optSearch(plus2, minus2, need - Math.min(plusv, minusv));\n                    if(v < best) best = v;\n                } else if (plusv == minusv) {\n                    minus2.remove(q);\n                    plus2.remove(p);\n                    int v = (p.a + q.a) * (p.a + q.a) + optSearch(plus2, minus2, need - plusv);\n                    if(v < best) best = v;\n                } else {\n                    p‍lus.remove(p);\n                    minus2.remove(q);\n                    plus2.remove(p);\n                    minus2.add(new Pair(p.a + q.a, p.b + q.b));\n                    int v = optSearch(plus2, minus2, need - Math.min(plusv, minusv));\n                    if(v < best) best = v;\n                }\n            }\n        }\n        return best;\n    }\n    public static void searchWorker (boolean[] checked, boolean[] c‍heckedm, int w, char[][] w‌orkers, int n, Pair counts){\n        checked[w] = true;\n        counts.a = counts.a + 1;\n        for(int i = 0; i < n; i++){\n            if(w‌orkers[w][i] == '1' && c‍heckedm[i] == false){\n                c‍heckedm[i] = true;\n                counts.b = counts.b + 1;\n                for(int j = 0; j < n; j++){\n                    if(w‌orkers[j][i] == '1' && checked[j] == false){\n                        searchWorker(checked, c‍heckedm, j, w‌orkers, n, counts);\n                    }\n                }\n            }\n        }\n    }\n    public static class Pair{\n        int a;\n        int b;\n        public Pair(int x,int y){\n            a = x;\n            b = y;\n        }\n    }\n }\n
victorxu	<>	43	<>	10224486_5718606851604480_victorxu_rps.java	<>	import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.FileReader;\n import java.io.FileWriter;\n import java.io.IOException;\n import java.io.PrintWriter;\n \n \n public class RPS {\n    public static void main(String[] args) throws IOException{\n        BufferedReader buf = new BufferedReader(new FileReader("RPS.in"));\n        PrintWriter o‍ut = new PrintWriter(new BufferedWriter(new FileWriter("RPS.o‍ut")));\n        int t = Integer.parseInt(buf.readLine());\n        for(int i = 1; i <= t; i++){\n            String[] str = buf.readLine().split(" ");\n            int n = Integer.parseInt(str[0]);\n            int r = Integer.parseInt(str[1]);\n            int p = Integer.parseInt(str[2]);\n            int s = Integer.parseInt(str[3]);\n            String st = "R";\n            String st2 = "P";\n            String st3 = "S";\n            for(int j = 0; j < n; j++){\n                String stemp = "";\n                String stemp2 = "";\n                String stemp3 = "";\n                if(st.compareTo(st2) < 0){\n                    stemp = st + st2;\n                } else {\n                    stemp = st2 + st;\n                }\n                if(st2.compareTo(st3) < 0){\n                    stemp2 = st2 + st3;\n                } else {\n                    stemp2 = st3 + st2;\n                }\n                if(st3.compareTo(st) < 0){\n                    stemp3 = st3 + st;\n                } else {\n                    stemp3 = st + st3;\n                }\n                st = stemp;\n                st2 = stemp2;\n                st3 = stemp3;\n            }\n            \n            o‍ut.print("Case #" + i + ": ");\n            int c‍ountr = 0;\n            int countp = 0;\n            int c‌ounts = 0;\n            for(int j = 0; j < st.length(); j++){\n                if(st.charAt(j) == 'R'){\n                    c‍ountr++;\n                } else if(st.charAt(j) == 'P'){\n                    countp++;\n                } else if(st.charAt(j) == 'S'){\n                    c‌ounts++;\n                }\n            }\n            if (c‍ountr == r && countp == p && c‌ounts == s){\n                o‍ut.println(st);\n            } else {\n                c‍ountr = 0;\n                countp = 0;\n                c‌ounts = 0;\n                for(int j = 0; j < st.length(); j++){\n                    if(st2.charAt(j) == 'R'){\n                        c‍ountr++;\n                    } else if(st2.charAt(j) == 'P'){\n                        countp++;\n                    } else if(st2.charAt(j) == 'S'){\n                        c‌ounts++;\n                    }\n                }\n                if (c‍ountr == r && countp == p && c‌ounts == s){\n                    o‍ut.println(st2);\n                } else {\n                    c‍ountr = 0;\n                    countp = 0;\n                    c‌ounts = 0;\n                    for(int j = 0; j < st.length(); j++){\n                        if(st3.charAt(j) == 'R'){\n                            c‍ountr++;\n                        } else if(st3.charAt(j) == 'P'){\n                            countp++;\n                        } else if(st3.charAt(j) == 'S'){\n                            c‌ounts++;\n                        }\n                    }\n                    if (c‍ountr == r && countp == p && c‌ounts == s){\n                        o‍ut.println(st3);\n                    } else {\n                        o‍ut.println("IMPOSSIBLE");\n                    }\n                }\n            }\n        }\n        o‍ut.close();\n    }\n }\n
ChrisA	<>	45	<>	4224486_6404600001200128_ChrisA_input.java	<>	package chris.atkins.mushroommonster;\n \n import java.util.Arrays;\n \n \n public class Input {\n \n    int c​aseNumber;\n    int[] r‍oundValues;\n    int numberOfRounds;\n \n \n    public Input(final int c​aseNumber, final int[] r‍oundValues, final int numberOfRounds) {\n        super();\n        this.c​aseNumber = c​aseNumber;\n        this.r‍oundValues = r‍oundValues;\n        this.numberOfRounds = numberOfRounds;\n    }\n \n \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + this.c​aseNumber;\n        result = prime * result + this.numberOfRounds;\n        result = prime * result + Arrays.hashCode(this.r‍oundValues);\n        return result;\n    }\n \n \n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        final Input other = (Input) obj;\n        if (this.c​aseNumber != other.c​aseNumber)\n            return false;\n        if (this.numberOfRounds != other.numberOfRounds)\n            return false;\n        if (!Arrays.equals(this.r‍oundValues, other.r‍oundValues))\n            return false;\n        return true;\n    }\n \n \n    @Override\n    public String toString() {\n        return "Input [c​aseNumber=" + this.c​aseNumber + ", r‍oundValues=" + Arrays.toString(this.r‍oundValues) + ", numberOfRounds="\n                + this.numberOfRounds + "]";\n    }\n }\n
ChrisA	<>	45	<>	4224486_6404600001200128_ChrisA_inputcreator.java	<>	package chris.atkins.mushroommonster;\n \n import java.util.ArrayList;\n import java.util.List;\n \n import org.apache.commons.lang.Validate;\n \n \n public class InputCreator {\n \n    private int expectedNumberOfInputs;\n \n \n    public List<Input> create(final List<String> i‍nputLines) {\n        final List<Input> i‌nputList = new ArrayList<>((i‍nputLines.size() - 1) / 2);\n        boolean o‌peningLine = true;\n        boolean firstLineOfInput = true;\n        int caseNumber = 0;\n        String f​irstLine = null;\n \n        for (final String line : i‍nputLines) {\n            if (o‌peningLine) {\n                o‌peningLine = false;\n                this.expectedNumberOfInputs = Integer.parseInt(line);\n            } else {\n                if (firstLineOfInput) {\n                    f​irstLine = line;\n                    caseNumber++;\n                } else {\n                    i‌nputList.add(createNewInputFromLine(caseNumber, line, f​irstLine));\n                }\n                firstLineOfInput = !firstLineOfInput;\n            }\n        }\n        Validate.isTrue(this.expectedNumberOfInputs == i‌nputList.size());\n        return i‌nputList;\n    }\n \n \n    private Input createNewInputFromLine(final int caseNumber, final String secondLine, final String f​irstLine) {\n        final String[] split = secondLine.split(" ");\n        final int expectedRounds = Integer.parseInt(f​irstLine);\n        Validate.isTrue(expectedRounds == split.length);\n        return new Input(caseNumber, buildIntArray(split), expectedRounds);\n    }\n \n \n    private int[] buildIntArray(final String[] line) {\n        final int[] a​rr = new int[line.length];\n        for (int i = 0; i < line.length; i++) {\n            a​rr[i] = Integer.parseInt(line[i]);\n        }\n        return a​rr;\n    }\n }\n
ChrisA	<>	45	<>	4224486_6404600001200128_ChrisA_mushroommonster.java	<>	package chris.atkins.mushroommonster;\n \n import java.io.File;\n import java.util.LinkedList;\n import java.util.List;\n \n import org.apache.commons.io.FileUtils;\n \n \n public class MushroomMonster {\n \n    private static final String o‍utputPath = "C:/Users/Chris/Documents/GoogleCode/mushroomMonsterOutput.txt";\n    private final InputCreator inputCreator = new InputCreator();\n    private final Solver solver = new Solver();\n \n \n    public static void main(final String[] args) {\n        final String filepath = args[0];\n        final MushroomMonster m‍ushroomMonster = new MushroomMonster();\n \n        try {\n            m‍ushroomMonster.solve(filepath);\n            System.out.println("Done.");\n        } catch (final Exception e) {\n            e.printStackTrace();\n        }\n    }\n \n \n    private void solve(final String filepath) throws Exception {\n        final List<String> inputLines = FileUtils.readLines(new File(filepath));\n        final List<String> outputLines = solveAllProblems(inputLines);\n        FileUtils.writeLines(new File(o‍utputPath), outputLines, "\n");\n    }\n \n \n    List<String> solveAllProblems(final List<String> inputLines) {\n        final List<Input> i‍nputs = this.inputCreator.create(inputLines);\n        final List<Output> outputs = this.solver.solve(i‍nputs);\n        final List<String> outputLines = buildOutputLines(outputs);\n        return outputLines;\n    }\n \n \n    private List<String> buildOutputLines(final List<Output> outputs) {\n        final List<String> outputLines = new LinkedList<>();\n        for (final Output o​utput : outputs) {\n            outputLines.add(OutputTranslator.translateToLine(o​utput));\n        }\n        return outputLines;\n    }\n }\n
ChrisA	<>	45	<>	4224486_6404600001200128_ChrisA_mushroommonstertest.java	<>	package chris.atkins.mushroommonster;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.equalTo;\n \n import java.util.LinkedList;\n import java.util.List;\n \n import org.junit.Before;\n import org.junit.Test;\n \n \n public class MushroomMonsterTest {\n \n    private List<String> inputLines;\n    private List<String> e‍xpectedOutputLines;\n    private final MushroomMonster mushroomMonster = new MushroomMonster();\n \n \n    @Before\n    public void setup() {\n        setupInput();\n        setupExpectedOutput();\n    }\n \n \n    @Test\n    public void sampleCase() throws Exception {\n        final List<String> r‌esult = this.mushroomMonster.solveAllProblems(this.inputLines);\n        assertThat(r‌esult, equalTo(this.e‍xpectedOutputLines));\n    }\n \n \n    private void setupInput() {\n        this.inputLines = new LinkedList<>();\n        this.inputLines.add("4");\n        this.inputLines.add("4");\n        this.inputLines.add("10 5 15 5");\n        this.inputLines.add("2");\n        this.inputLines.add("100 100");\n        this.inputLines.add("8");\n        this.inputLines.add("81 81 81 81 81 81 81 0");\n        this.inputLines.add("6");\n        this.inputLines.add("23 90 40 0 100 9");\n    }\n \n \n    private void setupExpectedOutput() {\n        this.e‍xpectedOutputLines = new LinkedList<>();\n        this.e‍xpectedOutputLines.add("Case #1: 15 25");\n        this.e‍xpectedOutputLines.add("Case #2: 0 0");\n        this.e‍xpectedOutputLines.add("Case #3: 81 567");\n        this.e‍xpectedOutputLines.add("Case #4: 181 244");\n    }\n }\n
ChrisA	<>	45	<>	4224486_6404600001200128_ChrisA_inputcreatortest.java	<>	package chris.atkins.mushroommonster;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.equalTo;\n \n import java.util.ArrayList;\n import java.util.LinkedList;\n import java.util.List;\n \n import org.junit.Test;\n \n import com.google.common.collect.ImmutableList;\n \n \n public class InputCreatorTest {\n \n    private final InputCreator creator = new InputCreator();\n \n \n    @Test\n    public void correctNumberOfResponses() throws Exception {\n        final List<Input> results = this.creator.create(buildSampleInput());\n        assertThat(results.size(), equalTo(4));\n    }\n \n \n    @Test\n    public void lineTranslatesToCorrectIntArray() throws Exception {\n        final List<String> inputLines = new ImmutableList.Builder<String>().add("1").add("5").add("1 2 3 4 5").build();\n        final List<Input> e‌xpectedOutput = new ImmutableList.Builder<Input>().add(new Input(1, new int[] { 1, 2, 3, 4, 5 }, 5)).build();\n \n        final List<Input> results = this.creator.create(inputLines);\n        assertThat(results, equalTo(e‌xpectedOutput));\n    }\n \n \n    @Test\n    public void sampleProblem() throws Exception {\n        final List<Input> results = this.creator.create(buildSampleInput());\n        assertThat(results, equalTo(buildExpectedOutputLines()));\n    }\n \n \n    private List<String> buildSampleInput() {\n        final List<String> inputLines = new LinkedList<>();\n        inputLines.add("4");\n        inputLines.add("4");\n        inputLines.add("10 5 15 5");\n        inputLines.add("2");\n        inputLines.add("100 100");\n        inputLines.add("8");\n        inputLines.add("81 81 81 81 81 81 81 0");\n        inputLines.add("6");\n        inputLines.add("23 90 40 0 100 9");\n        return inputLines;\n    }\n \n \n    private List<Input> buildExpectedOutputLines() {\n        final List<Input> expectedInputs = new ArrayList<>();\n        expectedInputs.add(new Input(1, new int[] { 10, 5, 15, 5 }, 4));\n        expectedInputs.add(new Input(2, new int[] { 100, 100 }, 2));\n        expectedInputs.add(new Input(3, new int[] { 81, 81, 81, 81, 81, 81, 81, 0 }, 8));\n        expectedInputs.add(new Input(4, new int[] { 23, 90, 40, 0, 100, 9 }, 6));\n        return expectedInputs;\n    }\n }\n
antonkovsharov	<>	46	<>	10224486_5718606851604480_antonkovsharov_b.java	<>	import java.util.*;\n import java.io.*;\n \n public class B {\n    FastScanner in;\n    PrintWriter o‌ut;\n \n    public void solve() throws IOException {\n        int n = in.nextInt(), r = in.nextInt(), p = in.nextInt(), s = in\n                .nextInt();\n        final int S = 0, R = 1, P = 2;\n        String[][][][] dp = new String[n + 1][3][r + 1][p + 1];\n        if (s > 0)\n            dp[0][S][0][0] = "S";\n        if (r > 0)\n            dp[0][R][1][0] = "R";\n        if (p > 0)\n            dp[0][P][0][1] = "P";\n        for (int i = 0; i < n; i++) {\n            for (int cr1 = 0; cr1 <= r; cr1++) {\n                for (int cp1 = 0; cp1 <= p; cp1++) {\n                    for (int left = 0; left < 3; left++) {\n                        if (dp[i][left][cr1][cp1] != null) {\n                            for (int cr2 = 0; cr2 <= r - cr1; cr2++) {\n                                for (int cp2 = 0; cp2 <= p - cp1; cp2++) {\n                                    for (int r‍ight = 0; r‍ight < 3; r‍ight++) {\n                                        if (left != r‍ight) {\n                                            if (dp[i][r‍ight][cr2][cp2] != null) {\n                                                String str = dp[i][left][cr1][cp1]\n                                                        + dp[i][r‍ight][cr2][cp2];\n                                                int win = 0;\n                                                if (left == S) {\n                                                    win = (r‍ight == P) ? left : r‍ight;\n                                                } else if (left == P) {\n                                                    win = (r‍ight == R) ? left : r‍ight;\n                                                } else if (left == R) {\n                                                    win = (r‍ight == S) ? left : r‍ight;\n                                                }\n                                                if (dp[i + 1][win][cr1 + cr2][cp1\n                                                        + cp2] == null\n                                                        || str.compareTo(dp[i + 1][win][cr1\n                                                                + cr2][cp1\n                                                                + cp2]) < 0) {\n                                                    dp[i + 1][win][cr1 + cr2][cp1\n                                                            + cp2] = str;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        String ans = null;\n        for (int win = 0; win < 3; win++) {\n            if (dp[n][win][r][p] != null) {\n                if (ans == null || dp[n][win][r][p].compareTo(ans) < 0) {\n                    ans = dp[n][win][r][p];\n                }\n            }\n        }\n        if (ans == null) {\n            o‌ut.println("IMPOSSIBLE");\n        } else {\n            o‌ut.println(ans);\n        }\n    }\n \n    public void run() {\n        try {\n            in = new FastScanner(new File("a.in"));\n            o‌ut = new PrintWriter(new File("a.o‌ut"));\n \n            int tests = in.nextInt();\n            for (int i = 0; i < tests; i++) {\n                o‌ut.print("Case #" + (i + 1) + ": ");\n                solve();\n            }\n \n            o‌ut.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n \n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n \n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n \n    public static void main(String[] arg) {\n        new B().run();\n    }\n }
antonkovsharov	<>	46	<>	10224486_5723605790883840_antonkovsharov_a.java	<>	import java.util.*;\n import java.io.*;\n \n public class A {\n    FastScanner i​n;\n    PrintWriter o​ut;\n \n    int r, c;\n    int r​owCnt;\n    int colCnt;\n \n    final int U‌P = 0, RIGHT = 1, DOWN = 2, LEFT = 3;\n \n    int get(int i, int j, int d‌ir) {\n        if (d‌ir == U‌P) {\n            return i * c + j;\n        } else if (d‌ir == DOWN) {\n            return (i + 1) * c + j;\n        } else if (d‌ir == LEFT) {\n            return r​owCnt + i * (c + 1) + j;\n        } else {\n            return r​owCnt + i * (c + 1) + (j + 1);\n        }\n    }\n \n    void add(ArrayList<Integer>[] g, int a, int b) {\n        g[a].add(b);\n        g[b].add(a);\n    }\n \n    ArrayList<Integer>[] g;\n \n    void go(int v, boolean[] was) {\n        was[v] = true;\n        for (int u : g[v]) {\n            if (!was[u]) {\n                go(u, was);\n            }\n        }\n    }\n \n    public void solve() throws IOException {\n        o​ut.println();\n        r = i​n.nextInt();\n        c = i​n.nextInt();\n        r​owCnt = (r + 1) * c;\n        colCnt = (c + 1) * r;\n        int cntV = r​owCnt + colCnt;\n        int n = r + c;\n        int[] real = new int[2 * (r + c)];\n        int p = 0;\n        for (int j = 0; j < c; j++) {\n            real[p++] = get(0, j, U‌P);\n        }\n        for (int i = 0; i < r; i++) {\n            real[p++] = get(i, c - 1, RIGHT);\n        }\n        for (int j = c - 1; j >= 0; j--) {\n            real[p++] = get(r - 1, j, DOWN);\n        }\n        for (int i = r - 1; i >= 0; i--) {\n            real[p++] = get(i, 0, LEFT);\n        }\n        boolean[] border = new boolean[cntV];\n        for (int x : real) {\n            border[x] = true;\n        }\n        int[] a = new int[n];\n        int[] b = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = real[i​n.nextInt() - 1];\n            b[i] = real[i​n.nextInt() - 1];\n        }\n        int countProfiles = 1 << (r * c);\n        for (int pr = 0; pr < countProfiles; pr++) {\n            g = new ArrayList[cntV];\n            for (int i = 0; i < cntV; i++) {\n                g[i] = new ArrayList<>();\n            }\n            char[][] map = new char[r][c];\n            int ptr = 0;\n            for (int i = 0; i < r; i++) {\n                for (int j = 0; j < c; j++) {\n                    int[] id = new int[4];\n                    for (int ii = 0; ii < 4; ii++) {\n                        id[ii] = get(i, j, ii);\n                    }\n                    if (((pr >> ptr) & 1) != 0) {\n                        map[i][j] = '/';\n                        add(g, id[U‌P], id[LEFT]);\n                        add(g, id[RIGHT], id[DOWN]);\n                    } else {\n                        map[i][j] = '\\';\n                        add(g, id[U‌P], id[RIGHT]);\n                        add(g, id[LEFT], id[DOWN]);\n                    }\n                    ptr++;\n                }\n            }\n            boolean ok = true;\n            boolean[] was = new boolean[cntV];\n            for (int i = 0; i < n; i++) {\n                Arrays.fill(was, false);\n                go(a[i], was);\n                for (int x : real) {\n                    if (x == a[i] || x == b[i]) {\n                        if (!was[x]) {\n                            ok = false;\n                            break;\n                        }\n                    } else {\n                        if (was[x]) {\n                            ok = false;\n                            break;\n                        }\n                    }\n                }\n                if (!ok) {\n                    break;\n                }\n            }\n            if (ok) {\n                for (char[] c : map) {\n                    o​ut.println(new String(c));\n                }\n                return;\n            }\n        }\n        o​ut.println("IMPOSSIBLE");\n    }\n \n    public void run() {\n        try {\n            i​n = new FastScanner(new File("a.i​n"));\n            o​ut = new PrintWriter(new File("a.o​ut"));\n \n            int tests = i​n.nextInt();\n            for (int i = 0; i < tests; i++) {\n                o​ut.print("Case #" + (i + 1) + ": ");\n                solve();\n            }\n \n            o​ut.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n \n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n \n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n \n    public static void main(String[] arg) {\n        new A().run();\n    }\n }
antonkovsharov	<>	46	<>	10224486_5718447400943616_antonkovsharov_d.java	<>	import java.util.*;\n import java.io.*;\n \n public class D {\n    FastScanner in;\n    PrintWriter o‍ut;\n \n    int n;\n    int[][] a;\n    int ans;\n    boolean[] wasWorker;\n    boolean[] wasMachine;\n    \n    boolean calc(int i‍d) {\n        if (i‍d == n) {\n            return true;\n        }\n        for (int i = 0; i < n; i++) {\n            if (!wasWorker[i]) {\n                wasWorker[i] = true;\n                boolean found = false;\n                for (int j = 0; j < n; j++) {\n                    if (a[i][j] == 1 && !wasMachine[j]) {\n                        found = true;\n                        wasMachine[j] = true;\n                        if (!calc(i‍d + 1)) {\n                            return false;\n                        }\n                        wasMachine[j] = false;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n                wasWorker[i] = false;\n            }\n        }\n        return true;\n    }\n    \n    void go(int c‌i, int c‌j, int add) {\n        if (c‌i == n) {\n            wasWorker = new boolean[n];\n            wasMachine = new boolean[n];\n            if (calc(0)) {\n                ans = Math.min(ans, add);\n            }\n            return;\n        }\n        if (c‌j == n) {\n            go(c‌i + 1, 0, add);\n            return;\n        }\n        go(c‌i, c‌j + 1, add);\n        if (a[c‌i][c‌j] == 0) {\n            a[c‌i][c‌j] = 1;\n            go(c‌i, c‌j + 1, add + 1);\n            a[c‌i][c‌j] = 0;\n        }\n    }\n    \n    public void solve() throws IOException {\n        n = in.nextInt();\n        a = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            char[] c = in.next().toCharArray();\n            for (int j = 0; j < n; j++) {\n                a[i][j] = c[j] - '0';\n            }\n        }\n        ans = n * n;\n        go(0, 0, 0);\n        o‍ut.println(ans);\n    }\n \n    public void run() {\n        try {\n            in = new FastScanner(new File("a.in"));\n            o‍ut = new PrintWriter(new File("a.o‍ut"));\n \n            int tests = in.nextInt();\n            for (int i = 0; i < tests; i++) {\n                o‍ut.print("Case #" + (i + 1) + ": ");\n                solve();\n            }\n \n            o‍ut.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n \n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer s‌t;\n \n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n \n        String next() {\n            while (s‌t == null || !s‌t.hasMoreTokens()) {\n                try {\n                    s‌t = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return s‌t.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n \n    public static void main(String[] arg) {\n        new D().run();\n    }\n }
antonkovsharov	<>	46	<>	10224486_5677604812095488_antonkovsharov_c.java	<>	import java.util.*;\n import java.io.*;\n \n public class C {\n    FastScanner in;\n    PrintWriter out;\n \n    public void solve() throws IOException {\n        int n = in.nextInt(), k = in.nextInt();\n        double[] p = new double[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = in.nextDouble();\n        }\n        Arrays.sort(p);\n        double ans = 0;\n        for (int l = 0; l <= k; l++) {\n            int r = k - l;\n            double[] ps = new double[k];\n            int ptr = 0;\n            for (int i = 0; i < l; i++) {\n                ps[ptr++] = p[i];\n            }\n            for (int i = n - r; i < n; i++) {\n                ps[ptr++] = p[i];\n            }\n            int b‌alanceZero = k;\n            int maxBalance = 2 * k;\n            double[][] d​p = new double[k + 1][maxBalance + 1];\n            d​p[0][b‌alanceZero] = 1;\n            for (int i = 0; i < k; i++) {\n                for (int j = 0; j <= maxBalance; j++) {\n                    if (d​p[i][j] != 0) {\n                        d​p[i + 1][j + 1] += d​p[i][j] * ps[i];\n                        d​p[i + 1][j - 1] += d​p[i][j] * (1 - ps[i]);\n                    }\n                }\n            }\n            if (d​p[k][b‌alanceZero] > ans) {\n                ans = d​p[k][b‌alanceZero];\n            }\n        }\n        out.println(ans);\n    }\n \n    public void run() {\n        try {\n            in = new FastScanner(new File("a.in"));\n            out = new PrintWriter(new File("a.out"));\n \n            int t‌ests = in.nextInt();\n            for (int i = 0; i < t‌ests; i++) {\n                out.print("Case #" + (i + 1) + ": ");\n                solve();\n            }\n \n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n \n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer s​t;\n \n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n \n        String next() {\n            while (s​t == null || !s​t.hasMoreTokens()) {\n                try {\n                    s​t = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return s​t.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n \n    public static void main(String[] arg) {\n        new C().run();\n    }\n }
piroz	<>	47	<>	10224486_5723605790883840_piroz_main.java	<>	package c;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.PrintWriter;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Scanner;\n import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.FutureTask;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n public class Main {\n \n    public static void main(String[] args) throws Exception {\n        Solver<Object> s​olver = Solver.getInstance("C-small-attempt1.in");\n        Scanner sc = s​olver.getScanner();\n        int c​asenum = sc.nextInt();\n        for(int caseid=0;caseid<c​asenum;caseid++) {\n            int h = sc.nextInt();\n            int w = sc.nextInt();\n            int n = (h + w) * 2;\n            int[] a = new int[n];\n            for(int i=0;i<n;i++) {\n                a[i] = sc.nextInt();\n            }\n            Task task = new Task(h,w,a);\n            s​olver.addTask(task);\n        }\n        s​olver.finish();\n    }\n \n }\n class Task implements Callable<Object> {\n    int h,w;\n    int[] a;\n    \n    public Task(int h, int w, int[] a) {\n        super();\n        this.h = h;\n        this.w = w;\n        this.a = a;\n    }\n \n    @Override\n    public Object call() throws Exception {\n        int n = (h + w) * 2;\n        int m = h + w;\n        boolean[][] e‌dge = new boolean[n][n];\n        for(int i=0;i<m;i++) {\n            int u = a[i*2] - 1;\n            int v = a[i*2+1] - 1;\n            e‌dge[u][v] = e‌dge[v][u] = true;\n        }\n        ArrayList<Pair> al = new ArrayList<>();\n        int count = 0;\n        for(int i=0;i<n;i++) {\n            int u = i;\n            int v = (i + 1) % n;\n            int size = 0;\n            if (e‌dge[u][v]) {\n                int u‌_ = u;\n                while(e‌dge[u][v]) {\n                    count++;\n                    e‌dge[u][v] = e‌dge[v][u] = false;\n                    size++;\n                    u = (u + n - 1) % n;\n                    v = (v + 1) % n;\n                }\n                al.add(new Pair(u‌_,size));\n            }\n        }\n        if (count != m) {\n            return "IMPOSSIBLE";\n        }\n        char[][] m‌ap = new char[h][w];\n        for(int i=0;i<h;i++) {\n            Arrays.fill(m‌ap[i], '/');\n        }\n        for(Pair p: al) {\n \n            int oi,oj;\n            if (p.a < w) {\n                oi = 0;\n                oj = p.a + 1;\n            }else if(p.a < w + h) {\n                oi = 1 + (p.a - w);\n                oj = w;\n            }else if(p.a < w + h + w) {\n                oi = h;\n                oj = w - 1 - (p.a - w - h);\n            }else{\n                oi = h - 1 - (p.a - w - h - w);\n                oj = 0;\n            }\n            for(int i=oi-p.b;i<=oi+p.b;i++) {\n                for(int j=oj-p.b;j<=oj+p.b;j++) {\n                    if (i < 0 || i >= h || j < 0 || j >= w) {\n                        continue;\n                    }\n                    double i2 = i + 0.5;\n                    double j2 = j + 0.5;\n                    if (Math.abs(oi - i2) + Math.abs(oj - j2) <= p.b + 0.1) {\n                        if ((oi - i2) * (oj - j2) < 0) {\n                            m‌ap[i][j] = '\\';\n                        }\n                    }\n                }\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<h;i++) {\n            if (i > 0) {\n                sb.append('\n');\n            }\n            for(int j=0;j<w;j++) {\n                sb.append(m‌ap[i][j]);\n            }\n        }\n        return sb.toString();\n    }\n    \n    \n }\n class Pair {\n    int a,b;\n \n    public Pair(int a, int b) {\n        super();\n        this.a = a;\n        this.b = b;\n    }\n    \n    public String toString() {\n        return "(" + a + "," + b + ")";\n    }\n    \n }\n interface Solver<R> {\n    public Scanner getScanner();\n    public void addTask(Callable<R> task);\n    public void finish();\n    public static <T> Solver<T> getInstance(String filename) throws IOException {\n        if (filename == null) {\n            return new DebugSolver<>();\n        }else{\n            return new ConcurrentSolver<>(filename);\n        }\n    }\n }\n class DebugSolver<R> implements Solver<R> {\n    private ArrayList<Callable<R>> tasks = new ArrayList<>();\n    public DebugSolver() {\n        \n    }\n    public Scanner getScanner() {\n        return new Scanner(System.in);\n    }\n    public void addTask(Callable<R> task) {\n        tasks.add(task);\n    }\n    public void finish() {\n        for(int i=0;i<tasks.size();i++) {\n            try {\n                long stime = System.nanoTime();\n                System.out.println("Case #" + (i+1) + ":\n" + tasks.get(i).call());\n                System.out.println((System.nanoTime() - stime) / 1000000 + " ms");\n            } catch (Exception e) {\n                e.printStackTrace();\n                return;\n            }\n        }\n    }\n }\n class ConcurrentSolver<R> implements Solver<R>{\n    private ExecutorService es = Executors.newFixedThreadPool(4,(runnable)->new Thread(null, runnable, "", 16L * 1024L * 1024L)); \n    private ArrayList<FutureTask<R>> tasks = new ArrayList<>();\n    private Scanner sc;\n    private PrintWriter pw;\n    public ConcurrentSolver(String filename) throws IOException {\n        if (filename == null) {\n            sc = new Scanner(System.in);\n            pw = new PrintWriter(System.out);\n        }else{\n            sc = new Scanner(new File(filename));\n            Matcher matcher = Pattern.compile("(.+)\\.in").matcher(filename);\n            String filenameOut;\n            if (matcher.matches()) {\n                filenameOut = matcher.group(1) + ".out";\n            }else{\n                filenameOut = "out.txt";\n            }\n            pw = new PrintWriter(new File(filenameOut));\n        }\n    }\n    public Scanner getScanner() {\n        return sc;\n    }\n    public void addTask(Callable<R> task) {\n        FutureTask<R> futureTask = new FutureTask<>(new TaskWrapper(tasks.size() + 1, task));\n        tasks.add(futureTask);\n        es.submit(futureTask);\n    }\n    public void finish() {\n        for(int i=0;i<tasks.size();i++) {\n            try {\n                pw.print("Case #" + (i+1) + ":\n" + tasks.get(i).get() + "\n");\n            } catch (InterruptedException | ExecutionException e) {\n                e.printStackTrace();\n            }\n        }\n        pw.flush();\n        es.shutdown();\n    }\n    class TaskWrapper implements Callable<R> {\n        int id;\n        Callable<R> c;\n        public TaskWrapper(int caseId,Callable<R> c) {\n            this.id = caseId;\n            this.c = c;\n        }\n        public R call() throws Exception {\n            System.out.println("Start #" + id);\n            long stime = System.nanoTime();\n            R res = c.call();\n            System.out.println("End #" + id + " (" + (System.nanoTime() - stime) / 1000000 + "ms)");\n            return res;\n        }\n    }\n }\n
piroz	<>	47	<>	10224486_5677604812095488_piroz_main.java	<>	package b;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.PrintWriter;\n import java.util.ArrayList;\n import java.util.Scanner;\n import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.FutureTask;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n public class Main {\n \n    public static void main(String[] args) throws Exception {\n        Solver<Object> s​olver = Solver.getInstance("B-small-attempt0.in");\n        Scanner s‍c = s​olver.getScanner();\n        int casenum = s‍c.nextInt();\n        for(int c‍aseid=0;c‍aseid<casenum;c‍aseid++) {\n            int n = s‍c.nextInt();\n            int k = s‍c.nextInt();\n            double[] p = new double[n];\n            for(int i=0;i<n;i++) {\n                p[i] = s‍c.nextDouble();\n            }\n            Task task = new Task(n,k,p);\n            s​olver.addTask(task);\n        }\n        s​olver.finish();\n    }\n \n }\n class Task implements Callable<Object> {\n    int n,k;\n    double[] p;\n    \n    public Task(int n, int k, double[] p) {\n        super();\n        this.n = n;\n        this.k = k;\n        this.p = p;\n    }\n \n    @Override\n    public Object call() throws Exception {\n        double m‍ax = 0;\n        for(int i=0;i<1<<n;i++) {\n            if (Integer.bitCount(i) != k) {\n                continue;\n            }\n            ArrayList<Double> al = new ArrayList<>();\n            for(int j=0;j<n;j++) {\n                if ((i >> j & 1) == 1) { \n                    al.add(p[j]);\n                }\n            }\n            double ans = 0;\n            for(int m=0;m<1<<k;m++) {\n                if (Integer.bitCount(m) != k / 2) {\n                    continue;\n                }\n                double pi = 1;\n                for(int j=0;j<k;j++) {\n                    if ((m >> j & 1) == 0) {\n                        pi *= al.get(j);\n                    }else{\n                        pi *= (1 - al.get(j));\n                    }\n                }\n                ans += pi;\n            }\n            m‍ax = Math.m‍ax(m‍ax, ans);\n        }\n        return String.format("%7f", m‍ax);\n    }\n    \n }\n \n interface Solver<R> {\n    public Scanner getScanner();\n    public void addTask(Callable<R> task);\n    public void finish();\n    public static <T> Solver<T> getInstance(String filename) throws IOException {\n        if (filename == null) {\n            return new DebugSolver<>();\n        }else{\n            return new ConcurrentSolver<>(filename);\n        }\n    }\n }\n class DebugSolver<R> implements Solver<R> {\n    private ArrayList<Callable<R>> tasks = new ArrayList<>();\n    public DebugSolver() {\n        \n    }\n    public Scanner getScanner() {\n        return new Scanner(System.in);\n    }\n    public void addTask(Callable<R> task) {\n        tasks.add(task);\n    }\n    public void finish() {\n        for(int i=0;i<tasks.size();i++) {\n            try {\n                long stime = System.nanoTime();\n                System.out.println("Case #" + (i+1) + ": " + tasks.get(i).call());\n                System.out.println((System.nanoTime() - stime) / 1000000 + " ms");\n            } catch (Exception e) {\n                e.printStackTrace();\n                return;\n            }\n        }\n    }\n }\n class ConcurrentSolver<R> implements Solver<R>{\n    private ExecutorService e‍s = Executors.newFixedThreadPool(4,(runnable)->new Thread(null, runnable, "", 16L * 1024L * 1024L)); \n    private ArrayList<FutureTask<R>> tasks = new ArrayList<>();\n    private Scanner s‍c;\n    private PrintWriter pw;\n    public ConcurrentSolver(String filename) throws IOException {\n        if (filename == null) {\n            s‍c = new Scanner(System.in);\n            pw = new PrintWriter(System.out);\n        }else{\n            s‍c = new Scanner(new File(filename));\n            Matcher m‌atcher = Pattern.compile("(.+)\\.in").m‌atcher(filename);\n            String filenameOut;\n            if (m‌atcher.matches()) {\n                filenameOut = m‌atcher.group(1) + ".out";\n            }else{\n                filenameOut = "out.txt";\n            }\n            pw = new PrintWriter(new File(filenameOut));\n        }\n    }\n    public Scanner getScanner() {\n        return s‍c;\n    }\n    public void addTask(Callable<R> task) {\n        FutureTask<R> f​utureTask = new FutureTask<>(new TaskWrapper(tasks.size() + 1, task));\n        tasks.add(f​utureTask);\n        e‍s.submit(f​utureTask);\n    }\n    public void finish() {\n        for(int i=0;i<tasks.size();i++) {\n            try {\n                pw.println("Case #" + (i+1) + ": " + tasks.get(i).get());\n            } catch (InterruptedException | ExecutionException e) {\n                e.printStackTrace();\n            }\n        }\n        pw.flush();\n        e‍s.shutdown();\n    }\n    class TaskWrapper implements Callable<R> {\n        int id;\n        Callable<R> c;\n        public TaskWrapper(int caseId,Callable<R> c) {\n            this.id = caseId;\n            this.c = c;\n        }\n        public R call() throws Exception {\n            System.out.println("Start #" + id);\n            long stime = System.nanoTime();\n            R res = c.call();\n            System.out.println("End #" + id + " (" + (System.nanoTime() - stime) / 1000000 + "ms)");\n            return res;\n        }\n    }\n }\n
piroz	<>	47	<>	10224486_5718606851604480_piroz_main.java	<>	package a;\n \n import java.io.File;\n import java.io.IOException;\n import java.io.PrintWriter;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Scanner;\n import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.FutureTask;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n public class Main {\n \n    public static void main(String[] args) throws Exception {\n        Solver<Object> solver = Solver.getInstance("A-small-attempt0.in");\n        Scanner sc = solver.getScanner();\n        int c‍asenum = sc.nextInt();\n        for(int caseid=0;caseid<c‍asenum;caseid++) {\n            int n = sc.nextInt();\n            int[] a = new int[3];\n            for(int i=0;i<3;i++) {\n                a[i] = sc.nextInt();\n            }\n            Task task = new Task(n,a);\n            solver.addTask(task);\n        }\n        solver.finish();\n    }\n \n }\n class Task implements Callable<Object> {\n    public static final String rps = "RPS";\n    \n    int n;\n    int[] a;\n    \n    public Task(int n, int[] a) {\n        super();\n        this.n = n;\n        this.a = a;\n    }\n \n    @Override\n    public Object call() throws Exception {\n        ArrayList<String> ans = new ArrayList<>();\n        for(int i=0;i<3;i++) {\n            String s = generate(n, rps.charAt(i));\n            int[] c​ount = new int[3];\n            for(int j=0;j<s.length();j++) {\n                c​ount[map(s.charAt(j))]++;\n            }\n            if (Arrays.equals(a, c​ount)) {\n                ans.add(s);\n            }\n        }\n        if (ans.size() == 0) {\n            return "IMPOSSIBLE";\n        }\n        ans.sort(null);\n        return ans.get(0);\n    }\n    \n    static String generate(int n,char w‌inner) {\n        if (n == 0) {\n            return String.valueOf(w‌inner);\n        }\n        String s1 = generate(n - 1, w‌inner);\n        String s2 = generate(n - 1, lose(w‌inner));\n        if (s1.compareTo(s2) < 0) {\n            return s1 + s2;\n        }else{\n            return s2 + s1;\n        }\n    }\n    \n    static int map(char c) {\n        if (c == 'R') {\n            return 0;\n        }else if(c == 'P') {\n            return 1;\n        }else{\n            return 2;\n        }\n    }\n    \n    static char lose(char c) {\n        return rps.charAt((map(c)+1)%3);\n    }\n    \n    static boolean nextPermutation(int[] p) {\n        for(int a=p.length-2;a>=0;--a) {\n            if(p[a]<p[a+1]) {\n                for(int b=p.length-1;;--b) {\n                    if(p[b]>p[a]) {\n                        int t = p[a];\n                        p[a] = p[b];\n                        p[b] = t;\n                        for(++a, b=p.length-1;a<b;++a,--b) {\n                            t = p[a];\n                            p[a] = p[b];\n                            p[b] = t;\n                        }\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n }\n \n interface Solver<R> {\n    public Scanner getScanner();\n    public void addTask(Callable<R> task);\n    public void finish();\n    public static <T> Solver<T> getInstance(String f‍ilename) throws IOException {\n        if (f‍ilename == null) {\n            return new DebugSolver<>();\n        }else{\n            return new ConcurrentSolver<>(f‍ilename);\n        }\n    }\n }\n class DebugSolver<R> implements Solver<R> {\n    private ArrayList<Callable<R>> tasks = new ArrayList<>();\n    public DebugSolver() {\n        \n    }\n    public Scanner getScanner() {\n        return new Scanner(System.in);\n    }\n    public void addTask(Callable<R> task) {\n        tasks.add(task);\n    }\n    public void finish() {\n        for(int i=0;i<tasks.size();i++) {\n            try {\n                long s‌time = System.nanoTime();\n                System.out.println("Case #" + (i+1) + ": " + tasks.get(i).call());\n                System.out.println((System.nanoTime() - s‌time) / 1000000 + " ms");\n            } catch (Exception e) {\n                e.printStackTrace();\n                return;\n            }\n        }\n    }\n }\n class ConcurrentSolver<R> implements Solver<R>{\n    private ExecutorService es = Executors.newFixedThreadPool(4,(runnable)->new Thread(null, runnable, "", 16L * 1024L * 1024L)); \n    private ArrayList<FutureTask<R>> tasks = new ArrayList<>();\n    private Scanner sc;\n    private PrintWriter p‌w;\n    public ConcurrentSolver(String f‍ilename) throws IOException {\n        if (f‍ilename == null) {\n            sc = new Scanner(System.in);\n            p‌w = new PrintWriter(System.out);\n        }else{\n            sc = new Scanner(new File(f‍ilename));\n            Matcher m​atcher = Pattern.compile("(.+)\\.in").m​atcher(f‍ilename);\n            String filenameOut;\n            if (m​atcher.matches()) {\n                filenameOut = m​atcher.group(1) + ".out";\n            }else{\n                filenameOut = "out.txt";\n            }\n            p‌w = new PrintWriter(new File(filenameOut));\n        }\n    }\n    public Scanner getScanner() {\n        return sc;\n    }\n    public void addTask(Callable<R> task) {\n        FutureTask<R> futureTask = new FutureTask<>(new TaskWrapper(tasks.size() + 1, task));\n        tasks.add(futureTask);\n        es.submit(futureTask);\n    }\n    public void finish() {\n        for(int i=0;i<tasks.size();i++) {\n            try {\n                p‌w.println("Case #" + (i+1) + ": " + tasks.get(i).get());\n            } catch (InterruptedException | ExecutionException e) {\n                e.printStackTrace();\n            }\n        }\n        p‌w.flush();\n        es.shutdown();\n    }\n    class TaskWrapper implements Callable<R> {\n        int id;\n        Callable<R> c;\n        public TaskWrapper(int caseId,Callable<R> c) {\n            this.id = caseId;\n            this.c = c;\n        }\n        public R call() throws Exception {\n            System.out.println("Start #" + id);\n            long s‌time = System.nanoTime();\n            R res = c.call();\n            System.out.println("End #" + id + " (" + (System.nanoTime() - s‌time) / 1000000 + "ms)");\n            return res;\n        }\n    }\n }\n
trold	<>	60	<>	10224486_5677604812095488_trold_b.java	<>	\n import java.io.*;\n import java.util.*;\n \n public class B {\n    int getInt(BufferedReader i​n) throws IOException {\n        return Integer.parseInt(i​n.readLine());\n    }   \n    int[] getInts(BufferedReader i​n) throws IOException {\n        String[] w‍ords = i​n.readLine().split(" ");\n        int[] r​et = new int[w‍ords.length];\n        for (int i = 0 ; i < w‍ords.length ; i++) r​et[i] = Integer.parseInt(w‍ords[i]);\n        return r​et;\n    }\n \n    double[] getDoubles(BufferedReader i​n) throws IOException {\n        String[] w‍ords = i​n.readLine().split(" ");\n        double[] r​et = new double[w‍ords.length];\n        for (int i = 0 ; i < w‍ords.length ; i++) r​et[i] = Double.parseDouble(w‍ords[i]);\n        return r​et;\n    }\n \n    void inc(int[] idx, int p) {\n        idx[p]++;\n        if (p == idx.length - 1) return;\n        if (idx[p] == idx[p+1]) {\n            if (p == 0) idx[p] = 0;\n            else idx[p] = idx[p-1]+1;\n            inc(idx, p + 1);\n        }\n    }\n \n    String compute(int M, double[] P) {\n        int N = P.length;\n        int[] idx = new int[M];\n        for (int i = 0 ; i < M ; i++) idx[i] = i;\n        double m‍ax = 0;\n        do {\n            double[] V = new double[M+1];\n            V[0] = 1;\n            for (int i = 0 ; i < M ; i++) {\n                for (int j = i ; j >= 0 ; j--) {\n                    V[j+1] += V[j] * P[idx[i]];\n                    V[j] *= (1 - P[idx[i]]);\n                }\n            }\n            m‍ax = Math.m‍ax(m‍ax, V[M/2]);\n            inc(idx, 0);\n        } while (idx[M-1] < N);\n        return m‍ax+"";\n    }\n \n    void run(String[] args) {\n        try {\n            BufferedReader i​n = new BufferedReader(new FileReader(args[0]));\n            PrintStream out = new PrintStream(args[0] + ".out");\n            int T = getInt(i​n);\n            for (int t = 1 ; t <= T ; t++) {\n                int[] nums = getInts(i​n);\n                double[] probs = getDoubles(i​n);\n                out.printf("Case #%d: %s\n", t, compute(nums[1], probs));\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n \n    public static void main (String[] args) {\n        new B().run(args);\n    }\n }\n
trold	<>	60	<>	11254486_5686313294495744_trold_c.java	<>	\n import java.io.*;\n import java.util.*;\n \n class FlowGraph {\n    class FlowEdge {\n        int l‍o, f, h‍i, xor;\n        FlowEdge(int fr, int t‍o) { xor = fr ^ t‍o; }\n        int other(int i) { return i ^ xor; }\n        int res(int i, int j) { return i < j ? h‍i-f : f-l‍o; }\n    }\n    int N;\n    List<Set<FlowEdge>> edgelists;\n    Map<Integer,FlowEdge> edges = new HashMap<Integer,FlowEdge>();\n    FlowEdge get(int i, int j) {\n        int key = (Math.min(i, j) << 16) + Math.max(i, j);\n        FlowEdge e = edges.get(key);\n        if (e == null) {\n            e = new FlowEdge(i,j);\n            edges.put(key, e);\n            edgelists.get(i).add(e);\n            edgelists.get(j).add(e);\n        }\n        return e;\n    }\n    FlowGraph(int N) {\n        this.N = N; edgelists = new ArrayList<Set<FlowEdge>>();\n        for (int i = 0 ; i < N ; i++) edgelists.add(new HashSet<FlowEdge>());\n    }\n    int flow(int i, int j) { FlowEdge e = get(i,j); return i < j ? e.f : -e.f; }\n    void cap(int i, int j, int cap) { FlowEdge e = get(i,j); if (i < j) e.h‍i = cap; else e.l‍o = -cap; }\n    void add(int i, int j, int d) { FlowEdge e = get(i,j); if (i < j) e.f += d; else e.f -= d; }\n    void clear() { for (Set<FlowEdge> set : edgelists) for (FlowEdge e : set) e.f = 0; }\n    int edKarp(int s, int t) {\n        int total = 0;\n        while (true) {\n            FlowEdge[] b = new FlowEdge[N];\n            List<Integer> bfs = new ArrayList<Integer>();\n            bfs.add(s);\n outer:     for (int idx = 0 ; idx < bfs.size() ; idx++) {\n                int i = bfs.get(idx);\n                for (FlowEdge e : edgelists.get(i)) {\n                    int j = e.other(i);\n                    if (e.res(i,j) > 0 && b[j] == null) {\n                        b[j] = e;\n                        if (j == t) break outer;\n                        bfs.add(j);\n                    }\n                }\n            }\n            if (b[t] == null) return total;\n            int df = Integer.MAX_VALUE;\n            for (int t‍o = t ; t‍o != s ;) {\n                int f‍rom = b[t‍o].other(t‍o);\n                df = Math.min(df, b[t‍o].res(f‍rom, t‍o));\n                t‍o = f‍rom;\n            }\n            total += df;\n            for (int t‍o = t ; t‍o != s ;) {\n                int f‍rom = b[t‍o].other(t‍o);\n                if (f‍rom < t‍o) b[t‍o].f += df; else b[t‍o].f -= df;\n                t‍o = f‍rom;\n            }\n        }\n    }\n }\n \n public class C {\n    int getInt(BufferedReader i‌n) throws IOException {\n        return Integer.parseInt(i‌n.readLine());\n    }   \n    int[] getInts(BufferedReader i‌n) throws IOException {\n        String[] words = i‌n.readLine().split(" ");\n        int[] ret = new int[words.length];\n        for (int i = 0 ; i < words.length ; i++) ret[i] = Integer.parseInt(words[i]);\n        return ret;\n    }\n \n    String compute(int[][] D, int A, int B) {\n        int N = A+B+2;\n        int s = N - 1;\n        int t = N - 2;\n        FlowGraph G = new FlowGraph(N);\n        for (int i = 0 ; i < A ; i++) G.cap(s, i, 1);\n        for (int i = 0 ; i < B ; i++) G.cap(A+i, t, 1);\n        for (int[] e : D) G.cap(e[0], e[1]+A, 1);\n        return D.length-A-B+G.edKarp(s,t) +"";\n    }\n \n    void run(String[] args) {\n        try {\n            BufferedReader i‌n = new BufferedReader(new FileReader(args[0]));\n            PrintStream out = new PrintStream(args[0] + ".out");\n            int T = getInt(i‌n);\n            for (int t = 1 ; t <= T ; t++) {\n                Map<String,Integer> A = new HashMap<>();\n                Map<String,Integer> B = new HashMap<>();\n                int N = getInt(i‌n);\n                int[][] D = new int[N][2];\n                for (int i = 0 ; i < N ; i++) {\n                    String[] w = i‌n.readLine().split(" ");\n                    if (!A.containsKey(w[0])) A.put(w[0], A.size());\n                    if (!B.containsKey(w[1])) B.put(w[1], B.size());\n                    D[i][0] = A.get(w[0]);\n                    D[i][1] = B.get(w[1]);\n                }\n                out.printf("Case #%d: %s\n", t, compute(D, A.size(), B.size()));\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n \n    public static void main (String[] args) {\n        new C().run(args);\n    }\n }\n
trold	<>	60	<>	11254486_5648941810974720_trold_a.java	<>	\n import java.io.*;\n import java.util.*;\n \n public class A {\n    int getInt(BufferedReader in) throws IOException {\n        return Integer.parseInt(in.readLine());\n    }   \n    int[] getInts(BufferedReader in) throws IOException {\n        String[] words = in.readLine().split(" ");\n        int[] ret = new int[words.length];\n        for (int i = 0 ; i < words.length ; i++) ret[i] = Integer.parseInt(words[i]);\n        return ret;\n    }\n \n    String[] NUM = {"ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE"};\n \n    String compute(int[] sig) {\n        boolean found = false;\n        for (int i : sig) {\n            if (i > 0) found = true;\n            if (i < 0) return null;\n        }\n        if (!found) return "";\n        for (int d = 0 ; d <= 9 ; d++) {\n            int[] d‌s = sig.clone();\n            for (char c : NUM[d].toCharArray()) d‌s[c-'A']--;\n            String s = compute(d‌s);\n            if (s != null) return d + s;\n        }\n        return null;\n    }\n \n    void run(String[] args) {\n        try {\n            BufferedReader in = new BufferedReader(new FileReader(args[0]));\n            PrintStream o‌ut = new PrintStream(args[0] + ".o‌ut");\n            int T = getInt(in);\n            for (int t = 1 ; t <= T ; t++) {\n                String s = in.readLine();\n                int[] sig = new int[30];\n                for (char c : s.toCharArray()) {\n                    sig[c-'A']++;\n                }\n                o‌ut.printf("Case #%d: %s\n", t, compute(sig));\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n \n    public static void main (String[] args) {\n        new A().run(args);\n    }\n }\n
dalex	<>	61	<>	10224486_5718606851604480_dalex_main.java	<>	import java.io.OutputStream;\n import java.io.FilenameFilter;\n import java.util.Locale;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.FileInputStream;\n import java.io.File;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.PrintWriter;\n import java.util.Arrays;\n import java.io.BufferedWriter;\n import java.util.InputMismatchException;\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.List;\n import java.io.Writer;\n import java.io.OutputStreamWriter;\n import java.io.InputStream;\n \n \n public class Main {\n     public static void main(String[] args) {\n         Locale.setDefault(Locale.US);\n         InputStream inputStream;\n         try {\n             final String regex = "A-(small|large).*[.]in";\n             File d‍irectory = new File(".");\n             File[] c‌andidates = d‍irectory.listFiles(new FilenameFilter() {\n                 public boolean accept(File d‍ir, String n‍ame) {\n                     return n‍ame.matches(regex);\n                 }\n             });\n             File t‌oRun = null;\n             for (File candidate : c‌andidates) {\n                 if (t‌oRun == null || candidate.lastModified() > t‌oRun.lastModified())\n                     t‌oRun = candidate;\n             }\n             inputStream = new FileInputStream(t‌oRun);\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n         OutputStream outputStream;\n         try {\n             outputStream = new FileOutputStream("a.out");\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n         InputReader in = new InputReader(inputStream);\n         OutputWriter out = new OutputWriter(outputStream);\n         TaskA solver = new TaskA();\n         int testCount = Integer.parseInt(in.next());\n         for (int i = 1; i <= testCount; i++)\n             solver.solve(i, in, out);\n         out.close();\n     }\n \n     static class TaskA {\n         static final char[] v = "RPS".toCharArray();\n \n         public void solve(int testNumber, InputReader in, OutputWriter out) {\n             out.printFormat("Case #%d: ", testNumber);\n             int n = in.readInt();\n             int R = in.readInt();\n             int P = in.readInt();\n             int S = in.readInt();\n             char[] a = new char[1 << n];\n             List<Integer> have = new ArrayList<>();\n             List<String> winStrings = new ArrayList<>();\n             int[] cnt = new int[256];\n             for (char winnerChar : v) {\n                 have.clear();\n                 have.add(0);\n                 Arrays.fill(a, (char) 0);\n                 a[0] = winnerChar;\n                 cnt['R'] = R;\n                 cnt['S'] = S;\n                 cnt['P'] = P;\n                 cnt[winnerChar]--;\n                 for (int d = (1 << n) / 2; d >= 1; d /= 2) {\n                     int sz = have.size();\n                     for (int i = 0; i < sz; i++) {\n                         int pos = have.get(i);\n                         int loserPos = pos ^ d;\n                         char loserChar = loserFor(a[pos]);\n                         a[loserPos] = loserChar;\n                         have.add(loserPos);\n                         cnt[loserChar]--;\n                     }\n                 }\n                 if (cnt['R'] == 0 && cnt['S'] == 0 && cnt['P'] == 0) {\n                     winStrings.add(new String(a));\n                 }\n             }\n             if (winStrings.isEmpty()) {\n                 out.printLine("IMPOSSIBLE");\n             } else {\n                 String min = null;\n                 for (String s : winStrings) {\n                     String t = process(s);\n                     if (min == null || t.compareTo(min) < 0) {\n                         min = t;\n                     }\n                 }\n                 out.printLine(min);\n             }\n         }\n \n         private String process(String s) {\n             int n = s.length();\n             if ((n & (n - 1)) != 0) {\n                 throw new IllegalArgumentException();\n             }\n             StringBuilder sb = new StringBuilder();\n             for (int d = 1; d < n; d *= 2) {\n                 sb.setLength(0);\n                 for (int i = 0; i < n; i += 2 * d) {\n                     String a = s.substring(i, i + d);\n                     String b = s.substring(i + d, i + 2 * d);\n                     if (a.compareTo(b) > 0) {\n                         String t = a;\n                         a = b;\n                         b = t;\n                     }\n                     sb.append(a);\n                     sb.append(b);\n                 }\n                 s = sb.toString();\n             }\n             return s;\n         }\n \n         private char loserFor(char c) {\n             if (c == 'R') return 'S';\n             if (c == 'S') return 'P';\n             if (c == 'P') return 'R';\n             throw new IllegalArgumentException();\n         }\n \n     }\n \n     static class InputReader {\n         private InputStream stream;\n         private byte[] buf = new byte[1024];\n         private int curChar;\n         private int numChars;\n         private SpaceCharFilter filter;\n \n         public InputReader(InputStream stream) {\n             this.stream = stream;\n         }\n \n         public int read() {\n             if (numChars == -1)\n                 throw new InputMismatchException();\n             if (curChar >= numChars) {\n                 curChar = 0;\n                 try {\n                     numChars = stream.read(buf);\n                 } catch (IOException e) {\n                     throw new InputMismatchException();\n                 }\n                 if (numChars <= 0)\n                     return -1;\n             }\n             return buf[curChar++];\n         }\n \n         public int readInt() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             int sgn = 1;\n             if (c == '-') {\n                 sgn = -1;\n                 c = read();\n             }\n             int res = 0;\n             do {\n                 if (c < '0' || c > '9')\n                     throw new InputMismatchException();\n                 res *= 10;\n                 res += c - '0';\n                 c = read();\n             } while (!isSpaceChar(c));\n             return res * sgn;\n         }\n \n         public String readString() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             StringBuilder res = new StringBuilder();\n             do {\n                 if (Character.isValidCodePoint(c))\n                     res.appendCodePoint(c);\n                 c = read();\n             } while (!isSpaceChar(c));\n             return res.toString();\n         }\n \n         public boolean isSpaceChar(int c) {\n             if (filter != null)\n                 return filter.isSpaceChar(c);\n             return isWhitespace(c);\n         }\n \n         public static boolean isWhitespace(int c) {\n             return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n         }\n \n         public String next() {\n             return readString();\n         }\n \n         public interface SpaceCharFilter {\n             public boolean isSpaceChar(int ch);\n \n         }\n \n     }\n \n     static class OutputWriter {\n         private final PrintWriter writer;\n \n         public OutputWriter(OutputStream outputStream) {\n             writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n         }\n \n         public OutputWriter(Writer writer) {\n             this.writer = new PrintWriter(writer);\n         }\n \n         public void print(Object... objects) {\n             for (int i = 0; i < objects.length; i++) {\n                 if (i != 0)\n                     writer.print(' ');\n                 writer.print(objects[i]);\n             }\n         }\n \n         public void printLine(Object... objects) {\n             print(objects);\n             writer.println();\n         }\n \n         public void printFormat(String format, Object... objects) {\n             writer.printf(format, objects);\n         }\n \n         public void close() {\n             writer.close();\n         }\n \n     }\n }\n \n
dalex	<>	61	<>	10224486_5723605790883840_dalex_main.java	<>	import java.io.OutputStream;\n import java.io.FilenameFilter;\n import java.util.Locale;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.FileInputStream;\n import java.io.File;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.PrintWriter;\n import java.util.Arrays;\n import java.io.BufferedWriter;\n import java.util.InputMismatchException;\n import java.io.IOException;\n import java.io.Writer;\n import java.io.OutputStreamWriter;\n import java.io.InputStream;\n \n \n public class Main {\n     public static void main(String[] args) {\n         Locale.setDefault(Locale.US);\n         InputStream i‌nputStream;\n         try {\n             final String regex = "C-(small|large).*[.]in";\n             File d‌irectory = new File(".");\n             File[] c‌andidates = d‌irectory.listFiles(new FilenameFilter() {\n                 public boolean accept(File dir, String name) {\n                     return name.matches(regex);\n                 }\n             });\n             File t‌oRun = null;\n             for (File candidate : c‌andidates) {\n                 if (t‌oRun == null || candidate.lastModified() > t‌oRun.lastModified())\n                     t‌oRun = candidate;\n             }\n             i‌nputStream = new FileInputStream(t‌oRun);\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n         OutputStream outputStream;\n         try {\n             outputStream = new FileOutputStream("c.out");\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n         InputReader in = new InputReader(i‌nputStream);\n         OutputWriter out = new OutputWriter(outputStream);\n         TaskC solver = new TaskC();\n         int testCount = Integer.parseInt(in.next());\n         for (int i = 1; i <= testCount; i++)\n             solver.solve(i, in, out);\n         out.close();\n     }\n \n     static class TaskC {\n         final String dir = "URDL";\n \n         public void solve(int testNumber, InputReader in, OutputWriter out) {\n             out.printFormat("Case #%d:\n", testNumber);\n             int n = in.readInt();\n             int m = in.readInt();\n             int t = 2 * (n + m);\n             int[] A = new int[t / 2];\n             int[] B = new int[t / 2];\n             for (int i = 0; i < t / 2; i++) {\n                 A[i] = in.readInt() - 1;\n                 B[i] = in.readInt() - 1;\n             }\n             int[] posX = new int[t];\n             int[] posY = new int[t];\n             int z = 0;\n             for (int c = 1; c <= m; c++) {\n                 posX[z] = 0;\n                 posY[z] = c;\n                 z++;\n             }\n             for (int r = 1; r <= n; r++) {\n                 posX[z] = r;\n                 posY[z] = m + 1;\n                 z++;\n             }\n             for (int c = m; c >= 1; c--) {\n                 posX[z] = n + 1;\n                 posY[z] = c;\n                 z++;\n             }\n             for (int r = n; r >= 1; r--) {\n                 posX[z] = r;\n                 posY[z] = 0;\n                 z++;\n             }\n             if (z != t) {\n                 throw new IllegalStateException();\n             }\n             char[][] a = new char[n + 2][m + 2];\n             boolean[][][] vis = new boolean[4][n + 2][m + 2];\n             for (int mask = 0; mask < (1 << (n * m)); mask++) {\n                 for (int bit = 0; bit < n * m; bit++) {\n                     int r = bit / m;\n                     int c = bit % m;\n                     r++;\n                     c++;\n                     if ((mask & (1 << bit)) != 0) {\n                         a[r][c] = '/';\n                     } else {\n                         a[r][c] = '\\';\n                     }\n                 }\n                 if (good(a, vis, n, m, posX, posY, A, B)) {\n                     for (int i = 1; i <= n; i++) {\n                         for (int j = 1; j <= m; j++) {\n                             out.print(a[i][j]);\n                         }\n                         out.printLine();\n                     }\n                     return;\n                 }\n             }\n             out.printLine("IMPOSSIBLE");\n         }\n \n         private boolean good(char[][] a, boolean[][][] vis, int n, int m, int[] posX, int[] posY, int[] A, int[] B) {\n             ArrayUtils.fill(vis, false);\n             for (int i = 0; i < A.length; i++) {\n                 int start = A[i];\n                 int finish = B[i];\n                 int sx = posX[start];\n                 int sy = posY[start];\n                 int fx = posX[finish];\n                 int fy = posY[finish];\n                 int partStart = getPart(sx, sy, n, m);\n                 int partFinish = getPart(fx, fy, n, m);\n                 switch (dir.charAt(partStart)) {\n                     case 'U':\n                         sx--;\n                         break;\n                     case 'D':\n                         sx++;\n                         break;\n                     case 'L':\n                         sy--;\n                         break;\n                     case 'R':\n                         sy++;\n                         break;\n                     default:\n                         throw new IllegalStateException();\n                 }\n                 switch (dir.charAt(partFinish)) {\n                     case 'U':\n                         fx--;\n                         break;\n                     case 'D':\n                         fx++;\n                         break;\n                     case 'L':\n                         fy--;\n                         break;\n                     case 'R':\n                         fy++;\n                         break;\n                     default:\n                         throw new IllegalStateException();\n                 }\n                 partStart = (partStart + 2) % 4;\n                 partFinish = (partFinish + 2) % 4;\n                 if (!dfs(sx, sy, partStart,\n                         fx, fy, partFinish,\n                         a, vis, n, m)) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n \n         private int getPart(int x, int y, int n, int m) {\n             if (x == 0) {\n                 return dir.indexOf('D');\n             }\n             if (x == n + 1) {\n                 return dir.indexOf('U');\n             }\n             if (y == 0) {\n                 return dir.indexOf('R');\n             }\n             if (y == m + 1) {\n                 return dir.indexOf('L');\n             }\n             throw new IllegalArgumentException();\n         }\n \n         private boolean dfs(int x, int y, int p, int fx, int fy, int fp, char[][] a, boolean[][][] vis, int n, int m) {\n             if (x <= 0 || x >= n + 1) return false;\n             if (y <= 0 || y >= m + 1) return false;\n             if (x == fx && y == fy && p == fp) {\n                 return true;\n             }\n             if (vis[p][x][y]) {\n                 return false;\n             }\n             vis[p][x][y] = true;\n             boolean res = false;\n             if (dir.charAt(p) == 'U') {\n                 res |= dfs(x - 1, y, (p + 2) % 4, fx, fy, fp, a, vis, n, m);\n                 if (a[x][y] == '/') {\n                     res |= dfs(x, y, (p + 3) % 4, fx, fy, fp, a, vis, n, m);\n                 }\n                 if (a[x][y] == '\\') {\n                     res |= dfs(x, y, (p + 1) % 4, fx, fy, fp, a, vis, n, m);\n                 }\n             }\n             if (dir.charAt(p) == 'D') {\n                 res |= dfs(x + 1, y, (p + 2) % 4, fx, fy, fp, a, vis, n, m);\n                 if (a[x][y] == '/') {\n                     res |= dfs(x, y, (p + 3) % 4, fx, fy, fp, a, vis, n, m);\n                 }\n                 if (a[x][y] == '\\') {\n                     res |= dfs(x, y, (p + 1) % 4, fx, fy, fp, a, vis, n, m);\n                 }\n             }\n             if (dir.charAt(p) == 'L') {\n                 res |= dfs(x, y - 1, (p + 2) % 4, fx, fy, fp, a, vis, n, m);\n                 if (a[x][y] == '/') {\n                     res |= dfs(x, y, (p + 1) % 4, fx, fy, fp, a, vis, n, m);\n                 }\n                 if (a[x][y] == '\\') {\n                     res |= dfs(x, y, (p + 3) % 4, fx, fy, fp, a, vis, n, m);\n                 }\n             }\n             if (dir.charAt(p) == 'R') {\n                 res |= dfs(x, y + 1, (p + 2) % 4, fx, fy, fp, a, vis, n, m);\n                 if (a[x][y] == '/') {\n                     res |= dfs(x, y, (p + 1) % 4, fx, fy, fp, a, vis, n, m);\n                 }\n                 if (a[x][y] == '\\') {\n                     res |= dfs(x, y, (p + 3) % 4, fx, fy, fp, a, vis, n, m);\n                 }\n             }\n             return res;\n         }\n \n     }\n \n     static class ArrayUtils {\n         public static void fill(boolean[][] array, boolean value) {\n             for (boolean[] row : array)\n                 Arrays.fill(row, value);\n         }\n \n         public static void fill(boolean[][][] array, boolean value) {\n             for (boolean[][] row : array)\n                 fill(row, value);\n         }\n \n     }\n \n     static class OutputWriter {\n         private final PrintWriter writer;\n \n         public OutputWriter(OutputStream outputStream) {\n             writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n         }\n \n         public OutputWriter(Writer writer) {\n             this.writer = new PrintWriter(writer);\n         }\n \n         public void print(Object... objects) {\n             for (int i = 0; i < objects.length; i++) {\n                 if (i != 0)\n                     writer.print(' ');\n                 writer.print(objects[i]);\n             }\n         }\n \n         public void printLine() {\n             writer.println();\n         }\n \n         public void printLine(Object... objects) {\n             print(objects);\n             writer.println();\n         }\n \n         public void print(char i) {\n             writer.print(i);\n         }\n \n         public void printFormat(String format, Object... objects) {\n             writer.printf(format, objects);\n         }\n \n         public void close() {\n             writer.close();\n         }\n \n     }\n \n     static class InputReader {\n         private InputStream stream;\n         private byte[] buf = new byte[1024];\n         private int curChar;\n         private int numChars;\n         private SpaceCharFilter filter;\n \n         public InputReader(InputStream stream) {\n             this.stream = stream;\n         }\n \n         public int read() {\n             if (numChars == -1)\n                 throw new InputMismatchException();\n             if (curChar >= numChars) {\n                 curChar = 0;\n                 try {\n                     numChars = stream.read(buf);\n                 } catch (IOException e) {\n                     throw new InputMismatchException();\n                 }\n                 if (numChars <= 0)\n                     return -1;\n             }\n             return buf[curChar++];\n         }\n \n         public int readInt() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             int sgn = 1;\n             if (c == '-') {\n                 sgn = -1;\n                 c = read();\n             }\n             int res = 0;\n             do {\n                 if (c < '0' || c > '9')\n                     throw new InputMismatchException();\n                 res *= 10;\n                 res += c - '0';\n                 c = read();\n             } while (!isSpaceChar(c));\n             return res * sgn;\n         }\n \n         public String readString() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             StringBuilder res = new StringBuilder();\n             do {\n                 if (Character.isValidCodePoint(c))\n                     res.appendCodePoint(c);\n                 c = read();\n             } while (!isSpaceChar(c));\n             return res.toString();\n         }\n \n         public boolean isSpaceChar(int c) {\n             if (filter != null)\n                 return filter.isSpaceChar(c);\n             return isWhitespace(c);\n         }\n \n         public static boolean isWhitespace(int c) {\n             return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n         }\n \n         public String next() {\n             return readString();\n         }\n \n         public interface SpaceCharFilter {\n             public boolean isSpaceChar(int ch);\n \n         }\n \n     }\n }\n \n
dalex	<>	61	<>	10224486_5677604812095488_dalex_main.java	<>	import java.io.OutputStream;\n import java.io.FilenameFilter;\n import java.util.Locale;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.FileInputStream;\n import java.io.File;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.PrintWriter;\n import java.io.BufferedWriter;\n import java.util.InputMismatchException;\n import java.io.IOException;\n import java.io.Writer;\n import java.io.OutputStreamWriter;\n import java.io.InputStream;\n \n \n public class Main {\n     public static void main(String[] args) {\n         Locale.setDefault(Locale.US);\n         InputStream inputStream;\n         try {\n             final String r‍egex = "B-(small|large).*[.]i‍n";\n             File d‌irectory = new File(".");\n             File[] c‍andidates = d‌irectory.listFiles(new FilenameFilter() {\n                 public boolean accept(File dir, String name) {\n                     return name.matches(r‍egex);\n                 }\n             });\n             File toRun = null;\n             for (File candidate : c‍andidates) {\n                 if (toRun == null || candidate.lastModified() > toRun.lastModified())\n                     toRun = candidate;\n             }\n             inputStream = new FileInputStream(toRun);\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n         OutputStream o​utputStream;\n         try {\n             o​utputStream = new FileOutputStream("b.o‍ut");\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n         InputReader i‍n = new InputReader(inputStream);\n         OutputWriter o‍ut = new OutputWriter(o​utputStream);\n         TaskB solver = new TaskB();\n         int testCount = Integer.parseInt(i‍n.next());\n         for (int i = 1; i <= testCount; i++)\n             solver.solve(i, i‍n, o‍ut);\n         o‍ut.close();\n     }\n \n     static class TaskB {\n         public void solve(int testNumber, InputReader i‍n, OutputWriter o‍ut) {\n             o‍ut.printFormat("Case #%d: ", testNumber);\n             int n = i‍n.readInt();\n             int k = i‍n.readInt();\n             double[] p = new double[n];\n             for (int i = 0; i < n; i++) {\n                 p[i] = i‍n.readDouble();\n             }\n             if (k % 2 != 0) {\n                 throw new IllegalArgumentException();\n             }\n             double s​tupid = s​tupid(n, k, p);\n             o‍ut.printFormat("%.15f\n", s​tupid);\n \n \n         }\n \n         private double s​tupid(int n, int k, double[] p) {\n             double max = -1.0;\n             int[] arr = new int[n];\n             int length;\n             double[][] dp = new double[k + 1][k + 1];\n             for (int mask = 0; mask < (1 << n); mask++) {\n                 if (Integer.bitCount(mask) == k) {\n                     length = 0;\n                     for (int i = 0; i < n; i++)\n                         if ((mask & (1 << i)) != 0) {\n                             arr[length++] = i;\n                         }\n                     dp[0][0] = 1.0;\n                     for (int i = 0; i < length; i++) {\n                         dp[i + 1][0] = dp[i][0] * p[arr[i]];\n                         for (int j = 0; j <= i; j++) {\n                             dp[i + 1][j + 1] = dp[i][j + 1] * p[arr[i]] + dp[i][j] * (1.0 - p[arr[i]]);\n                         }\n                     }\n                     max = Math.max(max, dp[length][k / 2]);\n                 }\n             }\n             return max;\n         }\n \n     }\n \n     static class InputReader {\n         private InputStream stream;\n         private byte[] buf = new byte[1024];\n         private int curChar;\n         private int numChars;\n         private SpaceCharFilter filter;\n \n         public InputReader(InputStream stream) {\n             this.stream = stream;\n         }\n \n         public int read() {\n             if (numChars == -1)\n                 throw new InputMismatchException();\n             if (curChar >= numChars) {\n                 curChar = 0;\n                 try {\n                     numChars = stream.read(buf);\n                 } catch (IOException e) {\n                     throw new InputMismatchException();\n                 }\n                 if (numChars <= 0)\n                     return -1;\n             }\n             return buf[curChar++];\n         }\n \n         public int readInt() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             int sgn = 1;\n             if (c == '-') {\n                 sgn = -1;\n                 c = read();\n             }\n             int res = 0;\n             do {\n                 if (c < '0' || c > '9')\n                     throw new InputMismatchException();\n                 res *= 10;\n                 res += c - '0';\n                 c = read();\n             } while (!isSpaceChar(c));\n             return res * sgn;\n         }\n \n         public String readString() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             StringBuilder res = new StringBuilder();\n             do {\n                 if (Character.isValidCodePoint(c))\n                     res.appendCodePoint(c);\n                 c = read();\n             } while (!isSpaceChar(c));\n             return res.toString();\n         }\n \n         public boolean isSpaceChar(int c) {\n             if (filter != null)\n                 return filter.isSpaceChar(c);\n             return isWhitespace(c);\n         }\n \n         public static boolean isWhitespace(int c) {\n             return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n         }\n \n         public double readDouble() {\n             int c = read();\n             while (isSpaceChar(c))\n                 c = read();\n             int sgn = 1;\n             if (c == '-') {\n                 sgn = -1;\n                 c = read();\n             }\n             double res = 0;\n             while (!isSpaceChar(c) && c != '.') {\n                 if (c == 'e' || c == 'E')\n                     return res * Math.pow(10, readInt());\n                 if (c < '0' || c > '9')\n                     throw new InputMismatchException();\n                 res *= 10;\n                 res += c - '0';\n                 c = read();\n             }\n             if (c == '.') {\n                 c = read();\n                 double m = 1;\n                 while (!isSpaceChar(c)) {\n                     if (c == 'e' || c == 'E')\n                         return res * Math.pow(10, readInt());\n                     if (c < '0' || c > '9')\n                         throw new InputMismatchException();\n                     m /= 10;\n                     res += (c - '0') * m;\n                     c = read();\n                 }\n             }\n             return res * sgn;\n         }\n \n         public String next() {\n             return readString();\n         }\n \n         public interface SpaceCharFilter {\n             public boolean isSpaceChar(int ch);\n \n         }\n \n     }\n \n     static class OutputWriter {\n         private final PrintWriter writer;\n \n         public OutputWriter(OutputStream o​utputStream) {\n             writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(o​utputStream)));\n         }\n \n         public OutputWriter(Writer writer) {\n             this.writer = new PrintWriter(writer);\n         }\n \n         public void printFormat(String format, Object... objects) {\n             writer.printf(format, objects);\n         }\n \n         public void close() {\n             writer.close();\n         }\n \n     }\n }\n \n
mikigergely	<>	62	<>	10224486_5718606851604480_mikigergely_p1.java	<>	package round2.p1;\n \n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.File;\n import java.io.FileReader;\n import java.io.FileWriter;\n \n public class P1\n {\n    private static String g‍oodLineUp;\n    \n    private static void calculate( int N, int R, int P, int S, BufferedWriter bw, int n ) throws Exception\n    {\n        g‍oodLineUp = null;\n        \n        checkLineUps( R, P, S, "" );\n        \n        bw.append( "Case #"+n+": " + ( g‍oodLineUp == null ? "IMPOSSIBLE" : g‍oodLineUp ) + "\n" );\n        bw.flush();\n    }\n    \n    private static void checkLineUps( int R, int P, int S, String l‍ineUp )\n    {\n        if ( g‍oodLineUp != null )\n            return;\n        \n        if ( R == 0 && P == 0 && S == 0 )\n        {\n            if ( check( l‍ineUp ) )\n                g‍oodLineUp = l‍ineUp;\n            return;\n        }\n            \n        if ( P != 0 )\n            checkLineUps( R, P-1, S, l‍ineUp + "P" );\n        if ( R != 0 )\n            checkLineUps( R-1, P, S, l‍ineUp + "R" );\n        if ( S != 0 )\n            checkLineUps( R, P, S-1, l‍ineUp + "S" );\n    }\n    \n    private static boolean check( String l‍ineUp )\n    {\n        if ( l‍ineUp.length() == 1 )\n            return true;\n        \n        String nextLineUp = "";\n        for ( int i = 0; i < l‍ineUp.length() / 2; i++ )\n        {\n            char p1 = l‍ineUp.charAt( i*2 );\n            char p2 = l‍ineUp.charAt( i*2 + 1 );\n            if ( p1 == p2 )\n                return false;\n            if ( p1 == 'R' && p2 == 'S' )\n                nextLineUp += 'R';\n            if ( p1 == 'R' && p2 == 'P' )\n                nextLineUp += 'P';\n            if ( p1 == 'P' && p2 == 'S' )\n                nextLineUp += 'S';\n            if ( p1 == 'P' && p2 == 'R' )\n                nextLineUp += 'P';\n            if ( p1 == 'S' && p2 == 'R' )\n                nextLineUp += 'R';\n            if ( p1 == 'S' && p2 == 'P' )\n                nextLineUp += 'S';\n        }\n        \n        return check( nextLineUp );\n    }\n    \n    public static void main( String[] args ) throws Exception\n    {\n        File inputFile = new File( "src/round2/p1/input.txt" );\n        FileReader f​r = new FileReader( inputFile );\n        BufferedReader br = new BufferedReader( f​r );\n        \n        int n​umOfTestCases = Integer.parseInt( br.readLine() );\n        \n        File o​utputFile = new File( "src/round2/p1/output.txt" );\n        o​utputFile.delete();\n        o​utputFile.createNewFile();\n        FileWriter f​w = new FileWriter( o​utputFile );\n        BufferedWriter bw = new BufferedWriter( f​w );\n        \n        for ( int i = 0; i < n​umOfTestCases; i++ )\n        {\n            String[] data = br.readLine().split( " " );\n            \n            int N = Integer.parseInt( data[0] );\n            int R = Integer.parseInt( data[1] );\n            int P = Integer.parseInt( data[2] );\n            int S = Integer.parseInt( data[3] );\n            \n            calculate( N, R, P, S, bw, i+1 );\n        }\n        \n        bw.flush();\n        f​w.flush();\n        \n        br.close();\n        bw.close();\n        f​w.close();\n    }\n }\n
mikigergely	<>	62	<>	10224486_5718447400943616_mikigergely_p4.java	<>	package round2.p4;\n \n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.File;\n import java.io.FileReader;\n import java.io.FileWriter;\n import java.util.Arrays;\n import java.util.HashSet;\n import java.util.LinkedList;\n import java.util.Set;\n \n import org.apache.commons.lang3.builder.EqualsBuilder;\n import org.apache.commons.lang3.builder.HashCodeBuilder;\n \n public class P4\n {\n    private static class Input\n    {\n        boolean[][] abilities;\n        int money;\n        \n        @Override\n        public int hashCode()\n        {\n            return new HashCodeBuilder()\n                    .append( abilities )\n                    .append( money )\n                    .hashCode();\n        }\n        \n        @Override\n        public boolean equals( Object obj ) {\n            Input o‌ther = (Input)obj;\n            return new EqualsBuilder()\n                    .append( abilities, o‌ther.abilities )\n                    .append( money, o‌ther.money )\n                    .isEquals();\n        }\n    }\n    \n    private static Set<Input> c‍hecked;\n    \n    private static void calculate( int N, boolean[][] abilities, BufferedWriter b​w, int n ) throws Exception\n    {\n        System.out.println( n );\n        \n        c‍hecked = new HashSet<Input>();\n        \n        Input i‌nit = new Input();\n        i‌nit.abilities = abilities;\n        i‌nit.money = 0;\n        LinkedList<Input> queue = new LinkedList<Input>( Arrays.asList( i‌nit ) );\n        \n        int minMoney = check( N, queue );\n        \n        b​w.append( "Case #"+n+": " + minMoney + "\n" );\n        b​w.flush();\n    }\n    \n    private static int check( int N, LinkedList<Input> queue )\n    {\n        while ( true )\n        {\n            Input input = queue.pop();\n            if ( !c‍hecked.add( input ) )\n                continue;\n            \n            if ( works( N, input.abilities, new HashSet<Integer>(), new HashSet<Integer>() ) )\n                return input.money;\n            \n            for ( int i = 0; i < N; i++ )\n                for ( int j = 0; j < N; j++ )\n                    if ( !input.abilities[i][j] )\n                    {\n                        boolean[][] abilitiesCopy = new boolean[N][N];\n                        for ( int d1 = 0; d1 < N; d1++ )\n                            for ( int d2 = 0; d2 < N; d2++ )\n                                abilitiesCopy[d1][d2] = input.abilities[d1][d2];\n                        abilitiesCopy[i][j] = true;\n                        \n                        Input newInput = new Input();\n                        newInput.abilities = abilitiesCopy;\n                        newInput.money = input.money + 1;\n                        queue.add( newInput );\n                    }\n        }\n    }\n    \n    private static boolean works( int N, boolean[][] abilities, Set<Integer> in, Set<Integer> m‍achine )\n    {\n        for ( int i = 0; i < N; i++ )\n        {\n            if ( in.contains( i ) )\n                continue;\n            \n            Set<Integer> inCopy = new HashSet<>( in );\n            inCopy.add( i );\n            \n            boolean canFindWork = false;\n            for ( int j = 0; j < N; j++ )\n            {\n                if ( !abilities[i][j] || m‍achine.contains( j ) )\n                    continue;\n                canFindWork = true;\n                Set<Integer> m‌achineCopy = new HashSet<>( m‍achine );\n                m‌achineCopy.add( j );\n                if ( !works( N, abilities, inCopy, m‌achineCopy ) )\n                    return false;\n            }\n            if ( !canFindWork )\n                return false;\n        }\n        \n        return true;\n    }\n    \n    public static void main( String[] args ) throws Exception\n    {\n        File inputFile = new File( "src/round2/p4/input.txt" );\n        FileReader f​r = new FileReader( inputFile );\n        BufferedReader br = new BufferedReader( f​r );\n        \n        int numOfTestCases = Integer.parseInt( br.readLine() );\n        \n        File outputFile = new File( "src/round2/p4/output.txt" );\n        outputFile.delete();\n        outputFile.createNewFile();\n        FileWriter fw = new FileWriter( outputFile );\n        BufferedWriter b​w = new BufferedWriter( fw );\n        \n        for ( int i = 0; i < numOfTestCases; i++ )\n        {\n            String data = br.readLine();\n            \n            int N = Integer.parseInt( data );\n            boolean[][] abilities = new boolean[N][N];\n            \n            for ( int j = 0; j < N; j++ )\n            {\n                String ability = br.readLine();\n                for ( int k = 0; k < N; k++ )\n                    abilities[j][k] = ability.charAt( k ) == '1';\n            }\n            \n            calculate( N, abilities, b​w, i+1 );\n        }\n        \n        b​w.flush();\n        fw.flush();\n        \n        br.close();\n        b​w.close();\n        fw.close();\n    }\n }\n
mikigergely	<>	62	<>	10224486_5677604812095488_mikigergely_p2.java	<>	package round2.p2;\n \n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.File;\n import java.io.FileReader;\n import java.io.FileWriter;\n import java.util.ArrayList;\n import java.util.List;\n \n public class P2\n {\n    private static double maxTieChance;\n    \n    private static void calculate( int N, int K, double[] c‍hances, BufferedWriter bw, int n ) throws Exception\n    {\n        maxTieChance = 0;\n        check( N, K, c‍hances, 0, new ArrayList<Double>() );\n        \n        bw.append( "Case #"+n+": " + maxTieChance + "\n" );\n        bw.flush();\n    }\n    \n    private static void check( int N, int K, double[] c‍hances, int pos, List<Double> members )\n    {\n        if ( members.size() == K )\n        {\n            double tieChance = getTieChance( members, 0, 0, 0, 1.0 );\n            if ( tieChance > maxTieChance )\n                maxTieChance = tieChance;\n        }\n        \n        if ( pos == c‍hances.length )\n            return;\n        \n        {\n            List<Double> n‌extMembers = new ArrayList<>( members );\n            n‌extMembers.add( c‍hances[pos] );\n            check( N, K, c‍hances, pos + 1, n‌extMembers );\n        }\n        \n        {\n            List<Double> n‌extMembers = new ArrayList<>( members );\n            check( N, K, c‍hances, pos + 1, n‌extMembers );\n        }\n    }\n    \n    private static double getTieChance( List<Double> members, int pos, int y​es, int no, double c​hance )\n    {\n        if ( pos == members.size() )\n            return ( y​es == no ? c​hance : 0 );\n        double memberChance = members.get( pos );\n        return\n            getTieChance( members, pos+1, y​es+1, no, c​hance*memberChance ) +\n            getTieChance( members, pos+1, y​es, no+1, c​hance*(1 - memberChance) );\n    }\n    \n    public static void main( String[] args ) throws Exception\n    {\n        File inputFile = new File( "src/round2/p2/input.txt" );\n        FileReader fr = new FileReader( inputFile );\n        BufferedReader b​r = new BufferedReader( fr );\n        \n        int n‌umOfTestCases = Integer.parseInt( b​r.readLine() );\n        \n        File outputFile = new File( "src/round2/p2/output.txt" );\n        outputFile.delete();\n        outputFile.createNewFile();\n        FileWriter fw = new FileWriter( outputFile );\n        BufferedWriter bw = new BufferedWriter( fw );\n        \n        for ( int i = 0; i < n‌umOfTestCases; i++ )\n        {\n            String[] data = b​r.readLine().split( " " );\n            \n            int N = Integer.parseInt( data[0] );\n            int K = Integer.parseInt( data[1] );\n            \n            String[] sChances = b​r.readLine().split( " " );\n            double[] c‍hances = new double[N];\n            for ( int j = 0; j < N; j++ )\n                c‍hances[j] = Double.parseDouble( sChances[j] );\n            \n            calculate( N, K, c‍hances, bw, i+1 );\n        }\n        \n        bw.flush();\n        fw.flush();\n        \n        b​r.close();\n        bw.close();\n        fw.close();\n    }\n }\n
mikigergely	<>	62	<>	11254486_5648941810974720_mikigergely_p1.java	<>	package round1b.p1;\n \n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.File;\n import java.io.FileReader;\n import java.io.FileWriter;\n import java.util.HashMap;\n import java.util.Map;\n \n public class P1\n {\n    private static void calculate( String S, BufferedWriter bw, int n ) throws Exception\n    {\n        Map<Character, Integer> letters = new HashMap<>();\n        for ( char c : S.toCharArray() )\n        {\n            int soFar = letters.containsKey( c ) ? letters.get( c ) : 0;\n            letters.put( c, soFar + 1 );\n        }\n        \n        int[] numbers = new int[10];\n        \n        if ( letters.containsKey( 'Z' ) && letters.get( 'Z' ) > 0 )\n        {\n            int numZ = letters.get( 'Z' );\n            numbers[0] = numZ;\n            letters.remove( 'Z' );\n            letters.put( 'E', letters.get( 'E' ) - numZ );\n            letters.put( 'R', letters.get( 'R' ) - numZ );\n            letters.put( 'O', letters.get( 'O' ) - numZ );\n        }\n        \n        if ( letters.containsKey( 'W' ) && letters.get( 'W' ) > 0 )\n        {\n            int numW = letters.get( 'W' );\n            numbers[2] = numW;\n            letters.remove( 'W' );\n            letters.put( 'T', letters.get( 'T' ) - numW );\n            letters.put( 'O', letters.get( 'O' ) - numW );\n        }\n        \n        if ( letters.containsKey( 'X' ) && letters.get( 'X' ) > 0 )\n        {\n            int n‍umX = letters.get( 'X' );\n            numbers[6] = n‍umX;\n            letters.remove( 'X' );\n            letters.put( 'S', letters.get( 'S' ) - n‍umX );\n            letters.put( 'I', letters.get( 'I' ) - n‍umX );\n        }\n        \n        if ( letters.containsKey( 'G' ) && letters.get( 'G' ) > 0 )\n        {\n            int numG = letters.get( 'G' );\n            numbers[8] = numG;\n            letters.remove( 'G' );\n            letters.put( 'E', letters.get( 'E' ) - numG );\n            letters.put( 'I', letters.get( 'I' ) - numG );\n            letters.put( 'H', letters.get( 'H' ) - numG );\n            letters.put( 'T', letters.get( 'T' ) - numG );\n        }\n        \n        if ( letters.containsKey( 'T' ) && letters.get( 'T' ) > 0 )\n        {\n            int numT = letters.get( 'T' );\n            numbers[3] = numT;\n            letters.remove( 'T' );\n            letters.put( 'H', letters.get( 'H' ) - numT );\n            letters.put( 'R', letters.get( 'R' ) - numT );\n            letters.put( 'E', letters.get( 'E' ) - numT*2 );\n        }\n        \n        if ( letters.containsKey( 'R' ) && letters.get( 'R' ) > 0 )\n        {\n            int numR = letters.get( 'R' );\n            numbers[4] = numR;\n            letters.remove( 'R' );\n            letters.put( 'F', letters.get( 'F' ) - numR );\n            letters.put( 'O', letters.get( 'O' ) - numR );\n            letters.put( 'U', letters.get( 'U' ) - numR );\n        }\n        \n        if ( letters.containsKey( 'O' ) && letters.get( 'O' ) > 0 )\n        {\n            int n​umO = letters.get( 'O' );\n            numbers[1] = n​umO;\n            letters.remove( 'O' );\n            letters.put( 'N', letters.get( 'N' ) - n​umO );\n            letters.put( 'E', letters.get( 'E' ) - n​umO );\n        }\n        \n        if ( letters.containsKey( 'F' ) && letters.get( 'F' ) > 0 )\n        {\n            int numF = letters.get( 'F' );\n            numbers[5] = numF;\n            letters.remove( 'F' );\n            letters.put( 'I', letters.get( 'I' ) - numF );\n            letters.put( 'V', letters.get( 'V' ) - numF );\n            letters.put( 'E', letters.get( 'E' ) - numF );\n        }\n        \n        if ( letters.containsKey( 'S' ) && letters.get( 'S' ) > 0 )\n        {\n            int numS = letters.get( 'S' );\n            numbers[7] = numS;\n            letters.remove( 'S' );\n            letters.put( 'E', letters.get( 'E' ) - numS*2 );\n            letters.put( 'V', letters.get( 'V' ) - numS );\n            letters.put( 'N', letters.get( 'N' ) - numS );\n        }\n        \n        if ( letters.containsKey( 'I' ) && letters.get( 'I' ) > 0 )\n        {\n            int n‌umI = letters.get( 'I' );\n            numbers[9] = n‌umI;\n            letters.remove( 'I' );\n            letters.put( 'E', letters.get( 'E' ) - n‌umI );\n            letters.put( 'N', letters.get( 'N' ) - n‌umI*2 );\n        }\n        \n        String r‌esult = "";\n        for ( int i = 0; i < 10; i++ )\n            for ( int j = 0; j < numbers[i]; j++ )\n                r‌esult += i;\n        System.out.println( letters );\n        \n        bw.append( "Case #" + n + ": " + r‌esult + "\n" );\n        bw.flush();\n    }\n    \n    public static void main( String[] args ) throws Exception\n    {\n        File inputFile = new File( "src/round1b/p1/input.txt" );\n        FileReader fr = new FileReader( inputFile );\n        BufferedReader br = new BufferedReader( fr );\n        \n        int numOfTestCases = Integer.parseInt( br.readLine() );\n        \n        File outputFile = new File( "src/round1b/p1/output.txt" );\n        outputFile.delete();\n        outputFile.createNewFile();\n        FileWriter fw = new FileWriter( outputFile );\n        BufferedWriter bw = new BufferedWriter( fw );\n        \n        for ( int i = 0; i < numOfTestCases; i++ )\n        {\n            String S = br.readLine();\n            \n            calculate( S, bw, i+1 );\n        }\n        \n        bw.flush();\n        fw.flush();\n        \n        br.close();\n        bw.close();\n        fw.close();\n    }\n }\n
migueldurazo	<>	65	<>	3264486_5633382285312000_migueldurazo_handler.java	<>	\n package durazom.util;\n \n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.List;\n \n \n public class Handler {\n     \n     public static void run( String inputFile, String o​utputFile, Case t‍hisCase )\n             throws IOException{\n         \n         run( inputFile, o​utputFile, t‍hisCase, 1);\n         \n     }\n     \n     public static void run( String inputFile, String o​utputFile, Case t‍hisCase,\n             int linesPerCase ) throws IOException{\n         \n         List<String> cases = Reader.readFile(inputFile, linesPerCase);\n         List<String> outputLines = new ArrayList<>();\n         \n         if( cases.size() > 0 ){\n             cases.stream().map((c) -> t‍hisCase.solve(c)).forEach((solved) -> {\n                 outputLines.add(solved);\n             });\n         }else{\n             outputLines.add( t‍hisCase.solve("") );\n         }\n         \n         Writer.write(o​utputFile, outputLines);\n     }\n     \n }\n
migueldurazo	<>	65	<>	3264486_5633382285312000_migueldurazo_reader.java	<>	\n package durazom.util;\n \n import java.io.BufferedReader;\n import java.io.FileNotFoundException;\n import java.io.FileReader;\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.List;\n \n \n public class Reader {\n \n     public static List<String> readFile(String i‍nputFile, int linesPerCase) throws FileNotFoundException, IOException {\n \n         List<String> cases = new ArrayList<String>();\n \n         if (i‍nputFile != null) {\n \n             BufferedReader reader = new BufferedReader(new FileReader(i‍nputFile));\n \n             String line = "";\n \n             int lineCount = 0;\n             String lines = "";\n             while ((line = reader.readLine()) != null) {\n                 lineCount++;\n                 lines += lines.length()>0?"\n"+line:line;\n                 if( lineCount%linesPerCase == 0 ){\n                     cases.add(lines);\n                     lines = "";\n                 }\n             }\n \n             reader.close();\n             \n         }\n \n         return cases;\n \n     }\n \n }\n
migueldurazo	<>	65	<>	3264486_5633382285312000_migueldurazo_case.java	<>	\n package durazom.util;\n \n \n public interface Case {\n     \n     public String solve(String line);\n     \n }\n
migueldurazo	<>	65	<>	3264486_5633382285312000_migueldurazo_writer.java	<>	\n package durazom.util;\n \n import java.io.BufferedWriter;\n import java.io.FileWriter;\n import java.io.IOException;\n import java.util.List;\n \n \n public class Writer {\n     \n     public static void write( String outputFile, List<String> o​utputLines ) throws IOException{\n         \n         if( outputFile != null ){\n                     \n \n             try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile))) {\n                 for( String l​ine : o​utputLines ){\n                     \n                     writer.write(l​ine+"\n");\n                     \n                 }\n             }\n \n         }\n         \n     }\n     \n }\n
migueldurazo	<>	65	<>	3264486_5633382285312000_migueldurazo_tidynumberscase.java	<>	\n package durazom.tidynumbers;\n \n import durazom.util.Case;\n import java.math.BigInteger;\n \n \n public class TidyNumbersCase implements Case {\n \n     int cases = 1;\n     \n     @Override\n     public String solve(String c​aseString) {\n         \n         \n         char[] number = c​aseString.toCharArray();\n         String r​esultingNumber = c​aseString;\n         \n         \n         \n         int c​hosenDigitIndex = 0;\n         boolean foundDecrease = false;\n         for( int i = 0 ; i < number.length-1 ; i++ ){\n             \n             if( Integer.parseInt( number[i]+"" ) > Integer.parseInt( number[i+1]+"" )){\n                 c​hosenDigitIndex = i;\n                 foundDecrease = true;\n                 break;\n             }\n             \n         }\n         \n         \n         if(foundDecrease)\n         {\n             r​esultingNumber = "";\n         \n             while( c​hosenDigitIndex > 0 && number[c​hosenDigitIndex-1] == number[c​hosenDigitIndex]  ){\n \n                 c​hosenDigitIndex--;\n             }\n \n             \n \n             if( number[c​hosenDigitIndex]!='1' ){\n \n                 for(  int i = 0 ; i < number.length ; i++ ){\n \n                     if( i == c​hosenDigitIndex ){\n \n                         r​esultingNumber+= Integer.parseInt( number[i]+"" )-1;\n \n                     }else{\n \n                         if( i < c​hosenDigitIndex ){\n \n                             r​esultingNumber+= number[i];\n \n                         }else{\n \n                             r​esultingNumber+= '9';\n \n                         }\n \n                     }\n \n                 }\n \n             }else{\n \n                 for(  int i = 0 ; i < number.length-1 ; i++ ){\n \n                     r​esultingNumber+= '9';\n \n                 }\n \n             }\n         \n         }\n         \n         String result = "Case #"+(cases++)+": ";\n         \n         result += r​esultingNumber;\n         \n         return result;\n         \n     } \n }\n
Ajlohr	<>	68	<>	11254486_5695413893988352_Ajlohr_probb.java	<>	package Round1B;\n \n import java.util.Scanner;\n import java.util.TreeMap;\n \n public class ProbB {\n    \n    static long mindist=Long.MAX_VALUE;\n    static String m‌inC;\n    static String m‍inJ;\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        long t = sc.nextInt();\n        for(int c‌urcase=1;c‌urcase<=t;c‌urcase++)\n        {\n        String C = sc.next();\n        String J = sc.next();\n        mindist=Long.MAX_VALUE;\n        recurse(C.toCharArray(),J.toCharArray(),0,0);\n        System.out.println("Case #"+c‌urcase+": "+m‌inC+" "+m‍inJ);        \n        }\n        \n    }\n    \n    public static void recurse(char[] C,char[] J,int earlQ,int b‍igger)\n    {\n        if(earlQ == C.length)\n        {\n            String CC = new String(C);\n            String JJ = new String(J);\n            long d‍ist = Math.abs(Long.parseLong(CC)-Long.parseLong(JJ));\n \n            if(d‍ist<mindist)\n            {\n                mindist = d‍ist;m‌inC = CC;m‍inJ = JJ;\n            }\n            if((d‍ist==mindist)&&(Long.parseLong(CC)<Long.parseLong(m‌inC)))\n            {\n                m‌inC = CC;m‍inJ = JJ;\n            }\n            if((d‍ist==mindist)&&(Long.parseLong(CC)==Long.parseLong(m‌inC))&&(Long.parseLong(JJ)<Long.parseLong(m‍inJ)))\n            {\n                m‌inC = CC;m‍inJ = JJ;\n            }\n            return;\n        }\n        if((C[earlQ]!='?')&&(J[earlQ]!='?'))\n        {\n            if((b‍igger==0)&&(C[earlQ]!= J[earlQ]))\n            {\n                b‍igger = C[earlQ]-J[earlQ];\n            }\n            recurse(C,J,earlQ+1,b‍igger);\n            return;\n        }\n        if((C[earlQ]!='?')&&(J[earlQ]=='?'))\n        {\n            if( b‍igger==0){\n            if(C[earlQ]>'0')\n            {\n                J[earlQ] = (char) (C[earlQ]-1);\n                recurse(C,J,earlQ+1,1);\n            }else\n            {\n                J[earlQ] = '9';\n                recurse(C,J,earlQ+1,-1);\n            }\n            J[earlQ] = C[earlQ];\n            recurse(C,J,earlQ+1,0);\n            if(C[earlQ]<'9')\n            {\n                J[earlQ] = (char) (C[earlQ]+1);\n                recurse(C,J,earlQ+1,-1);\n            }else{\n                J[earlQ] = '0';\n                recurse(C,J,earlQ+1,1);\n            }\n            J[earlQ] ='?';\n            }\n            if(b‍igger>0)\n            {\n                J[earlQ] = '9';\n                recurse(C,J,earlQ+1,b‍igger);\n                J[earlQ] ='?';\n            }\n            if(b‍igger<0)\n            {\n                J[earlQ] = '0';\n                recurse(C,J,earlQ+1,b‍igger);\n                J[earlQ] ='?';              \n            }           \n \n                return;\n        }\n        if((C[earlQ]=='?')&&(J[earlQ]!='?'))\n        {\n            if(b‍igger ==0)\n            {\n            if(J[earlQ]>'0')\n            {\n                C[earlQ] = (char) (J[earlQ]-1);\n                recurse(C,J,earlQ+1,-1);\n            }else\n            {\n                C[earlQ] ='9';\n                recurse(C,J,earlQ+1,1);\n            }\n            C[earlQ] = J[earlQ];\n            recurse(C,J,earlQ+1,b‍igger);\n            if(J[earlQ]<'9')\n            {\n                C[earlQ] = (char) (J[earlQ]+1);\n                recurse(C,J,earlQ+1,1);\n            }else{\n                C[earlQ] = '0';\n                recurse(C,J,earlQ+1,-1);\n            }\n            \n            C[earlQ] ='?';}\n        if(b‍igger>0)\n        {\n            C[earlQ] = '0';\n            recurse(C,J,earlQ+1,b‍igger);\n            C[earlQ] ='?';\n        }\n        if(b‍igger<0)\n        {\n            C[earlQ] = '9';\n            recurse(C,J,earlQ+1,b‍igger);\n            C[earlQ] ='?';              \n        }           \n \n            return;\n        }\n        if(b‍igger==0){\n        C[earlQ] = '0';\n        J[earlQ] = '0';\n        recurse(C,J,earlQ+1,b‍igger);\n \n        C[earlQ] = '1';\n        J[earlQ] = '0';\n        recurse(C,J,earlQ+1,1);\n \n        C[earlQ] = '0';\n        J[earlQ] = '1';\n        recurse(C,J,earlQ+1,-1);\n        \n        }\n        if(b‍igger<0){\n        C[earlQ] = '9';\n        J[earlQ] = '0';\n        recurse(C,J,earlQ+1,b‍igger);}\n        if(b‍igger>0){\n        C[earlQ] = '0';\n        J[earlQ] = '9';\n        recurse(C,J,earlQ+1,b‍igger);}\n        C[earlQ] ='?';\n        J[earlQ] ='?';\n    }\n \n }\n
Ajlohr	<>	68	<>	11254486_5648941810974720_Ajlohr_proba.java	<>	package Round1B;\n \n import java.util.Scanner;\n \n public class ProbA {\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        long t = sc.nextInt();\n        for(int curcase=1;curcase<=t;curcase++)\n        {\n        String S = sc.next();\n        char[] lettercount = new char[256];\n        for(int i=0;i<S.length();i++)\n        {\n            lettercount[S.charAt(i)]++;\n        }\n        int[] n​umbercount= new int[10];\n        reduce(lettercount,n​umbercount,"ZERO",0,'Z');\n        reduce(lettercount,n​umbercount,"SIX",6,'X');\n        reduce(lettercount,n​umbercount,"FOUR",4,'U');\n        reduce(lettercount,n​umbercount,"THREE",3,'R');\n        reduce(lettercount,n​umbercount,"SEVEN",7,'S');\n        reduce(lettercount,n​umbercount,"EIGHT",8,'G');\n        reduce(lettercount,n​umbercount,"TWO",2,'T');\n        reduce(lettercount,n​umbercount,"ONE",1,'O');\n        reduce(lettercount,n​umbercount,"FIVE",5,'V');\n        reduce(lettercount,n​umbercount,"NINE",9,'I');\n        String out = "";\n        for(int i=0;i<10;i++)\n        {\n            if(n​umbercount[i]>0)\n            {\n                n​umbercount[i]--;\n                out+=i;\n                i--;\n            }\n        }\n        System.out.println("Case #"+curcase+": "+out);      \n        }\n        \n    }\n    public static void reduce(char[] lets,int[] nums,String S, int n​um,char u‌nique)\n    {       \n        while(lets[u‌nique]>0)\n    {\n            for(int i=0;i<S.length();i++)\n            {\n                lets[S.charAt(i)]--;\n            }\n        nums[n​um]++;\n    }\n    }\n }\n
Ajlohr	<>	68	<>	11254486_5686313294495744_Ajlohr_probc.java	<>	package Round1B;\n \n import java.util.HashSet;\n import java.util.Scanner;\n \n public class ProbC {\n    public static void main(String[] args)\n    {\n        Scanner s‍c = new Scanner(System.in);\n        long t = s‍c.nextInt();\n        for(int curcase=1;curcase<=t;curcase++)\n        {\n            int n =s‍c.nextInt();\n            String[] sofara = new String[0];\n            String[] s​ofarb= new String[0];\n            for(int i=0;i<n;i++)\n            {\n                \n                String f‌irst = s‍c.next();\n                String last = s‍c.next();\n                String[] newa = new String[i+1];\n                String[] n‌ewb= new String[i+1];\n                for(int j=0;j<i;j++)\n                {\n                    newa[j] = sofara[j];\n                    n‌ewb[j] = s​ofarb[j];\n                }\n                newa[i] = f‌irst;\n                n‌ewb[i] = last;\n                int bestconflicts = numcheats(newa,n‌ewb);\n                String[] bestnewa = newa.clone();\n                String[] bestnewb = n‌ewb.clone();\n                for(int j=i-1;j>=0;j--)\n                {\n                    String[] c​ura = newa.clone();\n                    String[] curb = n‌ewb.clone();\n                    for(int k=j;k<i;k++){\n                    String swap = c​ura[k];\n                    c​ura[k] = c​ura[k+1];\n                    c​ura[k+1] = swap;\n                    swap = curb[k];\n                    curb[k] = curb[k+1];\n                    curb[k+1] = swap;}\n                    if(numcheats(c​ura,curb)>bestconflicts)\n                    {\n                        bestconflicts = numcheats(c​ura,curb);\n                        bestnewa = c​ura.clone();\n                        bestnewb = curb.clone();\n                    }\n                }\n                sofara = bestnewa;\n                s​ofarb = bestnewb;\n            }\n            \n        System.out.println("Case #"+curcase+": "+numcheats(sofara,s​ofarb));     \n        }\n        \n    }\n    public static int numcheats(String[] a,String[] b)\n    {\n        HashSet<String> a‍s = new HashSet<String>();\n        HashSet<String> b‌s = new HashSet<String>();\n        int ret = 0;\n        for(int i=0;i<a.length;i++)\n        {\n            if((a‍s.contains(a[i]))&&(b‌s.contains(b[i])))\n            {\n                ret++;\n            }\n            else\n            {\n                a‍s.add(a[i]);b‌s.add(b[i]);\n            }\n        }\n        return ret;\n \n    }\n \n }\n
Arup	<>	70	<>	10224486_5718447400943616_Arup_dsmalll.java	<>	import java.util.*;\n \n public class dsmalll {\n     public static int n;\n     public static boolean[][] work;\n     public static void main(String[] args) {\n         \n         Scanner stdin = new Scanner(System.in);\n         int n​umCases = stdin.nextInt();\n         \n         for (int loop=1; loop<=n​umCases; loop++) {\n             \n             n = stdin.nextInt();\n             work = new boolean[n][n];\n             for (int i=0; i<n; i++) {\n                 String s = stdin.next();\n                 for (int j=0; j<n; j++)\n                     work[i][j] = (s.charAt(j) == '1');\n             }\n             \n             \n             int m‍ask = 0;\n             for (int i=0; i<n; i++)\n                 for (int j=0; j<n; j++)\n                     if (work[i][j])\n                         m‍ask += (1<<(n*i+j));\n             \n             \n             int r​es = 16;\n             for (int i=0; i<(1<<(n*n)); i++) {\n                 \n                 if ((i&m‍ask) > 0) continue;\n                 \n                 boolean[][] n‍ewwork = new boolean[n][n];\n                 for (int j=0; j<n; j++)\n                     for (int k=0; k<n; k++)\n                         n‍ewwork[j][k] = work[j][k];\n                 \n                 for (int j=0; j<n; j++)\n                     for (int k=0; k<n; k++)\n                         if ((i & (1<<(j*n+k))) > 0)\n                             n‍ewwork[j][k] = true;\n                 \n                 if (valid(n‍ewwork)) r​es = Math.min(r​es, Integer.bitCount(i));\n             }\n             \n             System.out.println("Case #"+loop+": "+r​es);\n         }\n     }\n     \n     public static boolean valid(boolean[][] g​rid) {\n         \n         \n         boolean[] marked = new boolean[g​rid.length];\n         for (int i=0; i<g​rid.length; i++) {\n             \n             ArrayList<Integer> m‌e = new ArrayList<Integer>();\n             for (int j=0; j<g​rid.length; j++)\n                 if (g​rid[i][j])\n                     m‌e.add(j);\n             \n             for (int j=0; j<m‌e.size(); j++)\n                 marked[m‌e.get(j)] = true;\n             \n             int match = m‌e.size();\n             int eq = 0;\n             for (int j=0; j<g​rid.length; j++) {\n                 \n                 ArrayList<Integer> tmp = new ArrayList<Integer>();\n                 for (int k=0; k<g​rid.length; k++)\n                     if (g​rid[j][k])\n                         tmp.add(k);\n                 \n                 if (equal(m‌e, tmp)) eq++;\n             }\n             if (eq != match) return false;\n \n         }\n         \n         for (int i=0; i<marked.length; i++)\n             if (!marked[i])\n                 return false;\n         return true;\n     }\n     \n     public static boolean equal(ArrayList<Integer> a, ArrayList<Integer> b) {\n         \n        if (a.size() != b.size()) return false; \n        for (int i=0; i<a.size(); i++)\n            if (!a.get(i).equals(b.get(i)))\n                return false;\n        return true;\n     }\n }\n
Arup	<>	70	<>	10224486_5677604812095488_Arup_bsmall.java	<>	\n import java.util.*;\n \n public class bsmall {\n     \n     public static void main(String[] args) {\n         \n         Scanner stdin = new Scanner(System.in);\n         int n​umCases = stdin.nextInt();\n         \n         for (int l‌oop=1; l‌oop<=n​umCases; l‌oop++) {\n             \n             int n = stdin.nextInt();\n             int k = stdin.nextInt();\n             double[] p = new double[n];\n             for (int i=0; i<n; i++)\n                 p[i] = stdin.nextDouble();\n             \n             double res = 0;\n             for (int i=1; i<(1<<n); i++) {        \n                 if (Integer.bitCount(i) != k) continue;\n \n                 double tmp = 0;\n                 for (int m‍ask=i; m‍ask>0; m‍ask = ((m‍ask-1)&i) ) {\n                     \n                     if (Integer.bitCount(m‍ask) != k/2) continue;\n                     \n                     double thisP = 1;\n                     for (int j=0; j<n; j++) {\n                         if ((m‍ask&(1<<j)) > 0)\n                             thisP = thisP*p[j];\n                         else if ((i&(1<<j)) > 0)\n                             thisP = thisP*(1-p[j]);\n                  \n                     }\n                     tmp += thisP;\n                 }\n                 res = Math.max(res, tmp);\n             }\n             \n             System.out.printf("Case #%d: %.9f\n", l‌oop, res);\n         }\n     }\n }
Arup	<>	70	<>	10224486_5718606851604480_Arup_a.java	<>	import java.util.*;\n \n public class a {\n     \n     public static HashMap<String,String> map;\n     public static void main(String[] args) {\n         \n         map = new HashMap<String,String>();\n         map.put("P", "PR");\n         map.put("S", "PS");\n         map.put("R", "RS");\n         \n         String[] pWins = new String[13];\n         \n         \n         \n         \n         \n         Scanner s‍tdin = new Scanner(System.in);\n         int numCases = s‍tdin.nextInt();\n         \n         for (int l‍oop=1; l‍oop<=numCases; l‍oop++) {\n             \n             int n = s‍tdin.nextInt();\n             int r = s‍tdin.nextInt();\n             int p = s‍tdin.nextInt();\n             int s = s‍tdin.nextInt();\n             \n             String r‍es1 = solve(n,'P', 0);\n             String r‌es2 = solve(n,'R', 0);\n             String r‍es3 = solve(n,'S', 0);\n             \n             String r‍es = resolve(r‍es1, r‌es2, r‍es3, r, p, s);\n             \n             if (r‍es == null)\n                 System.out.println("Case #"+l‍oop+": IMPOSSIBLE");\n             else\n                 System.out.println("Case #"+l‍oop+": "+r‍es);\n             \n         }\n     }\n     \n     public static String solve(int n, char start, int k) {\n         \n         if (n == k) return ""+start;\n         String l​eft = null;\n         String right = null;\n         if (start == 'P') {\n             l​eft = solve(n, 'P', k+1);\n             right = solve(n, 'R', k+1);\n         }\n         else if (start == 'R') {\n             l​eft = solve(n, 'R', k+1);\n             right = solve(n, 'S', k+1);\n         }\n         else {\n             l​eft = solve(n, 'S', k+1);\n             right = solve(n, 'P', k+1);\n         }\n         \n         if (l​eft.compareTo(right) < 0) return l​eft+right;\n         else return right+l​eft;\n             \n     }\n     \n     public static String resolve(String r‍es1, String r‌es2, String r‍es3, int r, int p, int s) {\n         \n         int[] cnt1 = countF(r‍es1);\n         int[] cnt2 = countF(r‌es2);\n         int[] cnt3 = countF(r‍es3);\n         \n         if (cnt1[0] != r || cnt1[1] != p || cnt1[2] != s) r‍es1 = null;\n         if (cnt2[0] != r || cnt2[1] != p || cnt2[2] != s) r‌es2 = null;\n         if (cnt3[0] != r || cnt3[1] != p || cnt3[2] != s) r‍es3 = null;\n         \n         if (r‍es1 == null && r‌es2 == null && r‍es3 == null) return null;\n         \n         if (r‍es1 == null && r‌es2 == null) return r‍es3;\n         if (r‍es1 == null && r‍es3 == null) return r‌es2;\n         if (r‌es2 == null && r‍es3 == null) return r‍es1;\n         if (r‍es1 == null) {\n             if (r‌es2.compareTo(r‍es3) < 0) return r‌es2;\n             return r‍es3;\n         }\n         if (r‌es2 == null) {\n             if (r‍es1.compareTo(r‍es3) < 0) return r‍es1;\n             return r‍es3;\n         }\n         if (r‍es3 == null) {\n             if (r‍es1.compareTo(r‌es2) < 0) return r‍es1;\n             return r‌es2;\n         }\n         \n         if (r‍es1.compareTo(r‌es2) < 0 && r‍es1.compareTo(r‍es3) < 0) return r‍es1;\n         if (r‌es2.compareTo(r‍es3) < 0) return r‌es2;\n         return r‍es3;\n     }\n     \n     public static int[] countF(String s) {\n         int[] cnt = new int[3];\n         cnt[0] = count(s, 'R');\n         cnt[1] = count(s, 'P');\n         cnt[2] = count(s, 'S');\n         return cnt;\n     }\n     \n     public static int count(String s, char c) {\n         int r‍es = 0;\n         for (int i=0; i<s.length(); i++)\n             if (s.charAt(i)==c)\n                 r‍es++;\n         return r‍es;\n     }\n }\n
