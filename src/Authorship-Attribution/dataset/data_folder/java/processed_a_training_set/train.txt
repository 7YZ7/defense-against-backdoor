package codejam2015;\n  \n  \n  public class CProbCSmall2 {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         int numcases = sc.nextInt();\n         ML:\n         for(int cas  = 1;cas <= numcases;cas++ )\n         {\n             System.out.print("Case #"+cas+": ");\n             int C = sc.nextInt();\n             int D = sc.nextInt();\n             int v = sc.nextInt();\n             V=v;\n             int[] coins = new int[D];\n             Set<Integer> coin = new HashSet<Integer>();\n             for(int i=0;i<D;i++)\n             {\n                 coins[i] = (sc.nextInt());\n                 coin.add(coins[i]);\n             }\n             int modi =0;\n             if(!coin.contains(1))\n                 {modi++;\n                 coin.add(1);\n                 }\n             if((!coin.contains(2))&&(V>1))\n             {modi++;\n             coin.add(2);\n             }\n             for(int i=0;i<=V-D;i++)\n             {\n             cando = false;\n             tryall(coin,i);\n             if(cando)\n             {\n                 System.out.println(i+modi);\n                 break;\n             }\n             }\n             \n         }\n     }\n     static int V;\n     static boolean cando;\n     public static void tryall(Set<Integer> S,int i)\n     {\n         if(cando)\n             return;\n         if(i==0)\n         {\n             sums = new HashSet<Integer>();\n             allsums(S,S.size(),0);\n             Set<Integer> asdass= sums;\n             cando = true;\n             for(int j=1;j<=V;j++)\n             {\n                 if(!sums.contains(j))\n                     cando = false;\n             }\n             return;\n         }\n         \n         for(int j=1;j<V;j++)\n         {\n             if(S.contains(j))\n                 continue;\n             S.add(j);\n             tryall(S,i-1);\n             S.remove(j);\n             \n         }\n     }\n     static Set<Integer> sums;\n     public static void allsums(Set<Integer> source,int sizesums,int sum)\n     {\n         sums.add(sum);\n         if(sizesums ==0)\n         {\n             \n             return;\n         }\n         Set<Integer> cl  = new HashSet<Integer>(source);\n         for(Integer s : cl)\n         {\n             source.remove(s);\n             allsums(source,sizesums-1,sum+s);\n  \n             source.add(s);\n         }\n     }\n  }\n <CODESPLIT> 68
package Qualification;\n  \n  \n  public class ProbAA {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         long t = sc.nextLong();\n         sc.nextLine();\n         LOOP:\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             String s = sc.next();\n             int K = sc.nextInt();\n             sc.nextLine();\n             boolean[] cakes = new boolean[s.length()];\n             for(int i=0;i<cakes.length;i++)\n             {\n                 cakes[i] = ('+' == s.charAt(i));\n             }\n             int flips = 0;\n             for(int i=0;i<cakes.length-K+1;i++)\n             {\n                 if(!cakes[i])\n                 {\n                     \n                     for(int j=0;j<K;j++)\n                     {\n                         cakes[i+j]= !cakes[i+j];\n                     }\n                     flips++;\n  \n                 }\n             }\n             for(int j=0;j<K;j++)\n             {\n                 if (!cakes[cakes.length-K+j])\n                 {\n                     System.out.println("Case #"+curcase+": IMPOSSIBLE");\n                     continue LOOP;\n                 }\n             }\n             System.out.println("Case #"+curcase+": "+flips);\n         }\n         \n     }\n  }\n <CODESPLIT> 68
package Qualification;\n  \n  \n  public class ProbDsmall {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         long t = sc.nextInt();\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             int K= sc.nextInt();\n             int C= sc.nextInt();\n             int S= sc.nextInt();        \n             if(K==S)\n             {System.out.print("Case #"+curcase+":");\n             for(int i = 1;i<K+1;i++)\n             {\n                 System.out.print(" "+i);\n             }\n             System.out.println();\n             }else\n             {\n             \n             }\n         }\n     }\n  }\n <CODESPLIT> 68
package Qualification;\n  \n  \n  public class ProbB {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         long t = sc.nextInt();\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             String S = sc.next();\n             int changes = 0;\n             for(int i=0;i<S.length()-1;i++)\n             {\n                 if(S.charAt(i)!=S.charAt(i+1))\n                     changes++;\n             }\n  \n             if(S.charAt(S.length()-1)=='+')\n             {\n                 changes--;\n             }\n             System.out.println("Case #"+curcase+": "+comp(changes));\n         }\n         \n     }\n     \n     public static int comp(int n)\n     {\n         if(n==-1)\n             return 0;\n         if(n==0)\n             return 1;\n         return comp(n-1)+1;\n     }\n  }\n <CODESPLIT> 68
 \n  public class ProbA {\n     public static void main(String[] args) {\n         Scanner sc = new Scanner(System.in);\n         int numcases = sc.nextInt();\n         for(int curcase = 1; curcase<=numcases; curcase++)\n         {\n             int R = sc.nextInt();\n             int C = sc.nextInt();\n             sc.nextLine();\n             int [][] board = new int[R][C];\n             HashSet[][] restrictions = new HashSet[R][C];\n             for(int i=0;i<R;i++)\n             {\n                 String s = sc.nextLine();\n                 \n                 for(int j=0;j<C;j++)\n                 {\n                     restrictions[i][j] = new HashSet();\n                     if(s.charAt(j)=='^')\n                     board[i][j] = 1;\n                     if(s.charAt(j)=='>')\n                     board[i][j] = 2;\n                     if(s.charAt(j)=='v')\n                     board[i][j] = 3;\n                     if(s.charAt(j)=='<')\n                     board[i][j] = 4;                    \n                 }\n             }\n  \n             for(int i=0;i<R;i++)\n             {\n                     for(int j=0;j<C;j++)\n                     {\n                         if(board[i][j]!=0)\n                         {\n                             restrictions[i][j].add(4);\n                             break;\n                         }\n                     }\n                     for(int j=C-1;j>=0;j--)\n                     {\n                         if(board[i][j]!=0)\n                         {\n                             restrictions[i][j].add(2);\n                             break;\n                         }\n                     }\n             }\n             \n             for(int j=0;j<C;j++)\n             {\n                     for(int i=0;i<R;i++)\n                     {\n                         if(board[i][j]!=0)\n                         {\n                             restrictions[i][j].add(1);\n                             break;\n                         }\n                     }\n                     for(int i=R-1;i>=0;i--)\n                     {\n                         if(board[i][j]!=0)\n                         {\n                             restrictions[i][j].add(3);\n                             break;\n                         }\n                     }\n             }\n             \n             long count = 0;\n             LOOP:\n             for(int i=0;i<R;i++)\n             {\n                 for(int j=0;j<C;j++)\n                 {\n                     if(restrictions[i][j].size()==4)\n                     {\n                         count = Long.MAX_VALUE;\n                         break LOOP;\n                     }else{\n                         if(restrictions[i][j].contains(board[i][j]))\n                             count++;\n                     }\n                     \n                 }\n             }\n                         \n             if(count < Long.MAX_VALUE)\n             System.out.println("Case #"+curcase+": "+count);\n             else\n             System.out.println("Case #"+curcase+": IMPOSSIBLE");\n         }\n     }\n  }\n <CODESPLIT> 68
package Round1A;\n  \n  \n  public class ProbA {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         long t = sc.nextInt();\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             String s = sc.next();\n             String wb = "";\n             char[] c = s.toCharArray();\n             wb = wb+c[0];\n             for(int i=1;i<c.length;i++)\n             {\n                 if(c[i]<wb.charAt(0))\n                     wb = wb+c[i];\n                 else\n                     wb = c[i]+wb;\n             }\n                 System.out.println("Case #"+curcase+": "+wb);\n         \n         }\n         \n     }\n  }\n <CODESPLIT> 68
package codejam2015;\n  \n  \n  public class ProbC {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         int numcases = sc.nextInt();\n         for(int cas  = 1;cas <= numcases;cas++ )\n         {\n          int L = sc.nextInt();\n          long X = sc.nextLong();\n          String word = sc.next();\n          boolean isnegative =false;\n          char curletter = word.charAt(0);\n          for(int i=1;i<word.length();i++)\n          {\n              char newletter = word.charAt(i);\n              char result = 'n';\n              if(curletter =='i')\n              {\n                  if(newletter =='i')\n                  {\n                      isnegative ^=true;\n                      result = '1';\n                  }\n                  if(newletter =='j')\n                  {\n                     \n                      result = 'k';                   \n                  }\n                  if(newletter =='k')\n                  {\n                      isnegative ^=true;\n                      result = 'j';                   \n                  }\n               }\n              if(curletter =='j')\n              {\n                  if(newletter =='i')\n                  {\n                      isnegative ^=true;\n                      result = 'k';                   \n                  }\n                  if(newletter =='j')\n                  {\n                      isnegative ^=true;\n                      result = '1';                   \n                  }\n                  if(newletter =='k')\n                  {\n                     \n                      result = 'i';                   \n                  }               \n              }\n              if(curletter =='k')\n              {\n                  if(newletter =='i')\n                  {\n                     \n                      result = 'j';                   \n                  }\n                  if(newletter =='j')\n                  {\n                      isnegative ^=true;\n                      result = 'i';                   \n                  }\n                  if(newletter =='k')\n                  {\n                      isnegative ^=true;\n                      result = '1';                   \n                  }               \n              }\n              if(curletter=='1')\n              {\n                  if(newletter =='i')\n                  {\n                      result = 'i';\n                  }\n                  if(newletter =='j')\n                  {\n                      result = 'j';\n                  }\n                  if(newletter =='k')\n                  {\n                      result = 'k';\n                  }\n              }\n              curletter = result;\n          }\n          isnegative = (X%2==0)?false:isnegative;\n          if(((X%4==3)||(X%4==2))&&(curletter!='1'))\n          {\n              isnegative^=true;\n          }\n          if(X%2==0)\n              curletter = '1';\n          \n          if(isnegative&&(curletter =='1'))\n              System.out.println("Case #"+cas+": YES");\n          else\n              System.out.println("Case #"+cas+": NO");\n         }\n     }\n  }\n <CODESPLIT> 68
 \n  \n  public class ProbA {\n  public static void main(String[] args)\n  {\n     Scanner sc= new Scanner(System.in);\n     int numcases = sc.nextInt();\n     for(int curcase = 1;curcase <=numcases;curcase++)\n     {\n         int N = sc.nextInt();\n         System.out.println("Case #"+curcase+": "+compute(N));\n     }\n  }\n  public static int compute(int N)\n  {\n     String s = Integer.toString(N);\n     if(s.length()==1)\n         return N;\n  \n     String fh = s.substring(0, s.length()/2);\n     String sh = s.substring(s.length()/2, s.length());\n     int powten = 1;\n     int halfpowten =1;\n  \n     for(int i=0;i<s.length()-1;i++)\n     {\n         powten*=10;\n         if(i<fh.length()-1)\n             halfpowten*=10;\n     }\n     int numsaid = compute(powten-1);\n     numsaid++;\n     \n     if(Integer.parseInt(fh)!=halfpowten)\n     {\n     if(Integer.parseInt(sh)!=0)\n     {\n     int stepone = Integer.parseInt((new StringBuilder(fh)).reverse().toString());\n     numsaid+=stepone;\n     numsaid++;\n     numsaid+=Integer.parseInt(sh)-1;\n     }else{\n         numsaid++;\n         numsaid+= Integer.parseInt((new StringBuilder(fh)).reverse().toString());\n         numsaid++;\n     }\n     }else{\n         numsaid+=Integer.parseInt(sh);\n     }\n  \n     if(s.length()%2==1)\n     {\n         String fh2 = s.substring(0, s.length()/2+1);\n         String sh2 = s.substring(s.length()/2+1, s.length());\n         int powten2 = 1;\n         int halfpowten2 =1;\n  \n         for(int i=0;i<s.length()-1;i++)\n         {\n             powten2*=10;\n             if(i<fh.length()-1)\n                 halfpowten2*=10;\n         }\n         int numsaid2 = compute(powten2-1);\n         numsaid2++;\n         \n         if(Integer.parseInt(fh2)!=halfpowten2)\n         {\n         if(Integer.parseInt(sh2)!=0)\n         {\n         int stepone2 = Integer.parseInt((new StringBuilder(fh2)).reverse().toString());\n         numsaid2+=stepone2;\n         numsaid2++;\n         numsaid2+=Integer.parseInt(sh2)-1;\n         }else{\n             numsaid2++;\n             numsaid2+= Integer.parseInt((new StringBuilder(fh2)).reverse().toString());\n             numsaid2++;\n         }\n         }else{\n             numsaid2+=Integer.parseInt(sh2);\n         }       \n         return Math.min(numsaid, numsaid2);\n     }\n     \n     return numsaid;\n     \n  }\n  }\n <CODESPLIT> 68
 \n  \n  public class ProbDsmall {\n     public static void main(String[] args) {\n         Scanner sc = new Scanner(System.in);\n         int numcases = sc.nextInt();\n         for(int curcase = 1; curcase<=numcases; curcase++)\n         {\n             int R =sc.nextInt();\n             int C = sc.nextInt();\n             if(R==2)\n             {\n                 if(C%3==0)\n                 {\n                     System.out.println("Case #"+curcase+": 2");\n                 }else{\n                 System.out.println("Case #"+curcase+": 1");\n                 }\n             continue;\n             }if(R==3)\n             {\n                 System.out.println("Case #"+curcase+": 2");\n                 continue;\n                 \n             }\n             if(R==4)\n             {\n                 System.out.println("Case #"+curcase+": "+(1+((C%3==0)?2:0)));\n                 continue;\n                 \n             }\n             if(R==5)\n             {\n                 System.out.println("Case #"+curcase+": 1");\n                 continue;\n                 \n             }\n             if(R==6)\n             {\n                 if(C%3==0)\n                 {\n                     int count =0;\n                     count+=2;\n                     count++;\n                     count+=3;\n                     System.out.println("Case #"+curcase+": "+count);\n                 }else{\n                     \n                 System.out.println("Case #"+curcase+": 2");\n                 }\n                 continue;\n                 \n             }\n         }\n     }\n  \n  }\n <CODESPLIT> 68
package codejam2015;\n  \n  \n  public class CProbB {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         int numcases = sc.nextInt();\n         ML:\n         for(int cas  = 1;cas <= numcases;cas++ )\n         {\n             System.out.print("Case #"+cas+": ");\n             int K = sc.nextInt();\n             int L = sc.nextInt();\n             int S = sc.nextInt();\n             sc.nextLine();\n             String keys = sc.nextLine();\n             String target = sc.nextLine();\n             Map<Character,Integer> letters = new HashMap<Character,Integer>();\n             for(int i=0;i<K;i++)\n             {\n                 Character c = keys.charAt(i);\n                 if (letters.keySet().contains(c))\n                 {\n                     letters.put(c, letters.get(c)+1);\n                 }else{\n                     letters.put(c,1);\n                 }\n             }\n             for(int i=0;i<L;i++)\n             {\n                 if(!letters.containsKey(target.charAt(i)))\n                 {\n                     System.out.println("0.0000000");\n                     continue ML;\n                 }\n             }\n         \n             int r = rootlength(target);\n             int maxnum = (S - L)/r +1 ;\n             double probsingle = 1;\n             for(int i=0;i<L;i++)\n             {\n                 probsingle *= letters.get(target.charAt(i));\n                 probsingle/=K;\n             }\n             double totexp = probsingle *(S-L+1);\n             \n             System.out.printf("%.7f",maxnum-totexp);\n             System.out.println();\n             \n             \n         }\n     }\n     \n     public static int rootlength(String S)\n     {\n         if(S.length()==1)\n             return 1;\n         LOOP:\n         for(int i=1;i<S.length();i++)\n         {\n             for(int j=i;j<S.length();j++)\n             {\n                 if(S.charAt(j)!=S.charAt(j%i))\n                     continue LOOP;\n             }\n             return i;\n         }\n         return S.length();\n     }\n     \n  }\n <CODESPLIT> 68
 \n  \n  public class ProbA {\n  public static void main(String[] args)\n  {\n     Scanner sc= new Scanner(System.in);\n     int numcases = sc.nextInt();\n     for(int curcase = 1;curcase <=numcases;curcase++)\n     {\n         int N = sc.nextInt();\n         System.out.println("Case #"+curcase+": "+compute(N));\n     }\n  }\n  public static int compute(int N)\n  {\n     String s = Integer.toString(N);\n     if(s.length()==1)\n         return N;\n  \n     String fh = s.substring(0, s.length()/2);\n     String sh = s.substring(s.length()/2, s.length());\n     int powten = 1;\n     int halfpowten =1;\n  \n     for(int i=0;i<s.length()-1;i++)\n     {\n         powten*=10;\n         if(i<fh.length()-1)\n             halfpowten*=10;\n     }\n     int numsaid = compute(powten-1);\n     numsaid++;\n     \n     if(Integer.parseInt(fh)!=halfpowten)\n     {\n     if(Integer.parseInt(sh)!=0)\n     {\n     int stepone = Integer.parseInt((new StringBuilder(fh)).reverse().toString());\n     numsaid+=stepone;\n     numsaid++;\n     numsaid+=Integer.parseInt(sh)-1;\n     }else{\n         numsaid++;\n         numsaid+= Integer.parseInt((new StringBuilder(fh)).reverse().toString());\n         numsaid++;\n     }\n     }else{\n         numsaid+=Integer.parseInt(sh);\n     }\n     return numsaid;\n     \n  }\n  }\n <CODESPLIT> 68
package codejam2015;\n  \n  \n  public class ProbB {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         int numcases = sc.nextInt();\n         for(int cas  = 1;cas <= numcases;cas++ )\n         {\n             System.out.print("Case #"+cas+": ");\n         \n         int numdiners = sc.nextInt();\n         int[] plates = new int[numdiners + numdiners*1000+1];\n         for(int i=0;i<numdiners;i++)\n         {\n             plates[i] =sc.nextInt();\n         }\n         Arrays.sort(plates);\n         int bestnum = plates[numdiners + numdiners*1000];\n         for(int i=1;i<=bestnum;i++)\n         {\n             plates[0] = (plates[numdiners+numdiners*1000])/2;\n             plates[1] = (plates[numdiners+numdiners*1000]+1)/2;\n             plates[numdiners+numdiners*1000] = 0;\n             Arrays.sort(plates);\n             if(i + plates[numdiners+numdiners*1000]<bestnum)\n             {\n                 bestnum = plates[numdiners+numdiners*1000]+i;\n             \n         }\n         }\n         System.out.println(bestnum);\n         }\n     }\n  }\n <CODESPLIT> 68
 \n  public class ProbCSmall {\n     public static void main(String[] args) {\n         Scanner sc = new Scanner(System.in);\n         int numcases = sc.nextInt();\n         for(int curcase = 1; curcase<=numcases; curcase++)\n         {\n             int N = sc.nextInt();\n             sc.nextLine();\n             HashMap<String,HashSet<Integer>> linehas = new HashMap<String,HashSet<Integer>>();\n             List<HashSet<String>> eng = new ArrayList<HashSet<String>>();\n             List<HashSet<String>> fr = new ArrayList<HashSet<String>>();\n             String engs = sc.nextLine();\n             String[] engss = engs.split(" ");\n             String frs = sc.nextLine();\n             String[] frss = frs.split(" ");\n             eng.add(new HashSet<String>());\n             for(String s : engss)\n             {\n                 eng.get(0).add(s);\n                 linehas.put(s, new HashSet<Integer>());\n             }\n             fr.add(new HashSet<String>());\n             for(String s : frss)\n             {\n                 fr.get(0).add(s);\n                 linehas.put(s, new HashSet<Integer>());\n             }\n             if(N>2)\n             {\n             List<HashSet<String>> extra = new ArrayList<HashSet<String>>();\n             for(int i=0;i<N-2;i++)\n             {\n                 String line = sc.nextLine();\n                 extra.add(new HashSet<String>());\n                 for(String s : line.split(" "))\n                 {\n                     extra.get(i).add(s);\n                     if(linehas.keySet().contains(s))\n                     linehas.get(s).add(i);\n                     else\n                     {\n                         linehas.put(s, new HashSet<Integer>());\n                         linehas.get(s).add(i);\n                     }\n                 }\n             }\n             globalmin = Integer.MAX_VALUE;\n             System.out.println("Case #"+curcase+": "+tryall(eng,fr,extra));\n  \n             }else{\n                 eng.get(0).retainAll(fr.get(0));\n                 System.out.println("Case #"+curcase+": "+eng.get(0).size());\n             }\n  \n         }\n     }\n     public static int globalmin;\n         public static int tryall(List<HashSet<String>> en, List<HashSet<String>> fr, List<HashSet<String>> yet)\n         {\n             if(yet.size()==0)\n             {\n                 return count(en,fr);\n             }else\n             {\n                 if(count(en,fr)>globalmin)\n                     return Integer.MAX_VALUE;\n                 HashSet<String> h = yet.remove(yet.size()-1);\n                 en.add(h);\n                 int one = tryall(en,fr,yet);\n                 en.remove(en.size()-1);\n                 fr.add(h);\n                 int two = tryall(en,fr,yet);\n                 fr.remove(fr.size()-1);\n                 yet.add(h);\n                 if (globalmin >Math.min(one, two))\n                 globalmin = Math.min(one, two);\n                 return Math.min(one, two);\n             }\n         }\n     public static int count(List<HashSet<String>> en, List<HashSet<String>> fr)\n     {\n         HashSet<String> english = collect(en);\n         HashSet<String> french = collect(fr);       \n         english.retainAll(french);\n         return english.size();\n     }\n     public static HashSet<String> collect(List<HashSet<String>> en)\n     {\n         HashSet<String> ret = new HashSet<String>();\n         for( HashSet<String> h : en)\n         {\n             for( String s : h)\n                 ret.add(s);\n         }\n         return ret;\n     }\n  }\n <CODESPLIT> 68
package Qualification;\n  \n  \n  public class ProbA {\n  public static void main(String[] args)\n  {\n     Scanner sc = new Scanner(System.in);\n     long t = sc.nextLong();\n     sc.nextLine();\n     for(int curcase=1;curcase<=t;curcase++)\n     {\n         System.out.println("Case #"+curcase+": "+check(sc.nextLine()));\n     }\n     \n  }\n  public static String check(String a)\n  {\n     for(int i=0;i<a.length()-1;i++)\n     {\n         if(a.charAt(i)>a.charAt(i+1))\n         {\n             String s = a.substring(0,i)+Character.toString((char) (a.charAt(i)-1));\n             if (s.charAt(0)=='0')\n             s="";\n             for (int j=a.length()-1;j>i;j--)\n             {\n                 s+="9";\n             }\n             return check(s);\n         }\n     }\n     return a;\n  }\n  \n  }\n <CODESPLIT> 68
package Round1B;\n  \n  \n  public class ProblemB {\n     public static void main(String[] args) throws FileNotFoundException\n     {\n         Scanner sc = new Scanner(new FileInputStream("B-small-attempt2.in"));\n     \n         PrintStream out = new PrintStream(new FileOutputStream("out1.txt"));\n         long t = sc.nextLong();\n         sc.nextLine();\n         LOOP2:\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             int N =sc.nextInt();\n             int[] ROYGBV = new int[6];\n             for(int i=0;i<6;i++)\n             {\n                 ROYGBV[i] = sc.nextInt();\n             }\n             int[] RYB = new int[3];\n             if((ROYGBV[0]==ROYGBV[3])&&(ROYGBV[0]+ROYGBV[3]==N))\n             {\n                 out.print("Case #"+curcase+": ");\n                 for(int i=0;i<ROYGBV[0];i++)\n                 {\n                     out.print("RG");\n                 }\n                 out.println();\n                 continue LOOP2;\n             }\n             if((ROYGBV[0]-1 < ROYGBV[3])&&(ROYGBV[3]>0))\n             {\n             out.println("Case #"+curcase+": IMPOSSIBLE");\n             continue LOOP2;\n             }\n             if((ROYGBV[2]==ROYGBV[5])&&(ROYGBV[2]+ROYGBV[5]==N))\n             {\n                 out.print("Case #"+curcase+": ");\n                 for(int i=0;i<ROYGBV[2];i++)\n                 {\n                     out.print("YV");\n                 }\n                 out.println();\n                 continue LOOP2;\n             }\n             if((ROYGBV[2]-1 < ROYGBV[5])&&(ROYGBV[5]>0))\n             {\n             out.println("Case #"+curcase+": IMPOSSIBLE");\n             continue LOOP2;\n             }\n             if((ROYGBV[4]==ROYGBV[1])&&(ROYGBV[4]+ROYGBV[1]==N))\n             {\n                 out.print("Case #"+curcase+": ");\n                 for(int i=0;i<ROYGBV[4];i++)\n                 {\n                     out.print("BO");\n                 }\n                 out.println();\n                 continue LOOP2;\n             }\n             if((ROYGBV[4]-1 < ROYGBV[1])&&(ROYGBV[1]>0))\n             {\n             out.println("Case #"+curcase+": IMPOSSIBLE");\n             continue LOOP2;\n             }\n             RYB[0] = ROYGBV[0]-ROYGBV[3];\n             RYB[1] = ROYGBV[2]-ROYGBV[5];\n             RYB[2] = ROYGBV[4]-ROYGBV[1];\n             char[] prims=  {'R','Y','B'};\n             char[] comps=  {'G','V','O'};\n             boolean[] notfirstdone = new boolean[3];\n             char[] assignment = new char[N];\n                 \n             LOOP:\n             for(int i=0;i<N;){\n                 \n                 int[] order = ord(RYB);\n                 if(i==0){\n                 for(int j=2;j>=0;j--)\n                 {\n                     if(RYB[order[j]]>0)\n                     {\n                     assignment[0] = prims[order[j]];\n                     i++;\n                     RYB[order[j]]--;\n                     continue LOOP;\n                     }\n                 }\n                 }\n                 for(int j=0;j<3;j++)\n                 {\n                     assert(RYB[0]+RYB[1]+RYB[2]==6);\n                 if((RYB[order[j]]>0)&&(assignment[(N+i-1)%N]!=prims[order[j]])&&(assignment[(N+i+1)%N]!=prims[order[j]]))\n                 {\n                     assignment[i] = prims[order[j]];\n                     RYB[order[j]]--;\n                     i++;\n                     if(!notfirstdone[order[j]])\n                     {\n                         for(int k=0;k<ROYGBV[(order[j]*2+3)%6];k+=2)\n                         {\n                             assignment[i+k] = comps[order[j]];\n                             assignment[i+k+1]= prims[order[j]];\n                         }\n                         i+=2*ROYGBV[(order[j]*2+3)%6];\n                         notfirstdone[order[j]]=true;\n                     }\n                     continue LOOP;\n                 }\n                 }\n                 if(i==N)\n                     break LOOP;\n                 System.out.println(curcase+"failed on "+ROYGBV[0]+" "+ROYGBV[2]+" "+ROYGBV[4]);\n                 if(curcase==98){\n                     System.out.println(new String(assignment));\n                     System.out.println(RYB[0]+" "+RYB[1]+" "+RYB[2]);\n                 }\n                 out.println("Case #"+curcase+": IMPOSSIBLE");\n                 continue LOOP2;\n             }\n             assert(RYB[0] == 0);\n             assert(RYB[1] == 0);\n             assert(RYB[2] == 0);\n             out.println("Case #"+curcase+": "+new String(assignment));\n         }\n         \n     }\n     public static boolean tryassign(int n,int[] RYB,int[] assignment)\n     {\n         System.out.println(n);\n         if((n>1)&&(assignment[n-1]==assignment[n]))\n             return false;\n         if(n==assignment.length-1)\n         {\n             if(assignment[0]!=assignment[n])\n             return true;\n             else\n             return false;\n         }\n         for(int j=0;j<3;j++)\n         {\n             if(RYB[j]>0)\n             {\n             assignment[n] = j;\n             RYB[j]--;\n             if(tryassign(n+1,RYB,assignment))\n             {\n                 return true;\n             }\n             RYB[j]++;\n             }\n         }\n         return false;\n     }\n     \n     public static int[] ord(int[] RYB)\n     {\n         int[] order = new int[3];\n         if(RYB[0]>=Math.max(RYB[1],RYB[2]))\n         {\n             order[0] = 0;\n             if(RYB[1]>=RYB[2])\n             {\n                 order[1] = 1;\n                 order[2] = 2;\n             }else\n             {\n                 order[1] = 2;\n                 order[2] = 1;\n             }\n             return order;\n         }\n         if(RYB[1]>=Math.max(RYB[0],RYB[2]))\n         {\n             order[0] = 1;\n             if(RYB[0]>=RYB[2])\n             {\n                 order[1] = 0;\n                 order[2] = 2;\n             }else\n             {\n                 order[1] = 2;\n                 order[2] = 0;\n             }\n             return order;\n         }\n         if(RYB[2]>=Math.max(RYB[1],RYB[0]))\n         {\n             order[0] = 2;\n             if(RYB[1]>=RYB[0])\n             {\n                 order[1] = 1;\n                 order[2] = 0;\n             }else\n             {\n                 order[1] = 0;\n                 order[2] = 1;\n             }\n         }\n         return order;\n     }\n  }\n <CODESPLIT> 68
package codejam2015;\n  \n  \n  public class ProbD {\n     public static void main(String[] args) {\n         Scanner sc = new Scanner(System.in);\n         int numcases = sc.nextInt();\n         for (int cas = 1; cas <= numcases; cas++) {\n             System.out.print("Case #" + cas + ": ");\n             int X = sc.nextInt();\n             int R = sc.nextInt();\n             int C = sc.nextInt();\n             if (X == 1) {\n                 System.out.println("GABRIEL");\n                 continue;\n             }\n             if (X == 2) {\n                 if ((R * C) % 2 == 0) {\n                     System.out.println("GABRIEL");\n                 } else {\n                     System.out.println("RICHARD");\n                 }\n                 continue;\n             }\n             if (X == 3) {\n                 if ((R == 1) || (C == 1)) {\n                     System.out.println("RICHARD");\n                     continue;\n                 }\n                 if (R == 2) {\n                     if (C == 3) {\n                         System.out.println("GABRIEL");\n                     } else {\n                         System.out.println("RICHARD");\n                     }\n                     continue;\n                 }\n                 if (R == 3) {\n                     System.out.println("GABRIEL");\n                     continue;\n                 }\n                 if (R == 4) {\n                     if (C == 3) {\n                         System.out.println("GABRIEL");\n                     } else {\n                         System.out.println("RICHARD");\n                     }\n                     continue;\n                 }\n             }\n             if (X == 4) {\n                 if ((R < 3) || (C < 3)) {\n                     System.out.println("RICHARD");\n                     continue;\n                 }\n                 if (R == 3) {\n                     if (C == 3) {\n                         System.out.println("RICHARD");\n                     } else {\n                         System.out.println("GABRIEL");\n                     }\n                     continue;\n                 }\n                 if (R == 4) {\n                     System.out.println("GABRIEL");\n                     continue;\n                 }\n             }\n         }\n     }\n  }\n <CODESPLIT> 68
package Round1A;\n  \n  \n  public class ProbB {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         long t = sc.nextInt();\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n                 HashMap<Integer,Integer> counts = new HashMap<Integer,Integer>();\n                 int N = sc.nextInt();\n                 for(int i=0;i<2*N*N-N;i++)\n                 {\n                     int in = sc.nextInt();\n                     if(!counts.containsKey(in))\n                         counts.put(in, 0);\n                     counts.put(in, counts.get(in)+1);\n                 }\n                 TreeSet<Integer> odds = new TreeSet<Integer>();\n                 for(Integer i : counts.keySet())\n                 {\n                     if(counts.get(i)%2==1)\n                         odds.add(i);\n                 }\n                 String ret ="";\n                 for(Integer i : odds)\n                 {\n                     ret= ret+" "+i;\n                 }\n                 System.out.println("Case #"+curcase+":"+ret);\n     \n         }\n         \n     }\n  }\n <CODESPLIT> 68
 \n  \n  public class tinyC {\n     public static void main(String[] args)\n     {\n         Scanner sc= new Scanner(System.in);\n         int numcases = sc.nextInt();\n         for(int curcase = 1;curcase <=numcases;curcase++)\n         {\n             int N = sc.nextInt();\n             int h1pos;\n             int h2pos;\n             int h1speed;\n             int h2speed;\n             if(N==1)\n             {\n                 int D1 = sc.nextInt();\n                 int numhike = sc.nextInt();\n                 if(numhike ==1)\n                 {\n                     System.out.println("Case #"+curcase+": 0");\n                     continue;\n                 }\n                 h1speed = sc.nextInt();\n                 h2speed = h1speed+1;\n                 h1pos = D1;\n                 h2pos =D1;\n                 \n                 System.out.println("Case #"+curcase+": 0");\n                 continue;               \n             }else\n             {\n                 h1pos = sc.nextInt();\n                 sc.nextInt();\n                 h1speed =sc.nextInt();\n                 h2pos = sc.nextInt();\n                 sc.nextInt();\n                 h2speed = sc.nextInt();\n  \n                 if(h1pos<h2pos)\n                 {\n                     int swap = h1pos;\n                     h1pos = h2pos;\n                     h2pos = swap;\n                     swap  =h1speed;\n                     h1speed = h2speed;\n                     h2speed = swap;\n                 }\n                 if(h1speed == h2speed)\n                 {\n                     System.out.println("Case #"+curcase+": 0");\n                     continue;                               \n                 }\n                 double disttwo = (h1pos - h2pos)/360;\n                 double timeone = (1+disttwo)*h1speed*h2speed/(h1speed-h2speed);\n                 double hittime;\n                 if(timeone>0)\n                     hittime = timeone;\n                 else\n                     hittime = (360 - disttwo)*h1speed*h2speed/(h2speed-h1speed);\n                 double h1time = (360-h1pos)/360*h1speed;\n                 double h2time = (360-h2pos)/360*h2speed;\n                 if((h1time>= hittime)||(h2time>=hittime))\n                 {\n                     System.out.println("Case #"+curcase+": 1");\n                     continue;                       \n                 }else\n                 {\n                     System.out.println("Case #"+curcase+": 0");\n                     continue;                       \n                     \n                 }\n             }\n             \n         }\n     }\n  \n  }\n <CODESPLIT> 68
package Round1A;\n  \n  \n  public class Problem3 {\n     public static void main(String[] args) throws FileNotFoundException\n     {\n         Scanner sc = new Scanner(new FileInputStream("C-small-attempt1.in"));\n         PrintStream out = new PrintStream(new FileOutputStream("out3.txt"));\n         long t = sc.nextLong();\n         sc.nextLine();\n         LOOP:\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             List<Integer> startState = new ArrayList<Integer>(6);\n             int dragH = sc.nextInt();\n             startingHealth = dragH;\n             int dragA = sc.nextInt();\n             int knH = sc.nextInt();\n             int knA = sc.nextInt();\n             int B = sc.nextInt();\n             int D = sc.nextInt();\n             startState.add(dragH);\n             startState.add(dragA);\n             startState.add(knH);\n             startState.add(knA);\n             startState.add(B);\n             startState.add(D);\n             startState.add(0);\n             List<Set<List<Integer>>> frontier = new ArrayList<>();\n             frontier.add(new HashSet<>());\n             frontier.get(0).add(startState);\n             Set<List<Integer>>  seen = new HashSet<>();\n             seen.add(startState);\n             for(int i=0;!frontier.get(i).isEmpty();i++)\n             {\n                 System.out.println("Case: "+curcase+" frontier: "+frontier.get(i).size()+ " i:"+i + "  seen:"+seen.size());\n                 frontier.add(new HashSet<>());\n                 for(List<Integer> state : frontier.get(i))\n                 {\n                     if(state.get(2)<=0)\n                     {\n                         out.println("Case #"+curcase+": "+i);\n                         continue LOOP;\n                     }\n                     if(state.get(0)<=0)\n                     {\n                         continue;\n                     }\n  \n                     for(Move m : Move.values())\n                     {\n                         if((state.get(0)> state.get(3))&&(m==Move.CURE))\n                         {\n                             continue;\n                         }\n                         \n                         if((state.get(6)==1)&&((m==Move.BUFF)||(m==Move.DEBUFF)))\n                         {\n                             continue;\n                         }\n                         List<Integer> newstate = step(state,m);\n                         if(m==Move.ATTACK)\n                         {\n                             newstate.set(6, 1);\n                         }\n                         boolean hasbetter = strictlyBetter(state,newstate);\n                         for(List<Integer> s:seen)\n                         {\n                             hasbetter = hasbetter ||strictlyBetter(s,newstate);\n                         }\n                         if(seen.contains(newstate))\n                             continue;\n                         seen.add(newstate); \n  \n                         if(!hasbetter)\n                         frontier.get(i+1).add(newstate);\n                     }\n                 }\n             }\n             out.println("Case #"+curcase+": IMPOSSIBLE");\n         }\n         \n     }\n     public static int startingHealth;\n     public static List<Integer> step(List<Integer> config,Move move)\n     {\n         List<Integer> ret = new ArrayList<>(config);\n         switch(move)\n         {\n         case ATTACK:\n             ret.set(2, ret.get(2)-ret.get(1));\n             ret.set(0, ret.get(0)-ret.get(3));\n             return ret;\n         case BUFF:\n             ret.set(1, ret.get(1) + ret.get(4));\n             ret.set(0, ret.get(0)-ret.get(3));\n             return ret;\n         case DEBUFF:\n             ret.set(3, ret.get(3)-ret.get(5));\n             ret.set(0, ret.get(0)-ret.get(3));\n             return ret;\n         case CURE:\n             ret.set(0, startingHealth);\n             ret.set(0, ret.get(0)-ret.get(3));\n             return ret;\n         }\n         throw(new IllegalStateException());\n     }\n     \n     public static boolean strictlyBetter(List<Integer> s1,List<Integer> s2)\n     {\n         if((s1.get(0)>=s2.get(0))&&(s1.get(2)<=s2.get(2)&&(s1.get(1)>=s2.get(1))&&(s1.get(3)<=s2.get(3))))\n         return true;\n         return false;\n     }\n     public static enum Move\n     {\n         ATTACK,\n         BUFF,\n         DEBUFF,\n         CURE;\n     }\n  }\n <CODESPLIT> 68
 \n  \n  public class ProbBsmall {\n     public static void main(String[] args) {\n         Scanner sc = new Scanner(System.in);\n         int numcases = sc.nextInt();\n         for(int curcase = 1; curcase<=numcases; curcase++)\n         {\n             int N = sc.nextInt();\n             double V = sc.nextDouble();\n             double X = sc.nextDouble();\n             double[] R = new double[N];\n             double[] S = new double[N];\n             for(int i=0;i<N;i++)\n             {\n                 R[i] =sc.nextDouble();\n                 S[i] = sc.nextDouble();\n             }\n             if(N==1)\n             {\n                 if(X == S[0])\n                 System.out.println("Case #"+curcase+": "+(V/R[0]));\n                 else\n                 System.out.println("Case #"+curcase+": IMPOSSIBLE");\n             }else\n             {\n             if(S[0] == S[1])\n             {\n                 if(X == S[0])\n                 System.out.println("Case #"+curcase+": "+(V/(R[0]+R[1])));\n                 else\n                 System.out.println("Case #"+curcase+": IMPOSSIBLE");    \n                 continue;\n             }\n             if(S[0]==X)\n             {\n                 System.out.println("Case #"+curcase+": "+(V/(R[0])));\n                 continue;\n             }\n             if(S[1]==X)\n             {\n                 System.out.println("Case #"+curcase+": "+(V/(R[1])));\n                 continue;\n             }\n             \n             if(((X>S[0])&&(X>S[1]))||((X<S[0])&&(X<S[1])))\n                 {System.out.println("Case #"+curcase+": IMPOSSIBLE");   continue;}\n             \n  \n             double t2 = V*(X-S[0])/(R[1]*(S[1]-S[0]));\n             double t1 = (V - R[1]*t2)/R[0];\n             System.out.println("Case #"+curcase+": "+Math.max(t1, t2));\n                     \n             }\n         }\n     }\n  }\n <CODESPLIT> 68
package Qualification;\n  \n  \n  public class ProbA {\n  public static void main(String[] args)\n  {\n     Scanner sc = new Scanner(System.in);\n     long t = sc.nextInt();\n     for(int curcase=1;curcase<=t;curcase++)\n     {\n         long N = sc.nextInt();\n         boolean[] seen = new boolean[10];\n         if(N==0)\n         {\n             System.out.println("Case #"+curcase+": INSOMNIA");\n             continue;\n         }\n         for(int i=1;true;i++)\n         {\n             \n             digits(i*N,seen);\n             if(check(seen))\n             {\n                 System.out.println("Case #"+curcase+": "+(i*N));\n                 break;\n             }\n         }\n     }\n     \n  }\n  public static boolean check(boolean[] a)\n  {\n     for(int i=0;i<10;i++)\n         if(!a[i])\n             return false;\n     return true;\n  }\n  public static void digits(long n,boolean[] arr)\n  {\n     if(n==0)\n         return;\n     arr[(int)n%10]=true;\n     digits(n/10,arr);\n  }\n  }\n <CODESPLIT> 68
package Round1B;\n  \n  \n  public class ProblemA {\n     public static void main(String[] args) throws FileNotFoundException\n     {\n         Scanner sc = new Scanner(new FileInputStream("A-small-attempt0.in"));\n         PrintStream out = new PrintStream(new FileOutputStream("out1.txt"));\n         long t = sc.nextLong();\n         sc.nextLine();\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             int D = sc.nextInt();\n             int N = sc.nextInt();\n             int[] K = new int[N];\n             int[] S = new int[N];\n             for(int i=0;i<N;i++)\n             {\n                 K[i] = sc.nextInt();\n                 S[i] = sc.nextInt();\n             }\n             double fastest = Double.MAX_VALUE;\n             for(int i=0;i<N;i++)\n             {\n                 fastest = Math.min(fastest, ((double)S[i]*D)/(D-K[i]));\n             }\n             \n             out.println("Case #"+curcase+": "+fastest);\n         }\n         \n     }\n  }\n <CODESPLIT> 68
package codejam2015;\n  \n  \n  public class ProbA {\n  public static void main(String[] args)\n  {\n     Scanner sc = new Scanner(System.in);\n     int numcases = sc.nextInt();\n     for(int cas  = 1;cas <= numcases;cas++ )\n     {\n         System.out.print("Case #"+cas+": ");\n         int numstanding=0;\n         int numadded=0;\n         int maxshy = sc.nextInt();\n         String aud = sc.next();\n         for(int i=0;i<=maxshy;i++)\n         {\n             if(aud.charAt(i)!='0')\n             {\n                 numadded+= Math.max(i-numstanding,0);\n                 numstanding+=Math.max(i-numstanding,0);\n                 numstanding+= Integer.parseInt(""+aud.charAt(i));\n             }\n         }\n         System.out.println(numadded);\n     }\n     sc.close();\n  }\n  }\n <CODESPLIT> 68
package Qualification;\n  \n  \n  public class ProbC {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         long t = sc.nextInt();\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             int N = sc.nextInt();\n             int J = sc.nextInt();\n             ArrayList<String> ret = new ArrayList<String>();\n             boolean[] num = new boolean[N];\n             num[N-1] =true; num[0]=true;\n             numleft= J;\n             consider(num,ret,1);\n             System.out.println("Case #1:");\n             if(numleft>0)\n             System.out.println("impossible");\n             else\n             for(String s : ret)\n             {\n                 System.out.println(s);\n             }\n         }\n     }\n     public static int numleft;\n     public static int ping=0;\n     public static void consider(boolean[] n,ArrayList<String> r,int dig)\n     {\n         if(numleft<=0)\n             return;\n         if(dig<n.length-1)\n         {\n             consider(n,r,dig+1);\n             n[dig] =true;\n             if(dig==4)\n                 System.out.println(ping++);\n             consider(n,r,dig+1);\n             n[dig] = false;\n             return;\n         }\n         String out = base(n,10)+"";\n         for(int i=2;i<=10;i++)\n         {\n             long b = base(n,i);long f = factor(b);\n             if(f==b)\n                 return;\n             out+=" "+f;\n         }\n         numleft--;\n         r.add(out);\n     }   \n     public static long base(boolean[] num,int base)\n     {\n         long addin=1;\n         long ret=0;\n         for(int i=0;i<num.length;i++)\n         {\n             if(num[i])\n                 ret+=addin;\n             addin*=base;\n         }\n         return ret;\n     }\n     public static long factor (long num) {\n         if (num % 2 == 0) return 2;\n         for (long tst = 3 ; tst * tst <= num ; tst += 2)\n             if (num % tst == 0)\n                 return tst;\n         return num;\n     }\n  }\n <CODESPLIT> 68
package codejam2015;\n  \n  \n  public class CProbA2 {\n         public static void main(String[] args)\n         {\n             Scanner sc = new Scanner(System.in);\n             int numcases = sc.nextInt();\n             ML:\n             for(int cas  = 1;cas <= numcases;cas++ )\n             {\n                 System.out.print("Case #"+cas+": ");\n                 int R = sc.nextInt();\n                 int C = sc.nextInt();\n                 int W = sc.nextInt();\n                 System.out.println(recsolv(C,W,R));\n             }\n         }\n         public static int recsolv(int C,int W,int R)\n         {\n             int hitway = R-1+ ((C>W)?W+1:W);\n             if(C<2*W)\n             {\n                 return hitway;\n             }\n             int missway = R+Math.min(recsolv(W,W,R)+recsolv(C-W-1,W,R),recsolv(C-W,W,R));\n             return Math.max(hitway, missway);\n         }\n  }\n <CODESPLIT> 68
package Round1A;\n  \n  \n  public class ProbC2 {\n     public static void main(String[] args)\n     {\n         Scanner sc = new Scanner(System.in);\n         long t = sc.nextInt();\n         for(int curcase=1;curcase<=t;curcase++)\n         {\n             \n                 int N = sc.nextInt();\n                 HashMap<Integer,Integer> bffs = new HashMap<Integer,Integer>();\n                 for(int i=1;i<=N;i++)\n                 {\n                     int in = sc.nextInt();\n                     bffs.put(i, in);\n                 }\n                 Map<Integer,Integer> compon = new HashMap<Integer,Integer>();\n                 for(int i=1;i<=N;i++)\n                 {\n                     compon.put(i,i);\n                 }\n                 Map<Integer,Integer> colors= new HashMap<Integer,Integer>();\n                 boolean haschanged = true;\n                 while(haschanged)\n                 {\n                     \n                     haschanged = false;\n                     for(int i=1;i<=N;i++)\n                     {\n                         colors.put(compon.get(i),colors.keySet().size());\n                         if(compon.get(i)!=compon.get(bffs.get(i)))\n                         {\n                             compon.put(i, compon.get(bffs.get(i)));\n                             haschanged = true;\n                             break;\n                         }\n                     }\n                 }\n                 colors = new HashMap<Integer,Integer>();\n                 for(int i=1;i<=N;i++)\n                 {\n                     if(!colors.containsKey(compon.get(i)))\n                     colors.put(compon.get(i),colors.keySet().size());\n                 }\n                 Set<Integer> actual= new HashSet<Integer>();\n                 for(int i=1;i<=N;i++)\n                 {\n                     compon.put(i,colors.get(compon.get(i)));\n                     actual.add(compon.get(i));\n                 }\n                 int comps = actual.size();\n                 int[] best = new int[comps];\n                 boolean[] pair = new boolean[comps];\n                 int[] obest  =  new int[comps];\n  \n                 for(int j=0;j<comps;j++)\n                 {\n                 Set<Integer> bffae = new TreeSet<Integer>();\n                 Map<Integer,Integer> bffaebranch = new HashMap<Integer,Integer>();\n                 for(int i=1;i<=N;i++)\n                 {\n                     if(compon.get(i)!=j)\n                         continue;\n                     if(i==bffs.get(bffs.get(i)))\n                     {\n                         bffae.add(i);\n                         bffae.add(bffs.get(i));\n                         bffaebranch.put(i, 0);\n                         bffaebranch.put(bffs.get(i), 0);\n                     }\n                 }\n                 for(int i=1;i<=N;i++)\n                 {\n  \n                     if(compon.get(i)!=j)\n                         continue;\n                     if(bffae.contains(i))\n                     {\n                         pair[j] = true;\n                         if(2>best[j])\n                             best[j] = 2;\n                         if(2>obest[j])\n                             obest[j] = 2;\n                         continue;\n                     }\n                     Map<Integer,Integer> seen = new HashMap<Integer,Integer>();\n                     seen.put(i,0);\n                     int d=0;\n                     int cur =i;\n                     while(true)\n                     {\n                         d++;\n                         int next = bffs.get(cur);\n                         if(seen.keySet().contains(next))\n                         {\n                             if(d - seen.get(next)>best[j])\n                                 best[j] = d - seen.get(next);\n  \n                             break;\n                         }\n                         if(bffae.contains(next))\n                         {\n                             int dist = bffaebranch.get(bffs.get(next));\n                             if(d  > bffaebranch.get(next))\n                             {\n                                 bffaebranch.put(next,d);\n                             }\n                             if(2+ d + dist>best[j])\n                                 best[j] = 2+ d + dist;\n                             if(2+ d + dist>obest[j])\n                                 obest[j] = 2+ d + dist;\n                             break;\n                         }\n                         \n                         seen.put(next, d);\n                         cur = next;\n                     }\n                 }\n                 }\n                 \n                 int bestb=0;\n                 int b = 0;\n                 for(int i = 0;i<comps;i++)\n                 {\n                     if(best[i]>b)\n                     {\n                         b=best[i];\n                     }\n                 }\n                 int bb = 0;\n                 for(int i = 0;i<comps;i++)\n                 {\n                         bb+=obest[i];\n                 }\n                 bestb = Math.max(b, bb);\n                 System.out.println("Case #"+curcase+": "+bestb);\n         }\n         \n     }\n  }\n <CODESPLIT> 68
